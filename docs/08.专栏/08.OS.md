---
title: OS
date: 2022-12-19 12:57:16
permalink: /pages/1312c8/
tags:
  - 
author: 
  name: yuadh
  link: https://github.com/yuadh
---
# 对OS理解？

OS是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。

相当于是软件管家。



# 🍅 进程&线程

 ![1649652076433](https://interview.yuadh.com/assets/1649652076433.png) 

## 区别

1.  线程是进程的一个实体，是程序执行的最小单位
2.  进程是具有一定功能的程序在一个数据集上的一次动态执行的过程 
3.  进程是资源分配的独立单元，线程是资源调度的基本单元
5.  资源开销：**进程是拥有资源的一个独立单位，每个进程都有自己单独的地址空间，进程切换会消耗较大的资源——进程调度算法。线程只拥有一点在运行中必不可少的资源，一类线程共享代码和内存空间，线程切换消耗较小**
6.  内存分配：进程间地址空间和资源相互独立；线程共享本进程地址空间和资源
7.   进程比线程健壮
8.  执行过程：进程有独立的运行入口
8.  执行顺序；进程和线程均可并发执行

## CPU类比一个工厂

1. 一个进程 就是 一个车间，同时只能有一个进程运行，单个CPU一次只能运行一个任务
2. 多个线程 类比 车间的工人
3. 进程内存空间共享 类比 车间房间工人可进出
4. 一个线程使用某些共享内存时，其他线程必须等它结束才能使用这块内存类比 **洗手间**只能容纳一人 
5. 防止多个线程同时读写某一块区域，**加一把“互斥锁” 类比 在门上加一把锁**
6. 某些内存区域只能供给固定数目的线程使用 类比 **厨房容纳n个人，多的人只能在外面等着**
7. **信号量**，保证多个线程不会冲突 类比 门口放n把钥匙，进去取钥匙，出来放钥匙，后面的人发现钥匙架空就知道必须在门口等着



> #### 线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约CPU时间。

## 进程间通信

### 管道

匿名管道和命名管道。

管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，而且管道是单向传输的。

效率低下，因为如果a进程给b进程传输数据，**只有等b进程取到数据之后a进程才能返回，所以管道不适用于频繁通信的进程**。当然，优点就是简单，能够保证我们的数据是真的已经被其他进程拿走的。

### 消息队列

那我们是否可以把进程的数据放在某个内存后就马上让进程返回呢？不用等待其他进程来取就返回？

可以的。我们可以利用消息队列解决这个问题，例如a需要给b进程发送消息，只需将消息放在对应的消息队列中就可以，b进程需要的时候再去对应的消息队列中取出。这种通行方式类似于 缓存。

有缺点吗？
如果a进程发送的数据内存比较大，且两个进程通信非常频繁的话，队列模式就不大适合了。因为如果a发送的数据很大的话，意味着发送消息这个过程需要花很多时间读内存。

### 共享内存

共享内存这个通信方式就可以很好的解决 拷贝 所消耗的时间。

进程拥有自己的独立内存，两个进程怎么共享一块内存？

我们知道，系统加载一个进程时，分配给进程的内存不是实际物理内存，而是虚拟内存空间。那么我们就可以让**两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但是有一部分却是映射到相同的物理内存**，即，完成进程的内存共享机制。

### 信号量

共享内存存在问题吗？

**最大的问题就是  多进程竞争内存。**

我们可以通过信号量解决这个问题。

**信号量的本质就是一个计数器，用来实现进程间的互斥和同步。**

我们用信号量这个变量来辅助内存共享。

### 套接字

前面的4个通信方式(管道，消息队列，内存共享，信号量)都是多个进程在一台主机上的通信，如果是**两个相隔万里的进程还能通信吗**？

Socket可以解决这个问题，我们平时通过浏览器发起一个HTTP请求，然后服务器返回我们对应的数据，即是，socket通信

# 🍅反码 补码 原码

- 原码：计算机对数字二进制的定点表示方法，最高位表示符号位，其余位表示数值位。
  - 优点：易于分辨，缺点：不能够直接参与运算。

- 正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。
  如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。

- 正数的补码和其原码一样；负数的补码为其反码加1。
  例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；
  [-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001

- 补码来表示负数的原因：可以将加法运算扩展到所有的数值计算上，因此在数字电路中只需考虑加法器的设计就行，而不用再为减法设置新的数字电路。



# 死锁

#  













