<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | yuadhのinterview_note</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="yuadh的面试笔记网站">
    <meta name="keywords" content="yuadh个人面试笔记网站">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.1a8fa0bc.css" as="style"><link rel="preload" href="/assets/js/app.85915171.js" as="script"><link rel="preload" href="/assets/js/2.68cc8c44.js" as="script"><link rel="preload" href="/assets/js/58.85354619.js" as="script"><link rel="prefetch" href="/assets/js/10.bbbc158b.js"><link rel="prefetch" href="/assets/js/11.d369f77a.js"><link rel="prefetch" href="/assets/js/12.2df2e0c2.js"><link rel="prefetch" href="/assets/js/13.f9e3c2b4.js"><link rel="prefetch" href="/assets/js/14.a92cd37c.js"><link rel="prefetch" href="/assets/js/15.781d1409.js"><link rel="prefetch" href="/assets/js/16.7fa321a8.js"><link rel="prefetch" href="/assets/js/17.6ab202f5.js"><link rel="prefetch" href="/assets/js/18.1a27d2aa.js"><link rel="prefetch" href="/assets/js/19.3da5cbab.js"><link rel="prefetch" href="/assets/js/20.1fd3b090.js"><link rel="prefetch" href="/assets/js/21.b22c76a6.js"><link rel="prefetch" href="/assets/js/22.2634c2ca.js"><link rel="prefetch" href="/assets/js/23.5aff7e63.js"><link rel="prefetch" href="/assets/js/24.4c139f0f.js"><link rel="prefetch" href="/assets/js/25.e450fb7c.js"><link rel="prefetch" href="/assets/js/26.ff0075b2.js"><link rel="prefetch" href="/assets/js/27.98089b22.js"><link rel="prefetch" href="/assets/js/28.5faf04b4.js"><link rel="prefetch" href="/assets/js/29.05f69bfc.js"><link rel="prefetch" href="/assets/js/3.ec6089ea.js"><link rel="prefetch" href="/assets/js/30.c177236c.js"><link rel="prefetch" href="/assets/js/31.6394b9e4.js"><link rel="prefetch" href="/assets/js/32.3a53fdd1.js"><link rel="prefetch" href="/assets/js/33.86bf84ac.js"><link rel="prefetch" href="/assets/js/34.fd4fc47c.js"><link rel="prefetch" href="/assets/js/35.75b6eab4.js"><link rel="prefetch" href="/assets/js/36.9fb1af18.js"><link rel="prefetch" href="/assets/js/37.e1e8e4a8.js"><link rel="prefetch" href="/assets/js/38.4412b531.js"><link rel="prefetch" href="/assets/js/39.d69b0bc0.js"><link rel="prefetch" href="/assets/js/4.8f7ec523.js"><link rel="prefetch" href="/assets/js/40.626b72c9.js"><link rel="prefetch" href="/assets/js/41.68052477.js"><link rel="prefetch" href="/assets/js/42.5e513bfc.js"><link rel="prefetch" href="/assets/js/43.906a8a35.js"><link rel="prefetch" href="/assets/js/44.a92597fa.js"><link rel="prefetch" href="/assets/js/45.1d296301.js"><link rel="prefetch" href="/assets/js/46.870b43bb.js"><link rel="prefetch" href="/assets/js/47.958479e9.js"><link rel="prefetch" href="/assets/js/48.22e1287d.js"><link rel="prefetch" href="/assets/js/49.6f78ab18.js"><link rel="prefetch" href="/assets/js/5.ee867fce.js"><link rel="prefetch" href="/assets/js/50.a66f7f59.js"><link rel="prefetch" href="/assets/js/51.69bbb479.js"><link rel="prefetch" href="/assets/js/52.63b11e40.js"><link rel="prefetch" href="/assets/js/53.a19d04bf.js"><link rel="prefetch" href="/assets/js/54.8a49b361.js"><link rel="prefetch" href="/assets/js/55.c9e928f9.js"><link rel="prefetch" href="/assets/js/56.44895c58.js"><link rel="prefetch" href="/assets/js/57.b3d36188.js"><link rel="prefetch" href="/assets/js/59.85b16e63.js"><link rel="prefetch" href="/assets/js/6.eaba5766.js"><link rel="prefetch" href="/assets/js/60.b1008012.js"><link rel="prefetch" href="/assets/js/61.05f782d9.js"><link rel="prefetch" href="/assets/js/62.a84ea078.js"><link rel="prefetch" href="/assets/js/63.3e0f64e2.js"><link rel="prefetch" href="/assets/js/64.d0773b26.js"><link rel="prefetch" href="/assets/js/65.201c9d2f.js"><link rel="prefetch" href="/assets/js/66.022a5411.js"><link rel="prefetch" href="/assets/js/67.1cff8268.js"><link rel="prefetch" href="/assets/js/68.a18268f9.js"><link rel="prefetch" href="/assets/js/7.38795195.js"><link rel="prefetch" href="/assets/js/8.124fdfe3.js"><link rel="prefetch" href="/assets/js/9.8f91cfa5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1a8fa0bc.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="yuadhのinterview_note" class="logo"> <span class="site-name can-hide">yuadhのinterview_note</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/code/" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/frame/" class="nav-link">软件框架</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法|数据结构</a></div><div class="nav-item"><a href="/base/" class="nav-link">基础学科</a></div><div class="nav-item"><a href="/system/" class="nav-link">系统|工具</a></div><div class="nav-item"><a href="/project/" class="nav-link">项目</a></div><div class="nav-item"><a href="/interviews/" class="nav-link">面试综合</a></div><div class="nav-item"><a href="/part/" class="nav-link">专栏</a></div> <a href="https://github.com/yuadh/interview2" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/code/" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/frame/" class="nav-link">软件框架</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法|数据结构</a></div><div class="nav-item"><a href="/base/" class="nav-link">基础学科</a></div><div class="nav-item"><a href="/system/" class="nav-link">系统|工具</a></div><div class="nav-item"><a href="/project/" class="nav-link">项目</a></div><div class="nav-item"><a href="/interviews/" class="nav-link">面试综合</a></div><div class="nav-item"><a href="/part/" class="nav-link">专栏</a></div> <a href="https://github.com/yuadh/interview2" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/b48262/" class="sidebar-link">Browser</a></li><li><a href="/pages/eab60b/" class="sidebar-link">CN</a></li><li><a href="/pages/77ad0a/" class="sidebar-link">CSS</a></li><li><a href="/pages/8564fd/" class="sidebar-link">Git</a></li><li><a href="/pages/5798b5/" class="sidebar-link">HTML</a></li><li><a href="/pages/1f9ab3/" class="sidebar-link">JS</a></li><li><a href="/pages/c60f99/" class="sidebar-link">Optimize</a></li><li><a href="/pages/1312c8/" class="sidebar-link">OS</a></li><li><a href="/pages/a9e64c/" class="sidebar-link">Project-Others</a></li><li><a href="/pages/727eb5/" aria-current="page" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#相同" class="sidebar-link">相同</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#不同" class="sidebar-link">不同</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#区别" class="sidebar-link">区别？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#组件化" class="sidebar-link">组件化</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#vdom" class="sidebar-link">VDOM</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#react、vue-vdom相同点" class="sidebar-link">react、vue VDOM相同点</a></li><li class="sidebar-sub-header level4"><a href="/pages/727eb5/#diff-优化基本上思路相同" class="sidebar-link">diff 优化基本上思路相同</a></li><li class="sidebar-sub-header level4"><a href="/pages/727eb5/#diff-源码-相同之处" class="sidebar-link">diff  源码 相同之处</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#react和vue中vdom差别" class="sidebar-link">react和vue中VDOM差别</a></li><li class="sidebar-sub-header level4"><a href="/pages/727eb5/#dom的更新策略不同" class="sidebar-link">dom的更新策略不同</a></li><li class="sidebar-sub-header level5"><a href="/pages/727eb5/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#数据驱动视图" class="sidebar-link">数据驱动视图</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#vue-数据驱动视图" class="sidebar-link">vue 数据驱动视图</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#react的数据驱动视图" class="sidebar-link">react的数据驱动视图</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#核心思想" class="sidebar-link">核心思想</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#不习惯之处" class="sidebar-link">不习惯之处</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#jsx" class="sidebar-link">JSX</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#状态提升" class="sidebar-link">状态提升</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#react-16前" class="sidebar-link">React 16前!img</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#react-16后" class="sidebar-link">React 16后</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#constructor" class="sidebar-link">constructor</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#_16新增2个" class="sidebar-link">16新增2个</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#getderivedstatefromprops" class="sidebar-link">getDerivedStateFromProps</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#getsnapshotbeforeupdate" class="sidebar-link">getSnapshotBeforeUpdate</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#componentdidmount" class="sidebar-link">componentDidMount</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#shouldcomponentdidmount" class="sidebar-link">shouldComponentDidMount</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#componentdidupdate" class="sidebar-link">componentDidUpdate</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#componentwillunmount" class="sidebar-link">componentWillUnmount</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#准备废弃" class="sidebar-link">准备废弃</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#componentwillmount" class="sidebar-link">componentWillMount</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#componentwillreceiveprops-nextprops" class="sidebar-link">componentWillReceiveProps(nextProps)</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#componentwillupdate" class="sidebar-link">componentWillUpdate</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#setstate" class="sidebar-link">🔥 setState</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#有状态组件" class="sidebar-link">有状态组件</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#无状态组件" class="sidebar-link">无状态组件</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#受控组件" class="sidebar-link">受控组件</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#非受控组件" class="sidebar-link">非受控组件</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#class、hooks" class="sidebar-link">class、hooks</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#卡顿原因" class="sidebar-link">卡顿原因</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#优化场景" class="sidebar-link">优化场景</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#思路" class="sidebar-link">思路</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#react-memo" class="sidebar-link">React.memo</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#react-usememo" class="sidebar-link">React.useMemo</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#purecomponent" class="sidebar-link">PureComponent</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#高阶组件" class="sidebar-link">高阶组件</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#避免内联对象" class="sidebar-link">避免内联对象</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#避免匿名函数" class="sidebar-link">避免匿名函数</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#组件懒加载" class="sidebar-link">组件懒加载</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#用-css" class="sidebar-link">用 CSS</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#react-fragment" class="sidebar-link">React.Fragment</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#key-2" class="sidebar-link">key</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#合理使用context" class="sidebar-link">合理使用Context</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#虚拟列表" class="sidebar-link">虚拟列表</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#合理设计组件" class="sidebar-link">合理设计组件</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#同步or异步" class="sidebar-link">同步or异步</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#第二个参数" class="sidebar-link">第二个参数</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#state如何注入到组件" class="sidebar-link">state如何注入到组件</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#解决" class="sidebar-link">解决</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#限制" class="sidebar-link">限制</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#hooks和生命周期" class="sidebar-link">hooks和生命周期</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#usestate" class="sidebar-link">useState</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/pages/727eb5/#模拟componentdidmount" class="sidebar-link">模拟componentDidMount</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#uselayouteffect、useeffect" class="sidebar-link">useLayoutEffect、useEffect</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/pages/727eb5/#第二个参数-2" class="sidebar-link">第二个参数</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#usememo" class="sidebar-link">useMemo</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#usecallback" class="sidebar-link">useCallback</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#useref" class="sidebar-link">useRef</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#为啥ref获取不到hooks" class="sidebar-link">为啥ref获取不到hooks？</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#总结-2" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#使用场景" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#如何使用" class="sidebar-link">如何使用</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#render不能访问refs" class="sidebar-link">render不能访问refs</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#声明式编程" class="sidebar-link">声明式编程</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#惰性执行-lazy-evaluation" class="sidebar-link">惰性执行（Lazy Evaluation）</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#核心概念" class="sidebar-link">核心概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#数据不可变" class="sidebar-link">数据不可变</a></li><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#无状态" class="sidebar-link">无状态</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#没有副作用" class="sidebar-link">没有副作用</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#纯函数" class="sidebar-link">纯函数</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#spa" class="sidebar-link">SPA</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#mpa" class="sidebar-link">MPA</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#mvvm" class="sidebar-link">MVVM</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#mvc" class="sidebar-link">MVC</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#mvvm、mvc" class="sidebar-link">MVVM、MVC</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#单向数据流框架始祖flux" class="sidebar-link">单向数据流框架始祖Flux</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#import-react-导致文件变大" class="sidebar-link">import react 导致文件变大？</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#react-lazy" class="sidebar-link">React.lazy</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#使用-react-lazy" class="sidebar-link">使用 React.lazy</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#suspense-组件" class="sidebar-link">Suspense 组件</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#render" class="sidebar-link">render()</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#diff" class="sidebar-link">diff</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#re-render" class="sidebar-link">re-render</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/727eb5/#window-requestidlecallback" class="sidebar-link">window.requestIdleCallback()</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#双缓冲优化策略" class="sidebar-link">双缓冲优化策略</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#dangerouslysetinnerhtml" class="sidebar-link">dangerouslySetInnerHTML</a></li><li class="sidebar-sub-header level2"><a href="/pages/727eb5/#import-react-from-react" class="sidebar-link">import React from 'react'</a></li></ul></li><li><a href="/pages/520a27/" class="sidebar-link">Review</a></li><li><a href="/pages/7bb646/" class="sidebar-link">Vue</a></li><li><a href="/pages/98b72d/" class="sidebar-link">场景题</a></li><li><a href="/pages/8f19fc/" class="sidebar-link">备注</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/part/#专栏" data-v-06225672>专栏</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/yuadh" target="_blank" title="作者" class="beLink" data-v-06225672>yuadh</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-12-19</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">React<!----></h1> <!----> <div class="theme-vdoing-content content__default"><blockquote><p>虽然你知道可以优化，但不代表你应该优化</p></blockquote> <h1 id="为啥用react"><a href="#为啥用react" class="header-anchor">#</a> 为啥用React</h1> <p>答React的好处就是了</p> <ul><li><p>合成事件</p></li> <li><p>VDOM</p></li> <li><p>JSX</p></li> <li><p>生命周期</p></li> <li><p>单向数据流</p></li> <li><p>……</p></li></ul> <h1 id="react、vue"><a href="#react、vue" class="header-anchor">#</a> React、Vue</h1> <div class="language-css line-numbers-mode"><pre class="language-css"><code>引出mvc和mvvm
react和vue底层思想
优缺点
实践：技术选型
得出结论
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="相同"><a href="#相同" class="header-anchor">#</a> 相同</h2> <ul><li>组件化开发和VDOM</li> <li>支持props</li> <li>数据驱动视图，不直接操作ADOM</li> <li>支持SSR</li> <li>都借鉴MVVM的思想</li> <li>将注意力集中在 保持核心库，将其他功能 如 路由 和全局状态管理 交给相关的库</li> <li>都有自己的构建工具</li></ul> <h2 id="不同"><a href="#不同" class="header-anchor">#</a> 不同</h2> <ul><li><p>vue实现数据双向绑定，react单向数据流</p></li> <li><p>react的jsx功能强大，扩展性强</p></li> <li><p>vue的dom操作方便，for/if指令</p></li> <li><p>react思想很棒，代码更美观</p></li> <li><p>Vue标签更方便，也是封装好的语法糖</p></li> <li><p>VDOM</p></li></ul> <p><a href="https://mp.weixin.qq.com/s/oLo6vJDCjcx10QYSXqUUXA" target="_blank" rel="noopener noreferrer">Vue比React好？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="区别"><a href="#区别" class="header-anchor">#</a> 区别？</h2> <p>大体相同，都使用VDOM高效 更新视图， 提倡组件化， 实现 数据驱动视图， 使用diff算法， 对diff算法 优化，  router库实现url到组件的映射， 状态管理</p> <p>具体实现 不尽相同</p> <h3 id="组件化"><a href="#组件化" class="header-anchor">#</a> 组件化</h3> <p>组件是独立和可复用的代码组织单元，它使开发者使用小型、独立和通常可复用的组件构建大型应用</p> <p>提高开发效率**、测试性、**复用性</p> <p>降低耦合度，在保持接口不变可以替换不同组件快速完成需求，输入框，可替换日历、时间、范围等组件作具体的实现</p> <p><strong>调试方便</strong>，整个系统通过组件组合，出现问题时，排除法移除组件，根据报错组件快速定位问题，因为每个组件低耦合，职责单一，逻辑会比分析整个系统简单</p> <p><strong>提高可维护性</strong>，组件职责单一，被复用，对代码优化可获得系统整体升级</p> <p>都推崇组件化，将页面拆分成小的可复用单元提高 复用率和开发效率。 开发时react和vue有相同的套路，父子组件传参，数据状态管理，前端路由</p> <p>React推荐 JSX + inline style， 把 HTML 和 CSS 写进 JavaScript</p> <p>Vue 推荐 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解)，即 html，css，JS 写在同一个文件(vue也支持JSX写法)</p> <h3 id="vdom"><a href="#vdom" class="header-anchor">#</a> VDOM</h3> <p>表现为描述 DOM 结构及其属性信息的 对象</p> <ul><li>存储在内存</li> <li>描述ADOM</li> <li>数据变化 生成新的DOM，对比新旧VDOM将差异更新到ADOM</li></ul> <blockquote><p>优点</p></blockquote> <ul><li>减少 DOM 操作：虚拟 DOM 可以将多次 DOM 操作合并为一次操作</li> <li>研发效率的问题：虚拟 DOM 的出现，为数据驱动视图 思想提供 高度可用 载体， 前端开发 基于函数式 UI  编程方式实现高效的声明式编程</li> <li>跨平台的问题： 同一套虚拟 DOM，可 对接不同平台 渲染逻辑，从而实现“一次编码，多端运行”</li></ul> <blockquote><h3 id="react、vue-vdom相同点"><a href="#react、vue-vdom相同点" class="header-anchor">#</a> react、vue VDOM相同点</h3></blockquote> <p>都使用 Virtual DOM + Diff算法，最后都是生成render函数，render函数执行返回VNode(VDOM的数据结构，本质是树)</p> <p>每次UI更新，会根据render重新生成最新VNode，跟以前缓存起来老的VNode比对，使用Diff算法 更新ADOM（VDOM是 对象 ， 在JS引擎中， ADOM在浏览器渲染引擎中，所以操作VDOM比操作ADOM开销要小 ）</p> <blockquote><h4 id="diff-优化基本上思路相同"><a href="#diff-优化基本上思路相同" class="header-anchor">#</a> diff 优化基本上思路相同</h4></blockquote> <ul><li>tag不同认为是不同节点</li> <li>只比较同一层级，不跨级比较</li> <li>同一层级的节点用key唯一标识，tag和key都相同则认为是同一节点</li></ul> <blockquote><h4 id="diff-源码-相同之处"><a href="#diff-源码-相同之处" class="header-anchor">#</a> diff  源码 相同之处</h4></blockquote> <p>处理老节点部分，都需要把节点处理 key - value 的 Map 结构，方便在往后的比对中 快速通过节点的 key 取到对应 节点。同样在比对两个新老节点是否相同时，key 是否相同也是 判断标准。 设置一个唯一值 key 在 diff  处理 时 性能才最大化</p> <blockquote><h3 id="react和vue中vdom差别"><a href="#react和vue中vdom差别" class="header-anchor">#</a> react和vue中VDOM差别</h3></blockquote> <p>都是用js对象 模拟ADOM，VDOM的diff 最小化更新ADOM， 减小 性能损耗，按颗粒度分为不同的类型比较同层级dom节点，进行增、删、移</p> <p>按颗粒度分为tree diff， component diff， element diff. tree diff 比较同层级dom节点，进行增、删、移操作。如果遇到component， 就会重新tree diff流程</p> <blockquote><h4 id="dom的更新策略不同"><a href="#dom的更新策略不同" class="header-anchor">#</a> dom的更新策略不同</h4></blockquote> <p>react  自顶向下全diff。vue 跟踪每 个组件 依赖关系，不需要re-rendr</p> <p>react 状态 改变时， 重新render  生成新的VDOM tree， 新旧dom tree 比较，  patch打补丁方式，局部更新 。 react为 避免父组件更新 引起不必要 子组件更新，  在shouldComponentUpdate 逻辑判断，减少没必要 render，  重新生成VDOM，做差量对比</p> <p>vue通过Object.defineProperty 把 data 属性全部转为 getter/setter。 watcher实例对象 在组件渲染时，将属性记录为dep， 当dep 项中的 setter被调用时，通知watch重新计算，使得关联组件更新</p> <blockquote><h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h5></blockquote> <p>Vue2 核心Diff算法采用 双端比较 ，同时从新旧children的两端 比较，借助key值找到可复用的节点，再 操作。相比React的Diff算法，同样情况 可以减少移动节点次数，减少 性能损耗，更加 优雅</p> <h3 id="数据驱动视图"><a href="#数据驱动视图" class="header-anchor">#</a> 数据驱动视图</h3> <p>数据变化 相应 视图 更新。开发者只需要关注数据 变化而不用 手动 操作DOM</p> <blockquote><h3 id="vue-数据驱动视图"><a href="#vue-数据驱动视图" class="header-anchor">#</a> vue 数据驱动视图</h3></blockquote> <p>MVVM 框架实现。MVVM  包含3个部分:model、view和 viewModel</p> <ul><li>Model 数据</li> <li>View 视图部分， dom</li> <li>ViewModel 连接视图与数据的中间件</li></ul> <p>ViewModel是实现数据驱动视图的核心， 数据变化 ViewModel能够监听到 ， 及时 通知view 修改。同样当页面有事件触发 ，ViewModel也能够监听 ，并通知model响应。ViewModel相当于观察者，监控着双方的动作，及时通知对方操作</p> <p>首先，vuejs实例化过程中，会对遍历传给实例化对象选项中的data 选项，遍历其属性使用 Object.defineProperty 全部转为 getter/setter</p> <p>同时每个实例对象都有watcher实例对象，在模板编译的过程中，用getter访问data的属性，watcher此时把用到的data属性记为依赖，建立视图与数据联系。之后渲染视图的数据依赖改变，watcher对比前后两个的数值是否变化，确定是否通知视图re-render。这样实现所谓的数据对于视图驱动</p> <blockquote><h3 id="react的数据驱动视图"><a href="#react的数据驱动视图" class="header-anchor">#</a> react的数据驱动视图</h3></blockquote> <ul><li>pending 当前所有等待更新的<strong>state队列</strong></li> <li>isBatchingUpdates 标识当前是否处理批量更新状态，默认false</li> <li>dirtyComponent 当前所有待更新state的<strong>组件队列</strong></li></ul> <p>setState实现数据驱动视图，引发一次组件的更新过程从而实现页面的re-render</p> <ul><li>setState() 将接收的第一个参数state存储在pending队列</li> <li>判断是否处于批量更新，是 就将需要更新state的组件添加到dirtyComponents</li> <li>不是 会遍历dirtyComponents所有组件，调用updateComponent更新每个dirty组件</li></ul> <h2 id="核心思想"><a href="#核心思想" class="header-anchor">#</a> 核心思想</h2> <p><img src="https://interview.yuadh.com/assets/5e5d1297045d47898383a658cf3c0c65tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.image" alt="image.png"></p> <h1 id="react设计实现"><a href="#react设计实现" class="header-anchor">#</a> React设计实现</h1> <ul><li><p>是一个简单的JS UI库，用于构建高效、快速的用户界面</p></li> <li><p>是一个轻量级库</p></li> <li><p>遵循组件设计模式、声明式编程范式和函数式编程</p></li> <li><p>使用VDOM操作ADOM</p></li> <li><p>遵循从高阶组件到低阶组件的单向数据流</p></li></ul> <h2 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h2> <ul><li><p>提高性能</p></li> <li><p>JSX 可读性增加</p></li> <li><p>易集成使用</p></li> <li><p>代码直观</p></li> <li><p>组件简单可复用</p></li> <li><p>VDOM</p></li> <li><p>函数式编程</p></li></ul> <p><a href="https://mp.weixin.qq.com/s/l1f7KD2dGyYB25A7oWucyw" target="_blank" rel="noopener noreferrer">React 老矣，我建议大家用用别的框架<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="不习惯之处"><a href="#不习惯之处" class="header-anchor">#</a> 不习惯之处</h2> <p><a href="https://mp.weixin.qq.com/s/GglGDYgU9QDVprcQZ4nlYg" target="_blank" rel="noopener noreferrer">React 我爱你，但你太让我失望了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="jsx"><a href="#jsx" class="header-anchor">#</a> JSX</h2> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">const</span> ele<span class="token operator">=</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">hello world</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>既不是字符串也不是HTML，是jsx，是JS的语法扩展，生成React元素</p> <p>React认为渲染逻辑本质与其他UI逻辑内在耦合，将标签和逻辑共同存放在组件中，实现关注点分离</p> <p>编译之后，JSX被转换为JS普通函数调用，取值后得到JS对象</p> <p>允许在条件或循环语句中使用JSX，将其赋值给变量，传入JSX作为参数，以及从函数中返回JSX</p> <p><strong>防止注入攻击</strong></p> <ol><li>可以安全地在JSX中插入用户内容</li> <li>React的DOM在渲染所有内容后，会进行转义，确保应用中永不会注入那些不是自己写的内容</li></ol> <p><strong>JSX表示对象</strong></p> <p>Babel将JSX转译为一个名为React.createElement()函数调用</p> <p>React读取这些React元素对象并使用它们构建DOM以保持随时更新</p> <h2 id="状态提升"><a href="#状态提升" class="header-anchor">#</a> 状态提升</h2> <p>将多个组件需要共享的state 向上 移动到它们最近的公共组件 中，实现state 的共享</p> <p>让数据自顶向下单向流动，所有组件数据来自父辈组件，由父辈组件来统一存储和修改，再传入子组件</p> <p>**为了组件之间的数据更加单向性，**数据的传输上始终出现一对一的情况，方便我们只需要在向子组件传递数据的父组件上操作，并传回子组件，更新数据，体现了React单向数据流的设计思想，复用组件时，组件数据不会相互干扰，代码逻辑上便于管理</p> <h1 id="key"><a href="#key" class="header-anchor">#</a> key</h1> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token literal-property property">Warning</span><span class="token operator">:</span>Each child <span class="token keyword">in</span> an array or iterator should have a unique <span class="token string">&quot;key&quot;</span> prop
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>为啥使用</p></blockquote> <p>key在DOM中元素增删改查时帮助识别哪些元素发生变化，所以需要给每一个元素赋予唯一标志，想要访问key属性值，需要使用其他属性名 显性 访问</p> <p>diff算法将key作为唯一id对比组件value确定是否更新</p> <p>不传key也能用是因为react检测子组件没有key，默认将index作为key</p> <p>原则</p> <ul><li>key同，组件属性有变化，react只会更新组件变化的属性</li> <li>key不同，销毁之前的组件，导致re-render</li></ul> <blockquote><p>使用index存在啥问题</p></blockquote> <p>span单纯展示组件，是受控组件，值由我们定好</p> <p>若子组件只是受控组件，index作为key，表面可能不会出问题，实际性能可能受影响</p> <p>列表数据源 顺序 改变，<strong>若适用 index 作为key，对应key为0 1 2的组件都变，子组件全部会re-render</strong></p> <p><strong>注意：未添加key，兄弟节点更新位置前后错位一个，后续全部的比较都会 错误，导致找不到对比目标，性能大打折扣</strong></p> <p><strong>若使用id作为key，根据更新原则，子组件和key均未改变，顺序改变，我们只移动而不是re-render</strong></p> <p>input是非受控组件，用户可任意改变value</p> <blockquote><p>正确赋值key</p></blockquote> <p>若纯粹展示没有其他变更，使用index或其他值作为key没有问题，因为没有diff，就不会用key</p> <ul><li>和具体元素一一对应</li> <li>尽力不使用 index 作为key</li> <li>不使用随机数等 加上不稳定的key，否则性能开销比不加key更糟糕</li></ul> <blockquote><p>使用场景</p></blockquote> <p>由数组动态创建的子组件的情况</p> <p>为一个有复杂繁琐逻辑的组件添加key后，后续操作可改变key值，从而 达到 先销毁之前的组件，再重新创建该组件</p> <p><img src="https://interview.yuadh.com/assets/3b9afe10-dd69-11eb-ab90-d9ae814b240d.png" alt="img"></p> <h1 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> ⭐️ 生命周期</h1> <ul><li>挂载 mount，组件第一次在 DOM 树中被渲染</li> <li>更新过程 update，re-render</li> <li>卸载 unmount，组件从 DOM树中被移除过程</li></ul> <p>React15生命周期</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 父组件状态属性更新触发</span>
<span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 组件更新时调用，在此可拦截更新</span>
<span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 初始化渲染时调用（挂载前调用）</span>
<span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 组件更新时调用</span>
<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span>
<span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 初始化渲染时调用（挂载后调用）</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>React16</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 组件初始化和更新时调用</span>
<span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 组件更新时调用，在此可拦截更新</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 组件更新时调用</span>
<span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 组件初始化时调用（挂载后调用）</span>
<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span> <span class="token comment">// 组件更新后调用</span>
<span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="react-16前"><a href="#react-16前" class="header-anchor">#</a> React 16前<img src="https://interview.yuadh.com/assets/v2-48e4dd255a7690beaef4d496ac6af7ca_1440w.jpg" alt="img"></h2> <h2 id="react-16后"><a href="#react-16后" class="header-anchor">#</a> React 16后</h2> <p><img src="https://interview.yuadh.com/assets/1649667264564.png" alt="1649667264564"></p> <p>首次挂载 getDefaultProps、getInitialState、componentWillMount、render 和 componentDidMount</p> <p>卸载组件</p> <p>重新挂载组件 getInitialState、componentWillMount、render 和 componentDidMount，但并不执行 getDefaultProps</p> <p>更新组件 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate</p> <h2 id="constructor"><a href="#constructor" class="header-anchor">#</a> constructor</h2> <p>实例过程中自动调用，方法内部通过super关键字获取父组件的props</p> <ul><li>初始化state</li> <li>this上挂载方法</li></ul> <h2 id="_16新增2个"><a href="#_16新增2个" class="header-anchor">#</a> 16新增2个</h2> <h3 id="getderivedstatefromprops"><a href="#getderivedstatefromprops" class="header-anchor">#</a> getDerivedStateFromProps</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>type<span class="token punctuation">}</span> <span class="token operator">=</span> nextProps<span class="token punctuation">;</span>
    <span class="token comment">// 当传入的type发生变化的时候，更新state</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            type<span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 否则，对于state不进行任何操作</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li>静态方法(纯函数)</li> <li>只能通过preState 而不是 prevProps 作对比，保证了state 和 props 间的简单关系及不需要处理第一次渲染时 prevProps 为空的情况</li></ul> <p>执行时机：组件创建和更新阶段，不论是<code>props</code>变化还是<code>state</code>变化，也会调用</p> <p>在每次<code>render</code>方法前调用，第一个参数为即将更新的<code>props</code>，第二个参数为当前组件的<code>state</code>，可以比较<code>props</code> 和 <code>state</code>来加一些限制条件，防止无用的state更新</p> <p>该方法返回新对象更新state，不更新则返回 null</p> <p>静态方法阻止操作instance，阻止多次操作setState，没有instance就不能操作DOM</p> <p>逻辑应该会很简单，就不会出错，不出错就不会打断DFS过程</p> <p>getDerivedStateFromProps() contains the following legacy lifecycles:
componentWillMount
componentWillReceiveProps
componentWillUpdate</p> <blockquote><p>React 16.4后对getDerivedStateFromProps做了微调。在&gt;=16.4以后的版本中，组件任何的更新流程都会触发getDerivedStateFromProps，而在16.4以前，只有父组件的更新会触发该生命周期</p> <p>不咋使用</p></blockquote> <h3 id="getsnapshotbeforeupdate"><a href="#getsnapshotbeforeupdate" class="header-anchor">#</a> getSnapshotBeforeUpdate</h3> <p>返值Snapshot值(默认为 null )，作为componentDidUpdate第三个参数</p> <p>运行在render后，表示ADOM构建完成，但还没有渲染到页面，可理解为更新前的快照，用来做一些附加的DOM操作</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'#enter getSnapshotBeforeUpdate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'#enter componentDidUpdate snapshot = '</span><span class="token punctuation">,</span> snapshot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>获取组件更新前的一些信息，比如组件的滚动位置之类</p> <h2 id="componentdidmount"><a href="#componentdidmount" class="header-anchor">#</a> componentDidMount</h2> <p>组件挂载到ADOM节点后执行，render之后执行</p> <ul><li>执行数据获取，事件监听等操作</li></ul> <p>此处 调用 setState 触发一次额外的渲染，它 <strong>在浏览器刷新屏幕前执行！所以用户没有感知</strong>，但会带来一定性能问题</p> <p>和 componentWillMount 一样，有且仅有一次 调用！</p> <h2 id="shouldcomponentdidmount"><a href="#shouldcomponentdidmount" class="header-anchor">#</a> shouldComponentDidMount</h2> <p>告知组件本身基于当前的props和state是否需要 re-render，默认返回true</p> <p>执行时机：到新的props/state 调用，返回true/false告知组件更新与否</p> <p>一般情况，不建议在该周期方法中深层比较，影响效率</p> <p>同时也不能调用<code>setState</code>，会导致无限循环更新</p> <h2 id="componentdidupdate"><a href="#componentdidupdate" class="header-anchor">#</a> componentDidUpdate</h2> <p>ADOM挂载到页面后运行</p> <p>可根据前后的<code>props</code>和<code>state</code>变化操作，如获取数据，修改<code>DOM</code>等</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="componentwillunmount"><a href="#componentwillunmount" class="header-anchor">#</a> componentWillUnmount</h2> <p>组件卸载前，清理副作用</p> <p>一旦一个组件实例被卸载，不会被再次挂载，只可能被重新创建</p> <h2 id="准备废弃"><a href="#准备废弃" class="header-anchor">#</a> 准备废弃</h2> <ol><li>被废弃的3个方法都在render之前，因为fiber出现，可能因为高优先级任务 打断现有任务导致它们被执行多次</li> <li>React想约束使用者，好的框架能让人写出易维护和扩展的代码</li></ol> <h3 id="componentwillmount"><a href="#componentwillmount" class="header-anchor">#</a> componentWillMount</h3> <p>风险很高，鸡肋</p> <p>此函数可以使用 componentDidMount 和 constructor 代替</p> <p>为了约束开发者，直接干掉了此 API</p> <h3 id="componentwillreceiveprops-nextprops"><a href="#componentwillreceiveprops-nextprops" class="header-anchor">#</a> componentWillReceiveProps(nextProps)</h3> <p>一个API并非越复杂才越优秀</p> <p>props 变化执行，初始化render 时不执行</p> <p>老版本React中，若组件自身的某个state跟其props密切相关，没有一种优雅的方式处理state，而是需要在 componentWillReceiveProps 中判断前后2个props是否相同，若不同再将新的props更新到相应的state上</p> <p>通过 setState更新组件状态，旧属性通过this.props  获得，此处调用更新状态是安全的，不会触发额外render</p> <p><strong>优点</strong></p> <ul><li>可以在子组件的render函数执行前获取新的props，进而更新子组件自己的state</li> <li>可以将数据请求放在这里执行，需要的参数中nextProps获取，不必将所有请求都放在父组件中</li></ul> <p><strong>缺点</strong></p> <ul><li>破坏state数据的单一数据源，导致组件状态不可预测</li> <li>增加组件的重绘次数</li></ul> <h3 id="componentwillupdate"><a href="#componentwillupdate" class="header-anchor">#</a> componentWillUpdate</h3> <blockquote><p>componentWillUpdate( nextProps, nextState )</p></blockquote> <p>挡了新的Fiber架构的路</p> <ul><li>一次更新可能被调用多次，因为一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中的回调移至componentDidUpdate 就可以解决这个问题</li> <li>获取 DOM 元素状态，fiber中render可被打断，可能在WillMount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用getSnapshotBeforeUpdate解决</li></ul> <p>由getSnapshotBeforeUpdate(prevProps,prevState) 代替，在最终的render之前调用</p> <blockquote><p>为何要废弃它们？</p></blockquote> <p>在Fiber机制下，render阶段允许被暂停、终止和重启</p> <p>**导致render阶段的生命周期都可能重复执行。**这几个方法常年被滥用，执行过程中存在风险。比如setState fetch发起请求 操作ADOM等</p> <p>这些操作完全可以转移到其他方法中做</p> <p>即使没有开启异步渲染，Recat15中也可能导致一些严重的问题，比如componentWillReceiveProps和componentWillUpdate里滥用setState导致重复渲染，死循环</p> <p>首先确保了Fiber机制下数据安全性，同时也确保生命周期方法的行为更纯粹</p> <h2 id="setstate"><a href="#setstate" class="header-anchor">#</a> 🔥 setState</h2> <blockquote><p>componentWillMount中setState</p></blockquote> <p>无意义，应当将setState放在constructor中（初始化state）</p> <p>组件只挂载一次，componentWillMount中的setState回合constructor中state合并执行</p> <blockquote><p>componentDidMount中setState</p></blockquote> <p>导致组件初始化时触发更新，渲染2次</p> <blockquote><p>componentWillUnmount中setState</p></blockquote> <p>不会更新，无意义</p> <blockquote><p>shouldComponentUpdate和componentWillUpdate中setState</p></blockquote> <p><strong>禁止</strong></p> <p>造成死循环</p> <p>setState后会再次触发这2个函数，然后又触发setState</p> <blockquote><p>componentDidUpdate中setState</p></blockquote> <p>可以</p> <p>组件刚更新完成，又要更新一次，连续render两次</p> <p>和componentDidMount类似</p> <blockquote><p>componentWillReceiveProps中setState</p></blockquote> <p>可以</p> <p>不会re-render，因为只有 props变化才会触发，setState不会造成死循环</p> <h1 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 💚 组件通信</h1> <ul><li>父组件向子组件传递</li> <li>子组件向父组件传递</li> <li>兄弟组件之间的通信</li> <li>父组件向后代组件传递</li> <li>非关系组件传递</li></ul> <blockquote><p>父组件向子组件传递</p></blockquote> <p>React的数据流是单向的，这是最常见的方式，<strong><u>props</u></strong></p> <p>父子通信底层如何实现?</p> <blockquote><p>子组件向父组件传递</p></blockquote> <p>父组件向子组件**<u>传一个函数，然后通过这个函数的回调拿到子组件传递的值</u>**</p> <blockquote><p>兄弟组件之间的通信</p></blockquote> <p>父组件作为**<u>中间层实现数据互通</u>**</p> <blockquote><p>父组件向后代组件传递</p></blockquote> <p>最普通的事情，像全局数据一样</p> <p><strong><u>使用context可共享数据，其他数据都能读取对应的数据</u></strong></p> <blockquote><p>非关系组件传递</p></blockquote> <p>组件间关系类型复杂，<strong><u>可以将数据进行一个全局资源管理，从而实现通信，例如redux dva</u></strong></p> <h1 id="有-无状态组件"><a href="#有-无状态组件" class="header-anchor">#</a> 💙有/无状态组件</h1> <h2 id="有状态组件"><a href="#有状态组件" class="header-anchor">#</a> 有状态组件</h2> <p><strong>特点</strong></p> <ul><li>是类组件</li> <li>有继承</li> <li>有this</li> <li>有生命周期</li> <li>使用较多，易触发生命周期钩子函数</li> <li>内部使用state，根据外部组件传入的props和自身state渲染</li></ul> <p><strong>使用场景</strong></p> <ul><li>需要使用状态的</li> <li>需要状态操作组成的</li></ul> <p><strong>总结</strong></p> <p>可维护自己的state，可以对组件做更多的控制</p> <h2 id="无状态组件"><a href="#无状态组件" class="header-anchor">#</a> 无状态组件</h2> <p><strong>特点</strong></p> <ul><li>不依赖自身state</li> <li>可以是类组件或函数组件</li> <li>可避免使用this</li> <li>组件内部不维护state，props改变，组件re-render</li></ul> <p><strong>使用场景</strong></p> <p>组件不需要管理state</p> <p><strong>优点</strong></p> <ul><li>简化代码 专注render</li> <li>组件不需要实例化，无生命周期</li> <li>视图和数据解耦</li></ul> <p><strong>缺点</strong></p> <ul><li>无法使用ref</li> <li>无生命周期</li> <li>无法控制组件re-render</li></ul> <blockquote><p>当一个组件不需要管理自身状态时，就是无状组件，应该优先设计为函数组件，比如定义的<Button></Button></p></blockquote> <h1 id="受-非受控组件"><a href="#受-非受控组件" class="header-anchor">#</a> 受/非受控组件</h1> <h2 id="受控组件"><a href="#受控组件" class="header-anchor">#</a> 受控组件</h2> <p>表单状态变化，触发onChange，更新state</p> <p>受控组件中，组件渲染出的状态和value/checked属性相对应，react通过这种方式消除组件的局部状态，使组件变得可控</p> <p><strong>缺点</strong></p> <p>多个输入框需要获取到全部值时，需要每个都编写事件处理函数，代码臃肿</p> <p>后来，出现了非受控组件</p> <h2 id="非受控组件"><a href="#非受控组件" class="header-anchor">#</a> 非受控组件</h2> <p>Input组件有内部value，没有任何属性——非受控组件，组件状态不受外部环境控制，而是封闭在组件内部</p> <p>若把state的value放到props中——变成 受控组件(此时input值取决于外部传递的props)</p> <p>表单组件没有value props</p> <p>可使用ref 从 DOM 中获取表单值，而不是编写事件处理函数</p> <p>非受控组件可以减少代码量</p> <p><img src="https://interview.yuadh.com/assets/640.jpeg" alt="图片"></p> <h1 id="类-函数组件"><a href="#类-函数组件" class="header-anchor">#</a> 类/函数组件</h1> <p><strong>相同点</strong></p> <p>基本可认为两者完全一致</p> <p><strong>不同点</strong></p> <p>函数组件 是 无状态组件 的思想</p> <p>函数组件 无法使用 state，没有 生命周期方法，接收 props，渲染 DOM</p> <p>函数组件没有 this</p> <p>函数组件 更易理解</p> <p>函数组件性能优化依靠 React.memo缓存渲染结果实现</p> <p>类组件 基于面向对象编程，主打 没有副作用，引用透明等特点</p> <p>类组件性能优化依靠shouldC omponentUpdate阻断渲染实现</p> <h2 id="class、hooks"><a href="#class、hooks" class="header-anchor">#</a> class、hooks</h2> <p>函数式编程？</p> <p>class占内存啊，写了class写hooks可以快速切换，但是写了hooks再写class就不得行，因为所有最终回归的是C++ C 和操作系统，class相当于提供了一个框框，约束我们代码的编写</p> <p>hooks就有点放飞自我，因为是函数式编程不像class是一个类，实例 有静态方法，占用内存，而函数式就是运行完内存即释放，需要使用的变量得不到一个合适的保存，于是只有使用闭包方式，但是闭包存在挺多的问题，涉及到内存泄漏等，而且存在很多闭包，</p> <p>链式编程？</p> <p>如果有bug怎么调试，大家都是学生，首先是为了提高自己发现问题并解决问题的能力</p> <p>React存在兼容性，之所以不升级antd版本，为了兼容id浏览器</p> <h1 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 💚  性能优化</h1> <p><a href="https://mp.weixin.qq.com/s/TbB91lPQ-g2223Stqt8sJg" target="_blank" rel="noopener noreferrer">React 性能优化的那些事儿<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="卡顿原因"><a href="#卡顿原因" class="header-anchor">#</a> 卡顿原因</h2> <p>render时会根据现有render产生新的jsx数据和现有fiberRoot对比，找到不同地方，生成新的workInProgress，进而在挂载阶段把新的workInProgress交给服务器渲染</p> <p>这个过程中，为了让底层机制更加高效快速，react做了大量优化，设立任务优先级、异步调度、diff算法和时间分片等</p> <p>整个链路为了快速高效完成从数据更新到页面渲染的整体流程</p> <p>为了不让递归遍历寻找所有更新节点太大而占用浏览器资源，React升级了fiber架构，时间分片，实现增量更新</p> <p>diff——高效查找所有更新节点</p> <p>任务调度优先级——高效更新</p> <p>优化——控制刷新渲染的波及范围，只让该更新的更新，更新链路尽快走完</p> <h2 id="优化场景"><a href="#优化场景" class="header-anchor">#</a> 优化场景</h2> <ul><li>父组件更新，子组件不更新</li></ul> <blockquote><p>PureComponent、shouldComponentUpdate、父组件对子组件缓冲、memo</p></blockquote> <ul><li>组件自己控制是否刷新</li> <li>减少波及范围，无关刷新不存在state</li> <li>合并state，减少setState执行次数</li> <li>更快完成diff比较过程</li></ul> <h2 id="思路"><a href="#思路" class="header-anchor">#</a> 思路</h2> <ul><li>减少render次数</li> <li>减少渲染的节点</li> <li>key</li> <li>降低计算量</li> <li>缓存</li> <li>VDOM</li> <li>使用工具分析性能瓶颈</li> <li>使用不可突变数据结构，数组使用concat，对象使用Object.assign()</li> <li>组件尽可能拆分</li> <li>列表类组件优化</li> <li>bind函数优化</li> <li>不滥用props</li> <li>reactDOMServer进行服务端渲染组件</li></ul> <h2 id="react-memo"><a href="#react-memo" class="header-anchor">#</a> React.memo</h2> <p>React16.6新增，缓存组件</p> <p>和PureComponent相似，但memo只用于函数组件</p> <p>使用其对航班信息可视化系统做了优化</p> <p>React17+antvL7+antd</p> <p>记忆组件渲染结果，提高组件性能</p> <p>只检查props是否变化</p> <p>做浅比较</p> <p>第二个参数可传入自定义比较函数</p> <p>areEqual方法和shouldComponentUpdate返回值相反</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> App<span class="token operator">=</span>React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>
    <span class="token keyword">function</span> <span class="token function">myApp</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment">//使用props渲染 </span>
	<span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">areEqual</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//如果把prevProps传入render方法的返回结果和将nextProps传入render的返回结果一样，则返回true，否则返回false</span>
<span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="react-usememo"><a href="#react-usememo" class="header-anchor">#</a> React.useMemo</h2> <p>缓存大量计算</p> <p>函数组件中，匿名函数，箭头函数和普通函数会重新声明</p> <p>useMemo 第一个参数是函数，这个函数返回的值会被缓存，同时作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组值变化，会重新执行第一个参数的函数，并将函数返回的值缓存起来作为 useMemo 的返回值</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 避免这样做</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> someProp <span class="token operator">=</span> <span class="token function">heavyCalculation</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent someProp<span class="token operator">=</span><span class="token punctuation">{</span>someProp<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span> 
<span class="token punctuation">}</span>
  
<span class="token comment">// 只有 `props.item` 改变时someProp的值才会被重新计算</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> someProp <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">heavyCalculation</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent someProp<span class="token operator">=</span><span class="token punctuation">{</span>someProp<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span> 
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="purecomponent"><a href="#purecomponent" class="header-anchor">#</a> PureComponent</h2> <p>避免重复渲染</p> <p><code>React.Component</code>并未实现 <code>shouldComponentUpdate</code>()，而 <code>React.PureComponent</code>以浅层对比 Prop 和 State 的方式实现了该函数</p> <p><code>shouldComponentUpdate</code>做的是“浅层比较”。若是“深层比较”，某个特定组件的行为，需要我们自己编写</p> <p>父组件状态的每次更新，都会导致子组件re-render，即使传入相同props。但这里的re-render 不是说会更新DOM，而是每次都会调用diif算法判断是否需要更新DOM。这对大型组件例如组件树来说 非常消耗性能</p> <p><strong><code>shouldComponentUpdate</code>确保只有当组件props状态改变时才会re-render，返回false表示不希望组件re-render</strong></p> <p><code>PureComponent</code>进行浅比较判断组件是否应该re-render，对于传入的基本类型<code>props</code>，只要值相同，浅比较就会认为相同，对于传入的引用类型<code>props</code>，<strong>浅比较只会认为传入的props是不是同一个引用</strong>，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是不同的<code>props</code>。</p> <p><code>PureComponent</code>，因为进行浅比较也会花费时间，这种优化更适用于大型的展示组件上。大型组件也可以拆分成多个小组件，并使用<code>memo</code>来包裹小组件，也可以提升性能。</p> <ul><li>确保数据类型是值类型</li> <li>如果是引用类型，不应当有深层次的数据变化(解构)</li></ul> <p>判断步骤：</p> <ol><li>直接比较新老 <code>props</code> /新老 <code>state</code> 是否相等。相等不更新组件</li> <li>判断新老 <code>state</code> / <code>props</code> ，有不是对象/为 <code>null</code> 的，返回 false ，更新组件</li> <li><code>Object.keys</code> 将新老 <code>props</code> /新老 <code>state</code> 属性名 <code>key</code> 变成数组，判断数组长度是否相等，不相等证明有属性增加/减少，更新组件</li> <li>遍历老 <code>props</code> /老 <code>state</code> ，判断对应新 <code>props</code> /新 <code>state</code> ，有没有与之对应且相等的（这个相等是浅比较），有一个不对应/不相等，直接返回 <code>false</code> ，更新组件</li></ol> <h2 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h2> <p>函数组件没有 shouldComponentUpdate 方法，可利用 高阶组件 封装一个类似PureComponent 方法</p> <h2 id="避免内联对象"><a href="#避免内联对象" class="header-anchor">#</a> 避免内联对象</h2> <p><strong>使用内联对象时，react会在每次渲染时重新创建对此对象的引用，这会导致接收此对象的组件将其视为不同的对象</strong>，因此，该组件对于prop的浅层比较始终返回false，导致组件一直re-render。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// Don't do this!</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> aProp <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">someProp</span><span class="token operator">:</span> <span class="token string">'someValue'</span> <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token literal-property property">margin</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> aProp<span class="token operator">=</span><span class="token punctuation">{</span>aProp<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>

<span class="token comment">// Do this instead :)</span>
<span class="token keyword">const</span> styles <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">margin</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> aProp <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">someProp</span><span class="token operator">:</span> <span class="token string">'someValue'</span> <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent style<span class="token operator">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>aProp<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="避免匿名函数"><a href="#避免匿名函数" class="header-anchor">#</a> 避免匿名函数</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 避免这样做</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> props<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>

<span class="token comment">// 优化方法一</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handleChange <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> props<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent onChange<span class="token operator">=</span><span class="token punctuation">{</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>

<span class="token comment">// 优化方法二</span>
<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span> 
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="组件懒加载"><a href="#组件懒加载" class="header-anchor">#</a> 组件懒加载</h2> <p>使用新的React.Lazy和React.Suspense完成</p> <p><strong>React.lazy</strong></p> <p>定义动态加载的组件，可直接缩减打包后 bundle 体积，延迟加载在初次渲染时不需要渲染的组件</p> <p><strong>React.Suspense</strong></p> <p>悬挂 终止 暂停</p> <p>配合渲染 lazy 组件，在等待加载 lazy组件时展示 loading 元素，不至于直接空白，提升用户体验；</p> <blockquote><p>网球后台用到</p> <p>只有在生产环境下展示SettingDrawer</p></blockquote> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>PageLoading <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">renderSettingDrawer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>


<span class="token keyword">const</span> SettingDrawer <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/SettingDrawer'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="用-css"><a href="#用-css" class="header-anchor">#</a> 用 CSS</h2> <p>而不是强制加/卸载组件</p> <p>渲染成本很高，尤其是在需要更改DOM时。此操作可能非常消耗性能并可能导致延迟</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 避免对大型的组件频繁对加载和卸载</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>view<span class="token punctuation">,</span> setView<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'view1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> view <span class="token operator">===</span> <span class="token string">'view1'</span> <span class="token operator">?</span> <span class="token operator">&lt;</span>SomeComponent <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token operator">:</span> <span class="token operator">&lt;</span>AnotherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>

<span class="token comment">// 使用该方式提升性能和速度</span>
<span class="token keyword">const</span> visibleStyles <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">opacity</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> hiddenStyles <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">opacity</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>view<span class="token punctuation">,</span> setView<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'view1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>SomeComponent style<span class="token operator">=</span><span class="token punctuation">{</span>view <span class="token operator">===</span> <span class="token string">'view1'</span> <span class="token operator">?</span> visibleStyles <span class="token operator">:</span> hiddenStyles<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>AnotherComponent style<span class="token operator">=</span><span class="token punctuation">{</span>view <span class="token operator">!==</span> <span class="token string">'view1'</span> <span class="token operator">?</span> visibleStyles <span class="token operator">:</span> hiddenStyles<span class="token punctuation">}</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="react-fragment"><a href="#react-fragment" class="header-anchor">#</a> React.Fragment</h2> <p>无需 在DOM中添加额外标签，不会渲染任何元素</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello world<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello there<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello there again<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="key-2"><a href="#key-2" class="header-anchor">#</a> key</h2> <ul><li>保证key具有唯一性</li> <li>DIff算法根据key判断元素时新创建还是被移动的元素，从而减少不必要渲染</li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code>虽然key是一个prop，但是接受key的组件并不能读取到key的值，因为key和ref是React保留的两个特殊prop
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="合理使用context"><a href="#合理使用context" class="header-anchor">#</a> 合理使用Context</h2> <p>无需为每层组件手动添加 Props，通过provider接口在组件树间进行数据传递</p> <p><strong>原则</strong></p> <p>Context 中只定义被大多数组件所共用的属性</p> <ul><li>使用createContext创建一个上下文</li> <li>设置provider并通过value接口传递state数据</li> <li>局部组件从value接口中传递的数据对象中获取读写接口</li></ul> <blockquote><p>网球系统后台使用了这个技术</p></blockquote> <p>toggle——切换</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> LoginContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> LoginContext<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="虚拟列表"><a href="#虚拟列表" class="header-anchor">#</a> 虚拟列表</h2> <p>只渲染当前视口可见元素</p> <ul><li>无限滚动列表，table</li> <li>无限切换日历</li></ul> <h2 id="合理设计组件"><a href="#合理设计组件" class="header-anchor">#</a> 合理设计组件</h2> <p>简化Props</p> <p>简化State</p> <p>减少组件嵌套</p> <p>渲染函数内不该放太多副作用</p> <p>不滥用context，因为context可穿透React.memo或shouldComponentUpdate的对比，一旦context变化，所以依赖该context的组件都会刷新</p> <p>context不能精细化渲染</p> <h1 id="purecomponent、component"><a href="#purecomponent、component" class="header-anchor">#</a> PureComponent、Component</h1> <p>Component需要实现shouldComponentDidMount，而PureComponent通过浅对比默认实现了shouldComponentDidMount，当组件更新时，若组件的props 和 state都没有改变，不会触发render函数，省去VDOM的生成和对比过程</p> <p>PureComponent其最佳情况是展示组件，因为其shouldComponentUpdate()进行浅比较，如果是引用数据类型，只会比较是不是同一个地址，不会比较这个地址的数据是否改变，浅比较会忽略属性或状态突变情况</p> <p>如果确保 state和 props 经常在变，不用 PureComponent反而效率可能更好，因为浅比较也会耗性能</p> <h1 id="setstate-2"><a href="#setstate-2" class="header-anchor">#</a> ❤️ setState</h1> <p>告诉组件数据有更新，可能需要re-render，react通常会集齐一批需更新的组件，再一次性保证渲染性能</p> <p>setState改变之后，立即用this.state拿不到最新状态</p> <h2 id="同步or异步"><a href="#同步or异步" class="header-anchor">#</a> 同步or异步</h2> <img src="https://interview.yuadh.com/assets/1611908814278-be06f25f-ee6f-44d5-93f1-c0a24eecd456-16592529098803.png" alt="image.png" style="zoom:50%;"> <p>根据变量isBatchingUpdates(是否 是批量更新)  判断是直接更新this.state还是放到队列中回头再说，isBatchUpdates默认false(同步更新 this.state)，函数batchUpdates 会将isBatchingUpdates修改为true，当React调用事件处理/生命周期函数之前 调用batchedUpdates，后果就是 setState异步更新</p> <p>若isBatchingUpdates为true，命中batchUpdate机制，进行 &quot;异步更新&quot;，反之为 &quot;同步更新&quot;</p> <p>API层面，setState是普通的调用执行的函数，自然是同步API</p> <p>此 同步 非 彼 同步</p> <p>同步还是异步 指的是调用API后更新DOM是异步还是同步？——取决于 被调用的环境</p> <ul><li>React能控制的范围调用，如 合成事件、生命周期，会批量更新，状态合并后再更新DOM，为异步</li> <li>原生JS控制的范围调用，如 <strong><u><em>原生事件，定时器回调，Ajax回调，setState调用后立即更新DOM，为同步</em></u></strong></li></ul> <p>异步 就是 批量更新，减少ADOM渲染次数，在React能控制范围内，一定是批量更新(为了性能着想)，先合并 状态，再一次性 更新DOM</p> <p>setState意味着一个完整的渲染流程，包括</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>shouldComponentUpdate<span class="token operator">-</span><span class="token operator">&gt;</span>componentWillUpdate<span class="token operator">-</span><span class="token operator">&gt;</span>render<span class="token operator">-</span><span class="token operator">&gt;</span>componentDidUpdate
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>setState 批量更新(异步)  是为了避免 频繁 re-render，消耗性能</p> <p>批量更新 过程 和 事件循环 类似，来一个setState将其加入 队列，待时机成熟， 队列中 state 结果合并，最后只对最新的state 进行更新</p> <p><img src="https://interview.yuadh.com/assets/32f0f3289e2d41d098fea4ebe4685488tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.awebp" alt="img"></p> <p>在 react17 中，setState 批量执行，但如果在 setTimeout、事件监听器等函数里，setState 会同步执行。可以在外面包一层 batchUpdates 函数，手动设置 excutionContext 切换成批量执行</p> <p>react18 中所有的 setState 都是异步批量执行了</p> <h2 id="第二个参数"><a href="#第二个参数" class="header-anchor">#</a> 第二个参数</h2> <p>是一个可选的回调函数，这个函数 在 组件re-render后执行，等价于 componentDidUpdate 中执行</p> <p>可拿到更新后的state</p> <h2 id="state如何注入到组件"><a href="#state如何注入到组件" class="header-anchor">#</a> state如何注入到组件</h2> <p>通过connect 和 mapStateToProps 将state注入 到组件</p> <p>mapStateToProps(state,ownProps)中带有两个参数，含义是</p> <ul><li>state-store管理的 全局状态对象，所有组件状态都存储在该对象中</li> <li>ownProps 组件通过 props 传入的参数</li></ul> <h1 id="事件机制"><a href="#事件机制" class="header-anchor">#</a> 🍊 事件机制</h1> <p>react为了解决跨平台、兼容性问题，自己封装了一套事件机制，代理了原生事件，例如JSX的onClick和onChange都是合成事件</p> <p>充当浏览器原生事件的跨浏览器包装器 的对象</p> <p><strong>将不同浏览器行为组合到一个 API中，确保事件显示一致的 属性</strong></p> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>点我<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>React并不是将click事件绑定到了div的ADOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样减少内存消耗，还能在组件挂在销毁时统一订阅和移除事件</p> <p>除此之外，冒泡到document上的事件也不是原生浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。如果不想要事件冒泡的话应调用event.preventDefault()方法，而不是调用event.stopProppagation()方法</p> <p><img src="https://interview.yuadh.com/assets/1611890469312-7504e85d-c6db-481e-b9d3-5307a3de708c.jpeg" alt="img"></p> <p>合成事件 是react 模拟原生 DOM 事件 所有能力的事件对象，优点如下</p> <ul><li>兼容 所有浏览器，更好跨平台</li> <li>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果有很多的事件监听，就需要分配很多事件对象，造成高额内存分配。对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，便于下次复用</li> <li>事件统一 存放在一个数组，避免频繁新增和删除(垃圾回收)</li> <li>便于 react 统一管理</li></ul> <p>原生事件 先执行，合成事件 后执行，合成事件 冒泡绑定到 document 上，所以 尽量避免 原生事件和合成事件 混用，(<strong>为啥呢？？</strong>)</p> <p>因为 如果原生事件 阻止冒泡，可能导致合成事件无法执行，因为合成事件需要冒泡到 document 上才会执行</p> <h1 id="hooks"><a href="#hooks" class="header-anchor">#</a> 💚 Hooks</h1> <p>React16.8新增特性，主要解决了函数式组件无状态的问题</p> <p>类组件内部逻辑难以拆分和复用</p> <p>函数组件，内部无法定义和维护state，也叫 无状态 组件</p> <p><strong>轻量 灵活 易于维护和组织，学习成本低</strong></p> <p>组件功能清晰很小巧！</p> <ul><li>类组件需继承 class</li> <li>类组件可访问生命周期方法</li> <li>类组件可获取实例化后 的 this</li> <li>类组件可定义并维护state</li></ul> <p>hooks前，类组件边界强于函数组件</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">UI</span><span class="token operator">=</span><span class="token function">render</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
或
<span class="token constant">UI</span><span class="token operator">=</span><span class="token function">func</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="解决"><a href="#解决" class="header-anchor">#</a> 解决</h2> <ul><li>组件 逻辑复用，render props/HOC也为了复用，hooks作为官方底层API，最轻量且改造成本小，不影响组件层次结构和嵌套地狱</li> <li>复杂组件理解</li> <li>难以理解的class，不同生命周期使逻辑分散混乱，不易维护管理，关注this指向问题，代码复用代价高，HOC使整个组件变得臃肿</li> <li>状态与UI隔离，状态逻辑变成更小的粒度，易抽象为自定义hooks，组件状态和UI更清晰</li></ul> <h2 id="限制"><a href="#限制" class="header-anchor">#</a> 限制</h2> <ul><li>不在循环、条件和嵌套函数中调用(链表 实现Hook，可能导致 数组取值错位)</li> <li>仅在函数组件中调用hook(因为没有 this)</li> <li>useEffect中避免使用useState</li></ul> <h2 id="hooks和生命周期"><a href="#hooks和生命周期" class="header-anchor">#</a> hooks和生命周期</h2> <table><thead><tr><th><strong>class 组件</strong></th> <th><strong>Hooks 组件</strong></th></tr></thead> <tbody><tr><td>constructor</td> <td>useState</td></tr> <tr><td>getDerivedStateFromProps</td> <td>useState 里面 update 函数</td></tr> <tr><td>shouldComponentUpdate</td> <td>useMemo</td></tr> <tr><td>render</td> <td>函数本身</td></tr> <tr><td>componentDidMount</td> <td>useEffect</td></tr> <tr><td>componentDidUpdate</td> <td>useEffect</td></tr> <tr><td>componentWillUnmount</td> <td>useEffect 里面返回的函数</td></tr> <tr><td>componentDidCatch</td> <td>无</td></tr> <tr><td>getDerivedStateFromError</td> <td>无</td></tr></tbody></table> <h2 id="usestate"><a href="#usestate" class="header-anchor">#</a> useState</h2> <p>和class组件的state差不多</p> <p>返回一个state和更新state的函数</p> <p>初始渲染期间，返回状态和传入第一个参数相同</p> <p>setState用于state的更新，接收新的state并将组件的一次re-render加入 队列</p> <blockquote><p>为啥useState使用数组</p></blockquote> <p>解构赋值！！</p> <p>使用数组，我们可以对数组中元素命名，代码比较干净</p> <p>使用对象，解构时必须要和useState内部实现返回对象同名，多次使用只能设置别名</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 第一次使用</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> setState <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 第二次使用</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token literal-property property">state</span><span class="token operator">:</span> counter<span class="token punctuation">,</span> <span class="token literal-property property">setState</span><span class="token operator">:</span> setCounter <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><h4 id="模拟componentdidmount"><a href="#模拟componentdidmount" class="header-anchor">#</a> 模拟componentDidMount</h4></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'componentDidMount'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="uselayouteffect、useeffect"><a href="#uselayouteffect、useeffect" class="header-anchor">#</a> useLayoutEffect、useEffect</h2> <p>useEffect相当于是一个副作用的函数</p> <p>渲染阶段 可改变DOM、添加订阅、设置定时器、记录日志，执行包含副作用的操作都不被允许，可能产生bug 破坏UI一致性</p> <p>使用useEffect完成副作用操作</p> <ul><li>共同点</li></ul> <p>都是处理副作用，包括 DOM改变，订阅设置，定时器操作</p> <ul><li>不同点</li></ul> <p>useEffect 渲染之前 异步调用，不会等待DOM真正渲染后执行，可能会闪烁</p> <p>useLayoutEffect 渲染之前 同步调用，不会闪烁，**总是比 useEffect先执行！**可获取更新的state</p> <p><code>useLayoutEffect</code> 和 <code>componentDidMount</code>，<code>componentDidUpdate</code> 执行时机一样，在浏览器将所有变化渲染到屏幕之前执行</p> <p>建议使用 <code>useEffect</code>！建议使用 <code>useEffect</code>！建议使用 <code>useEffect</code>！ 避免阻塞视觉更新</p> <p>页面有异常就再替换为 useLayoutEffect</p> <blockquote><p>项目中用于发送请求</p></blockquote> <blockquote><h4 id="第二个参数-2"><a href="#第二个参数-2" class="header-anchor">#</a> 第二个参数</h4></blockquote> <div class="language-json line-numbers-mode"><pre class="language-json"><code>航班系统中使用useEffect第二参数对系统发送请求进行优化，仅在组件挂载和卸载时执行，传递一个<span class="token punctuation">[</span><span class="token punctuation">]</span>，作为第二参数，告诉React我的effect不依赖于props或state中的任何值，不需要重复执行

控制不同航班信息的展示，使用useEffect的第二个参数传递一个state，控制drawer的变化，只有state变化了，effect才会执行，async-await执行结束，数据更新，打开drawer就有效果了

收集子组件的值，将参数和函数一起传入子组件，子组件调用函数，父组件就能接收子组件的值了，根据传回来的数据，以及判断URL，重新获取数据，根据state更新对应的值，渲染界面
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>第一个参数 是回调函数</p> <p>第二个参数 是依赖</p> <p>当第二个参数为null或undefined时，回调每次 render 都会执行，参数为数组时，只有依赖变了才会执行</p> <p>VDOM转fiber的过程叫做reconcile，更新到DOM的过程叫做 commit，reconcile的过程可打断，需要schedule</p> <p><strong>hooks也是基于fiber实现，它在fiber节点上维护一个链表（memorizedState属性）来保存数据，每个hook都是从对应的链表元素上存取各自的数据</strong></p> <p>这个链表建立的过程叫做——mount，以后只需要update，所以每个hook的实现都分为mount和update两个阶段</p> <blockquote><p>useEffect第二个参数对应的是 deps，如何判断是否要更新？？</p></blockquote> <p>deps是新传入的参数，若是undefined会作为null，hook.memorizedState.deps 取到的是之前的 deps</p> <p>如果 prevDeps 是 null，直接返回 false，所以第二个参数传 undefined 或 null 函数都会执行</p> <p>否则，才会新旧的 deps 数组中每个元素对比，有一个不一样就返回 false</p> <h2 id="usememo"><a href="#usememo" class="header-anchor">#</a> useMemo</h2> <p>当父组件中调用子组件时，父组件的state变化，会导致父组件更新，子组件即使没有变化，也会更新</p> <p>函数式组件从头更新到尾，只要一处改变，所有模块都会刷新——没必要！</p> <p>理想状态是 各个模块只进行 自己的更新，不相互影响</p> <p>useMemo为了防止一种情况——父组件更新，无论是否最子组件操作，子组件都会更新</p> <p>memo 结合了 PureComponent 纯组件 和 componentShouldUpdate 功能，会对传入的props进行一次对比，根据第二个函数返回值判断哪些props需要更新</p> <p>useMemo和memo类似，都是 判断 是否满足当前限定条件决定是否执行 callback ，useMemo的第二个参数是一个数组，通过这个数组判断是否更新回调函数</p> <p>好处</p> <ul><li>减少不必要 循环 和 渲染</li> <li>减少 子组件 渲染次数</li> <li>避免不必要 的开销</li></ul> <h2 id="usecallback"><a href="#usecallback" class="header-anchor">#</a> useCallback</h2> <p>和useMemo <strong>可以说是一模一样</strong>，唯一不同的是useMemo返回函数运行结果，而useCallback返回函数</p> <p>缓存回调，避免传入的回调每次都是新的函数实例导致依赖组件re-render</p> <p>是父组件传递子组件的 一个函数，防止无关 刷新，必须配合 memo，否则可能 还会降低 性能</p> <h2 id="useref"><a href="#useref" class="header-anchor">#</a> useRef</h2> <p>获取组件真实节点，返回一个可变的ref对象，且这个对象 只有 current 属性，可设置 initialValue</p> <blockquote><p>缓存数据</p></blockquote> <p>react-redux 源码中，hooks推出后，react-redux用大量的useMemo重做了 Provide 等核心模块，运用了useRef 缓存数据，所运用的useRef() 没有一个是绑定在dom元素上的，都是用于数据缓存</p> <p>react-redux 利用 重新赋值，改变了缓存的数据，减少不必要更新，如果使用userState势必会re-render</p> <h3 id="为啥ref获取不到hooks"><a href="#为啥ref获取不到hooks" class="header-anchor">#</a> 为啥ref获取不到hooks？</h3> <h2 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h2> <ul><li>一个优秀的hooks一定具备 useMemo useCallback 等api 优化</li> <li>制作自定义hooks遇到传递过来的值，优先考虑使用useRef，再考虑使用useState</li> <li>封装时，应该将存放的值放入useRef中</li></ul> <h1 id="hooks原理"><a href="#hooks原理" class="header-anchor">#</a> Hooks原理</h1> <p>hooks的本质是链表，保存在组件对应fiber的memoizedState中</p> <h1 id="ref"><a href="#ref" class="header-anchor">#</a> 🙋 ref</h1> <p>ref --&gt; reference：引用</p> <p>React中 引用简写，是一个 属性，助于 存储 对React元素 或 组件的引用，引用由组件渲染配置函数返回</p> <p>ref使用有三种方式：字符串(不推荐使用)，对象，函数</p> <p>1、字符串 React16 之前用的最多的，如</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>info<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">text</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>2、函数格式，ref对应一个方法，该方法有一个参数，即，对应的节点实例</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token parameter">ele</span><span class="token operator">=&gt;</span><span class="token keyword">this</span><span class="token punctuation">.</span>info<span class="token operator">=</span>ele<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">test</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>3、createRef方法，React16 提供的API，使用React.createRef()实现</p> <h2 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h2> <ul><li>input标签聚焦</li> <li>希望直接使用DOM元素中的某个方法，或者<strong>直接使用自定义组件中的某一个方法</strong></li> <li>ref作用于内置的HTML组件，得到的将是真实的DOM元素</li> <li>ref作用于类组件，得到的将是类的实例</li> <li>ref不能作用于函数组件，因为函数组价没有实例，但是函数组件中可以传递ref</li></ul> <h2 id="如何使用"><a href="#如何使用" class="header-anchor">#</a> 如何使用</h2> <ol><li>class 组件 <code>React.createRef()</code> 声明</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token keyword">this</span><span class="token punctuation">.</span>myRef <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>myRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="2"><li>在函数组件使用 React.forwardRef() 来暴露函数组件的 DOM 元素</li></ol> <div class="language-JS line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> Input <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>input <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">MyComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">clickHandle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 操作Input组件聚焦</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>clickHandle<span class="token punctuation">}</span><span class="token operator">&gt;</span>
          点击
        <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Input ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h2 id="render不能访问refs"><a href="#render不能访问refs" class="header-anchor">#</a> render不能访问refs</h2> <p>因为 render 阶段 DOM还未生成，无法获取 DOM，DOM的获取需要在 pre-commit 和 commit 阶段</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>span id<span class="token operator">=</span><span class="token string">&quot;name&quot;</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>spanRef<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span><span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>spanRef<span class="token punctuation">.</span>current <span class="token operator">?</span> <span class="token string">'有值'</span> <span class="token operator">:</span> <span class="token string">'无值'</span>
  <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>不可以！</p> <p>因为render阶段DOM还没有生成</p> <p>DOM的获取应该在 pre-commit 阶段和 commit 阶段</p> <h1 id="高阶组件-hoc"><a href="#高阶组件-hoc" class="header-anchor">#</a> 🍊 高阶组件(HOC)</h1> <p>是&quot;纯组价&quot;，解决**<u><em>代码复用！</em></u>**</p> <p>不是react API 的一部分，是基于React的组合特性而形成的设计模式，HOC 是参数为 组**<u><em>件，返回值为 新组件 的函数！</em></u>**</p> <p>优点</p> <ul><li>逻辑复用、不影响被包裹组件的内部逻辑</li> <li>缺点是HOC传递给被 包裹组件的props 容易和被包裹后的组件 重名，被覆盖</li></ul> <blockquote><p>此处朱云博培训时讲过，BasicLayout中就存在这个情况，<strong>不知道谁传递的参数，而且参数名容易被覆盖</strong></p></blockquote> <p><strong><u><em>HOC就是装饰器模式的实现</em></u></strong>：通过给函数传入一个组件后在函数内部对该组件 进行功能的增强，最后返回这个组件，即允许向一个现有的组件添加新的功能，同时不修改该组件</p> <h1 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h1> <h2 id="声明式编程"><a href="#声明式编程" class="header-anchor">#</a> 声明式编程</h2> <h2 id="惰性执行-lazy-evaluation"><a href="#惰性执行-lazy-evaluation" class="header-anchor">#</a> 惰性执行（Lazy Evaluation）</h2> <p>函数只在需要的时候执行，即不产生无意义的中间变量。</p> <h2 id="核心概念"><a href="#核心概念" class="header-anchor">#</a> 核心概念</h2> <h3 id="数据不可变"><a href="#数据不可变" class="header-anchor">#</a> 数据不可变</h3> <h3 id="无状态"><a href="#无状态" class="header-anchor">#</a> 无状态</h3> <p>强调对于一个函数，不管合适运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</p> <p><img src="https://interview.yuadh.com/assets/1650114937658.png" alt="1650114937658"></p> <h2 id="没有副作用"><a href="#没有副作用" class="header-anchor">#</a> 没有副作用</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code>传递引用一时爽，代码重构火葬场
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="纯函数"><a href="#纯函数" class="header-anchor">#</a> 纯函数</h2> <h1 id="开发模式"><a href="#开发模式" class="header-anchor">#</a> 💙 开发模式</h1> <h2 id="spa"><a href="#spa" class="header-anchor">#</a> SPA</h2> <p>单页面应用，我们熟知的React就是典型的单页面应用</p> <h2 id="mpa"><a href="#mpa" class="header-anchor">#</a> MPA</h2> <h2 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h2> <p>Model-View-ViewModel，Model数据模型，View表示UI组件，ViewModel将Model和View关联起来</p> <p>数据绑定到viewModel层并自动将数据渲染到页面，视图变化时通知viewModel层更新数据</p> <p>将JS逻辑从繁琐的DOM操作中抽离出来</p> <p><strong><u>通信是双向的</u></strong></p> <p><img src="https://interview.yuadh.com/assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5paH6buY,size_20,color_FFFFFF,t_70,g_se,x_16-16618573458566-16618573478768.png" alt="在这里插入图片描述"></p> <blockquote><p>应用场景</p></blockquote> <ul><li>针对具有复杂交互逻辑的前端应用</li> <li>提供复杂架构抽象</li> <li>Ajax数据持久化，保证用户体验</li></ul> <h2 id="mvc"><a href="#mvc" class="header-anchor">#</a> MVC</h2> <p>Model View Controller</p> <p><img src="https://interview.yuadh.com/assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5paH6buY,size_20,color_FFFFFF,t_70,g_se,x_16-16618573121925.png" alt=" "></p> <p><strong><u>所有通信都是单向的</u></strong></p> <h2 id="mvvm、mvc"><a href="#mvvm、mvc" class="header-anchor">#</a> MVVM、MVC</h2> <p>MVC是后端的思想</p> <p>MVVM是前端的思想</p> <h2 id="单向数据流框架始祖flux"><a href="#单向数据流框架始祖flux" class="header-anchor">#</a> 单向数据流框架始祖Flux</h2> <p>一个Flux应用包含四个部分</p> <ol><li>dispatcher，处理动作分发，维持store之间的依赖管理</li> <li>store 负责存储数据和处理数据逻辑</li> <li>action 驱动dispatcher的JS对象</li> <li>view 视图部分，负责用户界面的显示</li></ol> <p>访问view——view发送 action——dispatcher接收action——store更新——发送change事件——view更新页面</p> <p><img src="https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwenpdf/202207210940314.png" alt="Flux -React 面试问题 - Edureka"></p> <h2 id="import-react-导致文件变大"><a href="#import-react-导致文件变大" class="header-anchor">#</a> import react 导致文件变大？</h2> <p>Gzip压缩</p> <h1 id="react路由懒加载"><a href="#react路由懒加载" class="header-anchor">#</a> React路由懒加载</h1> <h2 id="react-lazy"><a href="#react-lazy" class="header-anchor">#</a> React.lazy</h2> <p>React16.6新增React.lazy方法，像渲染常规组件一样处理动态引入的组件，配合 webpack 的 Code Splitting ，只有当组件被加载，对应的资源才会导入 ，从而达到懒加载的效果。</p> <h2 id="使用-react-lazy"><a href="#使用-react-lazy" class="header-anchor">#</a> 使用 React.lazy</h2> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 不使用 React.lazy</span>
<span class="token keyword">import</span> OtherComponent <span class="token keyword">from</span> <span class="token string">'./OtherComponent'</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 React.lazy</span>
<span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>React.lazy 接受一个函数作为参数，这个函数需要调用 import() 。它需要返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件。</p> <p>React.lazy 方法返回的是一个 lazy 组件的对象，类型是 react.lazy，并且 lazy 组件具有 _status 属性，与 Promise 类似它具有 Pending、Resolved、Rejected 三个状态，分别代表组件的加载中、已加载、和加载失败三中状态。</p> <p>需要注意的一点是，React.lazy 需要配合 Suspense 组件一起使用，在 Suspense 组件中渲染 React.lazy 异步加载的组件。如果单独使用 React.lazy，React 会给出错误提示。</p> <h3 id="suspense-组件"><a href="#suspense-组件" class="header-anchor">#</a> Suspense 组件</h3> <p>Suspense 内部主要通过捕获组件的状态去判断如何加载，上面我们提到 React.lazy 创建的动态加载组件具有 Pending、Resolved、Rejected 三种状态，当这个组件的状态为 Pending 时显示的是 Suspense 中 fallback 的内容，只有状态变为 resolve 后才显示组件</p> <h1 id="vdom-2"><a href="#vdom-2" class="header-anchor">#</a> ⭐️ VDom</h1> <p>一个对象，最少包含tag、props和children三个属性，将真实的DOM树转换为JS对象树，VD和dom对象一一对应</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>button <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;myButton&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span><span class="token keyword">this</span> is button<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token comment">//转换</span>
<span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'button'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">className</span><span class="token operator">:</span> <span class="token string">'myButton'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'text'</span>
        <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">'this is button'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>将多次DOM修改的结果一次性更新到页面上，有效减少页面渲染次数，减少修改DOM的重排重绘次数，提高渲染性能</p> <p>优越之处在于，提供更爽的、更高效的研发模式(函数式的UI编程模式)的同时，仍然保持还不错的性能</p> <ul><li>保证性能下限，不手动优化时，提供过得去的性能</li> <li>跨平台</li></ul> <p>原生DOM有很多属性和事件，创建空的div也要付出很多代价，可通过diff算法和数据改变前的DOM对比，计算出需要修改的DOM，只对变化的DOM操作，而不是更新整个视图</p> <h2 id="render"><a href="#render" class="header-anchor">#</a> render()</h2> <p>1.构建虚拟 DOM</p> <p>2.通过虚拟 DOM 构建真正的 DOM</p> <p>3.生成新的 VDOM</p> <p>4.比较两棵 VDOM 异同</p> <p>5.应用变更于 DOM</p> <h2 id="diff"><a href="#diff" class="header-anchor">#</a> diff</h2> <p>DOM是多叉树结构，若完整对比两棵树的差异，时间复杂度高，React团队优化实现了O(n)的复杂度</p> <p><strong>关键是只对比同层节点，而不是跨层对比</strong></p> <ol><li>JS建立节点描述对象</li> <li>状态或属性改变后重新计算VD生成补丁对象，diff比较分析新旧VDOM差异</li> <li>将差异patch到ADOM实现更新</li></ol> <p>JS层面的计算返回一个patch对象，即补丁，通过特定的操作解析patch，完成页面re-render</p> <p><img src="https://interview.yuadh.com/assets/1609406214678-c2afb29a-fcbc-4d54-8970-97cb7f20fe20.jpeg" alt="CgqCHl_qyouAAkb9AAB_cmWuZhc920_mh1609406106571.jpg"></p> <ol><li>ADOM映射为VDOM</li> <li>VDOM变化后，根据差距生成patch，这个patch是结构化数据，包括增加 更新 和移除</li> <li>根据patch更新 ADOM</li></ol> <p><img src="https://interview.yuadh.com/%5C1609406240365-40166729-9e07-43a2-a9f2-71838e830ad8.jpeg" alt="CgqCHl_qypGAZPuGAADYrK9nkJY878_mh1609406162857.jpg"></p> <p>大部分diff算法思路是</p> <ul><li>只比较同一层级，不跨级比较</li> <li>tag不同，直接删除重建，不再深度比较</li> <li>tag和key都相同，则认为是相同节点，不再深度比较</li></ul> <p>diff 从 <strong><u>树 组件 及 元素</u></strong> 3个层面进行复杂度的优化</p> <p>树diff</p> <blockquote><p>新旧两棵树逐层对比，找到需要更新的节点</p> <p>若节点是组件就  component diff</p> <p>1、忽略节点跨层级操作</p> <p>若节点不存在了，则该节点及其子节点会被删除掉，不会进一步比较</p></blockquote> <p>组件diff</p> <blockquote><p>节点是组件，先看组件类型</p> <p>类型不同直接替换(删除旧的)</p> <p>类型相同则只更新属性，深入组件做树diff(递归)</p> <p>若组件 是同一类型就进行树 对比，如果不是就直接放入 patch中，只要父组件类型不一致，就会re-render</p></blockquote> <p>元素diff</p> <blockquote><p>若节点是原生标签，则看标签名</p> <p><strong>标签名不同直接替换，相同则只更新属性，进入标签后代做树diff</strong></p></blockquote> <p><strong><u><em>同一层级子节点，通过key 进行列表对比</em></u></strong></p> <p>标记key，React 可以直接移动 DOM节点，降低消耗</p> <p><strong><u><em>patch做了啥</em></u></strong></p> <p><img src="https://interview.yuadh.com/assets/58f567538c1d4cffa7264cf5467ed271tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.image" alt="image-20210728172052418"></p> <h2 id="re-render"><a href="#re-render" class="header-anchor">#</a> re-render</h2> <ol><li>对比新旧 VNode，使用 diff算法</li> <li>对新旧两棵树进行深度优先遍历，标记每个节点，每遍历一个，就把该节点和新的节点进行对比，有差异就放在一个对象中</li> <li>遍历差异对象，根据对应 规则 更新VNode</li></ol> <p>VDOM 优势之处在于，不管数据如何变化，它都会尽量以最小的代码更新 DOM</p> <h1 id="vdom比原生快"><a href="#vdom比原生快" class="header-anchor">#</a> VDOM比原生快？</h1> <p><a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener noreferrer">网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h1 id="react17新特性"><a href="#react17新特性" class="header-anchor">#</a> React17新特性</h1> <p><a href="https://juejin.cn/post/6974617278784471048#heading-5" target="_blank" rel="noopener noreferrer">一起来看 React 18 最新特性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://zh-hans.reactjs.org/blog/2021/06/08/the-plan-for-react-18.html" target="_blank" rel="noopener noreferrer">React 18 带来了什么 ——官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>V15-V16，源码架构中的 Stack Reconciler-Fiber Reconciler</p> <p>启发式更新算法——对开发者无感知</p> <p>React纯JS写法太过灵活，编译时优化 方面先天不足，因此，React的优化主要在 <strong>运行时</strong></p> <blockquote><p>React15的痛点</p></blockquote> <p>React15 实现了batchdUpdates（批量更新），即 同一事件回调函数上下文中的多次 setState 只会触发一次 更新</p> <p>但是，如果单次更新就很耗时，造成页面卡顿</p> <p>因为v15的更新流程是同步的，一旦开始直到页面渲染前都不能中断</p> <p>为了解决 同步更新 长时间占用 线程 导致页面卡顿的问题，React开始重构，为了实现 Concurrent Mode（并发模式）</p> <blockquote><p>Concurrent Mode</p></blockquote> <p>为了 实现 一套 可中断/恢复 的更新机制</p> <p>2个部分组成</p> <ol><li>一套 协程 架构</li> <li>基于 协程架构的 启发式更新算法</li></ol> <p>协程架构就是V16实现的Fiber Reconciler，可将Fiber Reconciler理解为React自己实现的Generator</p> <p>协程架构 使 更新 可在需要时被 <strong>中断</strong>，酱紫 浏览器就有时间 完成 样式布局和绘制，减少 卡顿</p> <p>当进入下一次 Event Loop，协程架构 可 恢复中断 或 抛弃之前的 更新，重新开始新的更新流程</p> <p><strong>启发式更新算法</strong> 就是控制 协程架构 工作方式的算法</p> <blockquote><p>V16的启发式更新算法</p></blockquote> <p>启发式 ——不通过 显式指派，而是 通过 优先级 调度更新（优先级来自 人机交互的研究成果）</p> <p><em>人机交互研究结果表明：</em></p> <p><em>用户在输入框输入内容时，希望内容能实时显示</em></p> <p><em>异步请求时，即使等待一会儿再显示内容，用户勉强也能接受</em></p> <p>因此，V16中</p> <p><strong>输入框内容触发的 更新 优先级 &gt;请求数据返回 后触发 更新 优先级</strong></p> <p>V16的 expirationTimes模型只区分是否&gt;=expirationTimes 决定节点是否更新</p> <blockquote><p>V17启发式更新算法</p></blockquote> <p>最理想的模型——可指定任意几个 优先级，更新 以这些 优先级 对应的 update 生成页面快照</p> <p>V17的lanes模型可选定一个 更新区间，动态向 区间 增减 优先级，可处理更细粒度的更新</p> <h1 id="fiber"><a href="#fiber" class="header-anchor">#</a> 🔥 Fiber</h1> <p>JS单线程运行，负责页面JS解析和执行、绘制、事件处理、资源加载和处理，只能一个一个执行，若一个任务耗时很长，后面的任务则不能执行，卡死。</p> <p>JS引擎和页面渲染引擎两个线程互斥。</p> <p>React 15 ，渲染时 递归对比 VDOM，找需要变动的节点，同步更新，一气呵成！！此过程React霸占浏览器资源，导致用户触发的事件得不到响应，掉帧 卡顿！！Stack Reconciler是同步过程，使用JS引擎自身的函数调用栈，执行到栈空为止，渲染组件时，开始到渲染完成整个过程一气呵成，无法中断</p> <p>组件较大，js线程一直执行，等到整棵<code>VDOM</code>树计算完成 才会交给渲染的线程</p> <p>所有任务没有优先级，按照顺序执行</p> <p>期望找出有增删改的节点，同步更新这个过程分解成2个部分，或变成可中断/恢复的执行，类似 多任务OS的单处理调度</p> <p>将浏览器 渲染 布局 绘制 资源加载 事件响应 脚本执行 看成OS的process，通过 调度策略合理分配 CPU 资源，提高浏览器  响应速率，兼顾 执行效率</p> <p>React16起，引入 Fiber 架构</p> <p><strong>fiber是 链表，可以打断，可通过 requestIdleCallback 空闲调度 reconcile，不断循环，直到处理完所有的 VDOM 转fiber的reconcile，开始 commit，即 更新到ADOM</strong></p> <p>requestIdleCallback实现，React 团队 polyfill 了这个 API，使其兼容性更好且拓展了特性</p> <blockquote><h3 id="window-requestidlecallback"><a href="#window-requestidlecallback" class="header-anchor">#</a> window.requestIdleCallback()</h3></blockquote> <p>浏览器空闲时 被调用，使 开发者能在主事件循环上执行后台和低优先级工作，不影响延迟 关键事件，如 动画 和输入响应</p> <p>函数一般按先进先调用顺序执行，然而，如果回调指定了执行超时时间 timeout，可能会为了在超时前执行函数 打乱执行顺序</p> <p><img src="https://interview.yuadh.com/assets/process.png" alt="更新流程"></p> <ul><li>分批延时 操作 DOM，避免一次性操作大量 DOM 节点，用户体验更好</li> <li>给浏览器一点喘息的机会，对代码进行 编译 优化 及热代码优化</li></ul> <p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3OTYzMDkzMg==&amp;mid=2247488140&amp;idx=1&amp;sn=8740d01bd4ebfcd676ec0d40936345b6&amp;chksm=cf00ddb7f87754a1b124890c645b8f73c9dfcdd4b68d7983900815bfa47159e856e1cfd1c539&amp;scene=178&amp;cur_album_id=2150429217522614274#rd" target="_blank" rel="noopener noreferrer">手写简易版 React 来彻底搞懂 fiber 架构<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>实现元素的更新</p></blockquote> <h2 id="双缓冲优化策略"><a href="#双缓冲优化策略" class="header-anchor">#</a> 双缓冲优化策略</h2> <p>连体婴结构</p> <p>先绘制到一个缓冲区，再一次性传递给屏幕显示，防止抖动</p> <p>好处</p> <ul><li>及时复用对象(fiber)</li> <li>节省内存分配，GC时间开销</li></ul> <p>当前dom树对应的fiber树交currentFiber，正在构建的fiber树交workInProgress Fiber，两棵树 通过alternate相连</p> <p><img src="https://interview.yuadh.com/assets/image-20220921142827234.png" alt="image-20220921142827234"></p> <ul><li>将每次渲染完后的fiber树赋值给<code>currentRoot</code></li> <li>第一次更新时将<code>rooterFiber</code>的<code>alternate</code>指向<code>上一次渲染好的currentRoot</code></li> <li>第二次之后的更新将<code>workInProgressRoot</code>指向<code>currentRoot.alternate</code>，然后将当前的<code>workInProgressRoot.alternate</code>指向<code>上一次渲染好的currentRoot</code></li> <li>...</li> <li>进而达到复用fiber对象树</li></ul> <p>alternate对象会接收上方传递的新props，从getDerivedStateFromProps得到新的state，render不一样的组员，master和alternate差异越来越大，子组件出错 则回滚到组件的master分支</p> <p><strong><u>模拟git add、git commit和git revert</u></strong></p> <p><strong><u>更新过程由current和workInProgress 两株树双缓冲 完成</u></strong></p> <p>workInProgress更新完成后 修改 current 相关指针 指向新节点</p> <p>双缓冲：经过reconcile形成新的workInProgress Fiber，将workInProgress Fiber切换成current Fiber应用到ADOM，存在双fiber的好处是内存形成视图的描述，应用到dom，减少对dom的操作</p> <h1 id="react渲染机制"><a href="#react渲染机制" class="header-anchor">#</a> React渲染机制</h1> <p><img src="https://interview.yuadh.com/assets/image-20220531160934180.png" alt="image-20220531160934180"></p> <h1 id="获取dom"><a href="#获取dom" class="header-anchor">#</a> 获取dom</h1> <p>react-dom中的findDOMNode()</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> dom <span class="token operator">=</span> ReactDOM<span class="token punctuation">.</span><span class="token function">findDOMNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// this为当前组件的实例</span>
<span class="token punctuation">}</span>

<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>当组件被渲染 ，findDOMNode 返回该组件实例对应的DOM节点</p> <p>refs</p> <p>多用于React组件内子组件的引用</p> <p>有两种情况：</p> <p>（1）子组件为原生DOM：获取到的就是这个DOM节点。如下例，this.input就获取到了当前<code>&lt;input /&gt;</code>节点。</p> <div class="language-csharp line-numbers-mode"><pre class="language-csharp"><code><span class="token operator">&lt;</span>input <span class="token keyword">ref</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token keyword">ref</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>myInput <span class="token operator">=</span> <span class="token keyword">ref</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过this.myInput，我就可以对<code>&lt;input /&gt;</code>进行一系列操作，比如让输入框聚焦：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>this.myInput.<span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注：refs也支持字符串格式：</p> <div class="language-csharp line-numbers-mode"><pre class="language-csharp"><code><span class="token operator">&lt;</span>input <span class="token keyword">ref</span><span class="token operator">=</span>'myInput' <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>通过this.refs.myInput获取到节点。</p> <p>（2）子组件为React组件，比如<code>&lt;MyInput/&gt;</code>：获得的就是<code>&lt;MyInput/&gt;</code>的实例，因此就可以调用<code>&lt;MyInput/&gt;</code>的实例方法。
示例：</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> myComp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>refs<span class="token punctuation">.</span>myComp<span class="token punctuation">;</span>  <span class="token comment">// 获取到的是&lt;Comp /&gt;的实例myComp</span>
    <span class="token keyword">const</span> dom <span class="token operator">=</span> ReactDOM<span class="token punctuation">.</span><span class="token function">findDOMNode</span><span class="token punctuation">(</span>myComp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取到实例对应的DOM节点</span>
<span class="token punctuation">}</span>

<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Comp</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>myComp<span class="token punctuation">'</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>注：调用<code>&lt;Comp /&gt;</code>实例方法的方式：this.refs.myComp.method()，但并不建议这种调用方式。</p> <h1 id="others"><a href="#others" class="header-anchor">#</a> others</h1> <h2 id="dangerouslysetinnerhtml"><a href="#dangerouslysetinnerhtml" class="header-anchor">#</a> dangerouslySetInnerHTML</h2> <p>是REact中innerHTML的替代品</p> <p>网球系统中使用过，用来接收新闻正文，显示新闻数据HTML</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">dangerouslySetInnerHTML</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token literal-property property">__html</span><span class="token operator">:</span> newsTexts <span class="token punctuation">}</span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>React的HTML元素上的一个属性，它可能是危险的，因为我们容易收到XSS(跨站脚本攻击)——从第三方获取数据或用户提交内容时</p> <p>React会识别HTML标签，然后渲染</p> <p>HTML元素可能会执行脚本，当JS代码附加到HTML元素上</p> <p>使用HTML净化工具DOMPurify检测HTML中潜在的恶意部分</p> <h2 id="import-react-from-react"><a href="#import-react-from-react" class="header-anchor">#</a> import React from 'react'</h2> <p>在使用JSX的JS文件中，必须显示声明，为啥？</p> <p>JSX在编译时会被Babel编译为React.createElement()方法</p> <p>否则在运行时该模块会报错——未定义变量React</p> <p>React17中，不需要显式导入React</p></div></div> <!----> <div class="page-edit"><div class="edit-link"><a href="https://github.com/yuadh/interview2/edit/master/docs/08.专栏/10.React.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/02/07, 15:11:55</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/a9e64c/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Project-Others</div></a> <a href="/pages/520a27/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Review</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/a9e64c/" class="prev">Project-Others</a></span> <span class="next"><a href="/pages/520a27/">Review</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/code" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/e0384f/"><div>
            青训营真题day01
            <!----></div></a> <span class="date">02-07</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/332858/"><div>
            01day01-html与css
            <!----></div></a> <span class="date">02-07</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/0da785/"><div>
            day02-js
            <!----></div></a> <span class="date">02-07</span></dt></dl> <dl><dd></dd> <dt><a href="/code" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/yuadh" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2023
    <span>yuadh | <a href="https://github.com/yuadh/interview2/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.85915171.js" defer></script><script src="/assets/js/2.68cc8c44.js" defer></script><script src="/assets/js/58.85354619.js" defer></script>
  </body>
</html>
