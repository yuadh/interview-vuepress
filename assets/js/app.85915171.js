(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var o,i,s=e[0],l=e[1],c=e[2],u=0,p=[];u<s.length;u++)i=s[u],Object.prototype.hasOwnProperty.call(r,i)&&r[i]&&p.push(r[i][0]),r[i]=0;for(o in l)Object.prototype.hasOwnProperty.call(l,o)&&(n[o]=l[o]);for(d&&d(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],o=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(o=!1)}o&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var o={},r={1:0},a=[];function i(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var o=new Promise((function(e,o){t=r[n]=[e,o]}));e.push(t[2]=o);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"68cc8c44",3:"ec6089ea",4:"8f7ec523",5:"ee867fce",6:"eaba5766",7:"38795195",8:"124fdfe3",9:"8f91cfa5",10:"bbbc158b",11:"d369f77a",12:"2df2e0c2",13:"f9e3c2b4",14:"a92cd37c",15:"781d1409",16:"7fa321a8",17:"6ab202f5",18:"1a27d2aa",19:"3da5cbab",20:"1fd3b090",21:"b22c76a6",22:"2634c2ca",23:"5aff7e63",24:"4c139f0f",25:"e450fb7c",26:"ff0075b2",27:"98089b22",28:"5faf04b4",29:"05f69bfc",30:"c177236c",31:"6394b9e4",32:"3a53fdd1",33:"86bf84ac",34:"fd4fc47c",35:"75b6eab4",36:"9fb1af18",37:"e1e8e4a8",38:"4412b531",39:"d69b0bc0",40:"626b72c9",41:"68052477",42:"5e513bfc",43:"906a8a35",44:"a92597fa",45:"1d296301",46:"870b43bb",47:"958479e9",48:"22e1287d",49:"6f78ab18",50:"a66f7f59",51:"69bbb479",52:"63b11e40",53:"a19d04bf",54:"8a49b361",55:"c9e928f9",56:"44895c58",57:"b3d36188",58:"85354619",59:"85b16e63",60:"b1008012",61:"05f782d9",62:"a84ea078",63:"3e0f64e2",64:"d0773b26",65:"201c9d2f",66:"022a5411",67:"1cff8268",68:"a18268f9"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var o=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+o+": "+a+")",l.name="ChunkLoadError",l.type=o,l.request=a,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=o,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)i.d(t,o,function(e){return n[e]}.bind(null,o));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var d=l;a.push([104,0]),t()}([function(n,e,t){var o=t(56),r=o.all;n.exports=o.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){var o=t(29),r=Function.prototype,a=r.call,i=o&&r.bind.bind(a,a);n.exports=o?i:function(n){return function(){return a.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";function o(n,e,t,o,r,a,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),o&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return o}))},function(n,e,t){var o=t(3);n.exports=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var o=t(1),r=t(32),a=o({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(r(n),e)}},function(n,e,t){var o=t(70),r="object"==typeof self&&self&&self.Object===Object&&self,a=o||r||Function("return this")();n.exports=a},function(n,e,t){var o=t(0),r=t(56),a=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:o(n)||n===a}:function(n){return"object"==typeof n?null!==n:o(n)}},function(n,e,t){var o=t(164),r=t(167);n.exports=function(n,e){var t=r(n,e);return o(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return o})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(27);const o=/#.*$/,r=/\.(md|html)$/,a=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(o,"").replace(r,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(o),t=e?e[0]:"",r=s(n);return a.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(o);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const o=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===o)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,o){const{pages:r,themeConfig:a}=t,i=o&&a.locales&&a.locales[o]||a;if("auto"===(n.frontmatter.sidebar||i.sidebar||a.sidebar))return f(n);const s=i.sidebar||a.sidebar;if(s){const{base:t,config:o}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const o in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(o)))return{base:o,config:e[o]};var t;return{}}(e,s);return"auto"===o?f(n):o?o.map(n=>function n(e,t,o,r=1){if("string"==typeof e)return m(t,e,o);if(Array.isArray(e))return Object.assign(m(t,e[0],o),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,o),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,o,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var o=t(5),r=t(65),a=t(100),i=t(28),s=t(55),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=o?a?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var o=d(n,e);o&&o.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:o.configurable,enumerable:"enumerable"in t?t.enumerable:o.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var o=t(16),r=t(149),a=t(150),i=o?o.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?r(n):a(n)}},function(n,e,t){var o=t(5),r=t(13),a=t(35);n.exports=o?function(n,e,t){return r.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var o=t(8).Symbol;n.exports=o},function(n,e,t){var o=t(2),r=t(52).f,a=t(15),i=t(112),s=t(37),l=t(66),c=t(125);n.exports=function(n,e){var t,d,u,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?o:g?o[h]||s(h,{}):(o[h]||{}).prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=r(t,d))&&m.value:t[d],!c(f?d:h+(g?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&a(p,"sham",!0),i(t,d,p,n)}}},function(n,e,t){var o=t(1),r=o({}.toString),a=o("".slice);n.exports=function(n){return a(r(n),8,-1)}},function(n,e,t){var o=t(2),r=t(62),a=t(7),i=t(64),s=t(60),l=t(59),c=o.Symbol,d=r("wks"),u=l?c.for||c:c&&c.withoutSetter||i;n.exports=function(n){return a(d,n)||(d[n]=s&&a(c,n)?c[n]:u("Symbol."+n)),d[n]}},function(n,e,t){var o=t(154),r=t(155),a=t(156),i=t(157),s=t(158);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var o=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(o(n[t][0],e))return t;return-1}},function(n,e,t){var o=t(10)(Object,"create");n.exports=o},function(n,e,t){var o=t(176);n.exports=function(n,e){var t=n.__data__;return o(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var o=t(45);n.exports=function(n){if("string"==typeof n||o(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var o,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(o=function(){var n,e,t={version:"0.2.0"},o=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(o[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,o.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(o.barSelector),d=o.speed,u=o.easing;return l.offsetWidth,i((function(e){""===o.positionUsing&&(o.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===o.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===o.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,r}(n,d,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),o.trickleSpeed)};return o.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*o.trickleRate)},n=0,e=0,t.promise=function(o){return o&&"resolved"!==o.state()?(0===e&&t.start(),n++,e++,o.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=o.template;var r,i=e.querySelector(o.barSelector),l=n?"-100":a(t.status||0),d=document.querySelector(o.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),o.showSpinner||(r=e.querySelector(o.spinnerSelector))&&p(r),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(o.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var o,r=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((o=n[r]+a)in t)return o;return e}(t))}function o(n,e,o){e=t(e),n.style[e]=o}return function(n,e){var t,r,a=arguments;if(2==a.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&o(n,t,r);else o(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),o=t+e;l(t,e)||(n.className=o.substring(1))}function d(n,e){var t,o=u(n);l(n,e)&&(t=o.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?o.call(e,t,e,n):o)||(n.exports=r)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"/home/runner/work/interview-vuepress/interview-vuepress","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){"use strict";var o=t(17),r=t(32),a=t(33),i=t(129),s=t(131);o({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=a(e),o=arguments.length;s(t+o);for(var l=0;l<o;l++)e[t]=arguments[l],t++;return i(e,t),t}})},function(n,e,t){var o=t(9),r=String,a=TypeError;n.exports=function(n){if(o(n))return n;throw a(r(n)+" is not an object")}},function(n,e,t){var o=t(3);n.exports=!o((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var o=t(47),r=t(53);n.exports=function(n){return o(r(n))}},function(n,e,t){var o=t(2),r=t(0),a=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(o[n]):o[n]&&o[n][e]}},function(n,e,t){var o=t(53),r=Object;n.exports=function(n){return r(o(n))}},function(n,e,t){var o=t(123);n.exports=function(n){return o(n.length)}},function(n,e,t){var o=t(29),r=Function.prototype.call;n.exports=o?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var o=t(2),r=t(37),a=o["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=a},function(n,e,t){var o=t(2),r=Object.defineProperty;n.exports=function(n,e){try{r(o,n,{value:e,configurable:!0,writable:!0})}catch(t){o[n]=e}return e}},function(n,e,t){var o=t(148),r=t(12),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,l=o(function(){return arguments}())?o:function(n){return r(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var o=t(10)(t(8),"Map");n.exports=o},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var o=t(168),r=t(175),a=t(177),i=t(178),s=t(179);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var o=t(6),r=t(45),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(o(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(i.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var o=t(14),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==o(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var o=t(1),r=t(3),a=t(18),i=Object,s=o("".split);n.exports=r((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?s(n,""):i(n)}:i},function(n,e,t){var o=t(0),r=t(110),a=TypeError;n.exports=function(n){if(o(n))return n;throw a(r(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,o=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,a=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||a.test(n)?i(n.slice(2),s?2:8):o.test(n)?NaN:+n}n.exports=function(n,e,t){var o,r,a,i,s,l,c=0,d=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=o,a=r;return o=r=void 0,c=e,i=n.apply(a,t)}function y(n){return c=n,s=setTimeout(w,e),d?b(n):i}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function w(){var n=m();if(x(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-l);return g?p(t,a-(n-c)):t}(n))}function k(n){return s=void 0,v&&o?b(n):(o=r=void 0,i)}function T(){var n=m(),t=x(n);if(o=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(g)return s=setTimeout(w,e),b(l)}return void 0===s&&(s=setTimeout(w,e)),i}return e=f(e)||0,h(t)&&(d=!!t.leading,a=(g="maxWait"in t)?u(f(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),T.cancel=function(){void 0!==s&&clearTimeout(s),c=0,o=l=r=s=void 0},T.flush=function(){return void 0===s?i:k(m())},T}},function(n,e,t){var o=t(5),r=t(34),a=t(106),i=t(35),s=t(30),l=t(55),c=t(7),d=t(65),u=Object.getOwnPropertyDescriptor;e.f=o?u:function(n,e){if(n=s(n),e=l(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return i(!r(a.f,n,e),n[e])}},function(n,e,t){var o=t(54),r=TypeError;n.exports=function(n){if(o(n))throw r("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var o=t(107),r=t(57);n.exports=function(n){var e=o(n,"string");return r(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,o=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:o}},function(n,e,t){var o=t(31),r=t(0),a=t(58),i=t(59),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=o("Symbol");return r(e)&&a(e.prototype,s(n))}},function(n,e,t){var o=t(1);n.exports=o({}.isPrototypeOf)},function(n,e,t){var o=t(60);n.exports=o&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var o=t(61),r=t(3);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&o&&o<41}))},function(n,e,t){var o,r,a=t(2),i=t(108),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,d=c&&c.v8;d&&(r=(o=d.split("."))[0]>0&&o[0]<4?1:+(o[0]+o[1])),!r&&i&&(!(o=i.match(/Edge\/(\d+)/))||o[1]>=74)&&(o=i.match(/Chrome\/(\d+)/))&&(r=+o[1]),n.exports=r},function(n,e,t){var o=t(63),r=t(36);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.27.2",mode:o?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.27.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var o=t(1),r=0,a=Math.random(),i=o(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++r+a,36)}},function(n,e,t){var o=t(5),r=t(3),a=t(99);n.exports=!o&&!r((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var o=t(7),r=t(118),a=t(52),i=t(13);n.exports=function(n,e,t){for(var s=r(e),l=i.f,c=a.f,d=0;d<s.length;d++){var u=s[d];o(n,u)||t&&o(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var o=t(122);n.exports=function(n){var e=+n;return e!=e||0===e?0:o(e)}},function(n,e,t){var o=t(1),r=t(28),a=t(135);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=o(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return r(t),a(o),e?n(t,o):t.__proto__=o,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,o=e.length,r=n.length;++t<o;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var o=t(20),r=t(159),a=t(160),i=t(161),s=t(162),l=t(163);function c(n){var e=this.__data__=new o(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var o=t(14),r=t(40);n.exports=function(n){if(!r(n))return!1;var e=o(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var o=t(180),r=t(12);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:o(e,t,a,i,n,s))}},function(n,e,t){var o=t(77),r=t(183),a=t(78);n.exports=function(n,e,t,i,s,l){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new o:void 0;for(l.set(n,e),l.set(e,n);++h<d;){var v=n[h],b=e[h];if(i)var y=c?i(b,v,h,e,n,l):i(v,b,h,n,e,l);if(void 0!==y){if(y)continue;f=!1;break}if(g){if(!r(e,(function(n,e){if(!a(g,e)&&(v===n||s(v,n,t,i,l)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!s(v,b,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var o=t(41),r=t(181),a=t(182);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new o;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=r,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var o=t(193),r=t(199),a=t(83);n.exports=function(n){return a(n)?o(n):r(n)}},function(n,e,t){(function(n){var o=t(8),r=t(195),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===a?o.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(50)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var o=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==o||"symbol"!=o&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var o=t(196),r=t(197),a=t(198),i=a&&a.isTypedArray,s=i?r(i):o;n.exports=s},function(n,e,t){var o=t(73),r=t(43);n.exports=function(n){return null!=n&&r(n.length)&&!o(n)}},function(n,e,t){var o=t(10)(t(8),"Set");n.exports=o},function(n,e,t){var o=t(40);n.exports=function(n){return n==n&&!o(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var o=t(88),r=t(24);n.exports=function(n,e){for(var t=0,a=(e=o(e,n)).length;null!=n&&t<a;)n=n[r(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var o=t(6),r=t(44),a=t(210),i=t(213);n.exports=function(n,e){return o(n)?n:r(n,e)?[n]:a(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(146),r=t(151),a=t(222),i=t(230),s=t(239),l=t(103),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),i(o(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var o=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=o.exec(t);if(!r)return t;var a="",i=0,s=0;for(i=r.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(a+=t.substring(s,i)),s=i+1,a+=e}return s!==i?a+t.substring(s,i):a}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var o=t(248),r=t(249),a=t(250),i=!1,s=t(251).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),d=/^\uFEFF/;function u(n,t){var r,a,i=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)r=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),o.existsSync(a)&&(r=a)),r||Array.isArray(i)&&i.some((function(t){return a=e.resolveInclude(n,t,!0),o.existsSync(a)}))&&(r=a),!r)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return r}function p(n,t){var o,r=n.filename,a=arguments.length>1;if(n.cache){if(!r)throw new Error("cache option requires a filename");if(o=e.cache.get(r))return o;a||(t=h(r).toString().replace(d,""))}else if(!a){if(!r)throw new Error("Internal EJS error: no file name or template provided");t=h(r).toString().replace(d,"")}return o=e.compile(t,n),n.cache&&e.cache.set(r,o),o}function m(n,t,o){var r;if(!o){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,o){try{e(r=p(n)(t))}catch(n){o(n)}}));throw new Error("Please provide a callback function")}try{r=p(n)(t)}catch(n){return o(n)}o(null,r)}function h(n){return e.fileLoader(n)}function f(n,e,t,o,r){var a=e.split("\n"),i=Math.max(o-3,0),s=Math.min(a.length,o+3),l=r(t),c=a.slice(i,s).map((function(n,e){var t=e+i+1;return(t==o?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+o+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var o={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],o.client=t.client||!1,o.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,o.compileDebug=!1!==t.compileDebug,o.debug=!!t.debug,o.filename=t.filename,o.openDelimiter=t.openDelimiter||e.openDelimiter||"<",o.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",o.delimiter=t.delimiter||e.delimiter||"%",o.strict=t.strict||!1,o.context=t.context,o.cache=t.cache||!1,o.rmWhitespace=t.rmWhitespace,o.root=t.root,o.outputFunctionName=t.outputFunctionName,o.localsName=t.localsName||e.localsName||"locals",o.views=t.views,o.async=t.async,o.destructuredLocals=t.destructuredLocals,o.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,o.strict?o._with=!1:o._with=void 0===t._with||t._with,this.opts=o,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=o.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var o=r.dirname,a=r.extname,i=(0,r.resolve)(t?e:o(e),n);return a(n)||(i+=".ejs"),i},e.compile=function(n,e){return e&&e.scope&&(i||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),i=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var o=e||{},r=t||{};return 2==arguments.length&&a.shallowCopyFromList(r,o,l),p(r,n)(o)},e.renderFile=function(){var n,e,t,o=Array.prototype.slice.call(arguments),r=o.shift(),i={filename:r};return"function"==typeof arguments[arguments.length-1]&&(n=o.pop()),o.length?(e=o.shift(),o.length?a.shallowCopy(i,o.pop()):(e.settings&&(e.settings.views&&(i.views=e.settings.views),e.settings["view cache"]&&(i.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(i,t)),a.shallowCopyFromList(i,e,c)),i.filename=r):e={},m(i,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),o=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,o),new RegExp(n)},compile:function(){var n,e,t,o=this.opts,i="",s="",l=o.escapeFunction;if(!this.source){if(this.generateSource(),i+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',o.outputFunctionName&&(i+="  var "+o.outputFunctionName+" = __append;\n"),o.destructuredLocals&&o.destructuredLocals.length){for(var c="  var __locals = ("+o.localsName+" || {}),\n",d=0;d<o.destructuredLocals.length;d++){var m=o.destructuredLocals[d];d>0&&(c+=",\n  "),c+=m+" = __locals."+m}i+=c+";\n"}!1!==o._with&&(i+="  with ("+o.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=i+this.source+s}n=o.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(o.filename?JSON.stringify(o.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,o.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,o.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),o.strict&&(n='"use strict";\n'+n),o.debug&&console.log(n),o.compileDebug&&o.filename&&(n=n+"\n//# sourceURL="+o.filename+"\n");try{if(o.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(o.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(o.filename&&(n.message+=" in "+o.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",o.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=o.client?e:function(n){return e.apply(o.context,[n||{},l,function(e,t){var r=a.shallowCopy({},n);return t&&(r=a.shallowCopy(r,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=u(n,t),p(t)}(e,o)(r)},f])};if(h.dependencies=this.dependencies,o.filename&&"function"==typeof Object.defineProperty){var g=o.filename,v=r.basename(g,r.extname(g));try{Object.defineProperty(h,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,o=this.parseTemplateText(),r=this.opts.delimiter,i=this.opts.openDelimiter,s=this.opts.closeDelimiter;o&&o.length&&o.forEach((function(l,c){var p,m,f,g,b,y;if(0===l.indexOf(i+r)&&0!==l.indexOf(i+r+r)&&(m=o[c+2])!=r+s&&m!="-"+r+s&&m!="_"+r+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(f=l.match(/^\s*include\s+(\S+)/))&&(p=o[c-1])&&(p==i+r||p==i+r+"-"||p==i+r+"_"))return g=a.shallowCopy({},t.opts),b=function(n,e){var t,o,r=a.shallowCopy({},e);o=h(t=u(n,r)).toString().replace(d,""),r.filename=t;var i=new v(o,r);return i.generateSource(),{source:i.source,filename:t,template:o}}(f[1],g),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(f[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,o=t.exec(e),r=[];o;)0!==(n=o.index)&&(r.push(e.substring(0,n)),e=e.slice(n)),r.push(o[0]),e=e.slice(o[0].length),o=t.exec(e);return e&&r.push(e),r},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,o=this.opts.openDelimiter,r=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case o+t:case o+t+"_":this.mode=v.modes.EVAL;break;case o+t+"=":this.mode=v.modes.ESCAPED;break;case o+t+"-":this.mode=v.modes.RAW;break;case o+t+"#":this.mode=v.modes.COMMENT;break;case o+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(o+t+t,o+t)+'")\n';break;case t+t+r:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+r,t+r)+'")\n';break;case t+r:case"-"+t+r:case"_"+t+r:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var o={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(242),t(4)),a=Object(r.a)(o,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var o={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(243),t(4)),a=Object(r.a)(o,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,o){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":o===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(o)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var o=t(2),r=t(9),a=o.document,i=r(a)&&r(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){var o=t(5),r=t(3);n.exports=o&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var o=t(62),r=t(64),a=o("keys");n.exports=function(n){return a[n]||(a[n]=r(n))}},function(n,e,t){var o=t(1),r=t(7),a=t(30),i=t(120).indexOf,s=t(49),l=o([].push);n.exports=function(n,e){var t,o=a(n),c=0,d=[];for(t in o)!r(s,t)&&r(o,t)&&l(d,t);for(;e.length>c;)r(o,t=e[c++])&&(~i(d,t)||l(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(254)},function(n,e,t){"use strict";var o=t(17),r=t(126).left,a=t(127),i=t(61);o({target:"Array",proto:!0,forced:!t(128)&&i>79&&i<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,a=r&&!o.call({1:2},1);e.f=a?function(n){var e=r(this,n);return!!e&&e.enumerable}:o},function(n,e,t){var o=t(34),r=t(9),a=t(57),i=t(109),s=t(111),l=t(19),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!r(n)||a(n))return n;var t,l=i(n,d);if(l){if(void 0===e&&(e="default"),t=o(l,n,e),!r(t)||a(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var o=t(48),r=t(54);n.exports=function(n,e){var t=n[e];return r(t)?void 0:o(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var o=t(34),r=t(0),a=t(9),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!a(s=o(t,n)))return s;if(r(t=n.valueOf)&&!a(s=o(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!a(s=o(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var o=t(0),r=t(13),a=t(113),i=t(37);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(o(t)&&a(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var o=t(1),r=t(3),a=t(0),i=t(7),s=t(5),l=t(114).CONFIGURABLE,c=t(115),d=t(116),u=d.enforce,p=d.get,m=String,h=Object.defineProperty,f=o("".slice),g=o("".replace),v=o([].join),b=s&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===f(m(e),0,7)&&(e="["+g(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&i(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var o=u(n);return i(o,"source")||(o.source=v(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return a(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){var o=t(5),r=t(7),a=Function.prototype,i=o&&Object.getOwnPropertyDescriptor,s=r(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!o||o&&i(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var o=t(1),r=t(0),a=t(36),i=o(Function.toString);r(a.inspectSource)||(a.inspectSource=function(n){return i(n)}),n.exports=a.inspectSource},function(n,e,t){var o,r,a,i=t(117),s=t(2),l=t(9),c=t(15),d=t(7),u=t(36),p=t(101),m=t(49),h=s.TypeError,f=s.WeakMap;if(i||u.state){var g=u.state||(u.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,o=function(n,e){if(g.has(n))throw h("Object already initialized");return e.facade=n,g.set(n,e),e},r=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var v=p("state");m[v]=!0,o=function(n,e){if(d(n,v))throw h("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return d(n,v)?n[v]:{}},a=function(n){return d(n,v)}}n.exports={set:o,get:r,has:a,enforce:function(n){return a(n)?r(n):o(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var o=t(2),r=t(0),a=o.WeakMap;n.exports=r(a)&&/native code/.test(String(a))},function(n,e,t){var o=t(31),r=t(1),a=t(119),i=t(124),s=t(28),l=r([].concat);n.exports=o("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var o=t(102),r=t(98).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return o(n,r)}},function(n,e,t){var o=t(30),r=t(121),a=t(33),i=function(n){return function(e,t,i){var s,l=o(e),c=a(l),d=r(i,c);if(n&&t!=t){for(;c>d;)if((s=l[d++])!=s)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var o=t(67),r=Math.max,a=Math.min;n.exports=function(n,e){var t=o(n);return t<0?r(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,o=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?o:t)(e)}},function(n,e,t){var o=t(67),r=Math.min;n.exports=function(n){return n>0?r(o(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var o=t(3),r=t(0),a=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==d||t!=c&&(r(e)?o(e):!!e)},s=i.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",d=i.POLYFILL="P";n.exports=i},function(n,e,t){var o=t(48),r=t(32),a=t(47),i=t(33),s=TypeError,l=function(n){return function(e,t,l,c){o(t);var d=r(e),u=a(d),p=i(d),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(c=t(c,u[m],m,d));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var o=t(3);n.exports=function(n,e){var t=[][n];return!!t&&o((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var o=t(18);n.exports="undefined"!=typeof process&&"process"==o(process)},function(n,e,t){"use strict";var o=t(5),r=t(130),a=TypeError,i=Object.getOwnPropertyDescriptor,s=o&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!i(n,"length").writable)throw a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var o=t(18);n.exports=Array.isArray||function(n){return"Array"==o(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var o=t(17),r=t(2),a=t(133),i=t(134),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),o({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),o({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var o=t(29),r=Function.prototype,a=r.apply,i=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(o?i.bind(a):function(){return i.apply(a,arguments)})},function(n,e,t){"use strict";var o=t(31),r=t(7),a=t(15),i=t(58),s=t(68),l=t(66),c=t(136),d=t(137),u=t(138),p=t(142),m=t(143),h=t(5),f=t(63);n.exports=function(n,e,t,g){var v=g?2:1,b=n.split("."),y=b[b.length-1],x=o.apply(null,b);if(x){var w=x.prototype;if(!f&&r(w,"cause")&&delete w.cause,!t)return x;var k=o("Error"),T=e((function(n,e){var t=u(g?e:n,void 0),o=g?new x(n):new x;return void 0!==t&&a(o,"message",t),m(o,T,o.stack,2),this&&i(w,this)&&d(o,this,T),arguments.length>v&&p(o,arguments[v]),o}));if(T.prototype=w,"Error"!==y?s?s(T,k):l(T,k,{name:!0}):h&&"stackTraceLimit"in x&&(c(T,x,"stackTraceLimit"),c(T,x,"prepareStackTrace")),l(T,x),!f)try{w.name!==y&&a(w,"name",y),w.constructor=T}catch(n){}return T}}},function(n,e,t){var o=t(0),r=String,a=TypeError;n.exports=function(n){if("object"==typeof n||o(n))return n;throw a("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var o=t(13).f;n.exports=function(n,e,t){t in n||o(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var o=t(0),r=t(9),a=t(68);n.exports=function(n,e,t){var i,s;return a&&o(i=e.constructor)&&i!==t&&r(s=i.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){var o=t(139);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:o(n)}},function(n,e,t){var o=t(140),r=String;n.exports=function(n){if("Symbol"===o(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var o=t(141),r=t(0),a=t(18),i=t(19)("toStringTag"),s=Object,l="Arguments"==a(function(){return arguments}());n.exports=o?a:function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?a(e):"Object"==(o=a(e))&&r(e.callee)?"Arguments":o}},function(n,e,t){var o={};o[t(19)("toStringTag")]="z",n.exports="[object z]"===String(o)},function(n,e,t){var o=t(9),r=t(15);n.exports=function(n,e){o(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var o=t(15),r=t(144),a=t(145),i=Error.captureStackTrace;n.exports=function(n,e,t,s){a&&(i?i(n,e):o(n,"stack",r(t,s)))}},function(n,e,t){var o=t(1),r=Error,a=o("".replace),i=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var o=t(3),r=t(35);n.exports=!o((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var o=t(69),r=t(147);n.exports=function n(e,t,a,i,s){var l=-1,c=e.length;for(a||(a=r),s||(s=[]);++l<c;){var d=e[l];t>0&&a(d)?t>1?n(d,t-1,a,i,s):o(s,d):i||(s[s.length]=d)}return s}},function(n,e,t){var o=t(16),r=t(38),a=t(6),i=o?o.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||r(n)||!!(i&&n&&n[i])}},function(n,e,t){var o=t(14),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==o(n)}},function(n,e,t){var o=t(16),r=Object.prototype,a=r.hasOwnProperty,i=r.toString,s=o?o.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var o=!0}catch(n){}var r=i.call(n);return o&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var o=t(152),r=t(208),a=t(46),i=t(6),s=t(219);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?i(n)?r(n[0],n[1]):o(n):s(n)}},function(n,e,t){var o=t(153),r=t(207),a=t(86);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||o(t,n,e)}}},function(n,e,t){var o=t(71),r=t(75);n.exports=function(n,e,t,a){var i=t.length,s=i,l=!a;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var d=(c=t[i])[0],u=n[d],p=c[1];if(l&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new o;if(a)var h=a(u,p,d,n,e,m);if(!(void 0===h?r(p,u,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var o=t(21),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=o(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var o=t(21);n.exports=function(n){var e=this.__data__,t=o(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var o=t(21);n.exports=function(n){return o(this.__data__,n)>-1}},function(n,e,t){var o=t(21);n.exports=function(n,e){var t=this.__data__,r=o(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var o=t(20);n.exports=function(){this.__data__=new o,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var o=t(20),r=t(39),a=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof o){var i=t.__data__;if(!r||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var o=t(73),r=t(165),a=t(40),i=t(74),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||r(n))&&(o(n)?p:s).test(i(n))}},function(n,e,t){var o,r=t(166),a=(o=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+o:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var o=t(8)["__core-js_shared__"];n.exports=o},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var o=t(169),r=t(20),a=t(39);n.exports=function(){this.size=0,this.__data__={hash:new o,map:new(a||r),string:new o}}},function(n,e,t){var o=t(170),r=t(171),a=t(172),i=t(173),s=t(174);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var o=t(22);n.exports=function(){this.__data__=o?o(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var o=t(22),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(o){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var o=t(22),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return o?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var o=t(22);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=o&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var o=t(23);n.exports=function(n){var e=o(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var o=t(23);n.exports=function(n){return o(this,n).get(n)}},function(n,e,t){var o=t(23);n.exports=function(n){return o(this,n).has(n)}},function(n,e,t){var o=t(23);n.exports=function(n,e){var t=o(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var o=t(71),r=t(76),a=t(184),i=t(187),s=t(203),l=t(6),c=t(80),d=t(82),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),v=l(e),b=g?"[object Array]":s(n),y=v?"[object Array]":s(e),x=(b="[object Arguments]"==b?u:b)==u,w=(y="[object Arguments]"==y?u:y)==u,k=b==y;if(k&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(k&&!x)return f||(f=new o),g||d(n)?r(n,e,t,m,h,f):a(n,e,b,t,m,h,f);if(!(1&t)){var T=x&&p.call(n,"__wrapped__"),j=w&&p.call(e,"__wrapped__");if(T||j){var S=T?n.value():n,C=j?e.value():e;return f||(f=new o),h(S,C,t,m,f)}}return!!k&&(f||(f=new o),i(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length;++t<o;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var o=t(16),r=t(185),a=t(72),i=t(76),s=t(186),l=t(42),c=o?o.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,o,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&o;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;o|=2,p.set(n,e);var g=i(m(n),m(e),o,c,u,p);return p.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var o=t(8).Uint8Array;n.exports=o},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,o){t[++e]=[o,n]})),t}},function(n,e,t){var o=t(188),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var l=1&t,c=o(n),d=c.length;if(d!=o(e).length&&!l)return!1;for(var u=d;u--;){var p=c[u];if(!(l?p in e:r.call(e,p)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++u<d;){var v=n[p=c[u]],b=e[p];if(a)var y=l?a(b,v,p,e,n,s):a(v,b,p,n,e,s);if(!(void 0===y?v===b||i(v,b,t,a,s):y)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var o=t(189),r=t(190),a=t(79);n.exports=function(n){return o(n,a,r)}},function(n,e,t){var o=t(69),r=t(6);n.exports=function(n,e,t){var a=e(n);return r(n)?a:o(a,t(n))}},function(n,e,t){var o=t(191),r=t(192),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),o(i(n),(function(e){return a.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,r=0,a=[];++t<o;){var i=n[t];e(i,t,n)&&(a[r++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var o=t(194),r=t(38),a=t(6),i=t(80),s=t(81),l=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),d=!t&&r(n),u=!t&&!d&&i(n),p=!t&&!d&&!u&&l(n),m=t||d||u||p,h=m?o(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||u&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,o=Array(n);++t<n;)o[t]=e(t);return o}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var o=t(14),r=t(43),a=t(12),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&r(n.length)&&!!i[o(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var o=t(70),r=e&&!e.nodeType&&e,a=r&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===r&&o.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(50)(n))},function(n,e,t){var o=t(200),r=t(201),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!o(n))return r(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var o=t(202)(Object.keys,Object);n.exports=o},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var o=t(204),r=t(39),a=t(205),i=t(84),s=t(206),l=t(14),c=t(74),d=c(o),u=c(r),p=c(a),m=c(i),h=c(s),f=l;(o&&"[object DataView]"!=f(new o(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||a&&"[object Promise]"!=f(a.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,o=t?c(t):"";if(o)switch(o){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var o=t(10)(t(8),"DataView");n.exports=o},function(n,e,t){var o=t(10)(t(8),"Promise");n.exports=o},function(n,e,t){var o=t(10)(t(8),"WeakMap");n.exports=o},function(n,e,t){var o=t(85),r=t(79);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,o(i)]}return e}},function(n,e,t){var o=t(75),r=t(209),a=t(216),i=t(44),s=t(85),l=t(86),c=t(24);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=r(t,n);return void 0===i&&i===e?a(t,n):o(e,i,3)}}},function(n,e,t){var o=t(87);n.exports=function(n,e,t){var r=null==n?void 0:o(n,e);return void 0===r?t:r}},function(n,e,t){var o=t(211),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=o((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,o,r){e.push(o?r.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var o=t(212);n.exports=function(n){var e=o(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var o=t(41);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var o=arguments,r=e?e.apply(this,o):o[0],a=t.cache;if(a.has(r))return a.get(r);var i=n.apply(this,o);return t.cache=a.set(r,i)||a,i};return t.cache=new(r.Cache||o),t}r.Cache=o,n.exports=r},function(n,e,t){var o=t(214);n.exports=function(n){return null==n?"":o(n)}},function(n,e,t){var o=t(16),r=t(215),a=t(6),i=t(45),s=o?o.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return r(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,r=Array(o);++t<o;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var o=t(217),r=t(218);n.exports=function(n,e){return null!=n&&r(n,e,o)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var o=t(88),r=t(38),a=t(6),i=t(81),s=t(43),l=t(24);n.exports=function(n,e,t){for(var c=-1,d=(e=o(e,n)).length,u=!1;++c<d;){var p=l(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&s(d)&&i(p,d)&&(a(n)||r(n))}},function(n,e,t){var o=t(220),r=t(221),a=t(44),i=t(24);n.exports=function(n){return a(n)?o(i(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var o=t(87);n.exports=function(n){return function(e){return o(e,n)}}},function(n,e,t){var o=t(46),r=t(223),a=t(225);n.exports=function(n,e){return a(r(n,e,o),n+"")}},function(n,e,t){var o=t(224),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=r(a.length-e,0),l=Array(s);++i<s;)l[i]=a[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=a[i];return c[e]=t(l),o(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var o=t(226),r=t(229)(o);n.exports=r},function(n,e,t){var o=t(227),r=t(228),a=t(46),i=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:o(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var o=t(10),r=function(){try{var n=o(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,o=0;return function(){var r=t(),a=16-(r-o);if(o=r,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var o=t(77),r=t(231),a=t(236),i=t(78),s=t(237),l=t(42);n.exports=function(n,e,t){var c=-1,d=r,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=a;else if(u>=200){var f=e?null:s(n);if(f)return l(f);p=!1,d=i,h=new o}else h=e?[]:m;n:for(;++c<u;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(g)}else d(h,v,t)||(h!==m&&h.push(v),m.push(g))}return m}},function(n,e,t){var o=t(232);n.exports=function(n,e){return!!(null==n?0:n.length)&&o(n,e,0)>-1}},function(n,e,t){var o=t(233),r=t(234),a=t(235);n.exports=function(n,e,t){return e==e?a(n,e,t):o(n,r,t)}},function(n,e){n.exports=function(n,e,t,o){for(var r=n.length,a=t+(o?1:-1);o?a--:++a<r;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var o=t-1,r=n.length;++o<r;)if(n[o]===e)return o;return-1}},function(n,e){n.exports=function(n,e,t){for(var o=-1,r=null==n?0:n.length;++o<r;)if(t(e,n[o]))return!0;return!1}},function(n,e,t){var o=t(84),r=t(238),a=t(42),i=o&&1/a(new o([,-0]))[1]==1/0?function(n){return new o(n)}:r;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var o=t(83),r=t(12);n.exports=function(n){return r(n)&&o(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(17),r=t(2),a=t(247);o({global:!0},{Reflect:{}}),a(r.Reflect,"Reflect",!0)},function(n,e,t){var o=t(13).f,r=t(7),a=t(19)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,a)&&o(n,a,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,o=n.length-1;o>=0;o--){var r=n[o];"."===r?n.splice(o,1):".."===r?(n.splice(o,1),t++):t&&(n.splice(o,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function o(n,e){if(n.filter)return n.filter(e);for(var t=[],o=0;o<n.length;o++)e(n[o],o,n)&&t.push(n[o]);return t}e.resolve=function(){for(var n="",e=!1,r=arguments.length-1;r>=-1&&!e;r--){var a=r>=0?arguments[r]:process.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(n=a+"/"+n,e="/"===a.charAt(0))}return(e?"/":"")+(n=t(o(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),i="/"===r(n,-1);return(n=t(o(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&i&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(o(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function o(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var r=o(n.split("/")),a=o(t.split("/")),i=Math.min(r.length,a.length),s=i,l=0;l<i;l++)if(r[l]!==a[l]){s=l;break}var c=[];for(l=s;l<r.length;l++)c.push("..");return(c=c.concat(a.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,o=-1,r=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!r){o=a;break}}else r=!1;return-1===o?t?"/":".":t&&1===o?"/":n.slice(0,o)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,o=-1,r=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!r){t=e+1;break}}else-1===o&&(r=!1,o=e+1);return-1===o?"":n.slice(t,o)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,o=-1,r=!0,a=0,i=n.length-1;i>=0;--i){var s=n.charCodeAt(i);if(47!==s)-1===o&&(r=!1,o=i+1),46===s?-1===e?e=i:1!==a&&(a=1):-1!==e&&(a=-1);else if(!r){t=i+1;break}}return-1===e||-1===o||0===a||1===a&&e===o-1&&e===t+1?"":n.slice(e,o)};var r="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var o=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(o,"\\$&"):""};var r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function i(n){return r[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,i)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var o=0;o<t.length;o++){var r=t[o];void 0!==e[r]&&(n[r]=e[r])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"/home/runner/work/interview-vuepress/interview-vuepress/node_modules/vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var o=Object.freeze({}),r=Array.isArray;function a(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),o=n.split(","),r=0;r<o.length;r++)t[o[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var o=n.indexOf(e);if(o>-1)return n.splice(o,1)}}var w=Object.prototype.hasOwnProperty;function k(n,e){return w.call(n,e)}function T(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var j=/-(\w)/g,S=T((function(n){return n.replace(j,(function(n,e){return e?e.toUpperCase():""}))})),C=T((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,P=T((function(n){return n.replace(I,"-$1").toLowerCase()}));var _=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var o=arguments.length;return o?o>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function z(n,e){e=e||0;for(var t=n.length-e,o=new Array(t);t--;)o[t]=n[t+e];return o}function E(n,e){for(var t in e)n[t]=e[t];return n}function O(n){for(var e={},t=0;t<n.length;t++)n[t]&&E(e,n[t]);return e}function A(n,e,t){}var R=function(n,e,t){return!1},M=function(n){return n};function D(n,e){if(n===e)return!0;var t=d(n),o=d(e);if(!t||!o)return!t&&!o&&String(n)===String(e);try{var r=Array.isArray(n),a=Array.isArray(e);if(r&&a)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function N(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function H(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],B=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:R,isReservedAttr:R,isUnknownElement:R,getTagNamespace:A,parsePlatformTagName:M,mustUseProp:R,async:!0,_lifecycleHooks:B},$=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function J(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function q(n,e,t,o){Object.defineProperty(n,e,{value:t,enumerable:!!o,writable:!0,configurable:!0})}var V=new RegExp("[^".concat($.source,".$_\\d]"));var W="__proto__"in{},G="undefined"!=typeof window,X=G&&window.navigator.userAgent.toLowerCase(),K=X&&/msie|trident/.test(X),Y=X&&X.indexOf("msie 9.0")>0,Z=X&&X.indexOf("edge/")>0;X&&X.indexOf("android");var Q=X&&/iphone|ipad|ipod|ios/.test(X);X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X);var nn,en=X&&X.match(/firefox\/(\d+)/),tn={}.watch,on=!1;if(G)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){on=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var an=function(){return void 0===nn&&(nn=!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=G&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,o,r,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=o,this.elm=r,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function fn(n){return new mn(void 0,void 0,void 0,String(n))}function gn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],yn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,o=e.length;t<o;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function wn(n){xn.push(n),yn.target=n}function kn(){xn.pop(),yn.target=xn[xn.length-1]}var Tn=Array.prototype,jn=Object.create(Tn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Tn[n];q(jn,n,(function(){for(var t=[],o=0;o<arguments.length;o++)t[o]=arguments[o];var r,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&i.observeArray(r),i.dep.notify(),a}))}));var Sn=Object.getOwnPropertyNames(jn),Cn={},In=!0;function Pn(n){In=n}var _n={notify:A,depend:A,addSub:A,removeSub:A},zn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?_n:new yn,this.vmCount=0,q(n,"__ob__",this),r(n)){if(!t)if(W)n.__proto__=jn;else for(var o=0,a=Sn.length;o<a;o++){q(n,s=Sn[o],jn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(o=0;o<i.length;o++){var s;On(n,s=i[o],Cn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)En(n[e],!1,this.mock)},n}();function En(n,e,t){return n&&k(n,"__ob__")&&n.__ob__ instanceof zn?n.__ob__:!In||!t&&an()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Hn(n)||n instanceof mn?void 0:new zn(n,e,t)}function On(n,e,t,o,a,i){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,d=l&&l.set;c&&!d||t!==Cn&&2!==arguments.length||(t=n[e]);var u=!a&&En(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(s.depend(),u&&(u.dep.depend(),r(e)&&Mn(e))),Hn(e)&&!a?e.value:e},set:function(e){var o=c?c.call(n):t;if(H(o,e)){if(d)d.call(n,e);else{if(c)return;if(!a&&Hn(o)&&!Hn(e))return void(o.value=e);t=e}u=!a&&En(e,!1,i),s.notify()}}}),s}}function An(n,e,t){if(!Nn(n)){var o=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),o&&!o.shallow&&o.mock&&En(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||o&&o.vmCount?t:o?(On(o.value,e,t,void 0,o.shallow,o.mock),o.dep.notify(),t):(n[e]=t,t)}}function Rn(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Nn(n)||k(n,e)&&(delete n[e],t&&t.dep.notify())}}function Mn(n){for(var e=void 0,t=0,o=n.length;t<o;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&Mn(e)}function Dn(n){return Ln(n,!0),q(n,"__v_isShallow",!0),n}function Ln(n,e){if(!Nn(n)){En(n,e,an());0}}function Nn(n){return!(!n||!n.__v_isReadonly)}function Hn(n){return!(!n||!0!==n.__v_isRef)}function Un(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Hn(n))return n.value;var o=n&&n.__ob__;return o&&o.dep.depend(),n},set:function(n){var o=e[t];Hn(o)&&!Hn(n)?o.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Bn;var Fn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Bn,!n&&Bn&&(this.index=(Bn.scopes||(Bn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Bn;try{return Bn=this,n()}finally{Bn=e}}else 0},n.prototype.on=function(){Bn=this},n.prototype.off=function(){Bn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var o=this.parent.scopes.pop();o&&o!==this&&(this.parent.scopes[this.index]=o,o.index=this.index)}this.parent=void 0,this.active=!1}},n}();function $n(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Jn=T((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),o="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=o?n.slice(1):n,once:t,capture:o,passive:e}}));function qn(n,e){function t(){var n=t.fns;if(!r(n))return Ie(n,null,arguments,e,"v-on handler");for(var o=n.slice(),a=0;a<o.length;a++)Ie(o[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,o,r,i){var l,c,d,u;for(l in n)c=n[l],d=e[l],u=Jn(l),a(c)||(a(d)?(a(c.fns)&&(c=n[l]=qn(c,i)),s(u.once)&&(c=n[l]=r(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)a(n[l])&&o((u=Jn(l)).name,e[l],u.capture)}function Wn(n,e,t){var o;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),x(o.fns,l)}a(r)?o=qn([l]):i(r.fns)&&s(r.merged)?(o=r).fns.push(l):o=qn([r,l]),o.merged=!0,n[e]=o}function Gn(n,e,t,o,r){if(i(e)){if(k(e,t))return n[t]=e[t],r||delete e[t],!0;if(k(e,o))return n[t]=e[o],r||delete e[o],!0}return!1}function Xn(n){return l(n)?[fn(n)]:r(n)?function n(e,t){var o,c,d,u,p=[];for(o=0;o<e.length;o++)a(c=e[o])||"boolean"==typeof c||(d=p.length-1,u=p[d],r(c)?c.length>0&&(Kn((c=n(c,"".concat(t||"","_").concat(o)))[0])&&Kn(u)&&(p[d]=fn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Kn(u)?p[d]=fn(u.text+c):""!==c&&p.push(fn(c)):Kn(c)&&Kn(u)?p[d]=fn(u.text+c.text):(s(e._isVList)&&i(c.tag)&&a(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(o,"__")),p.push(c)));return p}(n):void 0}function Kn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Yn(n,e){var t,o,a,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,o=n.length;t<o;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,o=a.length;t<o;t++)s=a[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function Zn(n,e,t,o){var r,a=this.$scopedSlots[n];a?(t=t||{},o&&(t=E(E({},o),t)),r=a(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},r):r}function Qn(n){return zt(this.$options,"filters",n,!0)||M}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,o,r){var a=F.keyCodes[e]||t;return r&&o&&!F.keyCodes[e]?ne(r,o):a?ne(a,n):o?P(o)!==e:void 0===n}function te(n,e,t,o,a){if(t)if(d(t)){r(t)&&(t=O(t));var i=void 0,s=function(r){if("class"===r||"style"===r||y(r))i=n;else{var s=n.attrs&&n.attrs.type;i=o||F.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=S(r),c=P(r);l in i||c in i||(i[r]=t[r],a&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function oe(n,e){var t=this._staticTrees||(this._staticTrees=[]),o=t[n];return o&&!e||ae(o=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),o}function re(n,e,t){return ae(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ae(n,e,t){if(r(n))for(var o=0;o<n.length;o++)n[o]&&"string"!=typeof n[o]&&ie(n[o],"".concat(e,"_").concat(o),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(p(e)){var t=n.on=n.on?E({},n.on):{};for(var o in e){var r=t[o],a=e[o];t[o]=r?[].concat(r,a):a}}else;return n}function le(n,e,t,o){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var i=n[a];r(i)?le(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return o&&(e.$key=o),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var o=e[t];"string"==typeof o&&o&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=re,n._n=v,n._s=g,n._l=Yn,n._t=Zn,n._q=D,n._i=L,n._m=oe,n._f=Qn,n._k=ee,n._b=te,n._v=fn,n._e=hn,n._u=le,n._g=se,n._d=ce,n._p=de}function pe(n,e){if(!n||!n.length)return{};for(var t={},o=0,r=n.length;o<r;o++){var a=n[o],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,r){var a,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==o&&l===r.$key&&!i&&!r.$hasNormal)return r;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=ge(n,t,c,e[c]))}else a={};for(var d in t)d in a||(a[d]=ve(t,d));return e&&Object.isExtensible(e)&&(e._normalized=a),q(a,"$stable",s),q(a,"$key",l),q(a,"$hasNormal",i),a}function ge(n,e,t,o){var a=function(){var e=un;pn(n);var t=arguments.length?o.apply(null,arguments):o({}),a=(t=t&&"object"==typeof t&&!r(t)?[t]:Xn(t))&&t[0];return pn(e),t&&(!a||1===t.length&&a.isComment&&!he(a))?void 0:t};return o.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function ve(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};q(e,"_v_attr_proxy",!0),ye(e,n.$attrs,o,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,o,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:_(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Un(n,e,t)}))}}}function ye(n,e,t,o,r){var a=!1;for(var i in e)i in n?e[i]!==t[i]&&(a=!0):(a=!0,xe(n,i,o,r));for(var i in n)i in e||(a=!0,delete n[i]);return a}function xe(n,e,t,o){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[o][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function Te(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function je(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||he(t)))return t}}function Se(n,e,t,o,u,p){return(r(t)||l(t))&&(u=o,o=t,t=void 0),s(p)&&(u=2),function(n,e,t,o,l){if(i(t)&&i(t.__ob__))return hn();i(t)&&i(t.is)&&(e=t.is);if(!e)return hn();0;r(o)&&c(o[0])&&((t=t||{}).scopedSlots={default:o[0]},o.length=0);2===l?o=Xn(o):1===l&&(o=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(o));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),u=F.isReservedTag(e)?new mn(F.parsePlatformTagName(e),t,o,void 0,void 0,n):t&&t.pre||!i(m=zt(n.$options,"components",e))?new mn(e,t,o,void 0,void 0,n):xt(m,t,n,o,e)}else u=xt(e,t,n,o);return r(u)?u:i(u)?(i(p)&&function n(e,t,o){e.ns=t,"foreignObject"===e.tag&&(t=void 0,o=!0);if(i(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];i(c.tag)&&(a(c.ns)||s(o)&&"svg"!==c.tag)&&n(c,t,o)}}(u,p),i(t)&&function(n){d(n.style)&&Fe(n.style);d(n.class)&&Fe(n.class)}(t),u):hn()}(n,e,t,o,u)}function Ce(n,e,t){wn();try{if(e)for(var o=e;o=o.$parent;){var r=o.$options.errorCaptured;if(r)for(var a=0;a<r.length;a++)try{if(!1===r[a].call(o,n,e,t))return}catch(n){Pe(n,o,"errorCaptured hook")}}Pe(n,e,t)}finally{kn()}}function Ie(n,e,t,o,r){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return Ce(n,o,r+" (Promise/async)")})),a._handled=!0)}catch(n){Ce(n,o,r)}return a}function Pe(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&_e(e,null,"config.errorHandler")}_e(n,e,t)}function _e(n,e,t){if(!G||"undefined"==typeof console)throw n;console.error(n)}var ze,Ee=!1,Oe=[],Ae=!1;function Re(){Ae=!1;var n=Oe.slice(0);Oe.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Me=Promise.resolve();ze=function(){Me.then(Re),Q&&setTimeout(A)},Ee=!0}else if(K||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())ze="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Re)}:function(){setTimeout(Re,0)};else{var De=1,Le=new MutationObserver(Re),Ne=document.createTextNode(String(De));Le.observe(Ne,{characterData:!0}),ze=function(){De=(De+1)%2,Ne.data=String(De)},Ee=!0}function He(n,e){var t;if(Oe.push((function(){if(n)try{n.call(e)}catch(n){Ce(n,e,"nextTick")}else t&&t(e)})),Ae||(Ae=!0,ze()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ue(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var o=n.$options;o[e]=Ct(o[e],t)}(t,n,e)}}Ue("beforeMount"),Ue("mounted"),Ue("beforeUpdate"),Ue("updated"),Ue("beforeDestroy"),Ue("destroyed"),Ue("activated"),Ue("deactivated"),Ue("serverPrefetch"),Ue("renderTracked"),Ue("renderTriggered"),Ue("errorCaptured");var Be=new cn;function Fe(n){return function n(e,t){var o,a,i=r(e);if(!i&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(o=e.length;o--;)n(e[o],t);else if(Hn(e))n(e.value,t);else for(a=Object.keys(e),o=a.length;o--;)n(e[a[o]],t)}(n,Be),Be.clear(),n}var $e,Je=0,qe=function(){function n(n,e,t,o,r){var a,i;a=this,void 0===(i=Bn&&!Bn._vm?Bn:n?n._scope:void 0)&&(i=Bn),i&&i.active&&i.effects.push(a),(this.vm=n)&&r&&(n._watcher=this),o?(this.deep=!!o.deep,this.user=!!o.user,this.lazy=!!o.lazy,this.sync=!!o.sync,this.before=o.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Je,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=A)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ce(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Fe(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ie(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){$e.$on(n,e)}function We(n,e){$e.$off(n,e)}function Ge(n,e){var t=$e;return function o(){var r=e.apply(null,arguments);null!==r&&t.$off(n,o)}}function Xe(n,e,t){$e=n,Vn(e,t||{},Ve,We,Ge,n),$e=void 0}var Ke=null;function Ye(n){var e=Ke;return Ke=n,function(){Ke=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Qe(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Qe(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,o){void 0===o&&(o=!0),wn();var r=un;o&&pn(n);var a=n.$options[e],i="".concat(e," hook");if(a)for(var s=0,l=a.length;s<l;s++)Ie(a[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),o&&pn(r),kn()}var et=[],tt=[],ot={},rt=!1,at=!1,it=0;var st=0,lt=Date.now;if(G&&!K){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(st=lt(),at=!0,et.sort(dt),it=0;it<et.length;it++)(n=et[it]).before&&n.before(),e=n.id,ot[e]=null,n.run();var t=tt.slice(),o=et.slice();it=et.length=tt.length=0,ot={},rt=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Qe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],o=t.vm;o&&o._watcher===t&&o._isMounted&&!o._isDestroyed&&nt(o,"updated")}}(o),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&F.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==ot[e]&&(n!==yn.target||!n.noRecurse)){if(ot[e]=!0,at){for(var t=et.length-1;t>it&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,He(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),o=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<o.length;r++){var a=o[r];if("__ob__"!==a){var i=n[a].from;if(i in e._provided)t[a]=e._provided[i];else if("default"in n[a]){var s=n[a].default;t[a]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,a,i){var l,c=this,d=i.options;k(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var u=s(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||o,this.injections=mt(d.inject,a),this.slots=function(){return c.$slots||fe(a,n.scopedSlots,c.$slots=pe(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(a,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=fe(a,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,o){var i=Se(l,n,e,t,o,p);return i&&!r(i)&&(i.fnScopeId=d._scopeId,i.fnContext=a),i}:this._c=function(n,e,t,o){return Se(l,n,e,t,o,p)}}function ft(n,e,t,o,r){var a=gn(n);return a.fnContext=t,a.fnOptions=o,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function gt(n,e){for(var t in e)n[S(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},o=n.data.inlineTemplate;i(o)&&(t.render=o.render,t.staticRenderFns=o.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){var i=r.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==o&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=a;var u=r.data.attrs||o;n._attrsProxy&&ye(n._attrsProxy,u,d.data&&d.data.attrs||o,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||o;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||o,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Xe(n,t,p),e&&n.$options.props){Pn(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],v=n.$options.props;m[g]=Et(g,v,e,n)}Pn(!0),n.$options.propsData=e}c&&(n.$slots=pe(a,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,o=n.componentInstance;o._isMounted||(o._isMounted=!0,nt(o,"mounted")),n.data.keepAlive&&(t._isMounted?((e=o)._inactive=!1,tt.push(e)):Qe(o,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ze(e))||e._inactive)){e._inactive=!0;for(var o=0;o<e.$children.length;o++)n(e.$children[o]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(bt);function xt(n,e,t,l,c){if(!a(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=ke;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var o=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(o,t)}));var u=function(n){for(var e=0,t=o.length;e<t;e++)o[e].$forceUpdate();n&&(o.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=N((function(t){n.resolved=Te(t,e),r?o.length=0:u(!0)})),m=N((function(e){i(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(f(h)?a(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),i(h.error)&&(n.errorComp=Te(h.error,e)),i(h.loading)&&(n.loadingComp=Te(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),i(h.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,o,r){var a=hn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:o,tag:r},a}(p,e,t,l,c);e=e||{},qt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",o=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[o],l=e.model.callback;i(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(a[o]=[l].concat(s)):a[o]=l}(n.options,e);var m=function(n,e,t){var o=e.options.props;if(!a(o)){var r={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in o){var d=P(c);Gn(r,l,c,d,!0)||Gn(r,s,c,d,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var l=n.options,c={},d=l.props;if(i(d))for(var u in d)c[u]=Et(u,d,e||o);else i(t.attrs)&&gt(c,t.attrs),i(t.props)&&gt(c,t.props);var p=new ht(t,c,s,a,n),m=l.render.call(null,p._c,p);if(m instanceof mn)return ft(m,t,p.parent,l,p);if(r(m)){for(var h=Xn(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=ft(h[g],t,p.parent,l,p);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var o=yt[t],r=e[o],a=bt[o];r===a||r&&r._merged||(e[o]=r?wt(a,r):a)}}(e);var v=vt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function wt(n,e){var t=function(t,o){n(t,o),e(t,o)};return t._merged=!0,t}var kt=A,Tt=F.optionMergeStrategies;function jt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var o,r,a,i=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<i.length;s++)"__ob__"!==(o=i[s])&&(r=n[o],a=e[o],t&&k(n,o)?r!==a&&p(r)&&p(a)&&jt(r,a):An(n,o,a));return n}function St(n,e,t){return t?function(){var o=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return o?jt(o,r):r}:e?n?function(){return jt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Ct(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function It(n,e,t,o){var r=Object.create(n||null);return e?E(r,e):r}Tt.data=function(n,e,t){return t?St(n,e,t):e&&"function"!=typeof e?n:St(n,e)},B.forEach((function(n){Tt[n]=Ct})),U.forEach((function(n){Tt[n+"s"]=It})),Tt.watch=function(n,e,t,o){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var i in E(a,n),e){var s=a[i],l=e[i];s&&!r(s)&&(s=[s]),a[i]=s?s.concat(l):r(l)?l:[l]}return a},Tt.props=Tt.methods=Tt.inject=Tt.computed=function(n,e,t,o){if(!n)return e;var r=Object.create(null);return E(r,n),e&&E(r,e),r},Tt.provide=function(n,e){return n?function(){var t=Object.create(null);return jt(t,c(n)?n.call(this):n),e&&jt(t,c(e)?e.call(this):e,!1),t}:e};var Pt=function(n,e){return void 0===e?n:e};function _t(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var o,a,i={};if(r(t))for(o=t.length;o--;)"string"==typeof(a=t[o])&&(i[S(a)]={type:null});else if(p(t))for(var s in t)a=t[s],i[S(s)]=p(a)?a:{type:a};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var o=n.inject={};if(r(t))for(var a=0;a<t.length;a++)o[t[a]]={from:t[a]};else if(p(t))for(var i in t){var s=t[i];o[i]=p(s)?E({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var o=e[t];c(o)&&(e[t]={bind:o,update:o})}}(e),!e._base&&(e.extends&&(n=_t(n,e.extends,t)),e.mixins))for(var o=0,a=e.mixins.length;o<a;o++)n=_t(n,e.mixins[o],t);var i,s={};for(i in n)l(i);for(i in e)k(n,i)||l(i);function l(o){var r=Tt[o]||Pt;s[o]=r(n[o],e[o],t,o)}return s}function zt(n,e,t,o){if("string"==typeof t){var r=n[e];if(k(r,t))return r[t];var a=S(t);if(k(r,a))return r[a];var i=C(a);return k(r,i)?r[i]:r[t]||r[a]||r[i]}}function Et(n,e,t,o){var r=e[n],a=!k(t,n),i=t[n],s=Mt(Boolean,r.type);if(s>-1)if(a&&!k(r,"default"))i=!1;else if(""===i||i===P(n)){var l=Mt(String,r.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!k(e,"default"))return;var o=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(o)&&"Function"!==At(e.type)?o.call(n):o}(o,r,n);var d=In;Pn(!0),En(i),Pn(d)}return i}var Ot=/^\s*function (\w+)/;function At(n){var e=n&&n.toString().match(Ot);return e?e[1]:""}function Rt(n,e){return At(n)===At(e)}function Mt(n,e){if(!r(e))return Rt(e,n)?0:-1;for(var t=0,o=e.length;t<o;t++)if(Rt(e[t],n))return t;return-1}var Dt={enumerable:!0,configurable:!0,get:A,set:A};function Lt(n,e,t){Dt.get=function(){return this[e][t]},Dt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Dt)}function Nt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},o=n._props=Dn({}),r=n.$options._propKeys=[];n.$parent&&Pn(!1);var a=function(a){r.push(a);var i=Et(a,e,t,n);On(o,a,i),a in n||Lt(n,"_props",a)};for(var i in e)a(i);Pn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var o=n._setupContext=be(n);pn(n),wn();var r=Ie(t,null,[n._props||Dn({}),o],n,"setup");if(kn(),pn(),c(r))e.render=r;else if(d(r))if(n._setupState=r,r.__sfc){var a=n._setupProxy={};for(var i in r)"__sfc"!==i&&Un(a,r,i)}else for(var i in r)J(i)||Un(n,r,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?A:_(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Ce(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),o=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var a=t[r];0,o&&k(o,a)||J(a)||Lt(n,"_data",a)}var i=En(e);i&&i.vmCount++}(n);else{var t=En(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),o=an();for(var r in e){var a=e[r],i=c(a)?a:a.get;0,o||(t[r]=new qe(n,i||A,A,Ht)),r in n||Ut(n,r,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var o=e[t];if(r(o))for(var a=0;a<o.length;a++)$t(n,t,o[a]);else $t(n,t,o)}}(n,e.watch)}var Ht={lazy:!0};function Ut(n,e,t){var o=!an();c(t)?(Dt.get=o?Bt(e):Ft(t),Dt.set=A):(Dt.get=t.get?o&&!1!==t.cache?Bt(e):Ft(t.get):A,Dt.set=t.set||A),Object.defineProperty(n,e,Dt)}function Bt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Ft(n){return function(){return n.call(this,this)}}function $t(n,e,t,o){return p(t)&&(o=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,o)}var Jt=0;function qt(n){var e=n.options;if(n.super){var t=qt(n.super);if(t!==n.superOptions){n.superOptions=t;var o=function(n){var e,t=n.options,o=n.sealedOptions;for(var r in t)t[r]!==o[r]&&(e||(e={}),e[r]=t[r]);return e}(n);o&&E(n.extendOptions,o),(e=n.options=_t(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Wt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,o=t.cid,r=n._Ctor||(n._Ctor={});if(r[o])return r[o];var a=vt(n)||vt(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=_t(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Lt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ut(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,U.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=E({},i.options),r[o]=i,i}}function Gt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Xt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Kt(n,e){var t=n.cache,o=n.keys,r=n._vnode;for(var a in t){var i=t[a];if(i){var s=i.name;s&&!e(s)&&Yt(t,a,o,r)}}}function Yt(n,e,t,o){var r=n[e];!r||o&&r.tag===o.tag||r.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Jt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Fn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),o=e._parentVnode;t.parent=e.parent,t._parentVnode=o;var r=o.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=_t(qt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=pe(e._renderChildren,r),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):o,n._c=function(e,t,o,r){return Se(n,e,t,o,r,!1)},n.$createElement=function(e,t,o,r){return Se(n,e,t,o,r,!0)};var a=t&&t.data;On(n,"$attrs",a&&a.attrs||o,null,!0),On(n,"$listeners",e._parentListeners||o,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(Pn(!1),Object.keys(e).forEach((function(t){On(n,t,e[t])})),Pn(!0))}(e),Nt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var o=$n(n),r=dn?Reflect.ownKeys(t):Object.keys(t),a=0;a<r.length;a++){var i=r[a];Object.defineProperty(o,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=An,n.prototype.$delete=Rn,n.prototype.$watch=function(n,e,t){if(p(e))return $t(this,n,e,t);(t=t||{}).user=!0;var o=new qe(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(o.expression,'"');wn(),Ie(e,this,[o.value],this,r),kn()}return function(){o.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var o=this;if(r(n))for(var a=0,i=n.length;a<i;a++)o.$on(n[a],t);else(o._events[n]||(o._events[n]=[])).push(t),e.test(n)&&(o._hasHookEvent=!0);return o},n.prototype.$once=function(n,e){var t=this;function o(){t.$off(n,o),e.apply(t,arguments)}return o.fn=e,t.$on(n,o),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var o=0,a=n.length;o<a;o++)t.$off(n[o],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?z(t):t;for(var o=z(arguments,1),r='event handler for "'.concat(n,'"'),a=0,i=t.length;a<i;a++)Ie(t[a],e,o,e,r)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,o=t.$el,r=t._vnode,a=Ye(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),a(),o&&(o.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return He(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,o=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&we(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{pn(e),ke=e,n=o.call(e._renderProxy,e.$createElement)}catch(t){Ce(t,e,"render"),n=e._vnode}finally{ke=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=a,n}}(Vt);var Zt=[String,RegExp,Array],Qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Zt,exclude:Zt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,o=this.keyToCache;if(t){var r=t.tag,a=t.componentInstance,i=t.componentOptions;n[o]={name:Gt(i),tag:r,componentInstance:a},e.push(o),this.max&&e.length>parseInt(this.max)&&Yt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Yt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Kt(n,(function(n){return Xt(e,n)}))})),this.$watch("exclude",(function(e){Kt(n,(function(n){return!Xt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=je(n),t=e&&e.componentOptions;if(t){var o=Gt(t),r=this.include,a=this.exclude;if(r&&(!o||!Xt(r,o))||a&&o&&Xt(a,o))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:E,mergeOptions:_t,defineReactive:On},n.set=An,n.delete=Rn,n.nextTick=He,n.observable=function(n){return En(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,E(n.options.components,Qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=z(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=_t(this.options,n),this}}(n),Wt(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:an}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:ht}),Vt.version="2.7.14";var no=b("style,class"),eo=b("input,textarea,option,select,progress"),to=b("contenteditable,draggable,spellcheck"),oo=b("events,caret,typing,plaintext-only"),ro=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ao="http://www.w3.org/1999/xlink",io=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},so=function(n){return io(n)?n.slice(6,n.length):""},lo=function(n){return null==n||!1===n};function co(n){for(var e=n.data,t=n,o=n;i(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=uo(o.data,e));for(;i(t=t.parent);)t&&t.data&&(e=uo(e,t.data));return function(n,e){if(i(n)||i(e))return po(n,mo(e));return""}(e.staticClass,e.class)}function uo(n,e){return{staticClass:po(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function po(n,e){return n?e?n+" "+e:n:e||""}function mo(n){return Array.isArray(n)?function(n){for(var e,t="",o=0,r=n.length;o<r;o++)i(e=mo(n[o]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ho={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},fo=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),go=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vo=function(n){return fo(n)||go(n)};var bo=Object.create(null);var yo=b("text,number,password,search,email,tel,url");var xo=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ho[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wo={create:function(n,e){ko(e)},update:function(n,e){n.data.ref!==e.data.ref&&(ko(n,!0),ko(e))},destroy:function(n){ko(n,!0)}};function ko(n,e){var t=n.data.ref;if(i(t)){var o=n.context,a=n.componentInstance||n.elm,s=e?null:a,l=e?void 0:a;if(c(t))Ie(t,o,[s],o,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Hn(t),m=o.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?r(h)&&x(h,a):r(h)?h.includes(a)||h.push(a):u?(m[t]=[a],To(o,t,m[t])):t.value=[a]}else if(u){if(e&&m[t]!==a)return;m[t]=l,To(o,t,s)}else if(p){if(e&&t.value!==a)return;t.value=s}else 0}}}function To(n,e,t){var o=n._setupState;o&&k(o,e)&&(Hn(o[e])?o[e].value=t:o[e]=t)}var jo=new mn("",{},[]),So=["create","activate","update","remove","destroy"];function Co(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,o=i(t=n.data)&&i(t=t.attrs)&&t.type,r=i(t=e.data)&&i(t=t.attrs)&&t.type;return o===r||yo(o)&&yo(r)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Io(n,e,t){var o,r,a={};for(o=e;o<=t;++o)i(r=n[o].key)&&(a[r]=o);return a}var Po={create:_o,update:_o,destroy:function(n){_o(n,jo)}};function _o(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,o,r,a=n===jo,i=e===jo,s=Eo(n.data.directives,n.context),l=Eo(e.data.directives,e.context),c=[],d=[];for(t in l)o=s[t],r=l[t],o?(r.oldValue=o.value,r.oldArg=o.arg,Ao(r,"update",e,n),r.def&&r.def.componentUpdated&&d.push(r)):(Ao(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Ao(c[t],"inserted",e,n)};a?Wn(e,"insert",u):u()}d.length&&Wn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Ao(d[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||Ao(s[t],"unbind",n,n,i)}(n,e)}var zo=Object.create(null);function Eo(n,e){var t,o,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((o=n[t]).modifiers||(o.modifiers=zo),r[Oo(o)]=o,e._setupState&&e._setupState.__sfc){var a=o.def||zt(e,"_setupState","v-"+o.name);o.def="function"==typeof a?{bind:a,update:a}:a}o.def=o.def||zt(e.$options,"directives",o.name)}return r}function Oo(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ao(n,e,t,o,r){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,o,r)}catch(o){Ce(o,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ro=[wo,Po];function Mo(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var o,r,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(o in(i(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.attrs=E({},d)),d)r=d[o],c[o]!==r&&Do(l,o,r,e.data.pre);for(o in(K||Z)&&d.value!==c.value&&Do(l,"value",d.value),c)a(d[o])&&(io(o)?l.removeAttributeNS(ao,so(o)):to(o)||l.removeAttribute(o))}}function Do(n,e,t,o){o||n.tagName.indexOf("-")>-1?Lo(n,e,t):ro(e)?lo(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):to(e)?n.setAttribute(e,function(n,e){return lo(e)||"false"===e?"false":"contenteditable"===n&&oo(e)?e:"true"}(e,t)):io(e)?lo(t)?n.removeAttributeNS(ao,so(e)):n.setAttributeNS(ao,e,t):Lo(n,e,t)}function Lo(n,e,t){if(lo(t))n.removeAttribute(e);else{if(K&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var o=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",o)};n.addEventListener("input",o),n.__ieph=!0}n.setAttribute(e,t)}}var No={create:Mo,update:Mo};function Ho(n,e){var t=e.elm,o=e.data,r=n.data;if(!(a(o.staticClass)&&a(o.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var s=co(e),l=t._transitionClasses;i(l)&&(s=po(s,mo(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Uo,Bo={create:Ho,update:Ho};function Fo(n,e,t){var o=Uo;return function r(){var a=e.apply(null,arguments);null!==a&&qo(n,r,t,o)}}var $o=Ee&&!(en&&Number(en[1])<=53);function Jo(n,e,t,o){if($o){var r=st,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Uo.addEventListener(n,e,on?{capture:t,passive:o}:t)}function qo(n,e,t,o){(o||Uo).removeEventListener(n,e._wrapper||e,t)}function Vo(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},o=n.data.on||{};Uo=e.elm||n.elm,function(n){if(i(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,o,Jo,qo,Fo,e.context),Uo=void 0}}var Wo,Go={create:Vo,update:Vo,destroy:function(n){return Vo(n,jo)}};function Xo(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,o,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=E({},c)),l)t in c||(r[t]="");for(t in c){if(o=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),o===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=o;var d=a(o)?"":String(o);Ko(r,d)&&(r.value=d)}else if("innerHTML"===t&&go(r.tagName)&&a(r.innerHTML)){(Wo=Wo||document.createElement("div")).innerHTML="<svg>".concat(o,"</svg>");for(var u=Wo.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(o!==l[t])try{r[t]=o}catch(n){}}}}function Ko(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,o=n._vModifiers;if(i(o)){if(o.number)return v(t)!==v(e);if(o.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Yo={create:Xo,update:Xo},Zo=T((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var o=n.split(t);o.length>1&&(e[o[0].trim()]=o[1].trim())}})),e}));function Qo(n){var e=nr(n.style);return n.staticStyle?E(n.staticStyle,e):e}function nr(n){return Array.isArray(n)?O(n):"string"==typeof n?Zo(n):n}var er,tr=/^--/,or=/\s*!important$/,rr=function(n,e,t){if(tr.test(e))n.style.setProperty(e,t);else if(or.test(t))n.style.setProperty(P(e),t.replace(or,""),"important");else{var o=ir(e);if(Array.isArray(t))for(var r=0,a=t.length;r<a;r++)n.style[o]=t[r];else n.style[o]=t}},ar=["Webkit","Moz","ms"],ir=T((function(n){if(er=er||document.createElement("div").style,"filter"!==(n=S(n))&&n in er)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ar.length;t++){var o=ar[t]+e;if(o in er)return o}}));function sr(n,e){var t=e.data,o=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(o.staticStyle)&&a(o.style))){var r,s,l=e.elm,c=o.staticStyle,d=o.normalizedStyle||o.style||{},u=c||d,p=nr(e.data.style)||{};e.data.normalizedStyle=i(p.__ob__)?E({},p):p;var m=function(n,e){var t,o={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Qo(r.data))&&E(o,t);(t=Qo(n.data))&&E(o,t);for(var a=n;a=a.parent;)a.data&&(t=Qo(a.data))&&E(o,t);return o}(e,!0);for(s in u)a(m[s])&&rr(l,s,"");for(s in m)(r=m[s])!==u[s]&&rr(l,s,null==r?"":r)}}var lr={create:sr,update:sr},cr=/\s+/;function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(cr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ur(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(cr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),o=" "+e+" ";t.indexOf(o)>=0;)t=t.replace(o," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&E(e,mr(n.name||"v")),E(e,n),e}return"string"==typeof n?mr(n):void 0}}var mr=T((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),hr=G&&!Y,fr="transition",gr="transitionend",vr="animation",br="animationend";hr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(fr="WebkitTransition",gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(vr="WebkitAnimation",br="webkitAnimationEnd"));var yr=G?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xr(n){yr((function(){yr(n)}))}function wr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),dr(n,e))}function kr(n,e){n._transitionClasses&&x(n._transitionClasses,e),ur(n,e)}function Tr(n,e,t){var o=Sr(n,e),r=o.type,a=o.timeout,i=o.propCount;if(!r)return t();var s="transition"===r?gr:br,l=0,c=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),a+1),n.addEventListener(s,d)}var jr=/\b(transform|all)(,|$)/;function Sr(n,e){var t,o=window.getComputedStyle(n),r=(o[fr+"Delay"]||"").split(", "),a=(o[fr+"Duration"]||"").split(", "),i=Cr(r,a),s=(o[vr+"Delay"]||"").split(", "),l=(o[vr+"Duration"]||"").split(", "),c=Cr(s,l),d=0,u=0;return"transition"===e?i>0&&(t="transition",d=i,u=a.length):"animation"===e?c>0&&(t="animation",d=c,u=l.length):u=(t=(d=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&jr.test(o[fr+"Property"])}}function Cr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ir(e)+Ir(n[t])})))}function Ir(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Pr(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var o=pr(n.data.transition);if(!a(o)&&!i(t._enterCb)&&1===t.nodeType){for(var r=o.css,s=o.type,l=o.enterClass,u=o.enterToClass,p=o.enterActiveClass,m=o.appearClass,h=o.appearToClass,f=o.appearActiveClass,g=o.beforeEnter,b=o.enter,y=o.afterEnter,x=o.enterCancelled,w=o.beforeAppear,k=o.appear,T=o.afterAppear,j=o.appearCancelled,S=o.duration,C=Ke,I=Ke.$vnode;I&&I.parent;)C=I.context,I=I.parent;var P=!C._isMounted||!n.isRootInsert;if(!P||k||""===k){var _=P&&m?m:l,z=P&&f?f:p,E=P&&h?h:u,O=P&&w||g,A=P&&c(k)?k:b,R=P&&T||y,M=P&&j||x,D=v(d(S)?S.enter:S);0;var L=!1!==r&&!Y,H=Er(A),U=t._enterCb=N((function(){L&&(kr(t,E),kr(t,z)),U.cancelled?(L&&kr(t,_),M&&M(t)):R&&R(t),t._enterCb=null}));n.data.show||Wn(n,"insert",(function(){var e=t.parentNode,o=e&&e._pending&&e._pending[n.key];o&&o.tag===n.tag&&o.elm._leaveCb&&o.elm._leaveCb(),A&&A(t,U)})),O&&O(t),L&&(wr(t,_),wr(t,z),xr((function(){kr(t,_),U.cancelled||(wr(t,E),H||(zr(D)?setTimeout(U,D):Tr(t,s,U)))}))),n.data.show&&(e&&e(),A&&A(t,U)),L||H||U()}}}function _r(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var o=pr(n.data.transition);if(a(o)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var r=o.css,s=o.type,l=o.leaveClass,c=o.leaveToClass,u=o.leaveActiveClass,p=o.beforeLeave,m=o.leave,h=o.afterLeave,f=o.leaveCancelled,g=o.delayLeave,b=o.duration,y=!1!==r&&!Y,x=Er(m),w=v(d(b)?b.leave:b);0;var k=t._leaveCb=N((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(kr(t,c),kr(t,u)),k.cancelled?(y&&kr(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(T):T()}function T(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(wr(t,l),wr(t,u),xr((function(){kr(t,l),k.cancelled||(wr(t,c),x||(zr(w)?setTimeout(k,w):Tr(t,s,k)))}))),m&&m(t,k),y||x||k())}}function zr(n){return"number"==typeof n&&!isNaN(n)}function Er(n){if(a(n))return!1;var e=n.fns;return i(e)?Er(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Or(n,e){!0!==e.data.show&&Pr(e)}var Ar=function(n){var e,t,o={},c=n.modules,d=n.nodeOps;for(e=0;e<So.length;++e)for(o[So[e]]=[],t=0;t<c.length;++t)i(c[t][So[e]])&&o[So[e]].push(c[t][So[e]]);function u(n){var e=d.parentNode(n);i(e)&&d.removeChild(e,n)}function p(n,e,t,r,a,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=gn(n)),n.isRootInsert=!a,!function(n,e,t,r){var a=n.data;if(i(a)){var l=i(n.componentInstance)&&a.keepAlive;if(i(a=a.hook)&&i(a=a.init)&&a(n,!1),i(n.componentInstance))return m(n,e),h(t,n.elm,r),s(l)&&function(n,e,t,r){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(a=s.data)&&i(a=a.transition)){for(a=0;a<o.activate.length;++a)o.activate[a](jo,s);e.push(s);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var u=n.data,p=n.children,g=n.tag;i(g)?(n.elm=n.ns?d.createElementNS(n.ns,g):d.createElement(g,n),y(n),f(n,p,e),i(u)&&v(n,e),h(t,n.elm,r)):s(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,r)):(n.elm=d.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),y(n)):(ko(n),e.push(n))}function h(n,e,t){i(n)&&(i(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function f(n,e,t){if(r(e)){0;for(var o=0;o<e.length;++o)p(e[o],t,n.elm,null,!0,e,o)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function v(n,t){for(var r=0;r<o.create.length;++r)o.create[r](jo,n);i(e=n.data.hook)&&(i(e.create)&&e.create(jo,n),i(e.insert)&&t.push(n))}function y(n){var e;if(i(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;i(e=Ke)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function x(n,e,t,o,r,a){for(;o<=r;++o)p(t[o],a,n,e,!1,t,o)}function w(n){var e,t,r=n.data;if(i(r))for(i(e=r.hook)&&i(e=e.destroy)&&e(n),e=0;e<o.destroy.length;++e)o.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var o=n[e];i(o)&&(i(o.tag)?(T(o),w(o)):u(o.elm))}}function T(n,e){if(i(e)||i(n.data)){var t,r=o.remove.length+1;for(i(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&T(t,e),t=0;t<o.remove.length;++t)o.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else u(n.elm)}function j(n,e,t,o){for(var r=t;r<o;r++){var a=e[r];if(i(a)&&Co(n,a))return r}}function S(n,e,t,r,l,c){if(n!==e){i(e.elm)&&i(r)&&(e=r[l]=gn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?P(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;i(h)&&i(m=h.hook)&&i(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(i(h)&&g(e)){for(m=0;m<o.update.length;++m)o.update[m](n,e);i(m=h.hook)&&i(m=m.update)&&m(n,e)}a(e.text)?i(f)&&i(v)?f!==v&&function(n,e,t,o,r){var s,l,c,u=0,m=0,h=e.length-1,f=e[0],g=e[h],v=t.length-1,b=t[0],y=t[v],w=!r;for(0;u<=h&&m<=v;)a(f)?f=e[++u]:a(g)?g=e[--h]:Co(f,b)?(S(f,b,o,t,m),f=e[++u],b=t[++m]):Co(g,y)?(S(g,y,o,t,v),g=e[--h],y=t[--v]):Co(f,y)?(S(f,y,o,t,v),w&&d.insertBefore(n,f.elm,d.nextSibling(g.elm)),f=e[++u],y=t[--v]):Co(g,b)?(S(g,b,o,t,m),w&&d.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++m]):(a(s)&&(s=Io(e,u,h)),a(l=i(b.key)?s[b.key]:j(b,e,u,h))?p(b,o,n,f.elm,!1,t,m):Co(c=e[l],b)?(S(c,b,o,t,m),e[l]=void 0,w&&d.insertBefore(n,c.elm,f.elm)):p(b,o,n,f.elm,!1,t,m),b=t[++m]);u>h?x(n,a(t[v+1])?null:t[v+1].elm,t,m,v,o):m>v&&k(e,u,h)}(u,f,v,t,c):i(v)?(i(n.text)&&d.setTextContent(u,""),x(u,null,v,0,v.length-1,t)):i(f)?k(f,0,f.length-1):i(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),i(h)&&i(m=h.hook)&&i(m=m.postpatch)&&m(n,e)}}}function C(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var o=0;o<e.length;++o)e[o].data.hook.insert(e[o])}var I=b("attrs,class,staticClass,staticStyle,key");function P(n,e,t,o){var r,a=e.tag,l=e.data,c=e.children;if(o=o||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(r=l.hook)&&i(r=r.init)&&r(e,!0),i(r=e.componentInstance)))return m(e,t),!0;if(i(a)){if(i(c))if(n.hasChildNodes())if(i(r=l)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!P(u,c[p],t,o)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else f(e,c,t);if(i(l)){var h=!1;for(var g in l)if(!I(g)){h=!0,v(e,t);break}!h&&l.class&&Fe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!a(e)){var l,c=!1,u=[];if(a(n))c=!0,p(e,u);else{var m=i(n.nodeType);if(!m&&Co(n,e))S(n,e,u,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&P(n,e,u))return C(e,u,!0),n;l=n,n=new mn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=d.parentNode(h);if(p(e,u,h._leaveCb?null:f,d.nextSibling(h)),i(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<o.destroy.length;++y)o.destroy[y](v);if(v.elm=e.elm,b){for(var x=0;x<o.create.length;++x)o.create[x](jo,v);var T=v.data.hook.insert;if(T.merged)for(var j=1;j<T.fns.length;j++)T.fns[j]()}else ko(v);v=v.parent}i(f)?k([n],0,0):i(n.tag)&&w(n)}}return C(e,u,c),e.elm}i(n)&&w(n)}}({nodeOps:xo,modules:[No,Bo,Go,Yo,lr,G?{create:Or,activate:Or,remove:function(n,e){!0!==n.data.show?_r(n,e):e()}}:{}].concat(Ro)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Br(n,"input")}));var Rr={inserted:function(n,e,t,o){"select"===t.tag?(o.elm&&!o.elm._vOptions?Wn(t,"postpatch",(function(){Rr.componentUpdated(n,e,t)})):Mr(n,e,t.context),n._vOptions=[].map.call(n.options,Nr)):("textarea"===t.tag||yo(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Hr),n.addEventListener("compositionend",Ur),n.addEventListener("change",Ur),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Mr(n,e,t.context);var o=n._vOptions,r=n._vOptions=[].map.call(n.options,Nr);if(r.some((function(n,e){return!D(n,o[e])})))(n.multiple?e.value.some((function(n){return Lr(n,r)})):e.value!==e.oldValue&&Lr(e.value,r))&&Br(n,"change")}}};function Mr(n,e,t){Dr(n,e,t),(K||Z)&&setTimeout((function(){Dr(n,e,t)}),0)}function Dr(n,e,t){var o=e.value,r=n.multiple;if(!r||Array.isArray(o)){for(var a,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],r)a=L(o,Nr(i))>-1,i.selected!==a&&(i.selected=a);else if(D(Nr(i),o))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Lr(n,e){return e.every((function(e){return!D(e,n)}))}function Nr(n){return"_value"in n?n._value:n.value}function Hr(n){n.target.composing=!0}function Ur(n){n.target.composing&&(n.target.composing=!1,Br(n.target,"input"))}function Br(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fr(n){return!n.componentInstance||n.data&&n.data.transition?n:Fr(n.componentInstance._vnode)}var $r={model:Rr,show:{bind:function(n,e,t){var o=e.value,r=(t=Fr(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;o&&r?(t.data.show=!0,Pr(t,(function(){n.style.display=a}))):n.style.display=o?a:"none"},update:function(n,e,t){var o=e.value;!o!=!e.oldValue&&((t=Fr(t)).data&&t.data.transition?(t.data.show=!0,o?Pr(t,(function(){n.style.display=n.__vOriginalDisplay})):_r(t,(function(){n.style.display="none"}))):n.style.display=o?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,o,r){r||(n.style.display=n.__vOriginalDisplay)}}},Jr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function qr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?qr(je(e.children)):n}function Vr(n){var e={},t=n.$options;for(var o in t.propsData)e[o]=n[o];var r=t._parentListeners;for(var o in r)e[S(o)]=r[o];return e}function Wr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Gr=function(n){return n.tag||he(n)},Xr=function(n){return"show"===n.name},Kr={name:"transition",props:Jr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Gr)).length){0;var o=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var a=qr(r);if(!a)return r;if(this._leaving)return Wr(n,r);var i="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?i+"comment":i+a.tag:l(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var s=(a.data||(a.data={})).transition=Vr(this),c=this._vnode,d=qr(c);if(a.data.directives&&a.data.directives.some(Xr)&&(a.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,d)&&!he(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=E({},s);if("out-in"===o)return this._leaving=!0,Wn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Wr(n,r);if("in-out"===o){if(he(a))return c;var p,m=function(){p()};Wn(s,"afterEnter",m),Wn(s,"enterCancelled",m),Wn(u,"delayLeave",(function(n){p=n}))}}return r}}},Yr=E({tag:String,moveClass:String},Jr);function Zr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Qr(n){n.data.newPos=n.elm.getBoundingClientRect()}function na(n){var e=n.data.pos,t=n.data.newPos,o=e.left-t.left,r=e.top-t.top;if(o||r){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(o,"px,").concat(r,"px)"),a.transitionDuration="0s"}}delete Yr.mode;var ea={Transition:Kr,TransitionGroup:{props:Yr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,o){var r=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,o)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),o=this.prevChildren=this.children,r=this.$slots.default||[],a=this.children=[],i=Vr(this),s=0;s<r.length;s++){if((d=r[s]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))a.push(d),t[d.key]=d,(d.data||(d.data={})).transition=i;else;}if(o){var l=[],c=[];for(s=0;s<o.length;s++){var d;(d=o[s]).data.transition=i,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Zr),n.forEach(Qr),n.forEach(na),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,o=t.style;wr(t,e),o.transform=o.WebkitTransform=o.transitionDuration="",t.addEventListener(gr,t._moveCb=function n(o){o&&o.target!==t||o&&!/transform$/.test(o.propertyName)||(t.removeEventListener(gr,n),t._moveCb=null,kr(t,e))})}})))},methods:{hasMove:function(n,e){if(!hr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ur(t,n)})),dr(t,e),t.style.display="none",this.$el.appendChild(t);var o=Sr(t);return this.$el.removeChild(t),this._hasMove=o.hasTransform}}}};function ta(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&eo(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=vo,Vt.config.isReservedAttr=no,Vt.config.getTagNamespace=function(n){return go(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!G)return!0;if(vo(n))return!1;if(n=n.toLowerCase(),null!=bo[n])return bo[n];var e=document.createElement(n);return n.indexOf("-")>-1?bo[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:bo[n]=/HTMLUnknownElement/.test(e.toString())},E(Vt.options.directives,$r),E(Vt.options.components,ea),Vt.prototype.__patch__=G?Ar:A,Vt.prototype.$mount=function(n,e){return function(n,e,t){var o;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),o=function(){n._update(n._render(),t)},new qe(n,o,A,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var a=0;a<r.length;a++)r[a].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&G?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},G&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",Vt)}),0);var oa=/[!'()*]/g,ra=function(n){return"%"+n.charCodeAt(0).toString(16)},aa=/%2C/g,ia=function(n){return encodeURIComponent(n).replace(oa,ra).replace(aa,",")};function sa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var la=function(n){return null==n||"object"==typeof n?n:String(n)};function ca(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),o=sa(t.shift()),r=t.length>0?sa(t.join("=")):null;void 0===e[o]?e[o]=r:Array.isArray(e[o])?e[o].push(r):e[o]=[e[o],r]})),e):e}function da(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ia(e);if(Array.isArray(t)){var o=[];return t.forEach((function(n){void 0!==n&&(null===n?o.push(ia(e)):o.push(ia(e)+"="+ia(n)))})),o.join("&")}return ia(e)+"="+ia(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ua=/\/?$/;function pa(n,e,t,o){var r=o&&o.options.stringifyQuery,a=e.query||{};try{a=ma(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:ga(e,r),matched:n?fa(n):[]};return t&&(i.redirectedFrom=ga(t,r)),Object.freeze(i)}function ma(n){if(Array.isArray(n))return n.map(ma);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ma(n[t]);return e}return n}var ha=pa(null,{path:"/"});function fa(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function ga(n,e){var t=n.path,o=n.query;void 0===o&&(o={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||da)(o)+r}function va(n,e,t){return e===ha?n===e:!!e&&(n.path&&e.path?n.path.replace(ua,"")===e.path.replace(ua,"")&&(t||n.hash===e.hash&&ba(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&ba(n.query,e.query)&&ba(n.params,e.params))))}function ba(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),o=Object.keys(e).sort();return t.length===o.length&&t.every((function(t,r){var a=n[t];if(o[r]!==t)return!1;var i=e[t];return null==a||null==i?a===i:"object"==typeof a&&"object"==typeof i?ba(a,i):String(a)===String(i)}))}function ya(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var o in t.instances){var r=t.instances[o],a=t.enteredCbs[o];if(r&&a){delete t.enteredCbs[o];for(var i=0;i<a.length;i++)r._isBeingDestroyed||a[i](r)}}}}var xa={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,o=e.children,r=e.parent,a=e.data;a.routerView=!0;for(var i=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,u=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&d++,p.keepAlive&&r._directInactive&&r._inactive&&(u=!0),r=r.$parent}if(a.routerViewDepth=d,u){var m=c[s],h=m&&m.component;return h?(m.configProps&&wa(h,a,m.route,m.configProps),i(h,a,o)):i()}var f=l.matched[d],g=f&&f.components[s];if(!f||!g)return c[s]=null,i();c[s]={component:g},a.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),ya(l)};var v=f.props&&f.props[s];return v&&(ta(c[s],{route:l,configProps:v}),wa(g,a,l,v)),i(g,a,o)}};function wa(n,e,t,o){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,o);if(r){r=e.props=ta({},r);var a=e.attrs=e.attrs||{};for(var i in r)n.props&&i in n.props||(a[i]=r[i],delete r[i])}}function ka(n,e,t){var o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function Ta(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ja=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Sa=Ha,Ca=Ea,Ia=function(n,e){return Aa(Ea(n,e),e)},Pa=Aa,_a=Na,za=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Ea(n,e){for(var t,o=[],r=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=za.exec(n));){var l=t[0],c=t[1],d=t.index;if(i+=n.slice(a,d),a=d+l.length,c)i+=c[1];else{var u=n[a],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],v=t[7];i&&(o.push(i),i="");var b=null!=p&&null!=u&&u!==p,y="+"===g||"*"===g,x="?"===g||"*"===g,w=t[2]||s,k=h||f;o.push({name:m||r++,prefix:p||"",delimiter:w,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:k?Ma(k):v?".*":"[^"+Ra(w)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&o.push(i),o}function Oa(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Aa(n,e){for(var t=new Array(n.length),o=0;o<n.length;o++)"object"==typeof n[o]&&(t[o]=new RegExp("^(?:"+n[o].pattern+")$",La(e)));return function(e,o){for(var r="",a=e||{},i=(o||{}).pretty?Oa:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,d=a[l.name];if(null==d){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ja(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=i(d[u]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(d),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Ra(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Ma(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Da(n,e){return n.keys=e,n}function La(n){return n&&n.sensitive?"":"i"}function Na(n,e,t){ja(e)||(t=e||t,e=[]);for(var o=(t=t||{}).strict,r=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=Ra(s);else{var l=Ra(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Ra(t.delimiter||"/"),u=a.slice(-d.length)===d;return o||(a=(u?a.slice(0,-d.length):a)+"(?:"+d+"(?=$))?"),a+=r?"$":o&&u?"":"(?="+d+"|$)",Da(new RegExp("^"+a,La(t)),e)}function Ha(n,e,t){return ja(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var o=0;o<t.length;o++)e.push({name:o,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Da(n,e)}(n,e):ja(n)?function(n,e,t){for(var o=[],r=0;r<n.length;r++)o.push(Ha(n[r],e,t).source);return Da(new RegExp("(?:"+o.join("|")+")",La(t)),e)}(n,e,t):function(n,e,t){return Na(Ea(n,t),e,t)}(n,e,t)}Sa.parse=Ca,Sa.compile=Ia,Sa.tokensToFunction=Pa,Sa.tokensToRegExp=_a;var Ua=Object.create(null);function Ba(n,e,t){e=e||{};try{var o=Ua[n]||(Ua[n]=Sa.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),o(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Fa(n,e,t,o){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var a=(r=ta({},n)).params;return a&&"object"==typeof a&&(r.params=ta({},a)),r}if(!r.path&&r.params&&e){(r=ta({},r))._normalized=!0;var i=ta(ta({},e.params),r.params);if(e.name)r.name=e.name,r.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Ba(s,i,e.path)}else 0;return r}var l=function(n){var e="",t="",o=n.indexOf("#");o>=0&&(e=n.slice(o),n=n.slice(0,o));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",d=l.path?ka(l.path,c,t||r.append):c,u=function(n,e,t){void 0===e&&(e={});var o,r=t||ca;try{o=r(n||"")}catch(n){o={}}for(var a in e){var i=e[a];o[a]=Array.isArray(i)?i.map(la):la(i)}return o}(l.query,r.query,o&&o.options.parseQuery),p=r.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var $a,Ja=function(){},qa={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,o=this.$route,r=t.resolve(this.to,o,this.append),a=r.location,i=r.route,s=r.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=i.redirectedFrom?pa(null,Fa(i.redirectedFrom),null,t):i;l[h]=va(o,f,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(ua,"/").indexOf(e.path.replace(ua,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(o,f);var g=l[h]?this.ariaCurrentValue:null,v=function(n){Va(n)&&(e.replace?t.replace(a,Ja):t.push(a,Ja))},b={click:Va};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:v,isActive:l[m],isExactActive:l[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":g};else{var w=function n(e){var t;if(e)for(var o=0;o<e.length;o++){if("a"===(t=e[o]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=ta({},w.data);for(var T in k.on=k.on||{},k.on){var j=k.on[T];T in b&&(k.on[T]=Array.isArray(j)?j:[j])}for(var S in b)S in k.on?k.on[S].push(b[S]):k.on[S]=v;var C=w.data.attrs=ta({},w.data.attrs);C.href=s,C["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Va(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Wa="undefined"!=typeof window;function Ga(n,e,t,o,r){var a=e||[],i=t||Object.create(null),s=o||Object.create(null);n.forEach((function(n){!function n(e,t,o,r,a,i){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Ta(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var u={path:d,regex:Xa(d,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:i,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var a=i?Ta(i+"/"+r.path):void 0;n(e,t,o,r,u,a)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,o,h,a,u.path||"/")}l&&(o[l]||(o[l]=u))}(a,i,s,n,r)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:i,nameMap:s}}function Xa(n,e){return Sa(n,[],e)}function Ka(n,e){var t=Ga(n),o=t.pathList,r=t.pathMap,a=t.nameMap;function i(n,t,i){var s=Fa(n,t,!1,e),c=s.name;if(c){var d=a[c];if(!d)return l(null,s);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&u.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Ba(d.path,s.params),l(d,s,i)}if(s.path){s.params={};for(var m=0;m<o.length;m++){var h=o[m],f=r[h];if(Ya(f.regex,s.path,s.params))return l(f,s,i)}}return l(null,s)}function s(n,t){var o=n.redirect,r="function"==typeof o?o(pa(n,t,null,e)):o;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,d=s.path,u=t.query,p=t.hash,m=t.params;if(u=s.hasOwnProperty("query")?s.query:u,p=s.hasOwnProperty("hash")?s.hash:p,m=s.hasOwnProperty("params")?s.params:m,c){a[c];return i({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return ka(n,e.parent?e.parent.path:"/",!0)}(d,n);return i({_normalized:!0,path:Ba(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,o){return n&&n.redirect?s(n,o||t):n&&n.matchAs?function(n,e,t){var o=i({_normalized:!0,path:Ba(t,e.params)});if(o){var r=o.matched,a=r[r.length-1];return e.params=o.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):pa(n,t,o,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Ga([e||n],o,r,a,t),t&&t.alias.length&&Ga(t.alias.map((function(n){return{path:n,children:[e]}})),o,r,a,t)},getRoutes:function(){return o.map((function(n){return r[n]}))},addRoutes:function(n){Ga(n,o,r,a)}}}function Ya(n,e,t){var o=e.match(n);if(!o)return!1;if(!t)return!0;for(var r=1,a=o.length;r<a;++r){var i=n.keys[r-1];i&&(t[i.name||"pathMatch"]="string"==typeof o[r]?sa(o[r]):o[r])}return!0}var Za=Wa&&window.performance&&window.performance.now?window.performance:Date;function Qa(){return Za.now().toFixed(3)}var ni=Qa();function ei(){return ni}function ti(n){return ni=n}var oi=Object.create(null);function ri(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ta({},window.history.state);return t.key=ei(),window.history.replaceState(t,"",e),window.addEventListener("popstate",si),function(){window.removeEventListener("popstate",si)}}function ai(n,e,t,o){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var a=function(){var n=ei();if(n)return oi[n]}(),i=r.call(n,e,t,o?a:null);i&&("function"==typeof i.then?i.then((function(n){pi(n,a)})).catch((function(n){0})):pi(i,a))}))}}function ii(){var n=ei();n&&(oi[n]={x:window.pageXOffset,y:window.pageYOffset})}function si(n){ii(),n.state&&n.state.key&&ti(n.state.key)}function li(n){return di(n.x)||di(n.y)}function ci(n){return{x:di(n.x)?n.x:window.pageXOffset,y:di(n.y)?n.y:window.pageYOffset}}function di(n){return"number"==typeof n}var ui=/^#\d/;function pi(n,e){var t,o="object"==typeof n;if(o&&"string"==typeof n.selector){var r=ui.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),o=n.getBoundingClientRect();return{x:o.left-t.left-e.x,y:o.top-t.top-e.y}}(r,a={x:di((t=a).x)?t.x:0,y:di(t.y)?t.y:0})}else li(n)&&(e=ci(n))}else o&&li(n)&&(e=ci(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var mi,hi=Wa&&((-1===(mi=window.navigator.userAgent).indexOf("Android 2.")&&-1===mi.indexOf("Android 4.0")||-1===mi.indexOf("Mobile Safari")||-1!==mi.indexOf("Chrome")||-1!==mi.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fi(n,e){ii();var t=window.history;try{if(e){var o=ta({},t.state);o.key=ei(),t.replaceState(o,"",n)}else t.pushState({key:ti(Qa())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function gi(n){fi(n,!0)}var vi={redirected:2,aborted:4,cancelled:8,duplicated:16};function bi(n,e){return xi(n,e,vi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return wi.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yi(n,e){return xi(n,e,vi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xi(n,e,t,o){var r=new Error(o);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var wi=["params","query","hash"];function ki(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Ti(n,e){return ki(n)&&n._isRouter&&(null==e||n.type===e)}function ji(n,e,t){var o=function(r){r>=n.length?t():n[r]?e(n[r],(function(){o(r+1)})):o(r+1)};o(0)}function Si(n){return function(e,t,o){var r=!1,a=0,i=null;Ci(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,a++;var l,c=_i((function(e){var r;((r=e).__esModule||Pi&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:$a.extend(e),t.components[s]=e,--a<=0&&o()})),d=_i((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=ki(n)?n:new Error(e),o(i))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),r||o()}}function Ci(n,e){return Ii(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ii(n){return Array.prototype.concat.apply([],n)}var Pi="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function _i(n){var e=!1;return function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];if(!e)return e=!0,n.apply(this,t)}}var zi=function(n,e){this.router=n,this.base=function(n){if(!n)if(Wa){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ha,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ei(n,e,t,o){var r=Ci(n,(function(n,o,r,a){var i=function(n,e){"function"!=typeof n&&(n=$a.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,o,r,a)})):t(i,o,r,a)}));return Ii(o?r.reverse():r)}function Oi(n,e){if(e)return function(){return n.apply(e,arguments)}}zi.prototype.listen=function(n){this.cb=n},zi.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},zi.prototype.onError=function(n){this.errorCbs.push(n)},zi.prototype.transitionTo=function(n,e,t){var o,r=this;try{o=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(o,(function(){r.updateRoute(o),e&&e(o),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(o,a)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(o)})))}),(function(n){t&&t(n),n&&!r.ready&&(Ti(n,vi.redirected)&&a===ha||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},zi.prototype.confirmTransition=function(n,e,t){var o=this,r=this.current;this.pending=n;var a,i,s=function(n){!Ti(n)&&ki(n)&&(o.errorCbs.length?o.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(va(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&ai(this.router,r,n,!1),s(((i=xi(a=r,n,vi.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",i));var d=function(n,e){var t,o=Math.max(n.length,e.length);for(t=0;t<o&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return Ei(n,"beforeRouteLeave",Oi,!0)}(p),this.router.beforeHooks,function(n){return Ei(n,"beforeRouteUpdate",Oi)}(u),m.map((function(n){return n.beforeEnter})),Si(m)),f=function(e,t){if(o.pending!==n)return s(yi(r,n));try{e(n,r,(function(e){!1===e?(o.ensureURL(!0),s(function(n,e){return xi(n,e,vi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):ki(e)?(o.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bi(r,n)),"object"==typeof e&&e.replace?o.replace(e):o.push(e)):t(e)}))}catch(n){s(n)}};ji(h,f,(function(){ji(function(n){return Ei(n,"beforeRouteEnter",(function(n,e,t,o){return function(n,e,t){return function(o,r,a){return n(o,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,o)}))}(m).concat(o.router.resolveHooks),f,(function(){if(o.pending!==n)return s(yi(r,n));o.pending=null,e(n),o.router.app&&o.router.app.$nextTick((function(){ya(n)}))}))}))},zi.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},zi.prototype.setupListeners=function(){},zi.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ha,this.pending=null};var Ai=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Ri(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,o=hi&&t;o&&this.listeners.push(ri());var r=function(){var t=n.current,r=Ri(n.base);n.current===ha&&r===n._startLocation||n.transitionTo(r,(function(n){o&&ai(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){fi(Ta(o.base+n.fullPath)),ai(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){gi(Ta(o.base+n.fullPath)),ai(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Ri(this.base)!==this.current.fullPath){var e=Ta(this.base+this.current.fullPath);n?fi(e):gi(e)}},e.prototype.getCurrentLocation=function(){return Ri(this.base)},e}(zi);function Ri(n){var e=window.location.pathname,t=e.toLowerCase(),o=n.toLowerCase();return!n||t!==o&&0!==t.indexOf(Ta(o+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Mi=function(n){function e(e,t,o){n.call(this,e,t),o&&function(n){var e=Ri(n);if(!/^\/#/.test(e))return window.location.replace(Ta(n+"/#"+e)),!0}(this.base)||Di()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=hi&&e;t&&this.listeners.push(ri());var o=function(){var e=n.current;Di()&&n.transitionTo(Li(),(function(o){t&&ai(n.router,o,e,!0),hi||Ui(o.fullPath)}))},r=hi?"popstate":"hashchange";window.addEventListener(r,o),this.listeners.push((function(){window.removeEventListener(r,o)}))}},e.prototype.push=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){Hi(n.fullPath),ai(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,r=this.current;this.transitionTo(n,(function(n){Ui(n.fullPath),ai(o.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Li()!==e&&(n?Hi(e):Ui(e))},e.prototype.getCurrentLocation=function(){return Li()},e}(zi);function Di(){var n=Li();return"/"===n.charAt(0)||(Ui("/"+n),!1)}function Li(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ni(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Hi(n){hi?fi(Ni(n)):window.location.hash=n}function Ui(n){hi?gi(Ni(n)):window.location.replace(Ni(n))}var Bi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index+1).concat(n),o.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var o=this.stack[t];this.confirmTransition(o,(function(){var n=e.current;e.index=t,e.updateRoute(o),e.router.afterHooks.forEach((function(e){e&&e(o,n)}))}),(function(n){Ti(n,vi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(zi),Fi=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ka(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!hi&&!1!==n.fallback,this.fallback&&(e="hash"),Wa||(e="abstract"),this.mode=e,e){case"history":this.history=new Ai(this,n.base);break;case"hash":this.history=new Mi(this,n.base,this.fallback);break;case"abstract":this.history=new Bi(this,n.base);break;default:0}},$i={currentRoute:{configurable:!0}};Fi.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},$i.currentRoute.get=function(){return this.history&&this.history.current},Fi.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ai||t instanceof Mi){var o=function(n){t.setupListeners(),function(n){var o=t.current,r=e.options.scrollBehavior;hi&&r&&"fullPath"in n&&ai(e,n,o,!1)}(n)};t.transitionTo(t.getCurrentLocation(),o,o)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Fi.prototype.beforeEach=function(n){return qi(this.beforeHooks,n)},Fi.prototype.beforeResolve=function(n){return qi(this.resolveHooks,n)},Fi.prototype.afterEach=function(n){return qi(this.afterHooks,n)},Fi.prototype.onReady=function(n,e){this.history.onReady(n,e)},Fi.prototype.onError=function(n){this.history.onError(n)},Fi.prototype.push=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.push(n,e,t)}));this.history.push(n,e,t)},Fi.prototype.replace=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.replace(n,e,t)}));this.history.replace(n,e,t)},Fi.prototype.go=function(n){this.history.go(n)},Fi.prototype.back=function(){this.go(-1)},Fi.prototype.forward=function(){this.go(1)},Fi.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Fi.prototype.resolve=function(n,e,t){var o=Fa(n,e=e||this.history.current,t,this),r=this.match(o,e),a=r.redirectedFrom||r.fullPath;return{location:o,route:r,href:function(n,e,t){var o="hash"===t?"#"+e:e;return n?Ta(n+"/"+o):o}(this.history.base,a,this.mode),normalizedTo:o,resolved:r}},Fi.prototype.getRoutes=function(){return this.matcher.getRoutes()},Fi.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ha&&this.history.transitionTo(this.history.getCurrentLocation())},Fi.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ha&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Fi.prototype,$i);var Ji=Fi;function qi(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Fi.install=function n(e){if(!n.installed||$a!==e){n.installed=!0,$a=e;var t=function(n){return void 0!==n},o=function(n,e){var o=n.$options._parentVnode;t(o)&&t(o=o.data)&&t(o=o.registerRouteInstance)&&o(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,o(this,this)},destroyed:function(){o(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",xa),e.component("RouterLink",qa);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Fi.version="3.6.5",Fi.isNavigationFailure=Ti,Fi.NavigationFailureType=vi,Fi.START_LOCATION=ha,Wa&&window.Vue&&window.Vue.use(Fi);t(105);t(27),t(132);var Vi={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,338)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,337))},Wi={"v-c4eb3f2e":()=>t.e(5).then(t.bind(null,339)),"v-6c3e2d70":()=>t.e(6).then(t.bind(null,340)),"v-27da749f":()=>t.e(7).then(t.bind(null,341)),"v-29e3d7ac":()=>t.e(8).then(t.bind(null,342)),"v-2b13c1ac":()=>t.e(9).then(t.bind(null,343)),"v-b0032272":()=>t.e(10).then(t.bind(null,344)),"v-33f5de5b":()=>t.e(11).then(t.bind(null,345)),"v-70c2e2f9":()=>t.e(12).then(t.bind(null,346)),"v-376350a2":()=>t.e(13).then(t.bind(null,347)),"v-07469028":()=>t.e(14).then(t.bind(null,348)),"v-555f7cfd":()=>t.e(15).then(t.bind(null,349)),"v-d869d228":()=>t.e(16).then(t.bind(null,350)),"v-b58f79ec":()=>t.e(17).then(t.bind(null,351)),"v-24cb4b2f":()=>t.e(18).then(t.bind(null,352)),"v-7b1f601a":()=>t.e(19).then(t.bind(null,353)),"v-3b84b4fa":()=>t.e(20).then(t.bind(null,354)),"v-8f948314":()=>t.e(21).then(t.bind(null,355)),"v-5206eee8":()=>t.e(22).then(t.bind(null,356)),"v-cd74352a":()=>t.e(23).then(t.bind(null,357)),"v-30976638":()=>t.e(24).then(t.bind(null,358)),"v-f2b399c4":()=>t.e(25).then(t.bind(null,359)),"v-7655fbdc":()=>t.e(26).then(t.bind(null,360)),"v-65e592f2":()=>t.e(27).then(t.bind(null,361)),"v-2939de45":()=>t.e(28).then(t.bind(null,362)),"v-005bcdbb":()=>t.e(29).then(t.bind(null,363)),"v-2df0fd98":()=>t.e(30).then(t.bind(null,364)),"v-dc1e1c72":()=>t.e(31).then(t.bind(null,365)),"v-03002f20":()=>t.e(32).then(t.bind(null,366)),"v-ade772bc":()=>t.e(33).then(t.bind(null,367)),"v-5b48707e":()=>t.e(34).then(t.bind(null,368)),"v-e342d2e6":()=>t.e(35).then(t.bind(null,369)),"v-10b4fbfc":()=>t.e(36).then(t.bind(null,370)),"v-24441a1e":()=>t.e(37).then(t.bind(null,371)),"v-33468254":()=>t.e(38).then(t.bind(null,372)),"v-30b51d06":()=>t.e(39).then(t.bind(null,373)),"v-4cac09e4":()=>t.e(40).then(t.bind(null,374)),"v-68a34aaa":()=>t.e(41).then(t.bind(null,375)),"v-b4ba35be":()=>t.e(42).then(t.bind(null,376)),"v-690a5e5f":()=>t.e(43).then(t.bind(null,377)),"v-3c1c174c":()=>t.e(44).then(t.bind(null,378)),"v-5c6d07b0":()=>t.e(45).then(t.bind(null,379)),"v-1fb423a2":()=>t.e(46).then(t.bind(null,380)),"v-d885a53e":()=>t.e(47).then(t.bind(null,381)),"v-bd509ace":()=>t.e(48).then(t.bind(null,382)),"v-661ac802":()=>t.e(49).then(t.bind(null,383)),"v-b5259178":()=>t.e(50).then(t.bind(null,384)),"v-106c7e08":()=>t.e(51).then(t.bind(null,385)),"v-c427e130":()=>t.e(52).then(t.bind(null,386)),"v-61f931e4":()=>t.e(53).then(t.bind(null,387)),"v-4d580af8":()=>t.e(54).then(t.bind(null,388)),"v-72709de4":()=>t.e(55).then(t.bind(null,389)),"v-c1961cb8":()=>t.e(56).then(t.bind(null,390)),"v-50e6ac38":()=>t.e(57).then(t.bind(null,391)),"v-cb206f50":()=>t.e(58).then(t.bind(null,392)),"v-fae2a3b8":()=>t.e(59).then(t.bind(null,393)),"v-6b0e2206":()=>t.e(60).then(t.bind(null,394)),"v-e45e5412":()=>t.e(61).then(t.bind(null,395)),"v-985e936c":()=>t.e(62).then(t.bind(null,396)),"v-411169a5":()=>t.e(63).then(t.bind(null,397)),"v-da7221b6":()=>t.e(64).then(t.bind(null,398)),"v-794777be":()=>t.e(65).then(t.bind(null,399))};function Gi(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xi=/-(\w)/g,Ki=Gi(n=>n.replace(Xi,(n,e)=>e?e.toUpperCase():"")),Yi=/\B([A-Z])/g,Zi=Gi(n=>n.replace(Yi,"-$1").toLowerCase()),Qi=Gi(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Qi(Ki(e))):n(Qi(e))||n(Zi(e))}const es=Object.assign({},Vi,Wi),ts=n=>es[n],os=n=>Wi[n],rs=n=>Vi[n],as=n=>Vt.component(n);function is(n){return ns(os,n)}function ss(n){return ns(rs,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(as,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Vt.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(93),ms=t.n(ps),hs=t(94),fs=t.n(hs),gs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],n,this.siteMeta,xs)},updateCanonicalLink(){vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),vs()}};function vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function xs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ws=t(51),ks={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ws)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),o=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],i=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(r===o)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Ts=t(25),js=t.n(Ts),Ss={mounted(){js.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||js.a.start(),t()}),this.$router.afterEach(()=>{js.a.done(),this.isSidebarOpen=!1})}};t(240),t(241);class Cs{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Is={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Cs).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var o=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&o.firstChild?o.insertBefore(r,o.firstChild):o.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ps={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},_s={},zs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Es=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ps[n]},Os=function n(e,t,o){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),o&&o.forEach((function(e){var t=e.tag,o=e.attrs,a=e.children;r.appendChild(n(t,o,a))})),r},As=function(n,e,t){var o,r=(o=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(o));return 1!==r.length||t?r:r[0]},Rs=function(n,e){var t,o,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=zs(s.html),s.jsTpl=(t=s.js,o=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(o,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),o="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(o,{presets:["es2015"]}).code:o,a=[eval][0](r);return a.template=e,a}(s.js,s.html);var l=Es("vue");return s.jsLib.unshift(l),s},Ms=function(n,e){var t,o=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),i={css:o&&o[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},Ds=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ls(){var n=As(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=As(n,"vuepress-plugin-demo-block__code"),t=As(n,"vuepress-plugin-demo-block__display"),o=As(n,"vuepress-plugin-demo-block__footer"),r=As(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,o="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(o))(),a={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ds(n),htmlTpl:zs("")},i=Es("react"),s=Es("reactDOM");return a.jsLib.unshift(i,s),a}(a,i):"vanilla"===s?Ms(a,i):Rs(a,i),d=Os("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(o.appendChild(d),d.addEventListener("click",Ns.bind(null,d,l,e,o)),Es("jsfiddle")&&o.appendChild(function(n){var e=n.css,t=n.htmlTpl,o=n.jsTpl,r=n.jsLib,a=n.cssLib,i=r.concat(a).concat(Es("cssLib")).concat(Es("jsLib")).join(",");return Os("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:o}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Es("codepen")&&o.appendChild(function(n){var e=n.css,t=n.htmlTpl,o=n.jsTpl,r=n.jsLib,a=n.cssLib,i=JSON.stringify({css:e,html:t,js:o,js_external:r.concat(Es("jsLib")).join(";"),css_external:a.concat(Es("cssLib")).join(";"),layout:Es("codepenLayout"),js_pre_processor:Es("codepenJsProcessor"),editors:Es("codepenEditors")});return Os("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:Es("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!_s[n]){var e=Os("style",{innerHTML:n});document.body.appendChild(e),_s[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ls()}),300)}function Ns(n,e,t,o){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?o.classList.add("vuepress-plugin-demo-block__show-link"):o.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Hs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ls()},updated:function(){Ls()}},Us="auto",Bs="zoom-in",Fs="zoom-out",$s="grab",Js="move";function qs(n,e,t){var o=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};o?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Vs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ws(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Gs(n,e,t){!function(n){var e=Xs,t=Ks;if(n.transition){var o=n.transition;delete n.transition,n[e]=o}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var o=n.style,r={};for(var a in e)t&&(r[a]=o[a]||""),o[a]=e[a];return r}var Xs="transition",Ks="transform",Ys="transform",Zs="transitionend";var Qs=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Qs,onClose:Qs,onGrab:Qs,onMove:Qs,onRelease:Qs,onBeforeOpen:Qs,onBeforeClose:Qs,onBeforeGrab:Qs,onBeforeRelease:Qs,onImageLoading:Qs,onImageLoaded:Qs},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),ol(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var o=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(r)>=a||Math.abs(o)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!ol(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!ol(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,o=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,o)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,o=e.clientY;this.move(t,o)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function ol(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Gs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),qs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Gs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},al="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},il=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ws(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,o=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?$s:Fs,transition:Ys+"\n        "+o+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Gs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Gs(this.el,{transform:"none"})},grab:function(n,e,t){var o=cl(),r=o.x-n,a=o.y-e;Gs(this.el,{cursor:Js,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var o=cl(),r=o.x-n,a=o.y-e;Gs(this.el,{transition:Ys,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Gs(this.el,this.styleClose)},restoreOpenStyle:function(){Gs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,o=this.instance.options,r=o.customSize,a=o.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":al(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-i,y:l.y-s},d=c.x/i,u=c.y/s,p=a+Math.min(d,u);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*h/(100*this.rect.height);if(p>f||p>g)return{x:f,y:g}}return{x:p,y:p}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function dl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(o){qs(n,o,e[o],t)}))}var ul=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(rl),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return il(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Bs,qs(n,"click",this.handler.click),this.options.preloadImage&&Vs(Ws(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var o="string"==typeof n?document.querySelector(n):n;if("IMG"===o.tagName){if(this.options.onBeforeOpen(o),this.target.init(o,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(o),Vs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),qs(document,"scroll",this.handler.scroll),qs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&qs(window,"resize",this.handler.resizeWindow);var a=function n(){qs(o,Zs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&dl(document,e.handler,!0),t(o)};return qs(o,Zs,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Us,this.overlay.fadeOut(),this.target.zoomOut(),qs(document,"scroll",this.handler.scroll,!1),qs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&qs(window,"resize",this.handler.resizeWindow,!1);var o=function o(){qs(t,Zs,o,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&dl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return qs(t,Zs,o),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var a=function n(){qs(r,Zs,n,!1),o(r)};return qs(r,Zs,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Js,this.target.move(n,e,t);var r=this.target.el,a=function n(){qs(r,Zs,n,!1),o(r)};return qs(r,Zs,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Us,this.target.restoreOpenStyle();var o=function o(){qs(t,Zs,o,!1),n.lock=!1,n.released=!0,e(t)};return qs(t,Zs,o),this}}}]),n}();const pl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ml=Number("500");class hl{constructor(){this.instance=new ul(pl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ml){setTimeout(()=>this.update(n),e)}}var fl=[gs,ks,Ss,Is,Hs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],gl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(4),bl=Object(vl.a)(gl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",fl);const yl=[{name:"v-c4eb3f2e",path:"/code/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c4eb3f2e").then(t)}},{path:"/code/index.html",redirect:"/code/"},{path:"/00.目录页/01.前端基础.html",redirect:"/code/"},{name:"v-6c3e2d70",path:"/frame/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6c3e2d70").then(t)}},{path:"/frame/index.html",redirect:"/frame/"},{path:"/00.目录页/02.软件框架.html",redirect:"/frame/"},{name:"v-27da749f",path:"/algorithm/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-27da749f").then(t)}},{path:"/algorithm/index.html",redirect:"/algorithm/"},{path:"/00.目录页/03.算法与数据结构.html",redirect:"/algorithm/"},{name:"v-29e3d7ac",path:"/base/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-29e3d7ac").then(t)}},{path:"/base/index.html",redirect:"/base/"},{path:"/00.目录页/04.计算机基础.html",redirect:"/base/"},{name:"v-2b13c1ac",path:"/system/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2b13c1ac").then(t)}},{path:"/system/index.html",redirect:"/system/"},{path:"/00.目录页/05.系统与工具.html",redirect:"/system/"},{name:"v-b0032272",path:"/project/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b0032272").then(t)}},{path:"/project/index.html",redirect:"/project/"},{path:"/00.目录页/06.项目.html",redirect:"/project/"},{name:"v-33f5de5b",path:"/interviews/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-33f5de5b").then(t)}},{path:"/interviews/index.html",redirect:"/interviews/"},{path:"/00.目录页/07.面试综合.html",redirect:"/interviews/"},{name:"v-70c2e2f9",path:"/part/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-70c2e2f9").then(t)}},{path:"/part/index.html",redirect:"/part/"},{path:"/00.目录页/08.专栏.html",redirect:"/part/"},{name:"v-376350a2",path:"/pages/a4421a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-376350a2").then(t)}},{path:"/pages/a4421a/index.html",redirect:"/pages/a4421a/"},{path:"/01.前端基础/01.HTML/01.ruanyf/01.html语言简介.html",redirect:"/pages/a4421a/"},{name:"v-07469028",path:"/pages/e4644a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-07469028").then(t)}},{path:"/pages/e4644a/index.html",redirect:"/pages/e4644a/"},{path:"/01.前端基础/01.HTML/01.ruanyf/02.URL简介.html",redirect:"/pages/e4644a/"},{name:"v-555f7cfd",path:"/pages/ec6dce/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-555f7cfd").then(t)}},{path:"/pages/ec6dce/index.html",redirect:"/pages/ec6dce/"},{path:"/01.前端基础/01.HTML/01.ruanyf/03.元素属性.html",redirect:"/pages/ec6dce/"},{name:"v-d869d228",path:"/pages/ed5e93/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-d869d228").then(t)}},{path:"/pages/ed5e93/index.html",redirect:"/pages/ed5e93/"},{path:"/01.前端基础/01.HTML/01.ruanyf/04.字符编码.html",redirect:"/pages/ed5e93/"},{name:"v-b58f79ec",path:"/pages/d279ea/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b58f79ec").then(t)}},{path:"/pages/d279ea/index.html",redirect:"/pages/d279ea/"},{path:"/01.前端基础/01.HTML/01.ruanyf/05.语义结构.html",redirect:"/pages/d279ea/"},{name:"v-24cb4b2f",path:"/pages/1788c5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-24cb4b2f").then(t)}},{path:"/pages/1788c5/index.html",redirect:"/pages/1788c5/"},{path:"/01.前端基础/01.HTML/01.ruanyf/06.文本标签.html",redirect:"/pages/1788c5/"},{name:"v-7b1f601a",path:"/pages/02a35f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7b1f601a").then(t)}},{path:"/pages/02a35f/index.html",redirect:"/pages/02a35f/"},{path:"/01.前端基础/04.ES6/01.ruanyf/10.Generator.html",redirect:"/pages/02a35f/"},{name:"v-3b84b4fa",path:"/pages/aebd55/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3b84b4fa").then(t)}},{path:"/pages/aebd55/index.html",redirect:"/pages/aebd55/"},{path:"/01.前端基础/04.ES6/01.ruanyf/11.Promise.html",redirect:"/pages/aebd55/"},{name:"v-8f948314",path:"/pages/83b396/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-8f948314").then(t)}},{path:"/pages/83b396/index.html",redirect:"/pages/83b396/"},{path:"/02.软件框架/01.vscode/01.vs快捷键.html",redirect:"/pages/83b396/"},{name:"v-5206eee8",path:"/pages/c60c2c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5206eee8").then(t)}},{path:"/pages/c60c2c/index.html",redirect:"/pages/c60c2c/"},{path:"/02.软件框架/04.vue/01.heima/01.webpack构建工具.html",redirect:"/pages/c60c2c/"},{name:"v-cd74352a",path:"/pages/2e2311/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-cd74352a").then(t)}},{path:"/pages/2e2311/index.html",redirect:"/pages/2e2311/"},{path:"/02.软件框架/04.vue/01.heima/02.Vue快速开始.html",redirect:"/pages/2e2311/"},{name:"v-30976638",path:"/pages/017a2c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-30976638").then(t)}},{path:"/pages/017a2c/index.html",redirect:"/pages/017a2c/"},{path:"/02.软件框架/04.vue/01.heima/03.vue生态技术Router.html",redirect:"/pages/017a2c/"},{name:"v-f2b399c4",path:"/pages/9204e3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f2b399c4").then(t)}},{path:"/pages/9204e3/index.html",redirect:"/pages/9204e3/"},{path:"/02.软件框架/04.vue/01.heima/04.vue生态技术axios.html",redirect:"/pages/9204e3/"},{name:"v-7655fbdc",path:"/pages/46ecd6/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7655fbdc").then(t)}},{path:"/pages/46ecd6/index.html",redirect:"/pages/46ecd6/"},{path:"/02.软件框架/04.vue/01.heima/31.vue生态技术vuex.html",redirect:"/pages/46ecd6/"},{name:"v-65e592f2",path:"/pages/9b7e40/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-65e592f2").then(t)}},{path:"/pages/9b7e40/index.html",redirect:"/pages/9b7e40/"},{path:"/02.软件框架/06.react/01.React入门.html",redirect:"/pages/9b7e40/"},{name:"v-2939de45",path:"/pages/5082ac/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2939de45").then(t)}},{path:"/pages/5082ac/index.html",redirect:"/pages/5082ac/"},{path:"/02.软件框架/06.react/01.heima/01.react快速开始.html",redirect:"/pages/5082ac/"},{name:"v-005bcdbb",path:"/pages/e67f9a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-005bcdbb").then(t)}},{path:"/pages/e67f9a/index.html",redirect:"/pages/e67f9a/"},{path:"/02.软件框架/06.react/01.heima/02.react受控和非受控组件.html",redirect:"/pages/e67f9a/"},{name:"v-2df0fd98",path:"/pages/d4ac65/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2df0fd98").then(t)}},{path:"/pages/d4ac65/index.html",redirect:"/pages/d4ac65/"},{path:"/02.软件框架/06.react/01.heima/03.react组件通信.html",redirect:"/pages/d4ac65/"},{name:"v-dc1e1c72",path:"/pages/a33ce9/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-dc1e1c72").then(t)}},{path:"/pages/a33ce9/index.html",redirect:"/pages/a33ce9/"},{path:"/02.软件框架/06.react/01.heima/04.react生命周期.html",redirect:"/pages/a33ce9/"},{name:"v-03002f20",path:"/pages/f24f8d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-03002f20").then(t)}},{path:"/pages/f24f8d/index.html",redirect:"/pages/f24f8d/"},{path:"/02.软件框架/06.react/01.heima/05.react路由.html",redirect:"/pages/f24f8d/"},{name:"v-ade772bc",path:"/pages/361177/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-ade772bc").then(t)}},{path:"/pages/361177/index.html",redirect:"/pages/361177/"},{path:"/02.软件框架/06.react/01.heima/06.react的hooks.html",redirect:"/pages/361177/"},{name:"v-5b48707e",path:"/pages/bfa1be/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5b48707e").then(t)}},{path:"/pages/bfa1be/index.html",redirect:"/pages/bfa1be/"},{path:"/02.软件框架/06.react/01.heima/07.react生态redux.html",redirect:"/pages/bfa1be/"},{name:"v-e342d2e6",path:"/pages/6cbc7a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e342d2e6").then(t)}},{path:"/pages/6cbc7a/index.html",redirect:"/pages/6cbc7a/"},{path:"/02.软件框架/06.react/01.heima/08.react生态router.html",redirect:"/pages/6cbc7a/"},{name:"v-10b4fbfc",path:"/pages/424a10/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-10b4fbfc").then(t)}},{path:"/pages/424a10/index.html",redirect:"/pages/424a10/"},{path:"/02.软件框架/06.react/04.react官方/01.核心概念.html",redirect:"/pages/424a10/"},{name:"v-24441a1e",path:"/pages/69da0f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-24441a1e").then(t)}},{path:"/pages/69da0f/index.html",redirect:"/pages/69da0f/"},{path:"/02.软件框架/06.react/04.react官方/02.hooks.html",redirect:"/pages/69da0f/"},{name:"v-33468254",path:"/pages/acec16/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-33468254").then(t)}},{path:"/pages/acec16/index.html",redirect:"/pages/acec16/"},{path:"/02.软件框架/06.react/04.react官方/03.高级指引.html",redirect:"/pages/acec16/"},{name:"v-30b51d06",path:"/pages/17f77d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-30b51d06").then(t)}},{path:"/pages/17f77d/index.html",redirect:"/pages/17f77d/"},{path:"/02.软件框架/06.react/04.react官方/04.API.html",redirect:"/pages/17f77d/"},{name:"v-4cac09e4",path:"/pages/330866/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4cac09e4").then(t)}},{path:"/pages/330866/index.html",redirect:"/pages/330866/"},{path:"/06.项目/01.中台管理项目/01.项目介绍.html",redirect:"/pages/330866/"},{name:"v-68a34aaa",path:"/pages/bf4db4/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-68a34aaa").then(t)}},{path:"/pages/bf4db4/index.html",redirect:"/pages/bf4db4/"},{path:"/06.项目/04.react项目搭建/01.index.html",redirect:"/pages/bf4db4/"},{name:"v-b4ba35be",path:"/pages/e0384f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b4ba35be").then(t)}},{path:"/pages/e0384f/index.html",redirect:"/pages/e0384f/"},{path:"/07.面试综合/01.字节前端青训营/01.青训营真题day01.html",redirect:"/pages/e0384f/"},{name:"v-690a5e5f",path:"/pages/332858/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-690a5e5f").then(t)}},{path:"/pages/332858/index.html",redirect:"/pages/332858/"},{path:"/07.面试综合/01.字节前端青训营/01day01-html与css.html",redirect:"/pages/332858/"},{name:"v-3c1c174c",path:"/pages/0da785/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3c1c174c").then(t)}},{path:"/pages/0da785/index.html",redirect:"/pages/0da785/"},{path:"/07.面试综合/01.字节前端青训营/03.day02-js.html",redirect:"/pages/0da785/"},{name:"v-5c6d07b0",path:"/pages/e7f910/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5c6d07b0").then(t)}},{path:"/pages/e7f910/index.html",redirect:"/pages/e7f910/"},{path:"/07.面试综合/01.字节前端青训营/03.day03-ts.html",redirect:"/pages/e7f910/"},{name:"v-1fb423a2",path:"/pages/4dacdd/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1fb423a2").then(t)}},{path:"/pages/4dacdd/index.html",redirect:"/pages/4dacdd/"},{path:"/07.面试综合/01.字节前端青训营/04.day04-HTTP.html",redirect:"/pages/4dacdd/"},{name:"v-d885a53e",path:"/pages/b52f92/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-d885a53e").then(t)}},{path:"/pages/b52f92/index.html",redirect:"/pages/b52f92/"},{path:"/07.面试综合/02.blog/01.常用登录功能的逻辑.html",redirect:"/pages/b52f92/"},{name:"v-bd509ace",path:"/pages/0489e2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-bd509ace").then(t)}},{path:"/pages/0489e2/index.html",redirect:"/pages/0489e2/"},{path:"/07.面试综合/02.blog/02.代码多环境开发.html",redirect:"/pages/0489e2/"},{name:"v-661ac802",path:"/pages/b48262/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-661ac802").then(t)}},{path:"/pages/b48262/index.html",redirect:"/pages/b48262/"},{path:"/08.专栏/01.Browser.html",redirect:"/pages/b48262/"},{name:"v-b5259178",path:"/pages/eab60b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b5259178").then(t)}},{path:"/pages/eab60b/index.html",redirect:"/pages/eab60b/"},{path:"/08.专栏/02.CN.html",redirect:"/pages/eab60b/"},{name:"v-106c7e08",path:"/pages/77ad0a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-106c7e08").then(t)}},{path:"/pages/77ad0a/index.html",redirect:"/pages/77ad0a/"},{path:"/08.专栏/03.CSS.html",redirect:"/pages/77ad0a/"},{name:"v-c427e130",path:"/pages/8564fd/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c427e130").then(t)}},{path:"/pages/8564fd/index.html",redirect:"/pages/8564fd/"},{path:"/08.专栏/04.Git.html",redirect:"/pages/8564fd/"},{name:"v-61f931e4",path:"/pages/5798b5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-61f931e4").then(t)}},{path:"/pages/5798b5/index.html",redirect:"/pages/5798b5/"},{path:"/08.专栏/05.HTML.html",redirect:"/pages/5798b5/"},{name:"v-4d580af8",path:"/pages/1f9ab3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4d580af8").then(t)}},{path:"/pages/1f9ab3/index.html",redirect:"/pages/1f9ab3/"},{path:"/08.专栏/06.JS.html",redirect:"/pages/1f9ab3/"},{name:"v-72709de4",path:"/pages/c60f99/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-72709de4").then(t)}},{path:"/pages/c60f99/index.html",redirect:"/pages/c60f99/"},{path:"/08.专栏/07.Optimize.html",redirect:"/pages/c60f99/"},{name:"v-c1961cb8",path:"/pages/1312c8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c1961cb8").then(t)}},{path:"/pages/1312c8/index.html",redirect:"/pages/1312c8/"},{path:"/08.专栏/08.OS.html",redirect:"/pages/1312c8/"},{name:"v-50e6ac38",path:"/pages/a9e64c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-50e6ac38").then(t)}},{path:"/pages/a9e64c/index.html",redirect:"/pages/a9e64c/"},{path:"/08.专栏/09.Project-Others.html",redirect:"/pages/a9e64c/"},{name:"v-cb206f50",path:"/pages/727eb5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-cb206f50").then(t)}},{path:"/pages/727eb5/index.html",redirect:"/pages/727eb5/"},{path:"/08.专栏/10.React.html",redirect:"/pages/727eb5/"},{name:"v-fae2a3b8",path:"/pages/520a27/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-fae2a3b8").then(t)}},{path:"/pages/520a27/index.html",redirect:"/pages/520a27/"},{path:"/08.专栏/11.Review.html",redirect:"/pages/520a27/"},{name:"v-6b0e2206",path:"/pages/7bb646/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6b0e2206").then(t)}},{path:"/pages/7bb646/index.html",redirect:"/pages/7bb646/"},{path:"/08.专栏/12.Vue.html",redirect:"/pages/7bb646/"},{name:"v-e45e5412",path:"/pages/98b72d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e45e5412").then(t)}},{path:"/pages/98b72d/index.html",redirect:"/pages/98b72d/"},{path:"/08.专栏/13.场景题.html",redirect:"/pages/98b72d/"},{name:"v-985e936c",path:"/pages/8f19fc/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-985e936c").then(t)}},{path:"/pages/8f19fc/index.html",redirect:"/pages/8f19fc/"},{path:"/08.专栏/14.备注.html",redirect:"/pages/8f19fc/"},{name:"v-411169a5",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-411169a5").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-da7221b6",path:"/tags/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-da7221b6").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-794777be",path:"/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-794777be").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:bl}],xl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"yuadh个人面试笔记网站"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"前端基础",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.前端基础",imgUrl:"/img/ui.png",description:"前端基础页"}},title:"前端基础",date:"2021-08-08T21:00:00.000Z",permalink:"/code",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"yuadh",link:"https://github.com/Interview-Vuepress"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80.html",relativePath:"00.目录页/01.前端基础.md",key:"v-c4eb3f2e",path:"/code/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"软件框架",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.软件框架",imgUrl:"/img/ui.png",description:"软件框架页"}},title:"软件框架",date:"2021-08-08T21:00:00.000Z",permalink:"/frame",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"yuadh",link:"https://github.com/Interview-Vuepress"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6.html",relativePath:"00.目录页/02.软件框架.md",key:"v-6c3e2d70",path:"/frame/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"算法与设计结构",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.算法与设计结构",imgUrl:"/img/ui.png",description:"算法与设计结构页"}},title:"算法与设计结构",date:"2021-08-08T21:00:00.000Z",permalink:"/algorithm",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"yuadh",link:"https://github.com/Interview-Vuepress"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"00.目录页/03.算法与数据结构.md",key:"v-27da749f",path:"/algorithm/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"计算机基础",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.计算机基础",imgUrl:"/img/ui.png",description:"计算机基础页"}},title:"计算机基础",date:"2021-08-08T21:00:00.000Z",permalink:"/base",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"yuadh",link:"https://github.com/Interview-Vuepress"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html",relativePath:"00.目录页/04.计算机基础.md",key:"v-29e3d7ac",path:"/base/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"系统与工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"05.系统与工具",imgUrl:"/img/ui.png",description:"系统与工具页"}},title:"系统与工具",date:"2021-08-08T21:00:00.000Z",permalink:"/system",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"yuadh",link:"https://github.com/Interview-Vuepress"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录页/05.系统与工具.md",key:"v-2b13c1ac",path:"/system/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"项目",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"06.项目",imgUrl:"/img/ui.png",description:"项目页"}},title:"项目",date:"2021-08-08T21:00:00.000Z",permalink:"/project",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"yuadh",link:"https://github.com/Interview-Vuepress"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.%E9%A1%B9%E7%9B%AE.html",relativePath:"00.目录页/06.项目.md",key:"v-b0032272",path:"/project/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"面试综合",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"07.面试综合",imgUrl:"/img/ui.png",description:"面试综合页"}},title:"面试综合",date:"2021-08-08T21:00:00.000Z",permalink:"/interviews",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"yuadh",link:"https://github.com/Interview-Vuepress"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/07.%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88.html",relativePath:"00.目录页/07.面试综合.md",key:"v-33f5de5b",path:"/interviews/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"专栏",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"08.专栏",imgUrl:"/img/ui.png",description:"专栏页"}},title:"专栏",date:"2021-08-08T21:00:00.000Z",permalink:"/part",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"yuadh",link:"https://github.com/Interview-Vuepress"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/08.%E4%B8%93%E6%A0%8F.html",relativePath:"00.目录页/08.专栏.md",key:"v-70c2e2f9",path:"/part/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"html语言简介",frontmatter:{title:"html语言简介",date:"2022-11-30T10:57:40.000Z",permalink:"/pages/a4421a/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/01.HTML/01.ruanyf/01.html%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B.html",relativePath:"01.前端基础/01.HTML/01.ruanyf/01.html语言简介.md",key:"v-376350a2",path:"/pages/a4421a/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:771},{level:3,title:"标签",slug:"标签",normalizedTitle:"标签",charIndex:780},{level:3,title:"元素",slug:"元素",normalizedTitle:"元素",charIndex:1677},{level:3,title:"块级元素，行内元素",slug:"块级元素-行内元素",normalizedTitle:"块级元素，行内元素",charIndex:1951},{level:3,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:2252},{level:2,title:"基本标签",slug:"基本标签",normalizedTitle:"基本标签",charIndex:2517},{level:3,title:"<!doctype>",slug:"doctype",normalizedTitle:"&lt;!doctype&gt;",charIndex:null},{level:3,title:"<html>",slug:"html",normalizedTitle:"<html>",charIndex:3054},{level:3,title:"<head>",slug:"head",normalizedTitle:"<head>",charIndex:525},{level:3,title:"<meta>",slug:"meta",normalizedTitle:"<meta>",charIndex:1070},{level:3,title:"<body>",slug:"body",normalizedTitle:"<body>",charIndex:587},{level:2,title:"空格和换行",slug:"空格和换行",normalizedTitle:"空格和换行",charIndex:5657},{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:6100}],headersStr:"概述 基本概念 标签 元素 块级元素，行内元素 属性 基本标签 <!doctype> <html> <head> <meta> <body> 空格和换行 注释",content:'# 概述\n\nHTML 是网页使用的语言，定义了网页的结构和内容。浏览器访问网站，其实就是从服务器下载 HTML 代码，然后渲染出网页。\n\nHTML 的全名是“超文本标记语言”（HyperText Markup Language），上个世纪90年代由欧洲核子研究中心的物理学家蒂姆·伯纳斯-李（Tim Berners-Lee）发明。它的最大特点就是支持超链接，点击链接就可以跳转到其他网页，从而构成了整个互联网。\n\n1999年，HTML 4.01 版发布，成为广泛接受的 HTML 标准。2014年，HTML 5 发布，这是目前正在使用的版本。\n\n浏览器的网页开发，涉及三种技术：HTML、CSS 和 JavaScript。HTML 语言定义网页的结构和内容，CSS 样式表定义网页的样式，JavaScript 语言定义网页与用户的互动行为。HTML 语言是网页开发的基础，CSS 和 JavaScript 都是基于 HTML 才能生效，即使没有这两者，HTML 本身也能使用，可以完成基本的内容展示。本教程只介绍 HTML 语言。\n\n下面就是一个简单网页的 HTML 源码。\n\n<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n  <meta charset="utf-8">\n  <title>网页标题</title>\n</head>\n<body>\n  <p>Hello World</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面这段代码，可以保存成文件hello.html。浏览器打开这个本地文件，就能看到文字“Hello World”。\n\n浏览器右键菜单的“查看源码”（View page source），可以展示当前网页的 HTML 源码。\n\n\n# 基本概念\n\n\n# 标签\n\n网页的 HTML 代码由许许多多不同的标签（tag）构成。学习 HTML 语言，就是学习各种标签的用法。\n\n下面就是标签的一个例子。\n\n<title>网页标题</title>\n\n\n1\n\n\n上面代码中，<title>和</title>就是一对标签。\n\n标签用来告诉浏览器，如何处理这段代码。标签的内容就是浏览器所要渲染的、展示在网页上的内容。\n\n标签放在一对尖括号里面（比如<title>），大多数标签都是成对出现的，分成开始标签和结束标签，结束标签在标签名之前加斜杠（比如</title>）。但是，也有一些标签不是成对使用，而是只有开始标签，没有结束标签，比如上一节示例的<meta>标签。\n\n<meta charset="utf-8">\n\n\n1\n\n\n上面代码中，<meta>标签就没有结束标签</meta>。\n\n这种单独使用的标签，通常是因为标签本身就足够完成功能了，不需要标签之间的内容。实际应用中，它们主要用来提示浏览器，做一些特别处理。\n\n标签可以嵌套。\n\n<div><p>hello world</p></div>\n\n\n1\n\n\n上面代码中，<div>标签内部包含了一个<p>标签。\n\n嵌套时，必须保证正确的闭合顺序，不能跨层嵌套，否则会出现意想不到的渲染结果。\n\n<div><p>hello world</div></p>\n\n\n1\n\n\n上面代码就是错误的嵌套，闭合顺序不正确。\n\nHTML 标签名是大小写不敏感，比如<title>和<TITLE>是同一个标签。不过，一般习惯都是使用小写。\n\n另外，HTML 语言忽略缩进和换行。下面几种写法的渲染结果是一样的。\n\n<title>网页标题</title>\n\n<title>\n  网页标题\n</title>\n\n<title>网页\n标题</title>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n进一步说，整个网页的 HTML 代码完全可以写成一行，浏览器照样解析，结果完全一样。所以，正式发布网页之前，开发者有时会把源码压缩成一行，以减少传输的字节数。\n\n各种网页的样式效果，比如内容的缩进和换行，主要靠 CSS 来实现。\n\n\n# 元素\n\n浏览器渲染网页时，会把 HTML 源码解析成一个标签树，每个标签都是树的一个节点（node）。这种节点就称为网页元素（element）。所以，“标签”和“元素”基本上是同义词，只是使用的场合不一样：标签是从源码角度来看，元素是从编程角度来看，比如<p>标签对应网页的p元素。\n\n嵌套的标签就构成了网页元素的层级关系。\n\n<div><p>hello world</p></div>\n\n\n1\n\n\n上面代码中，div元素内部包含了一个p元素。上层元素又称为“父元素”，下层元素又称为“子元素”，即div是p的父元素，p是div的子元素。\n\n\n# 块级元素，行内元素\n\n所有元素可以分成两大类：块级元素（block）和行内元素（inline）。\n\n块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据 100% 的宽度。\n\n<p>hello</p>\n<p>world</p>\n\n\n1\n2\n\n\n上面代码中，p元素是块级元素，因此浏览器会将内容分成两行显示。\n\n行内元素默认与其他元素在同一行，不产生换行。比如，span就是行内元素，通常用来为某些文字指定特别的样式。\n\n<span>hello</span>\n<span>world</span>\n\n\n1\n2\n\n\n上面代码中，span元素是行内元素，因此浏览器会将两行内容放在一行显示。\n\n\n# 属性\n\n属性（attribute）是标签的额外信息，使用空格与标签名和其他属性分隔。\n\n<img src="demo.jpg" width="500">\n\n\n1\n\n\n上面代码中，<img>标签有两个属性：src和width。\n\n属性可以用等号指定属性值，比如上例的demo.jpg就是src的属性值。属性值一般放在双引号里面，这不是必需的，但推荐总是使用双引号。\n\n注意，属性名是大小写不敏感的，onclick和onClick是同一个属性。\n\nHTML 提供大量属性，用来定制标签的行为，详细介绍请看《元素的属性》一章。\n\n\n# 基本标签\n\n符合 HTML 语法标准的网页，应该满足下面的基本结构。\n\n<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n  <meta charset="utf-8">\n  <title></title>\n</head>\n<body>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n不管多么复杂的网页，都是从上面这个基本结构衍生出来的。\n\n前面说过，HTML 代码的缩进和换行，对于浏览器不产生作用。所以，上面的代码完全可以写成一行，渲染结果不变。上面这样分行写，只是为了提高可读性。\n\n下面就依次介绍，这个基本结构的主要标签。它们构成了网页的骨架。\n\n\n# <!doctype>\n\n网页的第一个标签通常是<!doctype>，表示文档类型，告诉浏览器如何解析网页。\n\n一般来说，只要像下面这样，简单声明doctype为html即可。浏览器就会按照 HTML 5 的规则处理网页。\n\n<!doctype html>\n\n\n1\n\n\n有时，该标签采用完全大写的形式，以便区别于正常的 HTML 标签。因为<!doctype>本质上不是标签，更像一个处理指令。\n\n<!DOCTYPE html>\n\n\n1\n\n\n\n# <html>\n\n<html>标签是网页的顶层容器，即标签树结构的顶层节点，也称为根元素（root element），其他元素都是它的子元素。一个网页只能有一个<html>标签。\n\n该标签的lang属性，表示网页内容默认的语言。\n\n<html lang="zh-CN">\n\n\n1\n\n\n上面代码表示，网页是中文内容。如果是英文内容，zh-CN要改成en。更详细的介绍，参见《元素的属性》一章。\n\n\n# <head>\n\n<head>标签是一个容器标签，用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染提供额外信息。\n\n<!doctype html>\n<html>\n  <head>\n    <title>网页标题</title>\n  </head>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n<head>是<html>的第一个子元素。如果网页不包含<head>，浏览器会自动创建一个。\n\n<head>的子元素一般有下面七个，后文会一一介绍。\n\n * <meta>：设置网页的元数据。\n * <link>：连接外部样式表。\n * <title>：设置网页标题。\n * <style>：放置内嵌的样式表。\n * <script>：引入脚本。\n * <noscript>：浏览器不支持脚本时，所要显示的内容。\n * <base>：设置网页内部相对 URL 的计算基准。\n\n\n# <meta>\n\n<meta>标签用于设置或说明网页的元数据，必须放在<head>里面。一个<meta>标签就是一项元数据，网页可以有多个<meta>。<meta>标签约定放在<head>内容的最前面。\n\n不管什么样的网页，一般都可以放置以下两个<meta>标签。\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <title>Page Title</title>\n</head>\n\n\n1\n2\n3\n4\n5\n\n\n上面例子中，第一个<meta>标签表示网页采用 UTF-8 格式编码，第二个<meta>标签表示网页在手机端可以自动缩放。\n\n<meta>标签有五个属性，下面依次介绍。\n\n（1）charset 属性\n\n<meta>标签的charset属性，用来指定网页的编码方式。该属性非常重要，如果设置得不正确，浏览器可能无法正确解码，就会显示乱码。\n\n<meta charset="utf-8">\n\n\n1\n\n\n上面代码声明，网页为 UTF-8 编码。虽然开发者可以使用其他的编码方式，但正确的做法几乎总是应该采用 UTF-8。\n\n注意，这里声明的编码方式，应该与网页实际的编码方式一致，即声明了utf-8，网页就应该使用 UTF-8 编码保存。如果这里声明了utf-8，实际却是使用另一种编码（比如 GB2312），并不会导致浏览器的自动转码，网页可能会显示为乱码。\n\n（2）name 属性，content 属性\n\n<meta>标签的name属性表示元数据的名字，content属性表示元数据的值。它们合在一起使用，就可以为网页指定一项元数据。\n\n<head>\n  <meta name="description" content="HTML 语言入门">\n  <meta name="keywords" content="HTML,教程">\n  <meta name="author" content="张三">\n</head>\n\n\n1\n2\n3\n4\n5\n\n\n上面代码包含了三个元数据：description是网页内容的描述，keywords是网页内容的关键字，author是网页作者。\n\n元数据有很多种，大部分涉及浏览器内部工作机制，或者特定的使用场景，这里就不一一介绍了。下面是一些例子。\n\n<meta name="viewport" content="width=device-width, initial-scale=1">\n<meta name="application-name" content="Application Name">\n<meta name="generator" content="program">\n<meta name="subject" content="your document\'s subject">\n<meta name="referrer" content="no-referrer">\n\n\n1\n2\n3\n4\n5\n\n\n（3）http-equiv 属性，content 属性\n\n<meta>标签的http-equiv属性用来补充 HTTP 回应的头信息字段，如果服务器发回的 HTTP 回应缺少某个字段，就可以用它补充。<meta>标签的content属性是对应的字段内容。这两个属性与 HTTP 协议相关，属于高级用法，这里就不详细介绍了。\n\n<meta http-equiv="Content-Security-Policy" content="default-src \'self\'">\n\n\n1\n\n\n上面代码设定 HTTP 回应的Content-Security-Policy字段。\n\n下面是另一些例子。\n\n<meta http-equiv="Content-Type" content="Type=text/html; charset=utf-8">\n<meta http-equiv="refresh" content="30">\n<meta http-equiv="refresh" content="30;URL=\'http://website.com\'">\n\n\n1\n2\n3\n\n\n\n# <body>\n\n<body>标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都放置在它的内部。它是<html>的第二个子元素，紧跟在<head>后面。\n\n<html>\n  <head>\n    <title>网页标题</title>\n  </head>\n  <body>\n    <p>hello world</p>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 空格和换行\n\nHTML 语言有自己的空格处理规则。标签内容的头部和尾部的空格，一律忽略不计。\n\n<p>  hello world   </p>\n\n\n1\n\n\n上面代码中，hello前面的空格和world后面的空格，浏览器一律忽略不计。\n\n标签内容里面的多个连续空格（包含制表符\\t），会被浏览器合并成一个。\n\n<p>hello      world</p>\n\n\n1\n\n\n上面代码中，hello与world之间有多个连续空格，浏览器会将它们合并成一个。网页渲染的结果是，hello与world之间只有一个空格。\n\n浏览器还会将文本里面的换行符（\\n）和回车符（\\r），替换成空格。\n\n<p>hello\n\n\n\nworld\n</p>\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，hello与world之间有多个换行，浏览器会将它们替换成空格，然后再将多个空格合并成一个。网页渲染的结果是，hello与world之间有一个空格。\n\n这意味着，HTML 源码里面的换行，不会产生换行效果。\n\n\n# 注释\n\nHTML 代码可以包含注释，浏览器会自动忽略注释。注释以\x3c!--开头，以--\x3e结尾，下面就是一个注释的例子。\n\n\x3c!-- 这是一个注释 --\x3e\n\n\n1\n\n\n注释可以是多行的，并且内部的 HTML 都不再生效了。\n\n\x3c!--\n  <p>hello world</p>\n--\x3e\n\n\n1\n2\n3\n\n\n上面代码是一个注释的区块，内部的代码都是无效的，浏览器不会解析，更不会渲染它们。\n\n注释有助于理解代码的含义，复杂的代码块前面最好加上注释。',normalizedContent:'# 概述\n\nhtml 是网页使用的语言，定义了网页的结构和内容。浏览器访问网站，其实就是从服务器下载 html 代码，然后渲染出网页。\n\nhtml 的全名是“超文本标记语言”（hypertext markup language），上个世纪90年代由欧洲核子研究中心的物理学家蒂姆·伯纳斯-李（tim berners-lee）发明。它的最大特点就是支持超链接，点击链接就可以跳转到其他网页，从而构成了整个互联网。\n\n1999年，html 4.01 版发布，成为广泛接受的 html 标准。2014年，html 5 发布，这是目前正在使用的版本。\n\n浏览器的网页开发，涉及三种技术：html、css 和 javascript。html 语言定义网页的结构和内容，css 样式表定义网页的样式，javascript 语言定义网页与用户的互动行为。html 语言是网页开发的基础，css 和 javascript 都是基于 html 才能生效，即使没有这两者，html 本身也能使用，可以完成基本的内容展示。本教程只介绍 html 语言。\n\n下面就是一个简单网页的 html 源码。\n\n<!doctype html>\n<html lang="zh-cn">\n<head>\n  <meta charset="utf-8">\n  <title>网页标题</title>\n</head>\n<body>\n  <p>hello world</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面这段代码，可以保存成文件hello.html。浏览器打开这个本地文件，就能看到文字“hello world”。\n\n浏览器右键菜单的“查看源码”（view page source），可以展示当前网页的 html 源码。\n\n\n# 基本概念\n\n\n# 标签\n\n网页的 html 代码由许许多多不同的标签（tag）构成。学习 html 语言，就是学习各种标签的用法。\n\n下面就是标签的一个例子。\n\n<title>网页标题</title>\n\n\n1\n\n\n上面代码中，<title>和</title>就是一对标签。\n\n标签用来告诉浏览器，如何处理这段代码。标签的内容就是浏览器所要渲染的、展示在网页上的内容。\n\n标签放在一对尖括号里面（比如<title>），大多数标签都是成对出现的，分成开始标签和结束标签，结束标签在标签名之前加斜杠（比如</title>）。但是，也有一些标签不是成对使用，而是只有开始标签，没有结束标签，比如上一节示例的<meta>标签。\n\n<meta charset="utf-8">\n\n\n1\n\n\n上面代码中，<meta>标签就没有结束标签</meta>。\n\n这种单独使用的标签，通常是因为标签本身就足够完成功能了，不需要标签之间的内容。实际应用中，它们主要用来提示浏览器，做一些特别处理。\n\n标签可以嵌套。\n\n<div><p>hello world</p></div>\n\n\n1\n\n\n上面代码中，<div>标签内部包含了一个<p>标签。\n\n嵌套时，必须保证正确的闭合顺序，不能跨层嵌套，否则会出现意想不到的渲染结果。\n\n<div><p>hello world</div></p>\n\n\n1\n\n\n上面代码就是错误的嵌套，闭合顺序不正确。\n\nhtml 标签名是大小写不敏感，比如<title>和<title>是同一个标签。不过，一般习惯都是使用小写。\n\n另外，html 语言忽略缩进和换行。下面几种写法的渲染结果是一样的。\n\n<title>网页标题</title>\n\n<title>\n  网页标题\n</title>\n\n<title>网页\n标题</title>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n进一步说，整个网页的 html 代码完全可以写成一行，浏览器照样解析，结果完全一样。所以，正式发布网页之前，开发者有时会把源码压缩成一行，以减少传输的字节数。\n\n各种网页的样式效果，比如内容的缩进和换行，主要靠 css 来实现。\n\n\n# 元素\n\n浏览器渲染网页时，会把 html 源码解析成一个标签树，每个标签都是树的一个节点（node）。这种节点就称为网页元素（element）。所以，“标签”和“元素”基本上是同义词，只是使用的场合不一样：标签是从源码角度来看，元素是从编程角度来看，比如<p>标签对应网页的p元素。\n\n嵌套的标签就构成了网页元素的层级关系。\n\n<div><p>hello world</p></div>\n\n\n1\n\n\n上面代码中，div元素内部包含了一个p元素。上层元素又称为“父元素”，下层元素又称为“子元素”，即div是p的父元素，p是div的子元素。\n\n\n# 块级元素，行内元素\n\n所有元素可以分成两大类：块级元素（block）和行内元素（inline）。\n\n块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据 100% 的宽度。\n\n<p>hello</p>\n<p>world</p>\n\n\n1\n2\n\n\n上面代码中，p元素是块级元素，因此浏览器会将内容分成两行显示。\n\n行内元素默认与其他元素在同一行，不产生换行。比如，span就是行内元素，通常用来为某些文字指定特别的样式。\n\n<span>hello</span>\n<span>world</span>\n\n\n1\n2\n\n\n上面代码中，span元素是行内元素，因此浏览器会将两行内容放在一行显示。\n\n\n# 属性\n\n属性（attribute）是标签的额外信息，使用空格与标签名和其他属性分隔。\n\n<img src="demo.jpg" width="500">\n\n\n1\n\n\n上面代码中，<img>标签有两个属性：src和width。\n\n属性可以用等号指定属性值，比如上例的demo.jpg就是src的属性值。属性值一般放在双引号里面，这不是必需的，但推荐总是使用双引号。\n\n注意，属性名是大小写不敏感的，onclick和onclick是同一个属性。\n\nhtml 提供大量属性，用来定制标签的行为，详细介绍请看《元素的属性》一章。\n\n\n# 基本标签\n\n符合 html 语法标准的网页，应该满足下面的基本结构。\n\n<!doctype html>\n<html lang="zh-cn">\n<head>\n  <meta charset="utf-8">\n  <title></title>\n</head>\n<body>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n不管多么复杂的网页，都是从上面这个基本结构衍生出来的。\n\n前面说过，html 代码的缩进和换行，对于浏览器不产生作用。所以，上面的代码完全可以写成一行，渲染结果不变。上面这样分行写，只是为了提高可读性。\n\n下面就依次介绍，这个基本结构的主要标签。它们构成了网页的骨架。\n\n\n# <!doctype>\n\n网页的第一个标签通常是<!doctype>，表示文档类型，告诉浏览器如何解析网页。\n\n一般来说，只要像下面这样，简单声明doctype为html即可。浏览器就会按照 html 5 的规则处理网页。\n\n<!doctype html>\n\n\n1\n\n\n有时，该标签采用完全大写的形式，以便区别于正常的 html 标签。因为<!doctype>本质上不是标签，更像一个处理指令。\n\n<!doctype html>\n\n\n1\n\n\n\n# <html>\n\n<html>标签是网页的顶层容器，即标签树结构的顶层节点，也称为根元素（root element），其他元素都是它的子元素。一个网页只能有一个<html>标签。\n\n该标签的lang属性，表示网页内容默认的语言。\n\n<html lang="zh-cn">\n\n\n1\n\n\n上面代码表示，网页是中文内容。如果是英文内容，zh-cn要改成en。更详细的介绍，参见《元素的属性》一章。\n\n\n# <head>\n\n<head>标签是一个容器标签，用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染提供额外信息。\n\n<!doctype html>\n<html>\n  <head>\n    <title>网页标题</title>\n  </head>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n\n\n<head>是<html>的第一个子元素。如果网页不包含<head>，浏览器会自动创建一个。\n\n<head>的子元素一般有下面七个，后文会一一介绍。\n\n * <meta>：设置网页的元数据。\n * <link>：连接外部样式表。\n * <title>：设置网页标题。\n * <style>：放置内嵌的样式表。\n * <script>：引入脚本。\n * <noscript>：浏览器不支持脚本时，所要显示的内容。\n * <base>：设置网页内部相对 url 的计算基准。\n\n\n# <meta>\n\n<meta>标签用于设置或说明网页的元数据，必须放在<head>里面。一个<meta>标签就是一项元数据，网页可以有多个<meta>。<meta>标签约定放在<head>内容的最前面。\n\n不管什么样的网页，一般都可以放置以下两个<meta>标签。\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <title>page title</title>\n</head>\n\n\n1\n2\n3\n4\n5\n\n\n上面例子中，第一个<meta>标签表示网页采用 utf-8 格式编码，第二个<meta>标签表示网页在手机端可以自动缩放。\n\n<meta>标签有五个属性，下面依次介绍。\n\n（1）charset 属性\n\n<meta>标签的charset属性，用来指定网页的编码方式。该属性非常重要，如果设置得不正确，浏览器可能无法正确解码，就会显示乱码。\n\n<meta charset="utf-8">\n\n\n1\n\n\n上面代码声明，网页为 utf-8 编码。虽然开发者可以使用其他的编码方式，但正确的做法几乎总是应该采用 utf-8。\n\n注意，这里声明的编码方式，应该与网页实际的编码方式一致，即声明了utf-8，网页就应该使用 utf-8 编码保存。如果这里声明了utf-8，实际却是使用另一种编码（比如 gb2312），并不会导致浏览器的自动转码，网页可能会显示为乱码。\n\n（2）name 属性，content 属性\n\n<meta>标签的name属性表示元数据的名字，content属性表示元数据的值。它们合在一起使用，就可以为网页指定一项元数据。\n\n<head>\n  <meta name="description" content="html 语言入门">\n  <meta name="keywords" content="html,教程">\n  <meta name="author" content="张三">\n</head>\n\n\n1\n2\n3\n4\n5\n\n\n上面代码包含了三个元数据：description是网页内容的描述，keywords是网页内容的关键字，author是网页作者。\n\n元数据有很多种，大部分涉及浏览器内部工作机制，或者特定的使用场景，这里就不一一介绍了。下面是一些例子。\n\n<meta name="viewport" content="width=device-width, initial-scale=1">\n<meta name="application-name" content="application name">\n<meta name="generator" content="program">\n<meta name="subject" content="your document\'s subject">\n<meta name="referrer" content="no-referrer">\n\n\n1\n2\n3\n4\n5\n\n\n（3）http-equiv 属性，content 属性\n\n<meta>标签的http-equiv属性用来补充 http 回应的头信息字段，如果服务器发回的 http 回应缺少某个字段，就可以用它补充。<meta>标签的content属性是对应的字段内容。这两个属性与 http 协议相关，属于高级用法，这里就不详细介绍了。\n\n<meta http-equiv="content-security-policy" content="default-src \'self\'">\n\n\n1\n\n\n上面代码设定 http 回应的content-security-policy字段。\n\n下面是另一些例子。\n\n<meta http-equiv="content-type" content="type=text/html; charset=utf-8">\n<meta http-equiv="refresh" content="30">\n<meta http-equiv="refresh" content="30;url=\'http://website.com\'">\n\n\n1\n2\n3\n\n\n\n# <body>\n\n<body>标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都放置在它的内部。它是<html>的第二个子元素，紧跟在<head>后面。\n\n<html>\n  <head>\n    <title>网页标题</title>\n  </head>\n  <body>\n    <p>hello world</p>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 空格和换行\n\nhtml 语言有自己的空格处理规则。标签内容的头部和尾部的空格，一律忽略不计。\n\n<p>  hello world   </p>\n\n\n1\n\n\n上面代码中，hello前面的空格和world后面的空格，浏览器一律忽略不计。\n\n标签内容里面的多个连续空格（包含制表符\\t），会被浏览器合并成一个。\n\n<p>hello      world</p>\n\n\n1\n\n\n上面代码中，hello与world之间有多个连续空格，浏览器会将它们合并成一个。网页渲染的结果是，hello与world之间只有一个空格。\n\n浏览器还会将文本里面的换行符（\\n）和回车符（\\r），替换成空格。\n\n<p>hello\n\n\n\nworld\n</p>\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，hello与world之间有多个换行，浏览器会将它们替换成空格，然后再将多个空格合并成一个。网页渲染的结果是，hello与world之间有一个空格。\n\n这意味着，html 源码里面的换行，不会产生换行效果。\n\n\n# 注释\n\nhtml 代码可以包含注释，浏览器会自动忽略注释。注释以\x3c!--开头，以--\x3e结尾，下面就是一个注释的例子。\n\n\x3c!-- 这是一个注释 --\x3e\n\n\n1\n\n\n注释可以是多行的，并且内部的 html 都不再生效了。\n\n\x3c!--\n  <p>hello world</p>\n--\x3e\n\n\n1\n2\n3\n\n\n上面代码是一个注释的区块，内部的代码都是无效的，浏览器不会解析，更不会渲染它们。\n\n注释有助于理解代码的含义，复杂的代码块前面最好加上注释。',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"URL简介",frontmatter:{title:"URL简介",date:"2022-11-30T11:59:53.000Z",permalink:"/pages/e4644a/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/01.HTML/01.ruanyf/02.URL%E7%AE%80%E4%BB%8B.html",relativePath:"01.前端基础/01.HTML/01.ruanyf/02.URL简介.md",key:"v-07469028",path:"/pages/e4644a/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:3,title:"协议",slug:"协议",normalizedTitle:"协议",charIndex:377},{level:3,title:"主机",slug:"主机",normalizedTitle:"主机",charIndex:692},{level:3,title:"端口",slug:"端口",normalizedTitle:"端口",charIndex:802},{level:3,title:"路径",slug:"路径",normalizedTitle:"路径",charIndex:969},{level:3,title:"查询参数",slug:"查询参数",normalizedTitle:"查询参数",charIndex:1298},{level:3,title:"锚点",slug:"锚点",normalizedTitle:"锚点",charIndex:1546},{level:2,title:"URL 字符",slug:"url-字符",normalizedTitle:"url 字符",charIndex:1659},{level:2,title:"绝对 URL 和相对 URL",slug:"绝对-url-和相对-url",normalizedTitle:"绝对 url 和相对 url",charIndex:2696},{level:2,title:"<base>",slug:"base",normalizedTitle:"<base>",charIndex:3409}],headersStr:"概述 协议 主机 端口 路径 查询参数 锚点 URL 字符 绝对 URL 和相对 URL <base>",content:'# 概述\n\nURL 是“统一资源定位符”（Uniform Resource Locator）的首字母缩写，中文译为“网址”，表示各种资源的互联网地址。下面就是一个典型的 URL。\n\nhttps://www.example.com/path/index.html\n\n\n1\n\n\n所谓资源，可以简单理解成各种可以通过互联网访问的文件，比如网页、图像、音频、视频、JavaScript 脚本等等。只有知道了它们的 URL，才能在互联网上获取它们。\n\n只要资源可以通过互联网访问，它就必然有对应的 URL。一个 URL 对应一个资源，但是同一个资源可能对应多个 URL。\n\nURL 是互联网的基础。互联网之所以“互联”，就是因为网页可以通过“链接”（link），包含其他 URL。用户只要点击，就可以从一个 URL 跳转到另一个 URL，前往不同的网站。\n\n\n# 协议\n\n协议（scheme）是浏览器请求服务器资源的方法，上例是https://的部分，表示使用 HTTPS 协议。\n\n互联网支持多种协议，必须指明网址使用哪一种协议，默认是 HTTP 协议。也就是说，如果省略协议，直接在浏览器地址栏输入www.example.com，那么浏览器默认会访问http://www.example.com。HTTPS 是 HTTP 的加密版本，出于安全考虑，越来越多的网站使用这个协议。\n\nHTTP 和 HTTPS 的协议名称后面，紧跟着一个冒号和两个斜杠（://）。其他协议不一定如此，邮件地址协议mailto:的协议名后面只有一个冒号，比如mailto:foo@example.com。\n\n\n# 主机\n\n主机（host）是资源所在的网站名或服务器的名字，又称为域名。上例的主机是www.example.com。\n\n有些主机没有域名，只有 IP 地址，比如192.168.2.15。这种情况常常出现在局域网。\n\n\n# 端口\n\n同一个域名下面可能同时包含多个网站，它们之间通过端口（port）区分。“端口”就是一个整数，可以简单理解成，访问者告诉服务器，想要访问哪一个网站。HTTP 协议的默认端口是80，如果省略了这个参数，服务器就会返回80端口的网站。\n\n端口紧跟在域名后面，两者之间使用冒号分隔，比如www.example.com:80。\n\n\n# 路径\n\n路径（path）是资源在网站的位置。比如，/path/index.html这个路径，指向网站的/path子目录下面的网页文件index.html。\n\n互联网的早期，路径是真实存在的物理位置。现在由于服务器可以模拟这些位置，所以路径只是虚拟位置。\n\n路径可能只包含目录，不包含文件名，比如/foo/，甚至结尾的斜杠都可以省略。这时，服务器通常会默认跳转到该目录里面的index.html文件（即等同于请求/foo/index.html），但也可能有其他的处理（比如列出目录里面的所有文件），这取决于服务器的设置。一般来说，访问www.example.com这个网址，很可能返回的是网页文件www.example.com/index.html。\n\n\n# 查询参数\n\n查询参数（parameter）是提供给服务器的额外信息。参数的位置是在路径后面，两者之间使用?分隔，上例是?key1=value1&key2=value2。\n\n查询参数可以有一组或多组。每组参数都是键值对（key-value pair）的形式，同时具有键名(key)和键值(value)，它们之间使用等号（=）连接。比如，key1=value就是一个键值对，key1是键名，value1是键值。\n\n多组参数之间使用&连接，比如key1=value1&key2=value2。\n\n\n# 锚点\n\n锚点（anchor）是网页内部的定位点，使用#加上锚点名称，放在网址的最后，比如#anchor。浏览器加载页面以后，会自动滚动到锚点所在的位置。\n\n锚点名称通过网页元素的id属性命名，详见《元素的属性》一章。\n\n\n# URL 字符\n\nURL 的各个组成部分，只能使用以下这些字符。\n\n * 26个英语字母（包括大写和小写）\n * 10个阿拉伯数字\n * 连词号（-）\n * 句点（.）\n * 下划线（_）\n\n此外，还有18个字符属于 URL 的保留字符，只能在给定的位置出现。比如，查询参数的开头是问号（?），也就是说，问号只能出现查询参数的开头，出现在其他位置就是非法的，会导致网址解析错误。网址的其他部分如果要使用这些保留字符，必须使用它们的转义形式。\n\nURL 字符转义的方法是，在这些字符的十六进制 ASCII 码前面加上百分号（%）。下面是这18个字符及其转义形式。\n\n * !：%21\n * #：%23\n * $：%24\n * &：%26\n * \'：%27\n * (：%28\n * )：%29\n * *：%2A\n * +：%2B\n * ,：%2C\n * /：%2F\n * :：%3A\n * ;：%3B\n * =：%3D\n * ?：%3F\n * @：%40\n * [：%5B\n * ]：%5D\n\n举例来说，有一个网页的 URL 是foo?bar.html，即文件里面包含一个问号，那么需要写成foo%3Fbar.html。\n\nURL 的合法字符，其实也可以采用这种转义方法，但是不建议使用。比如，字母a的十六进制 ASCII 码是61，转义形式后就是%61。因此，www.apple.com又可以写成www.%61pple.com，浏览器一样识别。\n\n值得注意的是，空格的转义形式是%20。对于那些包含空格的文件名，这个转义是必须的。\n\n既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在 URL 里面，比如www.example.com/中国.html，浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制 UTF-8 编码，每两位算作一组，然后每组头部添加百分号（%）。\n\n举例来说，汉字中的 UTF-8 十六进制编码是e4b8ad，每两个字符一组，URL 转义后就为%e4%b8%ad。也就是说，URL 里面凡是有汉字中的地方，都要写成%e4%b8%ad。因此，访问www.example.com/中国.html这个网址，需要写成下面的样子。\n\nwww.example.com/%e4%b8%ad%e5%9b%bd.html\n\n\n1\n\n\n上面代码中，中的转义形式是%e4%b8%ad，国是%e5%9b%bd。\n\n\n# 绝对 URL 和相对 URL\n\nURL 分成两种：绝对 URL 和相对 URL。\n\n绝对 URL 指的是，只靠 URL 本身就能确定资源的位置。这意味着，URL 必须带有资源的完整信息，包含协议、主机、路径等部分。前面的例子都是绝对 URL。\n\n相对 URL 指的是，URL 不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。比如，当前网页的 URL 是https://www.example.com/path/index.html，该网页上面有一个资源，URL 指向a.html，这个就是相对 URL。因为只知道a.html，并不能定位资源。浏览器假定，a.html与当前网址在同一个子目录下面，从而得到绝对 URL https://www.example.com/path/a.html。\n\n相对 URL 如果以斜杠（/）开头，就表示网站的根目录。否则，必须以当前目录为起点，推算资源的位置。比如，相对 URL /foo/bar.html表示网站根目录的子目录foo，foo/bar.html表示在当前目录的foo子目录。\n\nURL 还可以使用两个特殊简写，表示特定位置。\n\n * .：表示当前目录，比如./a.html（当前目录下的a.html文件）\n * ..：表示上级目录，比如../a.html（上级目录下的a.html文件）\n\n这两种简写可以多个连用，比如../../表示上两级目录。\n\n绝对 URL 也可以使用这两个简写，比如www.example.com/./index.html等同于www.example.com/index.html，这时.相当于根目录的当前目录，即根目录本身。\n\n\n# <base>\n\n<base>标签指定网页内部的所有相对 URL 的计算基准。整张网页只能有一个<base>标签，而 且只能放在<head>里面。它是单独使用的标签，没有闭合标签，下面是一个例子。\n\n<head>\n<base href="https://www.example.com/files/" target="_blank">\n</head>\n\n\n1\n2\n3\n\n\n<base>标签的href属性给出计算的基准网址，target属性给出如何打开链接的说明（参见《链接》一章）。已知计算基准是https://www.example.com/files/，那么相对 URL foo.html，就可以转成绝对 URL https://www.example.com/files/foo.html。\n\n注意，<base>标签必须至少具有href属性或target属性之一。\n\n<base href="http://foo.com/app/">\n<base target="_blank">\n\n\n1\n2\n\n\n一旦设置了<base>，就对整个网页都有效。如果要改变某个链接的行为，只能用绝对链接替代相对链接。尤其需要注意锚点，这时锚点也是针对<base>计算的，而不是针对当前网页的 URL。',normalizedContent:'# 概述\n\nurl 是“统一资源定位符”（uniform resource locator）的首字母缩写，中文译为“网址”，表示各种资源的互联网地址。下面就是一个典型的 url。\n\nhttps://www.example.com/path/index.html\n\n\n1\n\n\n所谓资源，可以简单理解成各种可以通过互联网访问的文件，比如网页、图像、音频、视频、javascript 脚本等等。只有知道了它们的 url，才能在互联网上获取它们。\n\n只要资源可以通过互联网访问，它就必然有对应的 url。一个 url 对应一个资源，但是同一个资源可能对应多个 url。\n\nurl 是互联网的基础。互联网之所以“互联”，就是因为网页可以通过“链接”（link），包含其他 url。用户只要点击，就可以从一个 url 跳转到另一个 url，前往不同的网站。\n\n\n# 协议\n\n协议（scheme）是浏览器请求服务器资源的方法，上例是https://的部分，表示使用 https 协议。\n\n互联网支持多种协议，必须指明网址使用哪一种协议，默认是 http 协议。也就是说，如果省略协议，直接在浏览器地址栏输入www.example.com，那么浏览器默认会访问http://www.example.com。https 是 http 的加密版本，出于安全考虑，越来越多的网站使用这个协议。\n\nhttp 和 https 的协议名称后面，紧跟着一个冒号和两个斜杠（://）。其他协议不一定如此，邮件地址协议mailto:的协议名后面只有一个冒号，比如mailto:foo@example.com。\n\n\n# 主机\n\n主机（host）是资源所在的网站名或服务器的名字，又称为域名。上例的主机是www.example.com。\n\n有些主机没有域名，只有 ip 地址，比如192.168.2.15。这种情况常常出现在局域网。\n\n\n# 端口\n\n同一个域名下面可能同时包含多个网站，它们之间通过端口（port）区分。“端口”就是一个整数，可以简单理解成，访问者告诉服务器，想要访问哪一个网站。http 协议的默认端口是80，如果省略了这个参数，服务器就会返回80端口的网站。\n\n端口紧跟在域名后面，两者之间使用冒号分隔，比如www.example.com:80。\n\n\n# 路径\n\n路径（path）是资源在网站的位置。比如，/path/index.html这个路径，指向网站的/path子目录下面的网页文件index.html。\n\n互联网的早期，路径是真实存在的物理位置。现在由于服务器可以模拟这些位置，所以路径只是虚拟位置。\n\n路径可能只包含目录，不包含文件名，比如/foo/，甚至结尾的斜杠都可以省略。这时，服务器通常会默认跳转到该目录里面的index.html文件（即等同于请求/foo/index.html），但也可能有其他的处理（比如列出目录里面的所有文件），这取决于服务器的设置。一般来说，访问www.example.com这个网址，很可能返回的是网页文件www.example.com/index.html。\n\n\n# 查询参数\n\n查询参数（parameter）是提供给服务器的额外信息。参数的位置是在路径后面，两者之间使用?分隔，上例是?key1=value1&key2=value2。\n\n查询参数可以有一组或多组。每组参数都是键值对（key-value pair）的形式，同时具有键名(key)和键值(value)，它们之间使用等号（=）连接。比如，key1=value就是一个键值对，key1是键名，value1是键值。\n\n多组参数之间使用&连接，比如key1=value1&key2=value2。\n\n\n# 锚点\n\n锚点（anchor）是网页内部的定位点，使用#加上锚点名称，放在网址的最后，比如#anchor。浏览器加载页面以后，会自动滚动到锚点所在的位置。\n\n锚点名称通过网页元素的id属性命名，详见《元素的属性》一章。\n\n\n# url 字符\n\nurl 的各个组成部分，只能使用以下这些字符。\n\n * 26个英语字母（包括大写和小写）\n * 10个阿拉伯数字\n * 连词号（-）\n * 句点（.）\n * 下划线（_）\n\n此外，还有18个字符属于 url 的保留字符，只能在给定的位置出现。比如，查询参数的开头是问号（?），也就是说，问号只能出现查询参数的开头，出现在其他位置就是非法的，会导致网址解析错误。网址的其他部分如果要使用这些保留字符，必须使用它们的转义形式。\n\nurl 字符转义的方法是，在这些字符的十六进制 ascii 码前面加上百分号（%）。下面是这18个字符及其转义形式。\n\n * !：%21\n * #：%23\n * $：%24\n * &：%26\n * \'：%27\n * (：%28\n * )：%29\n * *：%2a\n * +：%2b\n * ,：%2c\n * /：%2f\n * :：%3a\n * ;：%3b\n * =：%3d\n * ?：%3f\n * @：%40\n * [：%5b\n * ]：%5d\n\n举例来说，有一个网页的 url 是foo?bar.html，即文件里面包含一个问号，那么需要写成foo%3fbar.html。\n\nurl 的合法字符，其实也可以采用这种转义方法，但是不建议使用。比如，字母a的十六进制 ascii 码是61，转义形式后就是%61。因此，www.apple.com又可以写成www.%61pple.com，浏览器一样识别。\n\n值得注意的是，空格的转义形式是%20。对于那些包含空格的文件名，这个转义是必须的。\n\n既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在 url 里面，比如www.example.com/中国.html，浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制 utf-8 编码，每两位算作一组，然后每组头部添加百分号（%）。\n\n举例来说，汉字中的 utf-8 十六进制编码是e4b8ad，每两个字符一组，url 转义后就为%e4%b8%ad。也就是说，url 里面凡是有汉字中的地方，都要写成%e4%b8%ad。因此，访问www.example.com/中国.html这个网址，需要写成下面的样子。\n\nwww.example.com/%e4%b8%ad%e5%9b%bd.html\n\n\n1\n\n\n上面代码中，中的转义形式是%e4%b8%ad，国是%e5%9b%bd。\n\n\n# 绝对 url 和相对 url\n\nurl 分成两种：绝对 url 和相对 url。\n\n绝对 url 指的是，只靠 url 本身就能确定资源的位置。这意味着，url 必须带有资源的完整信息，包含协议、主机、路径等部分。前面的例子都是绝对 url。\n\n相对 url 指的是，url 不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。比如，当前网页的 url 是https://www.example.com/path/index.html，该网页上面有一个资源，url 指向a.html，这个就是相对 url。因为只知道a.html，并不能定位资源。浏览器假定，a.html与当前网址在同一个子目录下面，从而得到绝对 url https://www.example.com/path/a.html。\n\n相对 url 如果以斜杠（/）开头，就表示网站的根目录。否则，必须以当前目录为起点，推算资源的位置。比如，相对 url /foo/bar.html表示网站根目录的子目录foo，foo/bar.html表示在当前目录的foo子目录。\n\nurl 还可以使用两个特殊简写，表示特定位置。\n\n * .：表示当前目录，比如./a.html（当前目录下的a.html文件）\n * ..：表示上级目录，比如../a.html（上级目录下的a.html文件）\n\n这两种简写可以多个连用，比如../../表示上两级目录。\n\n绝对 url 也可以使用这两个简写，比如www.example.com/./index.html等同于www.example.com/index.html，这时.相当于根目录的当前目录，即根目录本身。\n\n\n# <base>\n\n<base>标签指定网页内部的所有相对 url 的计算基准。整张网页只能有一个<base>标签，而 且只能放在<head>里面。它是单独使用的标签，没有闭合标签，下面是一个例子。\n\n<head>\n<base href="https://www.example.com/files/" target="_blank">\n</head>\n\n\n1\n2\n3\n\n\n<base>标签的href属性给出计算的基准网址，target属性给出如何打开链接的说明（参见《链接》一章）。已知计算基准是https://www.example.com/files/，那么相对 url foo.html，就可以转成绝对 url https://www.example.com/files/foo.html。\n\n注意，<base>标签必须至少具有href属性或target属性之一。\n\n<base href="http://foo.com/app/">\n<base target="_blank">\n\n\n1\n2\n\n\n一旦设置了<base>，就对整个网页都有效。如果要改变某个链接的行为，只能用绝对链接替代相对链接。尤其需要注意锚点，这时锚点也是针对<base>计算的，而不是针对当前网页的 url。',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"元素属性",frontmatter:{title:"元素属性",date:"2022-11-30T12:19:22.000Z",permalink:"/pages/ec6dce/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/01.HTML/01.ruanyf/03.%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7.html",relativePath:"01.前端基础/01.HTML/01.ruanyf/03.元素属性.md",key:"v-555f7cfd",path:"/pages/ec6dce/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"全局属性",slug:"全局属性",normalizedTitle:"全局属性",charIndex:427},{level:3,title:"id",slug:"id",normalizedTitle:"id",charIndex:537},{level:3,title:"class",slug:"class",normalizedTitle:"class",charIndex:868},{level:3,title:"title",slug:"title",normalizedTitle:"title",charIndex:1117},{level:3,title:"tabindex",slug:"tabindex",normalizedTitle:"tabindex",charIndex:1319},{level:3,title:"accesskey",slug:"accesskey",normalizedTitle:"accesskey",charIndex:2136},{level:3,title:"style",slug:"style",normalizedTitle:"style",charIndex:2496},{level:3,title:"hidden",slug:"hidden",normalizedTitle:"hidden",charIndex:2603},{level:3,title:"lang，dir",slug:"lang-dir",normalizedTitle:"lang，dir",charIndex:2782},{level:3,title:"contenteditable",slug:"contenteditable",normalizedTitle:"contenteditable",charIndex:3162},{level:3,title:"spellcheck",slug:"spellcheck",normalizedTitle:"spellcheck",charIndex:3428},{level:3,title:"data-属性",slug:"data-属性",normalizedTitle:"data-属性",charIndex:3855},{level:3,title:"事件处理属性",slug:"事件处理属性",normalizedTitle:"事件处理属性",charIndex:4402}],headersStr:"简介 全局属性 id class title tabindex accesskey style hidden lang，dir contenteditable spellcheck data-属性 事件处理属性",content:'# 简介\n\n网页元素的属性（attribute）可以定制元素的行为，不同的属性会导致元素有不同的行为。元素属性的写法是 HTML 标签内部的“键值对”。\n\n<html lang="en">\n\n\n1\n\n\n上面代码中，<html>标签内部的键值对lang="en"，就称为html元素的属性。属性名为lang，属性值为en。\n\n属性名与标签名一样，不区分大小写，lang和LANG是同一个属性。\n\n属性名与属性值之间，通过等号=连接。属性值可以放在单引号或双引号之中，建议统一使用双引号。某些属性值可以不使用引号，但是建议不要这样写。\n\n有些属性是布尔属性，即属性值是一个布尔值，只有“打开”和“关闭”两种情况。这时属性值可以省略，只要添加了属性名，就表示打开该属性。\n\n<input type="text" required>\n\n\n1\n\n\n上面代码中，required就是<input>标签的布尔属性。如果加上这个属性，就表示打开，没有就是关闭。\n\n\n# 全局属性\n\n全局属性（global attributes）是所有元素都可以使用的属性。也就是说，你可以把下面的属性，加在任意一个网页元素上面，不过有些属性对某些元素可能不产生意义。\n\n下面是一些常见的全局属性。\n\n\n# id\n\nid属性是元素在网页内的唯一标识符。比如，网页可能包含多个<p>标签，id属性可以指定每个<p>标签的唯一标识符。\n\n<p id="p1"></p>\n<p id="p2"></p>\n<p id="p3"></p>\n\n\n1\n2\n3\n\n\n上面代码中，三个<p>标签具有不同的id属性，因此可以区分。\n\nid属性的值必须是全局唯一的，同一个页面不能有两个相同的id属性。另外，id属性的值不得包含空格。\n\nid属性的值还可以在最前面加上#，放到 URL 中作为锚点，定位到该元素在网页内部的位置。比如，用户访问网址https://foo.com/index.html#bar的时候，浏览器会自动将页面滚动到bar的位置，让用户第一眼就看到这部分内容。\n\n\n# class\n\nclass属性用来对网页元素进行分类。如果不同元素的class属性值相同，就表示它们是一类的。\n\n<p class="para"></p>\n<p></p>\n<p class="para"></p>\n\n\n1\n2\n3\n\n\n上面代码中，第一个<p>和第三个<p>是一类，因为它们的class属性相同。\n\n元素可以同时具有多个 class，它们之间使用空格分隔。\n\n<p class="p1 p2 p3"></p>\n\n\n1\n\n\n上面的p元素同时具有p1、p2、p3三个 class。\n\n\n# title\n\ntitle属性用来为元素添加附加说明。大多数浏览器中，鼠标悬浮在元素上面时，会将title属性值作为浮动提示，显示出来。\n\n<div title="版权说明">\n  <p>本站内容使用创意共享许可证，可以自由使用。</p>\n</div>\n\n\n1\n2\n3\n\n\n上面代码中，title属性解释了这一块内容的目的。鼠标悬停在上面时，浏览器会显示一个浮动提示。一旦鼠标移开，提示就会消失。\n\n\n# tabindex\n\n网页通常使用鼠标操作，但是某些情况下，用户可能希望使用键盘，或者只有键盘可以用。因此，浏览器允许使用 Tab 键，遍历网页元素。也就是说，只要不停按下 Tab 键，网页的焦点就会从一个元素转移到另一个元素，选定焦点元素以后，就可以进行下一步操作，比如按下回车键访问某个链接，或者直接在某个输入框输入文字。\n\n这里就有一个问题，按下 Tab 键的时候，浏览器怎么知道跳到哪一个元素。HTML 提供了tabindex属性，解决这个问题。它的名字的含义，就是 Tab 的顺序（index）。\n\ntabindex属性的值是一个整数，表示用户按下 Tab 键的时候，网页焦点转移的顺序。不同的属性值有不同的含义。\n\n * 负整数：该元素可以获得焦点（比如使用 JavaScript 的focus()方法），但不参与 Tab 键对网页元素的遍历。这个值通常是-1。\n * 0：该元素参与 Tab 键的遍历，顺序由浏览器指定，通常是按照其在网页里面出现的位置。\n * 正整数：网页元素按照从小到大的顺序（1、2、3、……），参与 Tab 键的遍历。如果多个元素的tabindex属性相同，则按照在网页源码里面出现的顺序遍历。\n\n<p tabindex="0">这段文字可以获得焦点。</p>\n\n\n1\n\n\n上面代码中，<p>标签的tabindex为0，意味着该元素可以获得焦点，并且也可以被 Tab 键遍历，顺序由其在源码里面的位置决定。\n\n一般来说，tabindex属性最好都设成0，按照自然顺序进行遍历，这样比较符合用户的预期，除非网页有特殊布局。如果网页所有元素都没有设置tabindex，那么只有那些默认可以遍历的元素（比如链接、输入框等）才能参与 Tab 键的遍历，顺序由其在源码的位置决定。因此实际上，只有那些无法获得焦点的元素（比如<span>、<div>）需要参与遍历，才有必要设置tabindex属性。\n\n\n# accesskey\n\naccesskey属性指定网页元素获得焦点的快捷键，该属性的值必须是单个的可打印字符。只要按下快捷键，该元素就会得到焦点。\n\n<button accesskey="s">提交</button>\n\n\n1\n\n\n上面代码中，<button>的快捷键是s，按下快捷键，该元素就得到了焦点。\n\naccesskey属性的字符键，必须配合功能键，一起按下才会生效。也就是说，快捷键是“功能键 + 字符键”的组合。不同的浏览器与不同的操作系统，功能键都不一样。比如，Chrome 浏览器在 Windows 系统和 Linux 系统的快捷键是Alt + 字符键，在 Mac 系统的快捷键是Ctrl + Alt + 字符键。\n\n注意，accesskey如果跟操作系统或浏览器级别的快捷键有冲突，这时不会生效。\n\n\n# style\n\nstyle属性用来指定当前元素的 CSS 样式。具体的设置，请看 CSS 教程。\n\n<p style="color: red;">hello</p>\n\n\n1\n\n\n上面代码指定文字颜色为红色。\n\n\n# hidden\n\nhidden是一个布尔属性，表示当前的网页元素不再跟页面相关，因此浏览器不会渲染这个元素，所以就不会在网页中看到它。\n\n<p hidden>本句不会显示在页面上。</p>\n\n\n1\n\n\n上面代码中，这个p元素不会出现在网页上。\n\n注意，CSS 的可见性设置，高于hidden属性。如果 CSS 设为该元素可见，hidden属性将无效。\n\n\n# lang，dir\n\nlang属性指定网页元素使用的语言。\n\n<p lang="en">hello</p>\n<p lang="zh">你好</p>\n\n\n1\n2\n\n\n上面代码中，第一个<p>的lang属性，表示使用英语，第二个<p>的lang属性，表示使用中文。\n\nlang属性的值，必须符合 BCP47 的标准。下面是一些常见的语言代码。\n\n * zh：中文\n * zh-Hans：简体中文\n * zh-Hant：繁体中文\n * en：英语\n * en-US：美国英语\n * en-GB：英国英语\n * es：西班牙语\n * fr：法语\n\ndir属性表示文字的阅读方向，有三个可能的值。\n\n * ltr：从左到右阅读，比如英语。\n * rtl：从右到左阅读，阿拉伯语、波斯语、希伯来语都属于这一类。\n * auto：浏览器根据内容的解析结果，自行决定。\n\n\n# contenteditable\n\nHTML 网页的内容默认是用户不能编辑，contenteditable属性允许用户修改内容。它有两个可能的值。\n\n * true或空字符串：内容可以编辑\n * false：不可以编辑\n\n<p contenteditable="true">\n鼠标点击，本句内容可修改。\n</p>\n\n\n1\n2\n3\n\n\n上面代码中，鼠标单击句子，就可以进入编辑状态，用户可以改变句子的内容。当然，除非提交到服务器，否则刷新页面还是显示原来的内容。\n\n该属性是枚举属性，不是布尔属性，规范的写法是最好带上属性值。\n\n\n# spellcheck\n\n浏览器一般会自带拼写检查功能，编辑内容时，拼错的单词下面会显示红色的波浪线。spellcheck属性就表示，是否打开拼写检查。\n\n它有两个可能的值。\n\n * true：打开拼写检查\n * false：关闭拼写检查\n\n<p contenteditable="true" spellcheck="true">\n英语单词 separate 容易写错成 seperate。\n</p>\n\n\n1\n2\n3\n\n\n上面代码中，seperate下面会有提示，表示拼错了。\n\n注意，由于该属性只在编辑时生效，所以这个例子必须加上contenteditable属性，表示本段内容可编辑。鼠标单击就可以进入编辑状态，这时才会看到拼写提示。不可编辑的状态下，拼写错误是不提示显示的。对于那些不可编辑的元素，该属性无效。\n\n这个属性看上去像布尔属性，但是其实是枚举属性，所以最好不要省略它的值。如果没有指定这个属性，浏览器将自行决定是否打开拼写检查。\n\n\n# data-属性\n\ndata-属性用于放置自定义数据。如果没有其他属性或元素合适放置数据，就可以放在data-属性。\n\n<a href="#" class="tooltip" data-tip="this is the tip!">链接</a>\n\n\n1\n\n\n上面代码中，data-tip用于放置链接的提示文字。\n\n由于data-属性只能通过 CSS 或 JavaScript 利用，所以这里不做详细介绍了。下面是 CSS 的例子。\n\n/* HTML 代码如下\n<div data-role="mobile">\nMobile only content\n</div>\n*/\ndiv[data-role="mobile"] {\n  display:none;\n}\n\n/* HTML 代码如下\n<div class="test" data-content="This is the div content">test</div>\n*/\n.test {\n  display: inline-block;\n}\n.test:after {\n  content: attr(data-content);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 事件处理属性\n\n除了上面这些属性，全局属性还包括事件处理属性（event handler），用来响应用户的动作。这些属性的值都是 JavaScript 代码，请参考 JavaScript 教程，这里只列出这些属性的名单。\n\n> onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting',normalizedContent:'# 简介\n\n网页元素的属性（attribute）可以定制元素的行为，不同的属性会导致元素有不同的行为。元素属性的写法是 html 标签内部的“键值对”。\n\n<html lang="en">\n\n\n1\n\n\n上面代码中，<html>标签内部的键值对lang="en"，就称为html元素的属性。属性名为lang，属性值为en。\n\n属性名与标签名一样，不区分大小写，lang和lang是同一个属性。\n\n属性名与属性值之间，通过等号=连接。属性值可以放在单引号或双引号之中，建议统一使用双引号。某些属性值可以不使用引号，但是建议不要这样写。\n\n有些属性是布尔属性，即属性值是一个布尔值，只有“打开”和“关闭”两种情况。这时属性值可以省略，只要添加了属性名，就表示打开该属性。\n\n<input type="text" required>\n\n\n1\n\n\n上面代码中，required就是<input>标签的布尔属性。如果加上这个属性，就表示打开，没有就是关闭。\n\n\n# 全局属性\n\n全局属性（global attributes）是所有元素都可以使用的属性。也就是说，你可以把下面的属性，加在任意一个网页元素上面，不过有些属性对某些元素可能不产生意义。\n\n下面是一些常见的全局属性。\n\n\n# id\n\nid属性是元素在网页内的唯一标识符。比如，网页可能包含多个<p>标签，id属性可以指定每个<p>标签的唯一标识符。\n\n<p id="p1"></p>\n<p id="p2"></p>\n<p id="p3"></p>\n\n\n1\n2\n3\n\n\n上面代码中，三个<p>标签具有不同的id属性，因此可以区分。\n\nid属性的值必须是全局唯一的，同一个页面不能有两个相同的id属性。另外，id属性的值不得包含空格。\n\nid属性的值还可以在最前面加上#，放到 url 中作为锚点，定位到该元素在网页内部的位置。比如，用户访问网址https://foo.com/index.html#bar的时候，浏览器会自动将页面滚动到bar的位置，让用户第一眼就看到这部分内容。\n\n\n# class\n\nclass属性用来对网页元素进行分类。如果不同元素的class属性值相同，就表示它们是一类的。\n\n<p class="para"></p>\n<p></p>\n<p class="para"></p>\n\n\n1\n2\n3\n\n\n上面代码中，第一个<p>和第三个<p>是一类，因为它们的class属性相同。\n\n元素可以同时具有多个 class，它们之间使用空格分隔。\n\n<p class="p1 p2 p3"></p>\n\n\n1\n\n\n上面的p元素同时具有p1、p2、p3三个 class。\n\n\n# title\n\ntitle属性用来为元素添加附加说明。大多数浏览器中，鼠标悬浮在元素上面时，会将title属性值作为浮动提示，显示出来。\n\n<div title="版权说明">\n  <p>本站内容使用创意共享许可证，可以自由使用。</p>\n</div>\n\n\n1\n2\n3\n\n\n上面代码中，title属性解释了这一块内容的目的。鼠标悬停在上面时，浏览器会显示一个浮动提示。一旦鼠标移开，提示就会消失。\n\n\n# tabindex\n\n网页通常使用鼠标操作，但是某些情况下，用户可能希望使用键盘，或者只有键盘可以用。因此，浏览器允许使用 tab 键，遍历网页元素。也就是说，只要不停按下 tab 键，网页的焦点就会从一个元素转移到另一个元素，选定焦点元素以后，就可以进行下一步操作，比如按下回车键访问某个链接，或者直接在某个输入框输入文字。\n\n这里就有一个问题，按下 tab 键的时候，浏览器怎么知道跳到哪一个元素。html 提供了tabindex属性，解决这个问题。它的名字的含义，就是 tab 的顺序（index）。\n\ntabindex属性的值是一个整数，表示用户按下 tab 键的时候，网页焦点转移的顺序。不同的属性值有不同的含义。\n\n * 负整数：该元素可以获得焦点（比如使用 javascript 的focus()方法），但不参与 tab 键对网页元素的遍历。这个值通常是-1。\n * 0：该元素参与 tab 键的遍历，顺序由浏览器指定，通常是按照其在网页里面出现的位置。\n * 正整数：网页元素按照从小到大的顺序（1、2、3、……），参与 tab 键的遍历。如果多个元素的tabindex属性相同，则按照在网页源码里面出现的顺序遍历。\n\n<p tabindex="0">这段文字可以获得焦点。</p>\n\n\n1\n\n\n上面代码中，<p>标签的tabindex为0，意味着该元素可以获得焦点，并且也可以被 tab 键遍历，顺序由其在源码里面的位置决定。\n\n一般来说，tabindex属性最好都设成0，按照自然顺序进行遍历，这样比较符合用户的预期，除非网页有特殊布局。如果网页所有元素都没有设置tabindex，那么只有那些默认可以遍历的元素（比如链接、输入框等）才能参与 tab 键的遍历，顺序由其在源码的位置决定。因此实际上，只有那些无法获得焦点的元素（比如<span>、<div>）需要参与遍历，才有必要设置tabindex属性。\n\n\n# accesskey\n\naccesskey属性指定网页元素获得焦点的快捷键，该属性的值必须是单个的可打印字符。只要按下快捷键，该元素就会得到焦点。\n\n<button accesskey="s">提交</button>\n\n\n1\n\n\n上面代码中，<button>的快捷键是s，按下快捷键，该元素就得到了焦点。\n\naccesskey属性的字符键，必须配合功能键，一起按下才会生效。也就是说，快捷键是“功能键 + 字符键”的组合。不同的浏览器与不同的操作系统，功能键都不一样。比如，chrome 浏览器在 windows 系统和 linux 系统的快捷键是alt + 字符键，在 mac 系统的快捷键是ctrl + alt + 字符键。\n\n注意，accesskey如果跟操作系统或浏览器级别的快捷键有冲突，这时不会生效。\n\n\n# style\n\nstyle属性用来指定当前元素的 css 样式。具体的设置，请看 css 教程。\n\n<p style="color: red;">hello</p>\n\n\n1\n\n\n上面代码指定文字颜色为红色。\n\n\n# hidden\n\nhidden是一个布尔属性，表示当前的网页元素不再跟页面相关，因此浏览器不会渲染这个元素，所以就不会在网页中看到它。\n\n<p hidden>本句不会显示在页面上。</p>\n\n\n1\n\n\n上面代码中，这个p元素不会出现在网页上。\n\n注意，css 的可见性设置，高于hidden属性。如果 css 设为该元素可见，hidden属性将无效。\n\n\n# lang，dir\n\nlang属性指定网页元素使用的语言。\n\n<p lang="en">hello</p>\n<p lang="zh">你好</p>\n\n\n1\n2\n\n\n上面代码中，第一个<p>的lang属性，表示使用英语，第二个<p>的lang属性，表示使用中文。\n\nlang属性的值，必须符合 bcp47 的标准。下面是一些常见的语言代码。\n\n * zh：中文\n * zh-hans：简体中文\n * zh-hant：繁体中文\n * en：英语\n * en-us：美国英语\n * en-gb：英国英语\n * es：西班牙语\n * fr：法语\n\ndir属性表示文字的阅读方向，有三个可能的值。\n\n * ltr：从左到右阅读，比如英语。\n * rtl：从右到左阅读，阿拉伯语、波斯语、希伯来语都属于这一类。\n * auto：浏览器根据内容的解析结果，自行决定。\n\n\n# contenteditable\n\nhtml 网页的内容默认是用户不能编辑，contenteditable属性允许用户修改内容。它有两个可能的值。\n\n * true或空字符串：内容可以编辑\n * false：不可以编辑\n\n<p contenteditable="true">\n鼠标点击，本句内容可修改。\n</p>\n\n\n1\n2\n3\n\n\n上面代码中，鼠标单击句子，就可以进入编辑状态，用户可以改变句子的内容。当然，除非提交到服务器，否则刷新页面还是显示原来的内容。\n\n该属性是枚举属性，不是布尔属性，规范的写法是最好带上属性值。\n\n\n# spellcheck\n\n浏览器一般会自带拼写检查功能，编辑内容时，拼错的单词下面会显示红色的波浪线。spellcheck属性就表示，是否打开拼写检查。\n\n它有两个可能的值。\n\n * true：打开拼写检查\n * false：关闭拼写检查\n\n<p contenteditable="true" spellcheck="true">\n英语单词 separate 容易写错成 seperate。\n</p>\n\n\n1\n2\n3\n\n\n上面代码中，seperate下面会有提示，表示拼错了。\n\n注意，由于该属性只在编辑时生效，所以这个例子必须加上contenteditable属性，表示本段内容可编辑。鼠标单击就可以进入编辑状态，这时才会看到拼写提示。不可编辑的状态下，拼写错误是不提示显示的。对于那些不可编辑的元素，该属性无效。\n\n这个属性看上去像布尔属性，但是其实是枚举属性，所以最好不要省略它的值。如果没有指定这个属性，浏览器将自行决定是否打开拼写检查。\n\n\n# data-属性\n\ndata-属性用于放置自定义数据。如果没有其他属性或元素合适放置数据，就可以放在data-属性。\n\n<a href="#" class="tooltip" data-tip="this is the tip!">链接</a>\n\n\n1\n\n\n上面代码中，data-tip用于放置链接的提示文字。\n\n由于data-属性只能通过 css 或 javascript 利用，所以这里不做详细介绍了。下面是 css 的例子。\n\n/* html 代码如下\n<div data-role="mobile">\nmobile only content\n</div>\n*/\ndiv[data-role="mobile"] {\n  display:none;\n}\n\n/* html 代码如下\n<div class="test" data-content="this is the div content">test</div>\n*/\n.test {\n  display: inline-block;\n}\n.test:after {\n  content: attr(data-content);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 事件处理属性\n\n除了上面这些属性，全局属性还包括事件处理属性（event handler），用来响应用户的动作。这些属性的值都是 javascript 代码，请参考 javascript 教程，这里只列出这些属性的名单。\n\n> onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"字符编码",frontmatter:{title:"字符编码",date:"2022-11-30T17:52:23.000Z",permalink:"/pages/ed5e93/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/01.HTML/01.ruanyf/04.%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html",relativePath:"01.前端基础/01.HTML/01.ruanyf/04.字符编码.md",key:"v-d869d228",path:"/pages/ed5e93/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"字符的数字表示法",slug:"字符的数字表示法",normalizedTitle:"字符的数字表示法",charIndex:289},{level:2,title:"字符的实体表示法",slug:"字符的实体表示法",normalizedTitle:"字符的实体表示法",charIndex:1238}],headersStr:"简介 字符的数字表示法 字符的实体表示法",content:'# 简介\n\n网页包含了大量的文字，浏览器必须知道这些文字的编码方法，才能把文字还原出来。\n\n一般情况下，服务器向浏览器发送 HTML 网页文件时，会通过 HTTP 头信息，声明网页的编码方式。\n\nContent-Type: text/html; charset=UTF-8\n\n\n1\n\n\n上面代码中，HTTP 头信息的Content-Type字段先声明，服务器发送的数据类型是text/html（即 HTML 网页），然后声明网页的文字编码是UTF-8。\n\n网页内部也会再用<meta>标签，再次声明网页的编码。\n\n<meta charset="UTF-8">\n\n\n1\n\n\n\n# 字符的数字表示法\n\n网页可以使用不同语言的编码方式，但是最常用的编码是 UTF-8。UTF-8 编码是 Unicode 字符集的一种表达方式。这个字符集的设计目标是包含世界上的所有字符，目前已经收入了十多万个字符。\n\n每个字符有一个 Unicode 号码，称为码点（code point）。如果知道码点，就能查到这是什么字符。举例来说，英文字母a的码点是十进制的97（十六进制的61），汉字“中”的码点是十进制的20013（十六进制的4e2d）。\n\n由于下面的原因，不是每一个 Unicode 字符都能直接在 HTML 语言里面显示。\n\n（1）不是每个 Unicode 字符都可以打印出来，有些没有可打印形式，比如换行符的码点是十进制的10（十六进制的A），就没有对应的字面形式。\n\n（2）小于号（<）和大于号（>）用来定义 HTML 标签，其他需要用到这两个符号的场合，必须防止它们被解释成标签。\n\n（3）由于 Unicode 字符太多，无法找到一种输入法，可以直接输入所有这些字符。换言之，没有一种键盘，有办法输入所有符号。\n\n（4）网页不允许混合使用多种编码，如果使用 UTF-8 编码的同时，又想插入其他编码的字符，就会很困难。\n\nHTML 为了解决上面这些问题，允许使用 Unicode 码点表示字符，浏览器会自动将码点转成对应的字符。\n\n字符的码点表示法是&#N;（十进制，N代表码点）或者&#xN;（十六进制，N代表码点），比如，字符a可以写成a（十进制）或者a（十六进制），字符中可以写成中（十进制）或者中（十六进制），浏览器会自动转换它们。\n\n<p>hello</p>\n\x3c!-- 等同于 --\x3e\n<p>&#104;&#101;&#108;&#108;&#111;</p>\n\x3c!-- 等同于 --\x3e\n<p>&#x68;&#x65;&#x6c;&#x6c;&#x6f;</p>\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，字符可以直接表示，也可以使用十进制码点或十六进制码点表示。\n\n注意，HTML 标签本身不能使用码点表示，否则浏览器会认为这是所要显示的文本内容，而不是标签。比如，<p>一旦写成<p>或者<p>，浏览器就不再认为这是标签了，而会当作文本内容将其显示为<p>。\n\n\n# 字符的实体表示法\n\n数字表示法的不方便之处，在于必须知道每个字符的码点，很难记忆。为了能够快速输入，HTML 为一些特殊字符，规定了容易记忆的名字，允许通过名字来表示它们，这称为实体表示法（entity）。\n\n实体的写法是&name;，其中的name是字符的名字。下面是其中一些特殊字符，及其对应的实体。\n\n * <：<\n * >：>\n * "："\n * \'：\'\n * &：&\n * ©：©\n * #：#\n * §：§\n * ¥：¥\n * $：$\n * £：£\n * ¢：¢\n * %：%\n * *：$ast;\n * @：@\n * ^：^\n * ±：±\n * 空格：\n\n注意，上面最后一个特殊字符是空格，它也有对应的实体表示法。\n\n字符的数字表示法和实体表示法，都可以表示正常情况无法输入的字符，逃脱了浏览器的限制，所以英语里面称为“escape”，中文翻译为“字符的转义”。',normalizedContent:'# 简介\n\n网页包含了大量的文字，浏览器必须知道这些文字的编码方法，才能把文字还原出来。\n\n一般情况下，服务器向浏览器发送 html 网页文件时，会通过 http 头信息，声明网页的编码方式。\n\ncontent-type: text/html; charset=utf-8\n\n\n1\n\n\n上面代码中，http 头信息的content-type字段先声明，服务器发送的数据类型是text/html（即 html 网页），然后声明网页的文字编码是utf-8。\n\n网页内部也会再用<meta>标签，再次声明网页的编码。\n\n<meta charset="utf-8">\n\n\n1\n\n\n\n# 字符的数字表示法\n\n网页可以使用不同语言的编码方式，但是最常用的编码是 utf-8。utf-8 编码是 unicode 字符集的一种表达方式。这个字符集的设计目标是包含世界上的所有字符，目前已经收入了十多万个字符。\n\n每个字符有一个 unicode 号码，称为码点（code point）。如果知道码点，就能查到这是什么字符。举例来说，英文字母a的码点是十进制的97（十六进制的61），汉字“中”的码点是十进制的20013（十六进制的4e2d）。\n\n由于下面的原因，不是每一个 unicode 字符都能直接在 html 语言里面显示。\n\n（1）不是每个 unicode 字符都可以打印出来，有些没有可打印形式，比如换行符的码点是十进制的10（十六进制的a），就没有对应的字面形式。\n\n（2）小于号（<）和大于号（>）用来定义 html 标签，其他需要用到这两个符号的场合，必须防止它们被解释成标签。\n\n（3）由于 unicode 字符太多，无法找到一种输入法，可以直接输入所有这些字符。换言之，没有一种键盘，有办法输入所有符号。\n\n（4）网页不允许混合使用多种编码，如果使用 utf-8 编码的同时，又想插入其他编码的字符，就会很困难。\n\nhtml 为了解决上面这些问题，允许使用 unicode 码点表示字符，浏览器会自动将码点转成对应的字符。\n\n字符的码点表示法是&#n;（十进制，n代表码点）或者&#xn;（十六进制，n代表码点），比如，字符a可以写成a（十进制）或者a（十六进制），字符中可以写成中（十进制）或者中（十六进制），浏览器会自动转换它们。\n\n<p>hello</p>\n\x3c!-- 等同于 --\x3e\n<p>&#104;&#101;&#108;&#108;&#111;</p>\n\x3c!-- 等同于 --\x3e\n<p>&#x68;&#x65;&#x6c;&#x6c;&#x6f;</p>\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，字符可以直接表示，也可以使用十进制码点或十六进制码点表示。\n\n注意，html 标签本身不能使用码点表示，否则浏览器会认为这是所要显示的文本内容，而不是标签。比如，<p>一旦写成<p>或者<p>，浏览器就不再认为这是标签了，而会当作文本内容将其显示为<p>。\n\n\n# 字符的实体表示法\n\n数字表示法的不方便之处，在于必须知道每个字符的码点，很难记忆。为了能够快速输入，html 为一些特殊字符，规定了容易记忆的名字，允许通过名字来表示它们，这称为实体表示法（entity）。\n\n实体的写法是&name;，其中的name是字符的名字。下面是其中一些特殊字符，及其对应的实体。\n\n * <：<\n * >：>\n * "："\n * \'：\'\n * &：&\n * ©：©\n * #：#\n * §：§\n * ¥：¥\n * $：$\n * £：£\n * ¢：¢\n * %：%\n * *：$ast;\n * @：@\n * ^：^\n * ±：±\n * 空格：\n\n注意，上面最后一个特殊字符是空格，它也有对应的实体表示法。\n\n字符的数字表示法和实体表示法，都可以表示正常情况无法输入的字符，逃脱了浏览器的限制，所以英语里面称为“escape”，中文翻译为“字符的转义”。',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"语义结构",frontmatter:{title:"语义结构",date:"2022-11-30T18:00:54.000Z",permalink:"/pages/d279ea/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/01.HTML/01.ruanyf/05.%E8%AF%AD%E4%B9%89%E7%BB%93%E6%9E%84.html",relativePath:"01.前端基础/01.HTML/01.ruanyf/05.语义结构.md",key:"v-b58f79ec",path:"/pages/d279ea/",headers:[{level:2,title:"网页的语义结构",slug:"网页的语义结构",normalizedTitle:"网页的语义结构",charIndex:2},{level:2,title:"含义",slug:"含义",normalizedTitle:"含义",charIndex:118},{level:2,title:"常用标签",slug:"常用标签",normalizedTitle:"常用标签",charIndex:493},{level:3,title:"<header>",slug:"header",normalizedTitle:"<header>",charIndex:238},{level:3,title:"<footer>",slug:"footer",normalizedTitle:"<footer>",charIndex:346},{level:3,title:"<main>",slug:"main",normalizedTitle:"<main>",charIndex:260},{level:3,title:"<article>",slug:"article",normalizedTitle:"<article>",charIndex:271},{level:3,title:"<aside>",slug:"aside",normalizedTitle:"<aside>",charIndex:1639},{level:3,title:"<section>",slug:"section",normalizedTitle:"<section>",charIndex:2313},{level:3,title:"<nav>",slug:"nav",normalizedTitle:"<nav>",charIndex:1779},{level:3,title:"<h1> ~ <h6>",slug:"h1-h6",normalizedTitle:"<h1> ~ <h6>",charIndex:3106},{level:3,title:"<hgroup>",slug:"hgroup",normalizedTitle:"<hgroup>",charIndex:3611}],headersStr:"网页的语义结构 含义 常用标签 <header> <footer> <main> <article> <aside> <section> <nav> <h1> ~ <h6> <hgroup>",content:'# 网页的语义结构\n\nHTML 标签的名称都带有语义（semantic），使用时应该尽量符合标签的语义，不要用错误语义的标签。语义良好的网页，天然具有良好的结构，对于开发者易读易写，容易维护，也能帮助计算机更好地处理网页内容。\n\n\n# 含义\n\nHTML 标签的一个重要作用，就是声明网页元素的性质，使得用户只看标签，就能了解这个元素的意义，阅读 HTML 源码就能了解网页的大致结构。这被称为 HTML 的语义原则。\n\n下面就是一个典型的语义结构的网页。\n\n<body>\n  <header>页眉</header>\n  <main>\n    <article>\n      <h1>文章标题</h1>\n      <p>文章内容</p>\n    </article>\n  </main>\n  <footer>页尾</footer>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n只看上面的代码，就可以知道，页面分成页眉（<header>）、主体（<main>）、页尾（<footer>）三个部分。\n\n编写 HTML 网页，第一步就是写出语义结构的网页骨架。\n\n\n# 常用标签\n\n\n# <header>\n\n<header>标签可以用在多个场景，既可以表示整个网页的头部，也可以表示一篇文章或者一个区块的头部。\n\n如果用在网页的头部，就称为“页眉”。网站导航和搜索栏通常会放在<header>里面。\n\n<header>\n  <h1>公司名称</h1>\n  <ul>\n    <li><a href="/home">首页</a></li>\n    <li><a href="/about">关于</a></li>\n    <li><a href="/contact">联系</a></li>\n  </ul>\n  <form target="/search">\n    <input name="q" type="search" />\n    <input type="submit" />\n  </form>\n</header>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果<header>用在文章的头部，则可以把文章标题、作者等信息放进去。\n\n<article>\n  <header>\n    <h2>文章标题</h2>\n    <p>张三，发表于2010年1月1日</p>\n  </header>\n</article>\n\n\n1\n2\n3\n4\n5\n6\n\n\n由于<header>可以用在多种场景，所以一个页面可能包含多个<header>，但是一个具体的场景里面只能包含一个，比如网页的页眉只能有一个。另外，<header>里面不能包含另一个<header>或<footer>。\n\n\n# <footer>\n\n<footer>标签表示网页、文章或章节的尾部。如果用于整张网页的尾部，就称为“页尾”，通常包含版权信息或者其他相关信息。\n\n<body>\n  <footer>\n    <p>© 2018 xxx 公司</p>\n  </footer>\n</body>\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，版权信息放在<footer>里面。\n\n<footer>也可以放在文章里面。\n\n<article>\n  <header>\n    <h1>文章标题</h1>\n  </header>\n  <footer>\n    <p>© 禁止转贴</p>\n  </footer>\n</article>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<footer>不能嵌套，即内部不能放置另一个<footer>，也不能放置<header>。\n\n\n# <main>\n\n<main>标签表示页面的主体内容，一个页面只能有一个<main>。\n\n<body>\n<header>页眉</header>\n<main>\n  <article>文章</article>\n</main>\n<aside>侧边栏</aside>\n<footer>页尾</footer>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码就是最典型的页面结构。\n\n注意，<main>是顶层标签，不能放置在<header>、<footer>、<article>、<aside>、<nav>等标签之中。\n\n另外，功能性区块（比如搜索栏）不适合放入<main>，除非当前页面就是搜索页面。\n\n\n# <article>\n\n<article>标签表示页面里面一段完整的内容，即使页面的其他部分不存在，也具有独立使用的意义，通常用来表示一篇文章或者一个论坛帖子。它可以有自己的标题（<h1>到<h6>）。\n\n<article>\n  <h2>文章标题</h2>\n  <p>文章内容</p>\n</article>\n\n\n1\n2\n3\n4\n\n\n一个网页可以包含一个或多个<article>，比如包含多篇文章。\n\n\n# <aside>\n\n<aside>标签用来放置与网页或文章主要内容间接相关的部分。网页级别的<aside>，可以用来放置侧边栏，但不一定就在页面的侧边；文章级别的<aside>，可以用来放置补充信息、评论或注释。\n\n下面是网页级别的<aside>的例子。\n\n<body>\n  <main>主体内容</main>\n  <aside>侧边栏</aside>\n</body>\n\n\n1\n2\n3\n4\n\n\n下面是文章评注的例子。\n\n<p>第一段</p>\n\n<aside>\n  <p>本段是文章的重点。</p>\n</aside>\n\n\n1\n2\n3\n4\n5\n\n\n\n# <section>\n\n<section>标签表示一个含有主题的独立部分，通常用在文档里面表示一个章节，比如<article>可以包含多个<section>。<section>总是多个一起使用，一个页面不能只有一个<section>。\n\n<article>\n  <h1>文章标题</h1>\n  <section>\n    <h2>第一章</h2>\n    <p>...</p>\n  </section>\n  <section>\n    <h2>第二章</h2>\n    <p>...</p>\n  </section>\n</article>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，<article>包含了两个<section>，代表两章。\n\n<section>很适合幻灯片展示的页面，每个<section>代表一个幻灯片。\n\n一般来说，<section>都应该有标题，即包含<h1>~<h6>标签。多个<section>可以放置在同一个<article>里面，一个<section>里面也可能包含多个<article>，这取决于<section>和<article>在当前页面的含义。\n\n\n# <nav>\n\n<nav>标签用于放置页面或文档的导航信息。\n\n<nav>\n  <ol>\n    <li><a href="item-a">商品 A</a></li>\n    <li><a href="item-b">商品 B</a></li>\n    <li>商品 C</li>\n  </ol>\n</nav>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n一般来说，<nav>往往放置在<header>里面，不适合放入<footer>。另外，一个页面可以有多个<nav>，比如一个用于站点导航，另一个用于文章导航。\n\n<nav>里面通常是列表，但也可以放置其他标签。\n\n\n# <h1> ~ <h6>\n\nHTML 提供了6个标签，用来表示文章的标题。按照标题的等级，一共分成六级。\n\n * <h1>：一级标题\n * <h2>：二级标题\n * <h3>：三级标题\n * <h4>：四级标题\n * <h5>：五级标题\n * <h6>：六级标题\n\n<h1>是最高级别的标题，<h6>是最低级别的标题。下一级标题都是上一级标题的子标题，比如，一个<h1>后面可以有多个<h2>，每个<h2>后面又可以有多个<h3>。\n\n<body>\n  <h1>JavaScript 语言介绍</h1>\n    <h2>概述</h2>\n    <h2>基本概念</h2>\n      <h3>网页</h3>\n      <h3>链接</h3>\n    <h2>主要用法</h2>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码，通过章节标题，清晰地表明了文章的主体结构。具体的内容，就可以写在章节标题的下面。\n\n标题不应该越级，比如h1下面直接写h3。虽然这样不会报错，但会导致文章失去清晰的章节结构。\n\n默认情况下，浏览器会粗体显示标题。h1的字号比h2大，h2比h3大，以此类推。\n\n\n# <hgroup>\n\n如果主标题包含多级标题（比如带有副标题），那么可以使用<hgroup>标签，将多级标题放在其中。\n\n<hgroup>\n  <h1>Heading 1</h1>\n  <h2>Subheading 1</h2>\n  <h2>Subheading 2</h2>\n</hgroup>\n\n\n1\n2\n3\n4\n5\n\n\n注意，<hgroup>只能包含<h1>~<h6>，不能包含其他标签。',normalizedContent:'# 网页的语义结构\n\nhtml 标签的名称都带有语义（semantic），使用时应该尽量符合标签的语义，不要用错误语义的标签。语义良好的网页，天然具有良好的结构，对于开发者易读易写，容易维护，也能帮助计算机更好地处理网页内容。\n\n\n# 含义\n\nhtml 标签的一个重要作用，就是声明网页元素的性质，使得用户只看标签，就能了解这个元素的意义，阅读 html 源码就能了解网页的大致结构。这被称为 html 的语义原则。\n\n下面就是一个典型的语义结构的网页。\n\n<body>\n  <header>页眉</header>\n  <main>\n    <article>\n      <h1>文章标题</h1>\n      <p>文章内容</p>\n    </article>\n  </main>\n  <footer>页尾</footer>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n只看上面的代码，就可以知道，页面分成页眉（<header>）、主体（<main>）、页尾（<footer>）三个部分。\n\n编写 html 网页，第一步就是写出语义结构的网页骨架。\n\n\n# 常用标签\n\n\n# <header>\n\n<header>标签可以用在多个场景，既可以表示整个网页的头部，也可以表示一篇文章或者一个区块的头部。\n\n如果用在网页的头部，就称为“页眉”。网站导航和搜索栏通常会放在<header>里面。\n\n<header>\n  <h1>公司名称</h1>\n  <ul>\n    <li><a href="/home">首页</a></li>\n    <li><a href="/about">关于</a></li>\n    <li><a href="/contact">联系</a></li>\n  </ul>\n  <form target="/search">\n    <input name="q" type="search" />\n    <input type="submit" />\n  </form>\n</header>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果<header>用在文章的头部，则可以把文章标题、作者等信息放进去。\n\n<article>\n  <header>\n    <h2>文章标题</h2>\n    <p>张三，发表于2010年1月1日</p>\n  </header>\n</article>\n\n\n1\n2\n3\n4\n5\n6\n\n\n由于<header>可以用在多种场景，所以一个页面可能包含多个<header>，但是一个具体的场景里面只能包含一个，比如网页的页眉只能有一个。另外，<header>里面不能包含另一个<header>或<footer>。\n\n\n# <footer>\n\n<footer>标签表示网页、文章或章节的尾部。如果用于整张网页的尾部，就称为“页尾”，通常包含版权信息或者其他相关信息。\n\n<body>\n  <footer>\n    <p>© 2018 xxx 公司</p>\n  </footer>\n</body>\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，版权信息放在<footer>里面。\n\n<footer>也可以放在文章里面。\n\n<article>\n  <header>\n    <h1>文章标题</h1>\n  </header>\n  <footer>\n    <p>© 禁止转贴</p>\n  </footer>\n</article>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n<footer>不能嵌套，即内部不能放置另一个<footer>，也不能放置<header>。\n\n\n# <main>\n\n<main>标签表示页面的主体内容，一个页面只能有一个<main>。\n\n<body>\n<header>页眉</header>\n<main>\n  <article>文章</article>\n</main>\n<aside>侧边栏</aside>\n<footer>页尾</footer>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码就是最典型的页面结构。\n\n注意，<main>是顶层标签，不能放置在<header>、<footer>、<article>、<aside>、<nav>等标签之中。\n\n另外，功能性区块（比如搜索栏）不适合放入<main>，除非当前页面就是搜索页面。\n\n\n# <article>\n\n<article>标签表示页面里面一段完整的内容，即使页面的其他部分不存在，也具有独立使用的意义，通常用来表示一篇文章或者一个论坛帖子。它可以有自己的标题（<h1>到<h6>）。\n\n<article>\n  <h2>文章标题</h2>\n  <p>文章内容</p>\n</article>\n\n\n1\n2\n3\n4\n\n\n一个网页可以包含一个或多个<article>，比如包含多篇文章。\n\n\n# <aside>\n\n<aside>标签用来放置与网页或文章主要内容间接相关的部分。网页级别的<aside>，可以用来放置侧边栏，但不一定就在页面的侧边；文章级别的<aside>，可以用来放置补充信息、评论或注释。\n\n下面是网页级别的<aside>的例子。\n\n<body>\n  <main>主体内容</main>\n  <aside>侧边栏</aside>\n</body>\n\n\n1\n2\n3\n4\n\n\n下面是文章评注的例子。\n\n<p>第一段</p>\n\n<aside>\n  <p>本段是文章的重点。</p>\n</aside>\n\n\n1\n2\n3\n4\n5\n\n\n\n# <section>\n\n<section>标签表示一个含有主题的独立部分，通常用在文档里面表示一个章节，比如<article>可以包含多个<section>。<section>总是多个一起使用，一个页面不能只有一个<section>。\n\n<article>\n  <h1>文章标题</h1>\n  <section>\n    <h2>第一章</h2>\n    <p>...</p>\n  </section>\n  <section>\n    <h2>第二章</h2>\n    <p>...</p>\n  </section>\n</article>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，<article>包含了两个<section>，代表两章。\n\n<section>很适合幻灯片展示的页面，每个<section>代表一个幻灯片。\n\n一般来说，<section>都应该有标题，即包含<h1>~<h6>标签。多个<section>可以放置在同一个<article>里面，一个<section>里面也可能包含多个<article>，这取决于<section>和<article>在当前页面的含义。\n\n\n# <nav>\n\n<nav>标签用于放置页面或文档的导航信息。\n\n<nav>\n  <ol>\n    <li><a href="item-a">商品 a</a></li>\n    <li><a href="item-b">商品 b</a></li>\n    <li>商品 c</li>\n  </ol>\n</nav>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n一般来说，<nav>往往放置在<header>里面，不适合放入<footer>。另外，一个页面可以有多个<nav>，比如一个用于站点导航，另一个用于文章导航。\n\n<nav>里面通常是列表，但也可以放置其他标签。\n\n\n# <h1> ~ <h6>\n\nhtml 提供了6个标签，用来表示文章的标题。按照标题的等级，一共分成六级。\n\n * <h1>：一级标题\n * <h2>：二级标题\n * <h3>：三级标题\n * <h4>：四级标题\n * <h5>：五级标题\n * <h6>：六级标题\n\n<h1>是最高级别的标题，<h6>是最低级别的标题。下一级标题都是上一级标题的子标题，比如，一个<h1>后面可以有多个<h2>，每个<h2>后面又可以有多个<h3>。\n\n<body>\n  <h1>javascript 语言介绍</h1>\n    <h2>概述</h2>\n    <h2>基本概念</h2>\n      <h3>网页</h3>\n      <h3>链接</h3>\n    <h2>主要用法</h2>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码，通过章节标题，清晰地表明了文章的主体结构。具体的内容，就可以写在章节标题的下面。\n\n标题不应该越级，比如h1下面直接写h3。虽然这样不会报错，但会导致文章失去清晰的章节结构。\n\n默认情况下，浏览器会粗体显示标题。h1的字号比h2大，h2比h3大，以此类推。\n\n\n# <hgroup>\n\n如果主标题包含多级标题（比如带有副标题），那么可以使用<hgroup>标签，将多级标题放在其中。\n\n<hgroup>\n  <h1>heading 1</h1>\n  <h2>subheading 1</h2>\n  <h2>subheading 2</h2>\n</hgroup>\n\n\n1\n2\n3\n4\n5\n\n\n注意，<hgroup>只能包含<h1>~<h6>，不能包含其他标签。',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"文本标签",frontmatter:{title:"文本标签",date:"2022-11-30T18:07:54.000Z",permalink:"/pages/1788c5/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/01.HTML/01.ruanyf/06.%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE.html",relativePath:"01.前端基础/01.HTML/01.ruanyf/06.文本标签.md",key:"v-24cb4b2f",path:"/pages/1788c5/",headers:[{level:2,title:"<div>",slug:"div",normalizedTitle:"<div>",charIndex:2},{level:2,title:"<p>",slug:"p",normalizedTitle:"<p>",charIndex:605},{level:2,title:"<span>",slug:"span",normalizedTitle:"<span>",charIndex:726},{level:2,title:"<br>，<wbr>",slug:"br-wbr",normalizedTitle:"<br>，<wbr>",charIndex:892}],headersStr:"<div> <p> <span> <br>，<wbr>",content:'# <div>\n\n<div>是一个通用标签，表示一个区块（division）。它没有语义，如果网页需要一个块级元素容器，又没有其他合适的标签，就可以使用这个标签。\n\n它的最常见用途就是提供 CSS 的钩子，用来指定各种样式。所以在早期，下面层层包裹的<div>就很常见。\n\n<div class="main">\n  <div class="article">\n    <div class="title">\n      <h1>文章标题</h1>\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码读起来很费力，因为不带有语义。后来，HTML 5 就提出了语义标签，改进了上面的代码。\n\n<main>\n  <article>\n    <header>\n      <h1>文章标题</h1>\n    </header>\n  </article>\n</main>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n<div>是无语义的块级元素。下面的例子使用<div>，将图像和文字组合在一起，构成一个警告区块。\n\n只要样式上需要多个块级元素组合在一起，就可以使用<div>。但是，这应该是最后的措施，带有语义的块级标签（比如<article>、<section>、<aside>、<nav>等）始终应该优先使用，当且仅当没有其他语义元素合适时，才可以使用<div>。\n\n\n# <p>\n\np标签是一个块级元素，代表文章的一个段落（paragraph）。不仅是文本，任何想以段落显示的内容，比如图片和表单项，都可以放进<p>元素。\n\n<p>hello world</p>\n\n\n1\n\n\n上面代码就是一个简单的段落。\n\n\n# <span>\n\n<span>是一个通用目的的行内标签（即不会产生换行），不带有任何语义。它通常用作 CSS 样式的钩子，如果需要对某些行内内容指定样式，就可以把它们放置在<span>。\n\n<p>这是一句<span>重要</span>的句子。</p>\n\n\n1\n\n\n上面代码中，句子里面需要强调的部分，就可以放在<span>。\n\n\n# <br>，<wbr>\n\n<br>让网页产生一个换行效果。该标签是单独使用的，没有闭合标签。\n\nhello<br>world\n\n\n1\n\n\n浏览器渲染上面代码时，会分成两行，hello和world各占一行。\n\n<br>对于诗歌和地址的换行非常有用。\n\n<p>\n  床前明月光，<br>\n  疑是地上霜。<br>\n  举头望明月，<br>\n  低头思故乡。\n</p>\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面的代码如果不用<br>，会显示成一行。\n\n注意，块级元素的间隔，不要使用<br>来产生，而要使用 CSS 指定。\n\n<p>第一段</p>\n<br>\n<br>\n<p>第二段</p>\n\n\n1\n2\n3\n4\n\n\n上面的代码希望段落之间有两个换行，这时不应该使用<br>，而应该使用 CSS。\n\n<wbr>标签跟<br>很相似，表示一个可选的断行。如果一行的宽度足够，则不断行；如果宽度不够，需要断行，就在<wbr>的位置的断行。它是为了防止浏览器在一个很长的单词中间，不正确地断行或者不断行，所以事先标明可以断行的位置，主要用于欧洲一些单词很长的语言或者 URL 的断行。\n\n<p>\nFernstraßen<wbr>bau<wbr>privat<wbr>finanzierungs<wbr>gesetz\n</p>\n\n\n1\n2\n3\n\n\n上面代码是一个很长的德语单词，为了防止不正确断行，事先用<wbr>告诉浏览器，可以选择在哪里断行。',normalizedContent:'# <div>\n\n<div>是一个通用标签，表示一个区块（division）。它没有语义，如果网页需要一个块级元素容器，又没有其他合适的标签，就可以使用这个标签。\n\n它的最常见用途就是提供 css 的钩子，用来指定各种样式。所以在早期，下面层层包裹的<div>就很常见。\n\n<div class="main">\n  <div class="article">\n    <div class="title">\n      <h1>文章标题</h1>\n    </div>\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码读起来很费力，因为不带有语义。后来，html 5 就提出了语义标签，改进了上面的代码。\n\n<main>\n  <article>\n    <header>\n      <h1>文章标题</h1>\n    </header>\n  </article>\n</main>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n<div>是无语义的块级元素。下面的例子使用<div>，将图像和文字组合在一起，构成一个警告区块。\n\n只要样式上需要多个块级元素组合在一起，就可以使用<div>。但是，这应该是最后的措施，带有语义的块级标签（比如<article>、<section>、<aside>、<nav>等）始终应该优先使用，当且仅当没有其他语义元素合适时，才可以使用<div>。\n\n\n# <p>\n\np标签是一个块级元素，代表文章的一个段落（paragraph）。不仅是文本，任何想以段落显示的内容，比如图片和表单项，都可以放进<p>元素。\n\n<p>hello world</p>\n\n\n1\n\n\n上面代码就是一个简单的段落。\n\n\n# <span>\n\n<span>是一个通用目的的行内标签（即不会产生换行），不带有任何语义。它通常用作 css 样式的钩子，如果需要对某些行内内容指定样式，就可以把它们放置在<span>。\n\n<p>这是一句<span>重要</span>的句子。</p>\n\n\n1\n\n\n上面代码中，句子里面需要强调的部分，就可以放在<span>。\n\n\n# <br>，<wbr>\n\n<br>让网页产生一个换行效果。该标签是单独使用的，没有闭合标签。\n\nhello<br>world\n\n\n1\n\n\n浏览器渲染上面代码时，会分成两行，hello和world各占一行。\n\n<br>对于诗歌和地址的换行非常有用。\n\n<p>\n  床前明月光，<br>\n  疑是地上霜。<br>\n  举头望明月，<br>\n  低头思故乡。\n</p>\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面的代码如果不用<br>，会显示成一行。\n\n注意，块级元素的间隔，不要使用<br>来产生，而要使用 css 指定。\n\n<p>第一段</p>\n<br>\n<br>\n<p>第二段</p>\n\n\n1\n2\n3\n4\n\n\n上面的代码希望段落之间有两个换行，这时不应该使用<br>，而应该使用 css。\n\n<wbr>标签跟<br>很相似，表示一个可选的断行。如果一行的宽度足够，则不断行；如果宽度不够，需要断行，就在<wbr>的位置的断行。它是为了防止浏览器在一个很长的单词中间，不正确地断行或者不断行，所以事先标明可以断行的位置，主要用于欧洲一些单词很长的语言或者 url 的断行。\n\n<p>\nfernstraßen<wbr>bau<wbr>privat<wbr>finanzierungs<wbr>gesetz\n</p>\n\n\n1\n2\n3\n\n\n上面代码是一个很长的德语单词，为了防止不正确断行，事先用<wbr>告诉浏览器，可以选择在哪里断行。',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Generator",frontmatter:{title:"Generator",date:"2022-11-29T15:04:05.000Z",permalink:"/pages/02a35f/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/04.ES6/01.ruanyf/10.Generator.html",relativePath:"01.前端基础/04.ES6/01.ruanyf/10.Generator.md",key:"v-7b1f601a",path:"/pages/02a35f/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Promise",frontmatter:{title:"Promise",date:"2022-11-29T09:59:23.000Z",permalink:"/pages/aebd55/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/04.ES6/01.ruanyf/11.Promise.html",relativePath:"01.前端基础/04.ES6/01.ruanyf/11.Promise.md",key:"v-3b84b4fa",path:"/pages/aebd55/",headers:[{level:2,title:"Promise含义",slug:"promise含义",normalizedTitle:"promise含义",charIndex:2},{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:942},{level:3,title:"调用 Ajax 例子",slug:"调用-ajax-例子",normalizedTitle:"调用 ajax 例子",charIndex:2269},{level:3,title:"多重调用",slug:"多重调用",normalizedTitle:"多重调用",charIndex:3691},{level:2,title:"Prototype.then()",slug:"prototype-then",normalizedTitle:"prototype.then()",charIndex:4589},{level:2,title:"prototype.catch()",slug:"prototype-catch",normalizedTitle:"prototype.catch()",charIndex:5108},{level:2,title:"prototype.finally()",slug:"prototype-finally",normalizedTitle:"prototype.finally()",charIndex:10550},{level:2,title:"Promise.all()",slug:"promise-all",normalizedTitle:"promise.all()",charIndex:11813},{level:2,title:"Promise.race()",slug:"promise-race",normalizedTitle:"promise.race()",charIndex:14086},{level:2,title:"Promise.allSettled()",slug:"promise-allsettled",normalizedTitle:"promise.allsettled()",charIndex:14718},{level:2,title:"Promise.any()",slug:"promise-any",normalizedTitle:"promise.any()",charIndex:16639},{level:2,title:"Promise.resolve()",slug:"promise-resolve",normalizedTitle:"promise.resolve()",charIndex:9392},{level:2,title:"Promise.reject()",slug:"promise-reject",normalizedTitle:"promise.reject()",charIndex:20068},{level:2,title:"Promise.try()",slug:"promise-try",normalizedTitle:"promise.try()",charIndex:20573},{level:2,title:"应用实例",slug:"应用实例",normalizedTitle:"应用实例",charIndex:22482}],headersStr:"Promise含义 基本用法 调用 Ajax 例子 多重调用 Prototype.then() prototype.catch() prototype.finally() Promise.all() Promise.race() Promise.allSettled() Promise.any() Promise.resolve() Promise.reject() Promise.try() 应用实例",content:"# Promise含义\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和强大。它由社区最早提出和实现，ES6 将其写进了语言标志，统一了用法，原生提供了 Promise 对象\n\n所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API ，各种异步操作都可以用同样的方法进行处理\n\npromise 对象有以下两个特点\n\n * 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态\n   \n   pending（进行中）\n   \n   fulfilled（已成功）\n   \n   rejected（已失败）\n   \n   只有异步操作的结果，可以决定当前是哪一种状态，任何其它操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是 承诺 ，表示其它手段无法改变\n\n * 一旦状态改变，就不会再变，任何时候都可以得到这个结果。promise 对象的状态改变，只有两种可能：从 pending 变成 fulfilled 或者 rejected 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型） 。如果改变已经发生了，你再对 promise 对象添加回调函数，也立即得到这个结果。这与 Event 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的\n\n> 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。\n\n有了 promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，promise 对象提供统一的接口，使得控制异步操作更加容易\n\nPromise 也有一些缺点。首先，无法取消 promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，promise 内部抛出的错误，不会反应到外部。第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段\n\n\n# 基本用法\n\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nPromise 构造函数接收一个函数作为参数，该函数的两个参数分别是 resolve 和 reject ，他们是两个函数，由 JS 引擎提供，不用自己部署\n\nresolve ： 将 Promise 对象的状态从 未完成 变成 成功（pending-resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n\nreject：将 promise 对象的状态从 未完成 变成 失败 （pending-rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\nPromise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n\n\n1\n2\n3\n4\n5\n\n\nthen 方法可以接收两个回调函数作为参数。第一个回调函数是 promise 对象的状态为 resolved 时调用，第二个回调函数是 Promise 对象的状态为 rejected 时调用。这两个函数都是可选的，不一定要提供。他们都接收 promise 对象传除的值作为参数\n\n下面时一个 promise 对象的简单例子\n\nfunction timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中， timeout 方法返回一个 promise 实例，表示一段时间后才会发生的结果。过了指定的时间以后，Promise 的状态才会变成 resolved ，就会触发 then 方法绑定的回调函数\n\n注意js执行会执行同步任务后才会去执行异步任务\n\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('resolved.');\n});\n\nconsole.log('Hi!');\n\n// Promise\n// Hi!\n// resolved\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 调用 Ajax 例子\n\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，getJSON 是对 XMLHttpReques 对象的封装，用于发出一个争对 JSON 数据的 HTTP 请求，并且返回一个 Promise 对象。需要注意的是，在 getJSON 内部，resolve和reject 函数调用时，都带有参数\n\n如果调用 resolve 和 reject 函数带有参数，那么他们的参数会被传递给回调函数。reject 函数的参数通常都是 Error 对象的实例，表示抛出的错误； resolve 函数的参数除了正常的值以外，还可能是另一个 promise 实例，如下\n\nconst p1 = new Promise(function (resolve, reject) {\n  // ...\n});\n\nconst p2 = new Promise(function (resolve, reject) {\n  // ...\n  resolve(p1);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。\n\n注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。\n\n\n# 多重调用\n\nconst p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nconst p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，p1 是一个 promise ， 3秒后状态变为 rejected 。 p2 的状态在 1s 之后改变，resolve 方法返回的是 p1. 由于 p2 返回的是另一个 promise，导致 p2 自己的状态无效了，由于 p1 的状态决定了 p2 的状态。所以后面的 then 语句都变成了针对后者 p1. 又过了2s，p1 变成了 rejected，导致触发了 catch方法指定的回调函数\n\n注意：一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。\n\nnew Promise((resolve, reject) => {\n  return resolve(1);\n  // 后面的语句不会执行\n  console.log(2);\n})\n\n\n1\n2\n3\n4\n5\n\n\nPromise 最终只会有两种状态，内部会线执行同步操作，再执行异步操作。需要使用 resolve() 或者 reject() 方法返回该状态否则会在内部报错，而promise对象的使用也是使用到这两种状态设置回调函数 then ，而不是单纯使用 promise\n\n\n# Prototype.then()\n\nPromise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。\n\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\nAjax 返回的是另一个 promise 对象，因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\n上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。\n\n\n# prototype.catch()\n\nPromise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。\n\np.then((val) => console.log('fulfilled:', val))\n  .catch((err) => console.log('rejected', err));\n\n// 等同于\np.then((val) => console.log('fulfilled:', val))\n  .then(null, (err) => console.log(\"rejected:\", err));\n\n\n1\n2\n3\n4\n5\n6\n\n\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，getJSON()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。\n\n等价例子：\n\nconst promise = new Promise(function(resolve, reject) {\n  throw new Error('test');\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n// Error: test\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n等同于\n\n// 写法一\nconst promise = new Promise(function(resolve, reject) {\n  try {\n    throw new Error('test');\n  } catch(e) {\n    reject(e);\n  }\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n// 写法二\nconst promise = new Promise(function(resolve, reject) {\n  reject(new Error('test'));\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意如果 promise 状态已经变成了 resolved ，再抛出错误是无效的\n\nconst promise = new Promise(function(resolve, reject) {\n  resolve('ok');\n  throw new Error('test');\n});\npromise\n  .then(function(value) { console.log(value) })\n  .catch(function(error) { console.log(error) });\n// ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。\n\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n\ngetJSON('/post/1.json').then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个Promise产生的错误\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，一共有三个 Promise 对象：一个由getJSON()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。\n\n一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。\n\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch()方法，而不使用then()方法的第二个参数。\n\n跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。\n\nconst someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing().then(function() {\n  console.log('everything is great');\n});\n\nsetTimeout(() => { console.log(123) }, 2000);\n// Uncaught (in promise) ReferenceError: x is not defined\n// 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，someAsyncThing() 函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。\n\n这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node.js 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。\n\nprocess.on('unhandledRejection', function (err, p) {\n  throw err;\n});\n\n\n1\n2\n3\n\n\n上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。\n\n注意，Node 有计划在未来废除unhandledRejection事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。\n\n再看下面的例子。\n\nconst promise = new Promise(function (resolve, reject) {\n  resolve('ok');\n  setTimeout(function () { throw new Error('test') }, 0)\n});\npromise.then(function (value) { console.log(value) });\n// ok\n// Uncaught Error: test\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。\n\n一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。\n\nconst someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// oh no [ReferenceError: x is not defined]\n// carry on\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。如果没有报错，则会跳过catch()方法。\n\nPromise.resolve()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// carry on\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的代码因为没有报错，跳过了catch()方法，直接执行后面的then()方法。此时，要是then()方法里面报错，就与前面的catch()无关了。\n\ncatch()方法之中，还能再抛出错误。\n\nconst someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为 y 没有声明\n  y + 2;\n}).then(function() {\n  console.log('carry on');\n});\n// oh no [ReferenceError: x is not defined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，catch()方法抛出一个错误，因为后面没有别的catch()方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。\n\nsomeAsyncThing().then(function() {\n  return someOtherAsyncThing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [ReferenceError: x is not defined]\n// carry on [ReferenceError: y is not defined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第二个catch()方法用来捕获前一个catch()方法抛出的错误。\n\n\n# prototype.finally()\n\nfinally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n\n\n1\n2\n3\n4\n\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。\n\nfinally本质上是then方法的特例。\n\npromise\n.finally(() => {\n  // 语句\n});\n\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。\n\nPromise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value),\n    reason => P.resolve(callback()).then(() => { throw reason })\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。\n\n从上面的实现还可以看到，finally方法总是会返回原来的值。\n\n// resolve 的值是 undefined\nPromise.resolve(2).then(() => {}, () => {})\n\n// resolve 的值是 2\nPromise.resolve(2).finally(() => {})\n\n// reject 的值是 undefined\nPromise.reject(3).then(() => {}, () => {})\n\n// reject 的值是 3\nPromise.reject(3).finally(() => {})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Promise.all()\n\n该方法用于将多个 promise 实例，包装成一个新的 promise 实例\n\nconst p = Promise.all([p1, p2, p3]);\n\n\n1\n\n\n上面代码中，Promise.all() 方法接收一个数组作为参数p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。\n\np的状态由p1、p2、p3决定，分成两种情况。\n\n（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n\n// 生成一个Promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。\n\nconst databasePromise = connectDatabase();\n\nconst booksPromise = databasePromise\n  .then(findAllBooks);\n\nconst userPromise = databasePromise\n  .then(getCurrentUser);\n\nPromise.all([\n  booksPromise,\n  userPromise\n])\n.then(([books, user]) => pickTopRecommendations(books, user));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，booksPromise 和 userPromise 是两个异步操作，只有等他们的结果都返回了，才会触发 pickTopRecommendations 这个回调函数\n\n注意，如果作为参数的 Promise 实例，自己定义了 catch 方法，那么他一旦 rejected ， 并不会触发 Promise.all() 的catch 方法\n\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", Error: 报错了]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中， p1 会 resolved ，p2 首先会 rejected，但是 p2 有自己的 catch 方法，该方法返回的是一个新的 Promise 实例，p2 指向的实际上是这个实例。该实例执行完 catch 方法后，也会变成 resolved，导致 Promise.all 方法参数里面的两个实例都会 resolved，因此会调用 then 方法指定的回调函数，而不会调用 catch 方法指定的回调函数\n\n如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。\n\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// Error: 报错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Promise.race()\n\nPromise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\n\nconst p = Promise.race([p1, p2, p3]);\n\n\n1\n\n\n上面代码中，只要 p1，p2，p3 之中有一个实例率先改变状态，p的状态就跟着改变。哪个率先改变的 Promise 实例的放回值，就传递给 p 的回调函数。\n\nPromise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。\n\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。\n\n\n# Promise.allSettled()\n\n有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。\n\nPromise.all()方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。\n\n为了解决这个问题，ES2020 引入了Promise.allSettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。\n\nPromise.allSettled()方法接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。只有等到参数数组的所有 Promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 Promise 对象才会发生状态变更。\n\nconst promises = [\n  fetch('/api-1'),\n  fetch('/api-2'),\n  fetch('/api-3'),\n];\n\nawait Promise.allSettled(promises);\nremoveLoadingIndicator();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面示例中，数组promises包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），removeLoadingIndicator()才会执行。\n\n该方法返回的新的 Promise 实例，一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 Promise 对象。\n\nconst resolved = Promise.resolve(42);\nconst rejected = Promise.reject(-1);\n\nconst allSettledPromise = Promise.allSettled([resolved, rejected]);\n\nallSettledPromise.then(function (results) {\n  console.log(results);\n});\n// [\n//    { status: 'fulfilled', value: 42 },\n//    { status: 'rejected', reason: -1 }\n// ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled。它的回调函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入Promise.allSettled()的数组里面的两个 Promise 对象。\n\nresults的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。\n\n// 异步操作成功时\n{status: 'fulfilled', value: value}\n\n// 异步操作失败时\n{status: 'rejected', reason: reason}\n\n\n1\n2\n3\n4\n5\n\n\n成员对象的status属性的值只可能是字符串fulfilled或字符串rejected，用来区分异步操作是成功还是失败。如果是成功（fulfilled），对象会有value属性，如果是失败（rejected），会有reason属性，对应两种状态时前面异步操作的返回值。\n\n下面是返回值的用法例子。\n\nconst promises = [ fetch('index.html'), fetch('https://does-not-exist/') ];\nconst results = await Promise.allSettled(promises);\n\n// 过滤出成功的请求\nconst successfulPromises = results.filter(p => p.status === 'fulfilled');\n\n// 过滤出失败的请求，并输出原因\nconst errors = results\n  .filter(p => p.status === 'rejected')\n  .map(p => p.reason);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# Promise.any()\n\nES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。\n\nPromise.any([\n  fetch('https://v8.dev/').then(() => 'home'),\n  fetch('https://v8.dev/blog').then(() => 'blog'),\n  fetch('https://v8.dev/docs').then(() => 'docs')\n]).then((first) => {  // 只要有一个 fetch() 请求成功\n  console.log(first);\n}).catch((error) => { // 所有三个 fetch() 全部请求失败\n  console.log(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。\n\nPromise.any()跟Promise.race()方法很像，只有一点不同，就是Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。\n\n下面是Promise()与await命令结合使用的例子。\n\nconst promises = [\n  fetch('/endpoint-a').then(() => 'a'),\n  fetch('/endpoint-b').then(() => 'b'),\n  fetch('/endpoint-c').then(() => 'c'),\n];\n\ntry {\n  const first = await Promise.any(promises);\n  console.log(first);\n} catch (error) {\n  console.log(error);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。\n\nPromise.any()抛出的错误是一个 AggregateError 实例\n\nvar resolved = Promise.resolve(42);\nvar rejected = Promise.reject(-1);\nvar alsoRejected = Promise.reject(Infinity);\n\nPromise.any([resolved, rejected, alsoRejected]).then(function (result) {\n  console.log(result); // 42\n});\n\nPromise.any([rejected, alsoRejected]).catch(function (results) {\n  console.log(results instanceof AggregateError); // true\n  console.log(results.errors); // [-1, Infinity]\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Promise.resolve()\n\n有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。\n\nconst jsPromise = Promise.resolve($.ajax('/whatever.json'));\n\n\n1\n\n\n上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。\n\nPromise.resolve()等价于下面的写法。\n\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n\n\n1\n2\n3\n\n\nPromise.resolve()方法的参数分成四种情况。\n\n（1）参数是一个 Promise 实例\n\n如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。\n\n（2）参数是一个thenable对象\n\nthenable对象指的是具有then方法的对象，比如下面这个对象。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\nPromise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nlet p1 = Promise.resolve(thenable);\np1.then(function (value) {\n  console.log(value);  // 42\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出42。\n\n（3）参数不是具有then()方法的对象，或根本就不是对象\n\n如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。\n\nconst p = Promise.resolve('Hello');\n\np.then(function (s) {\n  console.log(s)\n});\n// Hello\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。\n\n（4）不带有任何参数\n\nPromise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。\n\n所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。\n\nconst p = Promise.resolve();\n\np.then(function () {\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的变量p就是一个 Promise 对象。\n\n需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。\n\nsetTimeout(function () {\n  console.log('three');\n}, 0);\n\nPromise.resolve().then(function () {\n  console.log('two');\n});\n\nconsole.log('one');\n\n// one\n// two\n// three\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。\n\n\n# Promise.reject()\n\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。\n\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。\n\nPromise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。\n\nPromise.reject('出错了')\n.catch(e => {\n  console.log(e === '出错了')\n})\n// true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。\n\n\n# Promise.try()\n\n实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。\n\nPromise.resolve().then(f)\n\n\n1\n\n\n上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。\n\nconst f = () => console.log('now');\nPromise.resolve().then(f);\nconsole.log('next');\n// next\n// now\n\n\n1\n2\n3\n4\n5\n\n\n那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。\n\nconst f = () => console.log('now');\n(async () => f())();\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。\n\n(async () => f())()\n.then(...)\n\n\n1\n2\n\n\n需要注意的是，async () => f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。\n\n(async () => f())()\n.then(...)\n.catch(...)\n\n\n1\n2\n3\n\n\n第二种写法就是 new Promise()\n\nconst f = () => console.log('now');\n(\n  () => new Promise(\n    resolve => resolve(f())\n  )\n)();\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。\n\nconst f = () => console.log('now');\nPromise.try(f);\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n\n\n事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。\n\n由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n\nfunction getUsername(userId) {\n  return database.users.get({id: userId})\n  .then(function(user) {\n    return user.name;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。\n\ndatabase.users.get({id: userId})\n.then(...)\n.catch(...)\n\n\n1\n2\n3\n\n\n但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。\n\ntry {\n  database.users.get({id: userId})\n  .then(...)\n  .catch(...)\n} catch (e) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。\n\nPromise.try(() => database.users.get({id: userId}))\n  .then(...)\n  .catch(...)\n\n\n1\n2\n3\n\n\n事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。\n\n\n# 应用实例\n\n加载图片\n\n我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。\n\nconst preloadImage = function (path) {\n  return new Promise(function (resolve, reject) {\n    const image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nGenerator 函数与 Promise 的结合\n\n使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象\n\nfunction getFoo () {\n  return new Promise(function (resolve, reject){\n    resolve('foo');\n  });\n}\n\nconst g = function* () {\n  try {\n    const foo = yield getFoo();\n    console.log(foo);\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nfunction run (generator) {\n  const it = generator();\n\n  function go(result) {\n    if (result.done) return result.value;\n\n    return result.value.then(function (value) {\n      return go(it.next(value));\n    }, function (error) {\n      return go(it.throw(error));\n    });\n  }\n\n  go(it.next());\n}\n\nrun(g);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。",normalizedContent:"# promise含义\n\npromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和强大。它由社区最早提出和实现，es6 将其写进了语言标志，统一了用法，原生提供了 promise 对象\n\n所谓 promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来说，promise 是一个对象，从它可以获取异步操作的消息。promise 提供统一的 api ，各种异步操作都可以用同样的方法进行处理\n\npromise 对象有以下两个特点\n\n * 对象的状态不受外界影响。promise 对象代表一个异步操作，有三种状态\n   \n   pending（进行中）\n   \n   fulfilled（已成功）\n   \n   rejected（已失败）\n   \n   只有异步操作的结果，可以决定当前是哪一种状态，任何其它操作都无法改变这个状态。这也是 promise 这个名字的由来，它的英语意思就是 承诺 ，表示其它手段无法改变\n\n * 一旦状态改变，就不会再变，任何时候都可以得到这个结果。promise 对象的状态改变，只有两种可能：从 pending 变成 fulfilled 或者 rejected 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型） 。如果改变已经发生了，你再对 promise 对象添加回调函数，也立即得到这个结果。这与 event 完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的\n\n> 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。\n\n有了 promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，promise 对象提供统一的接口，使得控制异步操作更加容易\n\npromise 也有一些缺点。首先，无法取消 promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，promise 内部抛出的错误，不会反应到外部。第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段\n\n\n# 基本用法\n\nconst promise = new promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npromise 构造函数接收一个函数作为参数，该函数的两个参数分别是 resolve 和 reject ，他们是两个函数，由 js 引擎提供，不用自己部署\n\nresolve ： 将 promise 对象的状态从 未完成 变成 成功（pending-resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n\nreject：将 promise 对象的状态从 未完成 变成 失败 （pending-rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\npromise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n\n\n1\n2\n3\n4\n5\n\n\nthen 方法可以接收两个回调函数作为参数。第一个回调函数是 promise 对象的状态为 resolved 时调用，第二个回调函数是 promise 对象的状态为 rejected 时调用。这两个函数都是可选的，不一定要提供。他们都接收 promise 对象传除的值作为参数\n\n下面时一个 promise 对象的简单例子\n\nfunction timeout(ms) {\n  return new promise((resolve, reject) => {\n    settimeout(resolve, ms, 'done');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面代码中， timeout 方法返回一个 promise 实例，表示一段时间后才会发生的结果。过了指定的时间以后，promise 的状态才会变成 resolved ，就会触发 then 方法绑定的回调函数\n\n注意js执行会执行同步任务后才会去执行异步任务\n\nlet promise = new promise(function(resolve, reject) {\n  console.log('promise');\n  resolve();\n});\n\npromise.then(function() {\n  console.log('resolved.');\n});\n\nconsole.log('hi!');\n\n// promise\n// hi!\n// resolved\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 调用 ajax 例子\n\nconst getjson = function(url) {\n  const promise = new promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readystate !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new error(this.statustext));\n      }\n    };\n    const client = new xmlhttprequest();\n    client.open(\"get\", url);\n    client.onreadystatechange = handler;\n    client.responsetype = \"json\";\n    client.setrequestheader(\"accept\", \"application/json\");\n    client.send();\n\n  });\n\n  return promise;\n};\n\ngetjson(\"/posts.json\").then(function(json) {\n  console.log('contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n上面代码中，getjson 是对 xmlhttpreques 对象的封装，用于发出一个争对 json 数据的 http 请求，并且返回一个 promise 对象。需要注意的是，在 getjson 内部，resolve和reject 函数调用时，都带有参数\n\n如果调用 resolve 和 reject 函数带有参数，那么他们的参数会被传递给回调函数。reject 函数的参数通常都是 error 对象的实例，表示抛出的错误； resolve 函数的参数除了正常的值以外，还可能是另一个 promise 实例，如下\n\nconst p1 = new promise(function (resolve, reject) {\n  // ...\n});\n\nconst p2 = new promise(function (resolve, reject) {\n  // ...\n  resolve(p1);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，p1和p2都是 promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。\n\n注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。\n\n\n# 多重调用\n\nconst p1 = new promise(function (resolve, reject) {\n  settimeout(() => reject(new error('fail')), 3000)\n})\n\nconst p2 = new promise(function (resolve, reject) {\n  settimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// error: fail\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，p1 是一个 promise ， 3秒后状态变为 rejected 。 p2 的状态在 1s 之后改变，resolve 方法返回的是 p1. 由于 p2 返回的是另一个 promise，导致 p2 自己的状态无效了，由于 p1 的状态决定了 p2 的状态。所以后面的 then 语句都变成了针对后者 p1. 又过了2s，p1 变成了 rejected，导致触发了 catch方法指定的回调函数\n\n注意：一般来说，调用resolve或reject以后，promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。\n\nnew promise((resolve, reject) => {\n  return resolve(1);\n  // 后面的语句不会执行\n  console.log(2);\n})\n\n\n1\n2\n3\n4\n5\n\n\npromise 最终只会有两种状态，内部会线执行同步操作，再执行异步操作。需要使用 resolve() 或者 reject() 方法返回该状态否则会在内部报错，而promise对象的使用也是使用到这两种状态设置回调函数 then ，而不是单纯使用 promise\n\n\n# prototype.then()\n\npromise 实例具有then方法，也就是说，then方法是定义在原型对象promise.prototype上的。它的作用是为 promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数，它们都是可选的。\n\ngetjson(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\najax 返回的是另一个 promise 对象，因此可以采用链式写法，即then方法后面再调用另一个then方法。\n\n上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个promise对象（即有异步操作），这时后一个回调函数，就会等待该promise对象的状态发生变化，才会被调用。\n\n\n# prototype.catch()\n\npromise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。\n\np.then((val) => console.log('fulfilled:', val))\n  .catch((err) => console.log('rejected', err));\n\n// 等同于\np.then((val) => console.log('fulfilled:', val))\n  .then(null, (err) => console.log(\"rejected:\", err));\n\n\n1\n2\n3\n4\n5\n6\n\n\ngetjson('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getjson 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，getjson()方法返回一个 promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。\n\n等价例子：\n\nconst promise = new promise(function(resolve, reject) {\n  throw new error('test');\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n// error: test\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n等同于\n\n// 写法一\nconst promise = new promise(function(resolve, reject) {\n  try {\n    throw new error('test');\n  } catch(e) {\n    reject(e);\n  }\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n// 写法二\nconst promise = new promise(function(resolve, reject) {\n  reject(new error('test'));\n});\npromise.catch(function(error) {\n  console.log(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意如果 promise 状态已经变成了 resolved ，再抛出错误是无效的\n\nconst promise = new promise(function(resolve, reject) {\n  resolve('ok');\n  throw new error('test');\n});\npromise\n  .then(function(value) { console.log(value) })\n  .catch(function(error) { console.log(error) });\n// ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 promise 的状态一旦改变，就永久保持该状态，不会再变了。\n\npromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。\n\ngetjson('/post/1.json').then(function(post) {\n  return getjson(post.commenturl);\n}).then(function(comments) {\n  // some code\n}).catch(function(error) {\n  // 处理前面三个promise产生的错误\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，一共有三个 promise 对象：一个由getjson()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。\n\n一般来说，不要在then()方法里面定义 reject 状态的回调函数（即then的第二个参数），总是使用catch方法。\n\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch()方法，而不使用then()方法的第二个参数。\n\n跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。\n\nconst someasyncthing = function() {\n  return new promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeasyncthing().then(function() {\n  console.log('everything is great');\n});\n\nsettimeout(() => { console.log(123) }, 2000);\n// uncaught (in promise) referenceerror: x is not defined\n// 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面代码中，someasyncthing() 函数产生的 promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示referenceerror: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，promise 内部的错误不会影响到 promise 外部的代码，通俗的说法就是“promise 会吃掉错误”。\n\n这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，node.js 有一个unhandledrejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。\n\nprocess.on('unhandledrejection', function (err, p) {\n  throw err;\n});\n\n\n1\n2\n3\n\n\n上面代码中，unhandledrejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 promise 实例，它可以用来了解发生错误的环境信息。\n\n注意，node 有计划在未来废除unhandledrejection事件。如果 promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。\n\n再看下面的例子。\n\nconst promise = new promise(function (resolve, reject) {\n  resolve('ok');\n  settimeout(function () { throw new error('test') }, 0)\n});\npromise.then(function (value) { console.log(value) });\n// ok\n// uncaught error: test\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，promise 的运行已经结束了，所以这个错误是在 promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。\n\n一般总是建议，promise 对象后面要跟catch()方法，这样可以处理 promise 内部发生的错误。catch()方法返回的还是一个 promise 对象，因此后面还可以接着调用then()方法。\n\nconst someasyncthing = function() {\n  return new promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeasyncthing()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// oh no [referenceerror: x is not defined]\n// carry on\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。如果没有报错，则会跳过catch()方法。\n\npromise.resolve()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// carry on\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面的代码因为没有报错，跳过了catch()方法，直接执行后面的then()方法。此时，要是then()方法里面报错，就与前面的catch()无关了。\n\ncatch()方法之中，还能再抛出错误。\n\nconst someasyncthing = function() {\n  return new promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeasyncthing().then(function() {\n  return someotherasyncthing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为 y 没有声明\n  y + 2;\n}).then(function() {\n  console.log('carry on');\n});\n// oh no [referenceerror: x is not defined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，catch()方法抛出一个错误，因为后面没有别的catch()方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。\n\nsomeasyncthing().then(function() {\n  return someotherasyncthing();\n}).catch(function(error) {\n  console.log('oh no', error);\n  // 下面一行会报错，因为y没有声明\n  y + 2;\n}).catch(function(error) {\n  console.log('carry on', error);\n});\n// oh no [referenceerror: x is not defined]\n// carry on [referenceerror: y is not defined]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面代码中，第二个catch()方法用来捕获前一个catch()方法抛出的错误。\n\n\n# prototype.finally()\n\nfinally()方法用于指定不管 promise 对象最后状态如何，都会执行的操作。该方法是 es2018 引入标准的。\n\npromise\n.then(result => {···})\n.catch(error => {···})\n.finally(() => {···});\n\n\n1\n2\n3\n4\n\n\n上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。\n\nfinally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 promise 的执行结果。\n\nfinally本质上是then方法的特例。\n\npromise\n.finally(() => {\n  // 语句\n});\n\n// 等同于\npromise\n.then(\n  result => {\n    // 语句\n    return result;\n  },\n  error => {\n    // 语句\n    throw error;\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。\n\npromise.prototype.finally = function (callback) {\n  let p = this.constructor;\n  return this.then(\n    value  => p.resolve(callback()).then(() => value),\n    reason => p.resolve(callback()).then(() => { throw reason })\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，不管前面的 promise 是fulfilled还是rejected，都会执行回调函数callback。\n\n从上面的实现还可以看到，finally方法总是会返回原来的值。\n\n// resolve 的值是 undefined\npromise.resolve(2).then(() => {}, () => {})\n\n// resolve 的值是 2\npromise.resolve(2).finally(() => {})\n\n// reject 的值是 undefined\npromise.reject(3).then(() => {}, () => {})\n\n// reject 的值是 3\npromise.reject(3).finally(() => {})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# promise.all()\n\n该方法用于将多个 promise 实例，包装成一个新的 promise 实例\n\nconst p = promise.all([p1, p2, p3]);\n\n\n1\n\n\n上面代码中，promise.all() 方法接收一个数组作为参数p1、p2、p3都是 promise 实例，如果不是，就会先调用下面讲到的promise.resolve方法，将参数转为 promise 实例，再进一步处理。另外，promise.all()方法的参数可以不是数组，但必须具有 iterator 接口，且返回的每个成员都是 promise 实例。\n\np的状态由p1、p2、p3决定，分成两种情况。\n\n（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n\n（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n\n// 生成一个promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getjson('/post/' + id + \".json\");\n});\n\npromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，promises是包含 6 个 promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用promise.all方法后面的回调函数。\n\nconst databasepromise = connectdatabase();\n\nconst bookspromise = databasepromise\n  .then(findallbooks);\n\nconst userpromise = databasepromise\n  .then(getcurrentuser);\n\npromise.all([\n  bookspromise,\n  userpromise\n])\n.then(([books, user]) => picktoprecommendations(books, user));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，bookspromise 和 userpromise 是两个异步操作，只有等他们的结果都返回了，才会触发 picktoprecommendations 这个回调函数\n\n注意，如果作为参数的 promise 实例，自己定义了 catch 方法，那么他一旦 rejected ， 并不会触发 promise.all() 的catch 方法\n\nconst p1 = new promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new promise((resolve, reject) => {\n  throw new error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\npromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", error: 报错了]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码中， p1 会 resolved ，p2 首先会 rejected，但是 p2 有自己的 catch 方法，该方法返回的是一个新的 promise 实例，p2 指向的实际上是这个实例。该实例执行完 catch 方法后，也会变成 resolved，导致 promise.all 方法参数里面的两个实例都会 resolved，因此会调用 then 方法指定的回调函数，而不会调用 catch 方法指定的回调函数\n\n如果p2没有自己的catch方法，就会调用promise.all()的catch方法。\n\nconst p1 = new promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new promise((resolve, reject) => {\n  throw new error('报错了');\n})\n.then(result => result);\n\npromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// error: 报错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# promise.race()\n\npromise.race()方法同样是将多个 promise 实例，包装成一个新的 promise 实例。\n\nconst p = promise.race([p1, p2, p3]);\n\n\n1\n\n\n上面代码中，只要 p1，p2，p3 之中有一个实例率先改变状态，p的状态就跟着改变。哪个率先改变的 promise 实例的放回值，就传递给 p 的回调函数。\n\npromise.race()方法的参数与promise.all()方法一样，如果不是 promise 实例，就会先调用下面讲到的promise.resolve()方法，将参数转为 promise 实例，再进一步处理。\n\nconst p = promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new promise(function (resolve, reject) {\n    settimeout(() => reject(new error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。\n\n\n# promise.allsettled()\n\n有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 promise 方法很难实现这个要求。\n\npromise.all()方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。\n\n为了解决这个问题，es2020 引入了promise.allsettled()方法，用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”settled“，包含了”fulfilled“和”rejected“两种情况。\n\npromise.allsettled()方法接受一个数组作为参数，数组的每个成员都是一个 promise 对象，并返回一个新的 promise 对象。只有等到参数数组的所有 promise 对象都发生状态变更（不管是fulfilled还是rejected），返回的 promise 对象才会发生状态变更。\n\nconst promises = [\n  fetch('/api-1'),\n  fetch('/api-2'),\n  fetch('/api-3'),\n];\n\nawait promise.allsettled(promises);\nremoveloadingindicator();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面示例中，数组promises包含了三个请求，只有等到这三个请求都结束了（不管请求成功还是失败），removeloadingindicator()才会执行。\n\n该方法返回的新的 promise 实例，一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，该数组的每个成员对应前面数组的每个 promise 对象。\n\nconst resolved = promise.resolve(42);\nconst rejected = promise.reject(-1);\n\nconst allsettledpromise = promise.allsettled([resolved, rejected]);\n\nallsettledpromise.then(function (results) {\n  console.log(results);\n});\n// [\n//    { status: 'fulfilled', value: 42 },\n//    { status: 'rejected', reason: -1 }\n// ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，promise.allsettled()的返回值allsettledpromise，状态只可能变成fulfilled。它的回调函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应传入promise.allsettled()的数组里面的两个 promise 对象。\n\nresults的每个成员是一个对象，对象的格式是固定的，对应异步操作的结果。\n\n// 异步操作成功时\n{status: 'fulfilled', value: value}\n\n// 异步操作失败时\n{status: 'rejected', reason: reason}\n\n\n1\n2\n3\n4\n5\n\n\n成员对象的status属性的值只可能是字符串fulfilled或字符串rejected，用来区分异步操作是成功还是失败。如果是成功（fulfilled），对象会有value属性，如果是失败（rejected），会有reason属性，对应两种状态时前面异步操作的返回值。\n\n下面是返回值的用法例子。\n\nconst promises = [ fetch('index.html'), fetch('https://does-not-exist/') ];\nconst results = await promise.allsettled(promises);\n\n// 过滤出成功的请求\nconst successfulpromises = results.filter(p => p.status === 'fulfilled');\n\n// 过滤出失败的请求，并输出原因\nconst errors = results\n  .filter(p => p.status === 'rejected')\n  .map(p => p.reason);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# promise.any()\n\nes2021 引入了promise.any()方法。该方法接受一组 promise 实例作为参数，包装成一个新的 promise 实例返回。\n\npromise.any([\n  fetch('https://v8.dev/').then(() => 'home'),\n  fetch('https://v8.dev/blog').then(() => 'blog'),\n  fetch('https://v8.dev/docs').then(() => 'docs')\n]).then((first) => {  // 只要有一个 fetch() 请求成功\n  console.log(first);\n}).catch((error) => { // 所有三个 fetch() 全部请求失败\n  console.log(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。\n\npromise.any()跟promise.race()方法很像，只有一点不同，就是promise.any()不会因为某个 promise 变成rejected状态而结束，必须等到所有参数 promise 变成rejected状态才会结束。\n\n下面是promise()与await命令结合使用的例子。\n\nconst promises = [\n  fetch('/endpoint-a').then(() => 'a'),\n  fetch('/endpoint-b').then(() => 'b'),\n  fetch('/endpoint-c').then(() => 'c'),\n];\n\ntry {\n  const first = await promise.any(promises);\n  console.log(first);\n} catch (error) {\n  console.log(error);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面代码中，promise.any()方法的参数数组包含三个 promise 操作。其中只要有一个变成fulfilled，promise.any()返回的 promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。\n\npromise.any()抛出的错误是一个 aggregateerror 实例\n\nvar resolved = promise.resolve(42);\nvar rejected = promise.reject(-1);\nvar alsorejected = promise.reject(infinity);\n\npromise.any([resolved, rejected, alsorejected]).then(function (result) {\n  console.log(result); // 42\n});\n\npromise.any([rejected, alsorejected]).catch(function (results) {\n  console.log(results instanceof aggregateerror); // true\n  console.log(results.errors); // [-1, infinity]\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# promise.resolve()\n\n有时需要将现有对象转为 promise 对象，promise.resolve()方法就起到这个作用。\n\nconst jspromise = promise.resolve($.ajax('/whatever.json'));\n\n\n1\n\n\n上面代码将 jquery 生成的deferred对象，转为一个新的 promise 对象。\n\npromise.resolve()等价于下面的写法。\n\npromise.resolve('foo')\n// 等价于\nnew promise(resolve => resolve('foo'))\n\n\n1\n2\n3\n\n\npromise.resolve()方法的参数分成四种情况。\n\n（1）参数是一个 promise 实例\n\n如果参数是 promise 实例，那么promise.resolve将不做任何修改、原封不动地返回这个实例。\n\n（2）参数是一个thenable对象\n\nthenable对象指的是具有then方法的对象，比如下面这个对象。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\n\n1\n2\n3\n4\n5\n\n\npromise.resolve()方法会将这个对象转为 promise 对象，然后就立即执行thenable对象的then()方法。\n\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nlet p1 = promise.resolve(thenable);\np1.then(function (value) {\n  console.log(value);  // 42\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出42。\n\n（3）参数不是具有then()方法的对象，或根本就不是对象\n\n如果参数是一个原始值，或者是一个不具有then()方法的对象，则promise.resolve()方法返回一个新的 promise 对象，状态为resolved。\n\nconst p = promise.resolve('hello');\n\np.then(function (s) {\n  console.log(s)\n});\n// hello\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码生成一个新的 promise 对象的实例p。由于字符串hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。promise.resolve()方法的参数，会同时传给回调函数。\n\n（4）不带有任何参数\n\npromise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 promise 对象。\n\n所以，如果希望得到一个 promise 对象，比较方便的方法就是直接调用promise.resolve()方法。\n\nconst p = promise.resolve();\n\np.then(function () {\n  // ...\n});\n\n\n1\n2\n3\n4\n5\n\n\n上面代码的变量p就是一个 promise 对象。\n\n需要注意的是，立即resolve()的 promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。\n\nsettimeout(function () {\n  console.log('three');\n}, 0);\n\npromise.resolve().then(function () {\n  console.log('two');\n});\n\nconsole.log('one');\n\n// one\n// two\n// three\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面代码中，settimeout(fn, 0)在下一轮“事件循环”开始时执行，promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。\n\n\n# promise.reject()\n\npromise.reject(reason)方法也会返回一个新的 promise 实例，该实例的状态为rejected。\n\nconst p = promise.reject('出错了');\n// 等同于\nconst p = new promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码生成一个 promise 对象的实例p，状态为rejected，回调函数会立即执行。\n\npromise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。\n\npromise.reject('出错了')\n.catch(e => {\n  console.log(e === '出错了')\n})\n// true\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。\n\n\n# promise.try()\n\n实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。\n\npromise.resolve().then(f)\n\n\n1\n\n\n上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。\n\nconst f = () => console.log('now');\npromise.resolve().then(f);\nconsole.log('next');\n// next\n// now\n\n\n1\n2\n3\n4\n5\n\n\n那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 api 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。\n\nconst f = () => console.log('now');\n(async () => f())();\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n\n\n上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。\n\n(async () => f())()\n.then(...)\n\n\n1\n2\n\n\n需要注意的是，async () => f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。\n\n(async () => f())()\n.then(...)\n.catch(...)\n\n\n1\n2\n3\n\n\n第二种写法就是 new promise()\n\nconst f = () => console.log('now');\n(\n  () => new promise(\n    resolve => resolve(f())\n  )\n)();\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n鉴于这是一个很常见的需求，所以现在有一个提案，提供promise.try方法替代上面的写法。\n\nconst f = () => console.log('now');\npromise.try(f);\nconsole.log('next');\n// now\n// next\n\n\n1\n2\n3\n4\n5\n\n\n事实上，promise.try存在已久，promise 库bluebird、q和when，早就提供了这个方法。\n\n由于promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。\n\nfunction getusername(userid) {\n  return database.users.get({id: userid})\n  .then(function(user) {\n    return user.name;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，database.users.get()返回一个 promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。\n\ndatabase.users.get({id: userid})\n.then(...)\n.catch(...)\n\n\n1\n2\n3\n\n\n但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。\n\ntry {\n  database.users.get({id: userid})\n  .then(...)\n  .catch(...)\n} catch (e) {\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。\n\npromise.try(() => database.users.get({id: userid}))\n  .then(...)\n  .catch(...)\n\n\n1\n2\n3\n\n\n事实上，promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。\n\n\n# 应用实例\n\n加载图片\n\n我们可以将图片的加载写成一个promise，一旦加载完成，promise的状态就发生变化。\n\nconst preloadimage = function (path) {\n  return new promise(function (resolve, reject) {\n    const image = new image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ngenerator 函数与 promise 的结合\n\n使用 generator 函数管理流程，遇到异步操作的时候，通常返回一个promise对象\n\nfunction getfoo () {\n  return new promise(function (resolve, reject){\n    resolve('foo');\n  });\n}\n\nconst g = function* () {\n  try {\n    const foo = yield getfoo();\n    console.log(foo);\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nfunction run (generator) {\n  const it = generator();\n\n  function go(result) {\n    if (result.done) return result.value;\n\n    return result.value.then(function (value) {\n      return go(it.next(value));\n    }, function (error) {\n      return go(it.throw(error));\n    });\n  }\n\n  go(it.next());\n}\n\nrun(g);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码的 generator 函数g之中，有一个异步操作getfoo，它返回的就是一个promise对象。函数run用来处理这个promise对象，并调用下一个next方法。",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"vs快捷键",frontmatter:{title:"vs快捷键",date:"2022-11-25T13:04:12.000Z",permalink:"/pages/83b396/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/01.vscode/01.vs%E5%BF%AB%E6%8D%B7%E9%94%AE.html",relativePath:"02.软件框架/01.vscode/01.vs快捷键.md",key:"v-8f948314",path:"/pages/83b396/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"webpack构建工具",frontmatter:{title:"webpack构建工具",date:"2022-12-07T09:30:43.000Z",permalink:"/pages/c60c2c/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/04.vue/01.heima/01.webpack%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html",relativePath:"02.软件框架/04.vue/01.heima/01.webpack构建工具.md",key:"v-5206eee8",path:"/pages/c60c2c/",headers:[{level:2,title:"webpack构建工具",slug:"webpack构建工具",normalizedTitle:"webpack构建工具",charIndex:2},{level:2,title:"模块化",slug:"模块化",normalizedTitle:"模块化",charIndex:53},{level:2,title:"QA",slug:"qa",normalizedTitle:"qa",charIndex:333}],headersStr:"webpack构建工具 模块化 QA",content:"# webpack构建工具\n\n * 减少文件数量\n * 缩减代码体积\n * 提高浏览器打开的速度\n\n\n# 模块化\n\n * commonJs规范\n   \n   // 社区规范\n   // 导出\n   module.exports = {}\n   // 导入\n   const xxx = require\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * ES6规范\n   \n   // 官方规范\n   export //单个导出\n   export default {} //默认导出\n   // 导入\n   import xxx from 'xxx'\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# QA\n\n什么是webpack\n\nwebpack 是一个打包模块化 javascript 的工具，在webpack 里一切文件皆模块，通过loader转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，webpack 专注构建模块化项目\n\nwebpack的优点是什么\n\n 1. 专注处理模块化的项目，能做到开箱即用，一步到位\n 2. 通过 plugin 扩展，完整好用又不失灵活\n 3. 通过 loaders 扩展，可以让 webpack 把所有类型的文件都解析打包\n 4. 区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展\n\nwebpack的构建流程是什么？从读取配置到输出文件这个过程说全\n\nwebpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程\n\n 1. 初始化参数：从配置文件读取与合并参数，得到最终的参数\n 2. 开始编译：从上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，开始执行编译\n 3. 确定入口：根据配置中的 entry 找出所有入口文件\n 4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤指导所有入口依赖的文件都经过了本步骤的处理\n 5. 完成模块编译：在经过第四步使用 Loader 编译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系\n 6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk ，再把每个 Chunk 转换成一个单独的文件加入到传输列表，这步是可修改输出内容的最后机会\n 7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件名写入到文件系统",normalizedContent:"# webpack构建工具\n\n * 减少文件数量\n * 缩减代码体积\n * 提高浏览器打开的速度\n\n\n# 模块化\n\n * commonjs规范\n   \n   // 社区规范\n   // 导出\n   module.exports = {}\n   // 导入\n   const xxx = require\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * es6规范\n   \n   // 官方规范\n   export //单个导出\n   export default {} //默认导出\n   // 导入\n   import xxx from 'xxx'\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# qa\n\n什么是webpack\n\nwebpack 是一个打包模块化 javascript 的工具，在webpack 里一切文件皆模块，通过loader转换文件，通过 plugin 注入钩子，最后输出由多个模块组合成的文件，webpack 专注构建模块化项目\n\nwebpack的优点是什么\n\n 1. 专注处理模块化的项目，能做到开箱即用，一步到位\n 2. 通过 plugin 扩展，完整好用又不失灵活\n 3. 通过 loaders 扩展，可以让 webpack 把所有类型的文件都解析打包\n 4. 区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展\n\nwebpack的构建流程是什么？从读取配置到输出文件这个过程说全\n\nwebpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程\n\n 1. 初始化参数：从配置文件读取与合并参数，得到最终的参数\n 2. 开始编译：从上一步得到的参数初始化 compiler 对象，加载所有配置的插件，开始执行编译\n 3. 确定入口：根据配置中的 entry 找出所有入口文件\n 4. 编译模块：从入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤指导所有入口依赖的文件都经过了本步骤的处理\n 5. 完成模块编译：在经过第四步使用 loader 编译完所有模块后，得到了每个模块被翻译后的最终内容以及他们之间的依赖关系\n 6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk ，再把每个 chunk 转换成一个单独的文件加入到传输列表，这步是可修改输出内容的最后机会\n 7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件名写入到文件系统",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Vue快速开始",frontmatter:{title:"Vue快速开始",date:"2022-12-07T10:09:35.000Z",permalink:"/pages/2e2311/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/04.vue/01.heima/02.Vue%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html",relativePath:"02.软件框架/04.vue/01.heima/02.Vue快速开始.md",key:"v-cd74352a",path:"/pages/2e2311/",headers:[{level:2,title:"Vue常用指令",slug:"vue常用指令",normalizedTitle:"vue常用指令",charIndex:2},{level:3,title:"插值表达式",slug:"插值表达式",normalizedTitle:"插值表达式",charIndex:14},{level:3,title:"MVVM设计模式",slug:"mvvm设计模式",normalizedTitle:"mvvm设计模式",charIndex:474},{level:3,title:"V-bind",slug:"v-bind",normalizedTitle:"v-bind",charIndex:685},{level:3,title:"V-on",slug:"v-on",normalizedTitle:"v-on",charIndex:790},{level:3,title:"事件对象 $event",slug:"事件对象-event",normalizedTitle:"事件对象 $event",charIndex:914},{level:3,title:"v-on事件修饰符",slug:"v-on事件修饰符",normalizedTitle:"v-on事件修饰符",charIndex:1317},{level:3,title:"v-model",slug:"v-model",normalizedTitle:"v-model",charIndex:1470},{level:3,title:"v-text/v-html",slug:"v-text-v-html",normalizedTitle:"v-text/v-html",charIndex:2926},{level:3,title:"v-show/v-if",slug:"v-show-v-if",normalizedTitle:"v-show/v-if",charIndex:2981},{level:3,title:"v-for",slug:"v-for",normalizedTitle:"v-for",charIndex:3053},{level:2,title:"vue相关属性方法",slug:"vue相关属性方法",normalizedTitle:"vue相关属性方法",charIndex:3362},{level:3,title:"动态class",slug:"动态class",normalizedTitle:"动态class",charIndex:3376},{level:3,title:"动态 style",slug:"动态-style",normalizedTitle:"动态 style",charIndex:3431},{level:3,title:"vue过滤器",slug:"vue过滤器",normalizedTitle:"vue过滤器",charIndex:3491},{level:3,title:"Vue计算属性",slug:"vue计算属性",normalizedTitle:"vue计算属性",charIndex:3677},{level:3,title:"Vue监听器",slug:"vue监听器",normalizedTitle:"vue监听器",charIndex:3848},{level:2,title:"Vue组件通信",slug:"vue组件通信",normalizedTitle:"vue组件通信",charIndex:4165},{level:3,title:"父传子通信",slug:"父传子通信",normalizedTitle:"父传子通信",charIndex:4177},{level:3,title:"子向父通信",slug:"子向父通信",normalizedTitle:"子向父通信",charIndex:4580},{level:3,title:"兄弟组件通信",slug:"兄弟组件通信",normalizedTitle:"兄弟组件通信",charIndex:5217},{level:2,title:"组件生命周期",slug:"组件生命周期",normalizedTitle:"组件生命周期",charIndex:5256},{level:3,title:"阶段函数",slug:"阶段函数",normalizedTitle:"阶段函数",charIndex:5267},{level:2,title:"组件进阶概念",slug:"组件进阶概念",normalizedTitle:"组件进阶概念",charIndex:5425},{level:3,title:"动态组件",slug:"动态组件",normalizedTitle:"动态组件",charIndex:5436},{level:3,title:"组件缓存/激活非激活生命周期函数",slug:"组件缓存-激活非激活生命周期函数",normalizedTitle:"组件缓存/激活非激活生命周期函数",charIndex:5843},{level:2,title:"组件插槽",slug:"组件插槽",normalizedTitle:"组件插槽",charIndex:6313},{level:3,title:"具名插槽",slug:"具名插槽",normalizedTitle:"具名插槽",charIndex:6420},{level:3,title:"作用域插槽",slug:"作用域插槽",normalizedTitle:"作用域插槽",charIndex:6583},{level:2,title:"Vue自定义指令",slug:"vue自定义指令",normalizedTitle:"vue自定义指令",charIndex:6958},{level:3,title:"自定义指令传值",slug:"自定义指令传值",normalizedTitle:"自定义指令传值",charIndex:7115},{level:2,title:"$nextTick/$refs",slug:"nexttick-refs",normalizedTitle:"$nexttick/$refs",charIndex:7771}],headersStr:"Vue常用指令 插值表达式 MVVM设计模式 V-bind V-on 事件对象 $event v-on事件修饰符 v-model v-text/v-html v-show/v-if v-for vue相关属性方法 动态class 动态 style vue过滤器 Vue计算属性 Vue监听器 Vue组件通信 父传子通信 子向父通信 兄弟组件通信 组件生命周期 阶段函数 组件进阶概念 动态组件 组件缓存/激活非激活生命周期函数 组件插槽 具名插槽 作用域插槽 Vue自定义指令 自定义指令传值 $nextTick/$refs",content:'# Vue常用指令\n\n\n# 插值表达式\n\n声明式渲染/文本插值\n\n{{表达式}}\n\n<template>\n  <div>\n    <h1>{{ msg }}</h1> //可以是变量\n    <h2>{{ obj.name }}</h2> //可以是对象.属性\n    <h3>{{ obj.age > 18 ? \'成年\' : \'未成年\' }}</h3>  //可以是表达式\n  </div>\n</template>\n\n<script>\nexport default {\n  data() { // 格式固定, 定义vue数据之处\n    return { //固定格式，返回一个数据对象\n      msg: "hello, vue", // key相当于变量名\n      obj: {\n        name: "小vue",\n        age: 5\n      }\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# MVVM设计模式\n\n * M：model 数据模型 （data）\n * V：view视图（html页面）\n * VM：ViewModel视图模型（vue.js）\n\nMVVM 通过 数据双向绑定 让数据自动地双向同步，不需要操作DOM\n\n> 联系：React是单向数据流，需要通过添加事件处理函数（即受控或非受控组件的事件处理来完成数据和视图一致）。在Vue中不需要这么做，大大减少了对DOM的操作，提高了开发效率\n\n\n# V-bind\n\n语法：v-bind:属性名="vue变量"\n\n简写形式：:\n\n代码示例\n\n<img v-bind:src="url"/>\n//简写\n<img :src="url"/>\n\n\n1\n2\n3\n\n\n\n# V-on\n\n语法：v-on:事件名="methods"\n\n简写形式：@\n\n代码示例\n\n<button v-on:click="count=count+1"/>\n<button @click="count=count+1"/>\n\n\n1\n2\n\n\n\n# 事件对象 $event\n\n系统会自动传递事件对象 e\n\n<a @click="one" href="http://www.baidu.com">百度</a>\n<a @click="two(10, $event)" href="http://www.taobao.com">淘宝</a>\n<script>\nexport default {\n  methods: {\n    // 1. 事件触发, 无传值, 可以直接获取事件对象是\n    one(e){\n      e.preventDefault()\n    },\n    // 2. 事件触发, 传值, 需要手动传入$event\n    two(num, e){\n      e.preventDefault()\n    }\n  }\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# v-on事件修饰符\n\n * .stop 阻止事件冒泡\n * .prevent 阻止默认行为\n * .once 只执行一次\n * .enter 检测回车键\n * .esc 检测返回键\n\n代码示例\n\n <input type="text" @keydown.enter="enterFn">\n\n\n1\n\n\n\n# v-model\n\nv-model 是实现vue变量和表单标签 value 属性，双向绑定的指令\n\n <input type="text" v-model="username">\n\n\n1\n\n\n代码示例\n\n不同表单标签 v-model 绑定的值\n\n<template>\n  <div>\n    <div>\n      <span>来自于: </span>\n      \x3c!-- 下拉菜单要绑定在select上 --\x3e\n      <select v-model="from">\n        <option value="北京市">北京</option>\n        <option value="南京市">南京</option>\n        <option value="天津市">天津</option>\n      </select>\n    </div>\n    <div>\n      \x3c!-- (重要)\n      遇到复选框, v-model的变量值\n      非数组 - 关联的是复选框的checked属性（只要选中一个复选框，就会把checked的值true给此变量）\n      数组   - 关联的是复选框的value属性\n       --\x3e\n      <span>爱好: </span>\n      <input type="checkbox" v-model="hobby" value="抽烟">抽烟\n      <input type="checkbox" v-model="hobby" value="喝酒">喝酒\n      <input type="checkbox" v-model="hobby" value="写代码">写代码\n    </div>\n    <div>\n      <span>性别: </span>\n      <input type="radio" value="男" name="sex" v-model="gender">男\n      <input type="radio" value="女" name="sex" v-model="gender">女\n    </div>\n    <div>\n      <span>自我介绍</span>\n      <textarea v-model="intro"></textarea>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data(){\n    return {\n      from: "",\n      //hobby:"", //默认是空字符串，但是只要勾选一个复选框，此值即为true\n      hobby: [],\n      gender: "男",\n      intro: ""\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n该指令也有一些功能修饰符\n\n * .number 以parseFloat转成数字类型\n * .trim 去除首尾空白字符\n * .lazy 在change时触发而非inupt时\n\n\n# v-text/v-html\n\nv-text把值当成普通字符串显示, v-html把值当做html解析\n\n\n# v-show/v-if\n\n * v-show 用的display:none隐藏 (频繁切换使用)\n * v-if 直接从DOM树上移除\n\n\n# v-for\n\n<li v-for="(item, index) in arr" :key="index">\n  {{ item }} ---- {{ index }}\n</li>\n\n\n1\n2\n3\n\n\n这些方法会触发数组改变, v-for会监测到并更新页面（以下即为数组的变更方法）\n\n * push()\n * pop()\n * shift()\n * unshift()\n * splice()\n * sort()\n * reverse()\n\n这些方法不会触发v-for更新\n\n * slice()\n * filter()\n * concat()\n\n数组变更才会引起界面变化，源地址发生改变才会引起UI发生变化\n\n\n# vue相关属性方法\n\n\n# 动态class\n\n将 class 值设置为动态\n\n<div :class{xxx:boolean}>\n\n\n# 动态 style\n\n将内置 style 设置为动态\n\n<div :style="{css属性:css值}"/>\n\n\n# vue过滤器\n\n定义\n\n * 全局：Vue.filter(\'name\',(args)=>{return newValue})\n * 局部：filters:{name:(args)=>{return newValue}}\n\n声明\n\n * {{value | filterName(args)}}\n * :src="value | filterName(args)"\n\n\n# Vue计算属性\n\n一个变量的值, 需要用另外变量计算而得来\n\ncomputed，定义时是一个函数，但本质上是一个属性（使用时不加小括号）\n\ncomputed: { //computed: 计算\n    "计算属性名" () {\n        return "值" // 必须将最终结果返回\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# Vue监听器\n\n可以侦听data/computed属性值改变\n\nwatch: {\n    "被侦听的属性名" (newVal, oldVal){\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n深度监听 - 立即执行\n\nwatch: {\n    "要侦听的属性名": {\n        handler (newVal, oldVal) { //这个handler就是之前的简写形式\n        },   \n        deep: true, // 深度侦听复杂类型内变化\n        immediate: true, // 立即执行     \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Vue组件通信\n\n\n# 父传子通信\n\n子组件\n\n<template>\n  <div class="my-product">\n     \n    <h3>标题: {{ title }}</h3>\n    <p>价格: {{ price }}元</p>\n    <p>{{ intro }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n   //PS：props与data，computed都是变量，所以可以在上方通过插值表达式显示\n  props: [\'title\', \'price\', \'intro\']\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n父组件\n\n <Product title="好吃的口水鸡" price="50" intro="开业大酬宾, 全场8折"></Product>\n\n\n1\n\n\n\n# 子向父通信\n\n子组件\n\n<template>\n  <div class="my-product">\n    <h3>标题: {{ title }}</h3>\n    <p>价格: {{ price }}元</p>\n    <p>{{ intro }}</p>\n    <button @click="subFn">宝刀-砍1元</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: [\'index\', \'title\', \'price\', \'intro\'],\n  methods: {\n    subFn(){\n      //2.通过$emit触发父组件事件\n      this.$emit(\'subprice\', this.index, 1) // 子向父\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n父组件\n\n<template>\n\t<Myproduct\n   @subprice="fn">\n  </Myproduct>\n</template>\n\n\n<script>\n\tmethods: {\n    fn(inde, price){\n      //...\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 兄弟组件通信\n\nevent-bus\n\n使用较不方便，推荐使用vuex\n\n\n# 组件生命周期\n\n\n# 阶段函数\n\n阶段    方法名             方法名\n初始化   beforeCreate    created\n挂载    beforeMount     mounted\n更新    beforeUpdate    updated\n销毁    beforeDestroy   destroyed\n\n\n# 组件进阶概念\n\n\n# 动态组件\n\n <p>下面显示注册组件-动态切换:</p>\n <div style="border: 1px solid red;">\n     //PS： 如果comName是UserName，则显示UserName组件，反之则显示UserInfo\n     <component :is="comName"></component>\n </div>\n\n<script>\nexport default {\n    data(){\n        return {\n            comName: "UserName"\n        }\n    },\n    components: {\n        UserName,\n        UserInfo\n    }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 组件缓存/激活非激活生命周期函数\n\n<keep-alive> // keep-alive：保持-活着\n    <component :is="xxx"></component>\n</keep-alive>\n<script>\nexport default {\n    created(){\n        console.log("02-UserName-创建");\n    },\n    destroyed(){\n        console.log("02-UserName-销毁");\n    },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n被缓存的组件不再创建和销毁, 而是激活和非激活\n\n// 组件缓存下 - 多了2个钩子函数\nactivated(){\n    console.log("02-UserName-激活");\n},\ndeactivated(){\n    console.log("02-UserName-失去激活");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 组件插槽\n\n<slot>\n\n<Pannel>\n\t<div>\n    插槽填充\n  </div>\n</Pannel>\n\n\n1\n2\n3\n4\n5\n\n\n会替换组件中的 <slot> 标签，此标签里可以写默认的结构\n\n\n# 具名插槽\n\n当一个组件内有2处以上需要外部传入标签的地方\n\n<slot name="title"/>\n\n<Pannel>\n\t<template v-slot:title>\n  \t<div>\n      title\n    </div>\n  </template>\n</Pannel>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 作用域插槽\n\n父组件想使用子组件插槽里的数据\n\n父组件\n\n<Pannel>\n\t<template v-slot="scope">\n\t\t{{scope.row.defaultTwo}}\n  </template>\n</Pannel>\n\n\n1\n2\n3\n4\n5\n\n\n子组件\n\n<div class >\n  <slot :row="defaultObj">{{default.defaultOne}}</slot>\n</div>\n\n\n1\n2\n3\n\n\n * 在slot 标签上绑定自定义属性和子组件内的值\n\n * 组件使用 v-slot="变量名绑定"\n\n * 变量名绑定后会获取到插槽中的值 ，可直接使用\n   \n   {{scope.row.defaultTwo}}\n   \n   \n   1\n   \n\n可以让组件更加灵活的适用于不同的场景和项目\n\n\n# Vue自定义指令\n\n * 全局注册\n\nVue.directive("指令名",{\n\t"inserted"(el){\n\n\t}\n})\n\n\n1\n2\n3\n4\n5\n\n * 局部注册\n\ndirectives:{\n\t"指令名":{\n\t\tinserted(el){\n\t\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 自定义指令传值\n\n// 目标: 自定义指令传值\nVue.directive(\'color\', {\n  inserted(el, binding) { //binding里边存储了指令的很多信息，binding.value存储的是指令传递过来的数据，比如下边的colorStr变量\n    el.style.color = binding.value\n  },\n\t// 注意:\n\t// inserted方法 - 指令所在标签, 被插入到网页上触发(一次)\n\t// update方法 - 指令对应数据/标签更新时, 此方法执行\n  update(el, binding) { //数据更新时，执行此方法（如果不写这个方法，那么colorStr变量改变值，颜色不会发生改变）\n    el.style.color = binding.value\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n<p v-color="colorStr" @click="changeColor">修改文字颜色</p>\n\n<script>\n  data() {\n    return {\n      colorStr: "red",\n    };\n  },\n  methods: {\n    changeColor() {\n      this.colorStr = \'blue\';\n    },\n  },\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# $nextTick/$refs\n\n$refs\n\n<h1 ref = "myH1">\n  \n</h1>\n\n<script>\n\tmounted(){\n    console.log(this.$refs.myH1)\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n可以访问该 DOM 所有的属性和方法\n\n$nextTick\n\n点击搜索按钮自身隐藏，出现输入框并马上处于激活状态\n\n<template>\n  <div>\n      <input ref="myInp" type="text" placeholder="这是一个输入框" v-if="isShow">\n      <button v-else @click="btn">点击我进行搜索</button>\n  </div>\n</template>\n\n<script>\n// 目标: 点按钮(消失) - 输入框出现并聚焦\n// 1. 获取到输入框\n// 2. 输入框调用事件方法focus()达到聚焦行为\nexport default {\n    data(){\n        return {\n            isShow: false\n        }\n    },\n    methods: {\n        //注意函数内使用await，需要添加async\n        async btn(){\n            this.isShow = true;\n            // this.$refs.myInp.focus() //PS：会报错，myInp是undefined\n            // 原因: data变化更新DOM是异步的\n            // 输入框还没有挂载到真实DOM上\n            // 解决:\n            // this.$nextTick(() => {\n            //     this.$refs.myInp.focus()\n            // })\n            // 扩展: await取代回调函数\n            // $nextTick()原地返回Promise对象\n            await this.$nextTick() //等待执行完毕之后，再获取焦点\n            this.$refs.myInp.focus()\n        }\n    }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n',normalizedContent:'# vue常用指令\n\n\n# 插值表达式\n\n声明式渲染/文本插值\n\n{{表达式}}\n\n<template>\n  <div>\n    <h1>{{ msg }}</h1> //可以是变量\n    <h2>{{ obj.name }}</h2> //可以是对象.属性\n    <h3>{{ obj.age > 18 ? \'成年\' : \'未成年\' }}</h3>  //可以是表达式\n  </div>\n</template>\n\n<script>\nexport default {\n  data() { // 格式固定, 定义vue数据之处\n    return { //固定格式，返回一个数据对象\n      msg: "hello, vue", // key相当于变量名\n      obj: {\n        name: "小vue",\n        age: 5\n      }\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# mvvm设计模式\n\n * m：model 数据模型 （data）\n * v：view视图（html页面）\n * vm：viewmodel视图模型（vue.js）\n\nmvvm 通过 数据双向绑定 让数据自动地双向同步，不需要操作dom\n\n> 联系：react是单向数据流，需要通过添加事件处理函数（即受控或非受控组件的事件处理来完成数据和视图一致）。在vue中不需要这么做，大大减少了对dom的操作，提高了开发效率\n\n\n# v-bind\n\n语法：v-bind:属性名="vue变量"\n\n简写形式：:\n\n代码示例\n\n<img v-bind:src="url"/>\n//简写\n<img :src="url"/>\n\n\n1\n2\n3\n\n\n\n# v-on\n\n语法：v-on:事件名="methods"\n\n简写形式：@\n\n代码示例\n\n<button v-on:click="count=count+1"/>\n<button @click="count=count+1"/>\n\n\n1\n2\n\n\n\n# 事件对象 $event\n\n系统会自动传递事件对象 e\n\n<a @click="one" href="http://www.baidu.com">百度</a>\n<a @click="two(10, $event)" href="http://www.taobao.com">淘宝</a>\n<script>\nexport default {\n  methods: {\n    // 1. 事件触发, 无传值, 可以直接获取事件对象是\n    one(e){\n      e.preventdefault()\n    },\n    // 2. 事件触发, 传值, 需要手动传入$event\n    two(num, e){\n      e.preventdefault()\n    }\n  }\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# v-on事件修饰符\n\n * .stop 阻止事件冒泡\n * .prevent 阻止默认行为\n * .once 只执行一次\n * .enter 检测回车键\n * .esc 检测返回键\n\n代码示例\n\n <input type="text" @keydown.enter="enterfn">\n\n\n1\n\n\n\n# v-model\n\nv-model 是实现vue变量和表单标签 value 属性，双向绑定的指令\n\n <input type="text" v-model="username">\n\n\n1\n\n\n代码示例\n\n不同表单标签 v-model 绑定的值\n\n<template>\n  <div>\n    <div>\n      <span>来自于: </span>\n      \x3c!-- 下拉菜单要绑定在select上 --\x3e\n      <select v-model="from">\n        <option value="北京市">北京</option>\n        <option value="南京市">南京</option>\n        <option value="天津市">天津</option>\n      </select>\n    </div>\n    <div>\n      \x3c!-- (重要)\n      遇到复选框, v-model的变量值\n      非数组 - 关联的是复选框的checked属性（只要选中一个复选框，就会把checked的值true给此变量）\n      数组   - 关联的是复选框的value属性\n       --\x3e\n      <span>爱好: </span>\n      <input type="checkbox" v-model="hobby" value="抽烟">抽烟\n      <input type="checkbox" v-model="hobby" value="喝酒">喝酒\n      <input type="checkbox" v-model="hobby" value="写代码">写代码\n    </div>\n    <div>\n      <span>性别: </span>\n      <input type="radio" value="男" name="sex" v-model="gender">男\n      <input type="radio" value="女" name="sex" v-model="gender">女\n    </div>\n    <div>\n      <span>自我介绍</span>\n      <textarea v-model="intro"></textarea>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data(){\n    return {\n      from: "",\n      //hobby:"", //默认是空字符串，但是只要勾选一个复选框，此值即为true\n      hobby: [],\n      gender: "男",\n      intro: ""\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n该指令也有一些功能修饰符\n\n * .number 以parsefloat转成数字类型\n * .trim 去除首尾空白字符\n * .lazy 在change时触发而非inupt时\n\n\n# v-text/v-html\n\nv-text把值当成普通字符串显示, v-html把值当做html解析\n\n\n# v-show/v-if\n\n * v-show 用的display:none隐藏 (频繁切换使用)\n * v-if 直接从dom树上移除\n\n\n# v-for\n\n<li v-for="(item, index) in arr" :key="index">\n  {{ item }} ---- {{ index }}\n</li>\n\n\n1\n2\n3\n\n\n这些方法会触发数组改变, v-for会监测到并更新页面（以下即为数组的变更方法）\n\n * push()\n * pop()\n * shift()\n * unshift()\n * splice()\n * sort()\n * reverse()\n\n这些方法不会触发v-for更新\n\n * slice()\n * filter()\n * concat()\n\n数组变更才会引起界面变化，源地址发生改变才会引起ui发生变化\n\n\n# vue相关属性方法\n\n\n# 动态class\n\n将 class 值设置为动态\n\n<div :class{xxx:boolean}>\n\n\n# 动态 style\n\n将内置 style 设置为动态\n\n<div :style="{css属性:css值}"/>\n\n\n# vue过滤器\n\n定义\n\n * 全局：vue.filter(\'name\',(args)=>{return newvalue})\n * 局部：filters:{name:(args)=>{return newvalue}}\n\n声明\n\n * {{value | filtername(args)}}\n * :src="value | filtername(args)"\n\n\n# vue计算属性\n\n一个变量的值, 需要用另外变量计算而得来\n\ncomputed，定义时是一个函数，但本质上是一个属性（使用时不加小括号）\n\ncomputed: { //computed: 计算\n    "计算属性名" () {\n        return "值" // 必须将最终结果返回\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# vue监听器\n\n可以侦听data/computed属性值改变\n\nwatch: {\n    "被侦听的属性名" (newval, oldval){\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n深度监听 - 立即执行\n\nwatch: {\n    "要侦听的属性名": {\n        handler (newval, oldval) { //这个handler就是之前的简写形式\n        },   \n        deep: true, // 深度侦听复杂类型内变化\n        immediate: true, // 立即执行     \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# vue组件通信\n\n\n# 父传子通信\n\n子组件\n\n<template>\n  <div class="my-product">\n     \n    <h3>标题: {{ title }}</h3>\n    <p>价格: {{ price }}元</p>\n    <p>{{ intro }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n   //ps：props与data，computed都是变量，所以可以在上方通过插值表达式显示\n  props: [\'title\', \'price\', \'intro\']\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n父组件\n\n <product title="好吃的口水鸡" price="50" intro="开业大酬宾, 全场8折"></product>\n\n\n1\n\n\n\n# 子向父通信\n\n子组件\n\n<template>\n  <div class="my-product">\n    <h3>标题: {{ title }}</h3>\n    <p>价格: {{ price }}元</p>\n    <p>{{ intro }}</p>\n    <button @click="subfn">宝刀-砍1元</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: [\'index\', \'title\', \'price\', \'intro\'],\n  methods: {\n    subfn(){\n      //2.通过$emit触发父组件事件\n      this.$emit(\'subprice\', this.index, 1) // 子向父\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n父组件\n\n<template>\n\t<myproduct\n   @subprice="fn">\n  </myproduct>\n</template>\n\n\n<script>\n\tmethods: {\n    fn(inde, price){\n      //...\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 兄弟组件通信\n\nevent-bus\n\n使用较不方便，推荐使用vuex\n\n\n# 组件生命周期\n\n\n# 阶段函数\n\n阶段    方法名             方法名\n初始化   beforecreate    created\n挂载    beforemount     mounted\n更新    beforeupdate    updated\n销毁    beforedestroy   destroyed\n\n\n# 组件进阶概念\n\n\n# 动态组件\n\n <p>下面显示注册组件-动态切换:</p>\n <div style="border: 1px solid red;">\n     //ps： 如果comname是username，则显示username组件，反之则显示userinfo\n     <component :is="comname"></component>\n </div>\n\n<script>\nexport default {\n    data(){\n        return {\n            comname: "username"\n        }\n    },\n    components: {\n        username,\n        userinfo\n    }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 组件缓存/激活非激活生命周期函数\n\n<keep-alive> // keep-alive：保持-活着\n    <component :is="xxx"></component>\n</keep-alive>\n<script>\nexport default {\n    created(){\n        console.log("02-username-创建");\n    },\n    destroyed(){\n        console.log("02-username-销毁");\n    },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n被缓存的组件不再创建和销毁, 而是激活和非激活\n\n// 组件缓存下 - 多了2个钩子函数\nactivated(){\n    console.log("02-username-激活");\n},\ndeactivated(){\n    console.log("02-username-失去激活");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 组件插槽\n\n<slot>\n\n<pannel>\n\t<div>\n    插槽填充\n  </div>\n</pannel>\n\n\n1\n2\n3\n4\n5\n\n\n会替换组件中的 <slot> 标签，此标签里可以写默认的结构\n\n\n# 具名插槽\n\n当一个组件内有2处以上需要外部传入标签的地方\n\n<slot name="title"/>\n\n<pannel>\n\t<template v-slot:title>\n  \t<div>\n      title\n    </div>\n  </template>\n</pannel>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 作用域插槽\n\n父组件想使用子组件插槽里的数据\n\n父组件\n\n<pannel>\n\t<template v-slot="scope">\n\t\t{{scope.row.defaulttwo}}\n  </template>\n</pannel>\n\n\n1\n2\n3\n4\n5\n\n\n子组件\n\n<div class >\n  <slot :row="defaultobj">{{default.defaultone}}</slot>\n</div>\n\n\n1\n2\n3\n\n\n * 在slot 标签上绑定自定义属性和子组件内的值\n\n * 组件使用 v-slot="变量名绑定"\n\n * 变量名绑定后会获取到插槽中的值 ，可直接使用\n   \n   {{scope.row.defaulttwo}}\n   \n   \n   1\n   \n\n可以让组件更加灵活的适用于不同的场景和项目\n\n\n# vue自定义指令\n\n * 全局注册\n\nvue.directive("指令名",{\n\t"inserted"(el){\n\n\t}\n})\n\n\n1\n2\n3\n4\n5\n\n * 局部注册\n\ndirectives:{\n\t"指令名":{\n\t\tinserted(el){\n\t\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 自定义指令传值\n\n// 目标: 自定义指令传值\nvue.directive(\'color\', {\n  inserted(el, binding) { //binding里边存储了指令的很多信息，binding.value存储的是指令传递过来的数据，比如下边的colorstr变量\n    el.style.color = binding.value\n  },\n\t// 注意:\n\t// inserted方法 - 指令所在标签, 被插入到网页上触发(一次)\n\t// update方法 - 指令对应数据/标签更新时, 此方法执行\n  update(el, binding) { //数据更新时，执行此方法（如果不写这个方法，那么colorstr变量改变值，颜色不会发生改变）\n    el.style.color = binding.value\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n<p v-color="colorstr" @click="changecolor">修改文字颜色</p>\n\n<script>\n  data() {\n    return {\n      colorstr: "red",\n    };\n  },\n  methods: {\n    changecolor() {\n      this.colorstr = \'blue\';\n    },\n  },\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# $nexttick/$refs\n\n$refs\n\n<h1 ref = "myh1">\n  \n</h1>\n\n<script>\n\tmounted(){\n    console.log(this.$refs.myh1)\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n可以访问该 dom 所有的属性和方法\n\n$nexttick\n\n点击搜索按钮自身隐藏，出现输入框并马上处于激活状态\n\n<template>\n  <div>\n      <input ref="myinp" type="text" placeholder="这是一个输入框" v-if="isshow">\n      <button v-else @click="btn">点击我进行搜索</button>\n  </div>\n</template>\n\n<script>\n// 目标: 点按钮(消失) - 输入框出现并聚焦\n// 1. 获取到输入框\n// 2. 输入框调用事件方法focus()达到聚焦行为\nexport default {\n    data(){\n        return {\n            isshow: false\n        }\n    },\n    methods: {\n        //注意函数内使用await，需要添加async\n        async btn(){\n            this.isshow = true;\n            // this.$refs.myinp.focus() //ps：会报错，myinp是undefined\n            // 原因: data变化更新dom是异步的\n            // 输入框还没有挂载到真实dom上\n            // 解决:\n            // this.$nexttick(() => {\n            //     this.$refs.myinp.focus()\n            // })\n            // 扩展: await取代回调函数\n            // $nexttick()原地返回promise对象\n            await this.$nexttick() //等待执行完毕之后，再获取焦点\n            this.$refs.myinp.focus()\n        }\n    }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"vue生态技术Router",frontmatter:{title:"vue生态技术Router",date:"2022-12-08T18:27:35.000Z",permalink:"/pages/017a2c/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/04.vue/01.heima/03.vue%E7%94%9F%E6%80%81%E6%8A%80%E6%9C%AFRouter.html",relativePath:"02.软件框架/04.vue/01.heima/03.vue生态技术Router.md",key:"v-30976638",path:"/pages/017a2c/",headers:[{level:2,title:"Vue-Router",slug:"vue-router",normalizedTitle:"vue-router",charIndex:2},{level:2,title:"声明式导航",slug:"声明式导航",normalizedTitle:"声明式导航",charIndex:591},{level:2,title:"路由重定向和模式",slug:"路由重定向和模式",normalizedTitle:"路由重定向和模式",charIndex:1716},{level:2,title:"编程式导航",slug:"编程式导航",normalizedTitle:"编程式导航",charIndex:2080},{level:2,title:"路由守卫",slug:"路由守卫",normalizedTitle:"路由守卫",charIndex:2457}],headersStr:"Vue-Router 声明式导航 路由重定向和模式 编程式导航 路由守卫",content:'# Vue-Router\n\n单页面应用(SPA): 所有功能在一个html页面上实现 （Single Page Application）\n\n * yarn add vue-router\n\n * import VueRouter from \'vue-roter\' --main.js\n\n * Vue.use(VueRoter) -- main.js\n\n * const routes = [\n   \t{\n   \t\tpath:\'/home\',\n   \t\tcomponent:Home\n   \t},\n   \t{\n   \t\tpath:\'/my\',\n   \t\tcomponent:My\n   \t}\n   ]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * const router = new VueRouter({routes}) --main.js\n\n * 挂载 Vue 实例 ：new Vue({router,render:h=>h(App)}).$mount(\'#app\')\n\n * App.vue 替换\n   \n   <template>\n   \t<router-view></router-view>\n   </template>\n   \n   \n   1\n   2\n   3\n   \n\n\n# 声明式导航\n\nrouter-link提供了声明式导航高亮的功能(自带类名)\n\n<router-link to="/find">发现音乐</router-link>\n\n路由传参\n\n{ path: "/part/:username", // 有:的路径代表要接收具体的值 component: Part }\n\n<template>\n  <div>\n      <p>关注明星</p>\n      <p>发现精彩</p>\n      <p>寻找伙伴</p>\n      <p>加入我们</p>\n      <p>人名: {{ $route.query.name }} -- {{ $route.params.username }}</p>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n<router-link to="/part?name=小传&age=18">朋友-小传</router-link>\n<router-link to="/part/小智">朋友-小智</router-link>\n\n\n1\n2\n\n\n> ?key=value 用$route.query.key 取值\n> \n> /值 提前在路由规则/path/:key 用$route.params.key 取值\n\n路由嵌套\n\nconst routes = [\n  // ...省略其他\n  {\n    path: "/find",\n    name: "Find",\n    component: Find,\n    children: [\n      {\n        path: "recommend",\n        component: Recommend\n      },\n      {\n        path: "ranking",\n        component: Ranking\n      },\n      {\n        path: "songlist",\n        component: SongList\n      }\n    ]\n  }\n  // ...省略其他\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n路由匹配\n\nrouter-link自带的2个类名\n\n * router-link-exact-active (精确匹配) url中hash值路径, 与href属性值完全相同, 设置此类名\n\n * router-link-active (模糊匹配) url中hash值, 包含href属性值这个路径\n\n\n# 路由重定向和模式\n\n//main.js中增加\n  {\n    path: "/", // 默认hash值路径\n    redirect: "/find" // 重定向到/find\n    // 浏览器url中#后的路径被改变成/find-重新匹配数组规则\n  }\n\n\n1\n2\n3\n4\n5\n6\n\n\n设置重定向\n\n404\n\nimport NotFound from \'@/views/NotFound\'\n\nconst routes = [\n  // ...省略了其他配置\n  // 404在最后(规则是从前往后逐个比较path)\n  {\n    path: "*",\n    component: NotFound\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n模式\n\n * hash\n * history\n\n\n# 编程式导航\n\nJS 跳转\n\nthis.$router.push({\n    path: "路由路径", // 都去 router/index.js定义\n    name: "路由名"\n})\n\n\n1\n2\n3\n4\n\n\n传参\n\noneBtn(){\n  this.$router.push({\n    name: \'Part\',// /part/小传\n    params: {\n      username: \'小传\'\n    }\n  })\n},\ntwoBtn(){\n  this.$router.push({\n    name: \'Part\', // /part?name=小智\n    query: {\n      name: \'小智\'\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 路由守卫\n\n路由跳转之前, 先执行一次前置守卫函数, 判断是否可以正常跳转\n\nrouter.beforeEach(to,from,next)=>{}\n\n// 目标: 路由守卫\n// 场景: 当你要对路由权限判断时\n// 语法: router.beforeEach((to, from, next)=>{//路由跳转"之前"先执行这里, 决定是否跳转})\n// 参数1: 要跳转到的路由 (路由对象信息)    目标\n// 参数2: 从哪里跳转的路由 (路由对象信息)  来源\n// 参数3: 函数体 - next()才会让路由正常的跳转切换, next(false)在原地停留, next("强制修改到另一个路由路径上")\n// 注意: 如果不调用next, 页面留在原地\n\n// 例子: 判断用户是否登录, 是否决定去"我的音乐"/my\nconst isLogin = true; // 登录状态(未登录)\nrouter.beforeEach((to, from, next) => {\n  if (to.path === "/my" && isLogin === false) {\n    alert("请登录")\n    next(false) // 阻止路由跳转\n  } else {\n    next() // 正常放行\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:'# vue-router\n\n单页面应用(spa): 所有功能在一个html页面上实现 （single page application）\n\n * yarn add vue-router\n\n * import vuerouter from \'vue-roter\' --main.js\n\n * vue.use(vueroter) -- main.js\n\n * const routes = [\n   \t{\n   \t\tpath:\'/home\',\n   \t\tcomponent:home\n   \t},\n   \t{\n   \t\tpath:\'/my\',\n   \t\tcomponent:my\n   \t}\n   ]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * const router = new vuerouter({routes}) --main.js\n\n * 挂载 vue 实例 ：new vue({router,render:h=>h(app)}).$mount(\'#app\')\n\n * app.vue 替换\n   \n   <template>\n   \t<router-view></router-view>\n   </template>\n   \n   \n   1\n   2\n   3\n   \n\n\n# 声明式导航\n\nrouter-link提供了声明式导航高亮的功能(自带类名)\n\n<router-link to="/find">发现音乐</router-link>\n\n路由传参\n\n{ path: "/part/:username", // 有:的路径代表要接收具体的值 component: part }\n\n<template>\n  <div>\n      <p>关注明星</p>\n      <p>发现精彩</p>\n      <p>寻找伙伴</p>\n      <p>加入我们</p>\n      <p>人名: {{ $route.query.name }} -- {{ $route.params.username }}</p>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n<router-link to="/part?name=小传&age=18">朋友-小传</router-link>\n<router-link to="/part/小智">朋友-小智</router-link>\n\n\n1\n2\n\n\n> ?key=value 用$route.query.key 取值\n> \n> /值 提前在路由规则/path/:key 用$route.params.key 取值\n\n路由嵌套\n\nconst routes = [\n  // ...省略其他\n  {\n    path: "/find",\n    name: "find",\n    component: find,\n    children: [\n      {\n        path: "recommend",\n        component: recommend\n      },\n      {\n        path: "ranking",\n        component: ranking\n      },\n      {\n        path: "songlist",\n        component: songlist\n      }\n    ]\n  }\n  // ...省略其他\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n路由匹配\n\nrouter-link自带的2个类名\n\n * router-link-exact-active (精确匹配) url中hash值路径, 与href属性值完全相同, 设置此类名\n\n * router-link-active (模糊匹配) url中hash值, 包含href属性值这个路径\n\n\n# 路由重定向和模式\n\n//main.js中增加\n  {\n    path: "/", // 默认hash值路径\n    redirect: "/find" // 重定向到/find\n    // 浏览器url中#后的路径被改变成/find-重新匹配数组规则\n  }\n\n\n1\n2\n3\n4\n5\n6\n\n\n设置重定向\n\n404\n\nimport notfound from \'@/views/notfound\'\n\nconst routes = [\n  // ...省略了其他配置\n  // 404在最后(规则是从前往后逐个比较path)\n  {\n    path: "*",\n    component: notfound\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n模式\n\n * hash\n * history\n\n\n# 编程式导航\n\njs 跳转\n\nthis.$router.push({\n    path: "路由路径", // 都去 router/index.js定义\n    name: "路由名"\n})\n\n\n1\n2\n3\n4\n\n\n传参\n\nonebtn(){\n  this.$router.push({\n    name: \'part\',// /part/小传\n    params: {\n      username: \'小传\'\n    }\n  })\n},\ntwobtn(){\n  this.$router.push({\n    name: \'part\', // /part?name=小智\n    query: {\n      name: \'小智\'\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 路由守卫\n\n路由跳转之前, 先执行一次前置守卫函数, 判断是否可以正常跳转\n\nrouter.beforeeach(to,from,next)=>{}\n\n// 目标: 路由守卫\n// 场景: 当你要对路由权限判断时\n// 语法: router.beforeeach((to, from, next)=>{//路由跳转"之前"先执行这里, 决定是否跳转})\n// 参数1: 要跳转到的路由 (路由对象信息)    目标\n// 参数2: 从哪里跳转的路由 (路由对象信息)  来源\n// 参数3: 函数体 - next()才会让路由正常的跳转切换, next(false)在原地停留, next("强制修改到另一个路由路径上")\n// 注意: 如果不调用next, 页面留在原地\n\n// 例子: 判断用户是否登录, 是否决定去"我的音乐"/my\nconst islogin = true; // 登录状态(未登录)\nrouter.beforeeach((to, from, next) => {\n  if (to.path === "/my" && islogin === false) {\n    alert("请登录")\n    next(false) // 阻止路由跳转\n  } else {\n    next() // 正常放行\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"vue生态技术axios",frontmatter:{title:"vue生态技术axios",date:"2022-12-08T16:38:12.000Z",permalink:"/pages/9204e3/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/04.vue/01.heima/04.vue%E7%94%9F%E6%80%81%E6%8A%80%E6%9C%AFaxios.html",relativePath:"02.软件框架/04.vue/01.heima/04.vue生态技术axios.md",key:"v-f2b399c4",path:"/pages/9204e3/",headers:[{level:2,title:"axios",slug:"axios",normalizedTitle:"axios",charIndex:2}],headersStr:"axios",content:"# axios\n\naxios({\n  method:'method',\n  url:'url',\n  data:{\n    xxx:xxx\n  },\n  params:{\n    xxx:xxx\n  }\n}).then(res=>{\n  console.log(res.data)\n}).catch(err=>{\n  console.log(err)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"# axios\n\naxios({\n  method:'method',\n  url:'url',\n  data:{\n    xxx:xxx\n  },\n  params:{\n    xxx:xxx\n  }\n}).then(res=>{\n  console.log(res.data)\n}).catch(err=>{\n  console.log(err)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"vue生态技术vuex",frontmatter:{title:"vue生态技术vuex",date:"2022-11-29T15:17:54.000Z",permalink:"/pages/46ecd6/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/04.vue/01.heima/31.vue%E7%94%9F%E6%80%81%E6%8A%80%E6%9C%AFvuex.html",relativePath:"02.软件框架/04.vue/01.heima/31.vue生态技术vuex.md",key:"v-7655fbdc",path:"/pages/46ecd6/",headers:[{level:2,title:"vuex基础-介绍",slug:"vuex基础-介绍",normalizedTitle:"vuex基础-介绍",charIndex:2},{level:2,title:"vuex基础-初始化功能",slug:"vuex基础-初始化功能",normalizedTitle:"vuex基础-初始化功能",charIndex:346},{level:2,title:"vuex基础-state",slug:"vuex基础-state",normalizedTitle:"vuex基础-state",charIndex:900},{level:2,title:"vuex基础-mutations",slug:"vuex基础-mutations",normalizedTitle:"vuex基础-mutations",charIndex:1797},{level:2,title:"vuex基础-actions",slug:"vuex基础-actions",normalizedTitle:"vuex基础-actions",charIndex:3310},{level:2,title:"vuex基础-getters",slug:"vuex基础-getters",normalizedTitle:"vuex基础-getters",charIndex:4103},{level:2,title:"Vuex中的模块化-Module",slug:"vuex中的模块化-module",normalizedTitle:"vuex中的模块化-module",charIndex:4666},{level:3,title:"为什么会有模块化？",slug:"为什么会有模块化",normalizedTitle:"为什么会有模块化？",charIndex:4687},{level:3,title:"模块化的简单应用",slug:"模块化的简单应用",normalizedTitle:"模块化的简单应用",charIndex:4838},{level:3,title:"模块化中的命名空间",slug:"模块化中的命名空间",normalizedTitle:"模块化中的命名空间",charIndex:5638},{level:2,title:"vuex案例-搭建黑马头条项目",slug:"vuex案例-搭建黑马头条项目",normalizedTitle:"vuex案例-搭建黑马头条项目",charIndex:7213},{level:2,title:"vuex案例-封装分类组件和频道组件",slug:"vuex案例-封装分类组件和频道组件",normalizedTitle:"vuex案例-封装分类组件和频道组件",charIndex:8749},{level:2,title:"vuex案例-在vuex中加载分类和频道数据",slug:"vuex案例-在vuex中加载分类和频道数据",normalizedTitle:"vuex案例-在vuex中加载分类和频道数据",charIndex:10473},{level:3,title:"设计categtory和newlist的vuex模块",slug:"设计categtory和newlist的vuex模块",normalizedTitle:"设计categtory和newlist的vuex模块",charIndex:10500},{level:3,title:"分类模块下设置分类数组和当前激活分类",slug:"分类模块下设置分类数组和当前激活分类",normalizedTitle:"分类模块下设置分类数组和当前激活分类",charIndex:11208},{level:3,title:"遍历分类数据并判断激活class",slug:"遍历分类数据并判断激活class",normalizedTitle:"遍历分类数据并判断激活class",charIndex:11908},{level:3,title:"封装调用获取分类action,激活第一个分类",slug:"封装调用获取分类action-激活第一个分类",normalizedTitle:"封装调用获取分类action,激活第一个分类",charIndex:12219},{level:3,title:"定义新闻数据，并封装获取新闻的Action",slug:"定义新闻数据-并封装获取新闻的action",normalizedTitle:"定义新闻数据，并封装获取新闻的action",charIndex:13029},{level:3,title:"监听激活分类，触发获取新闻Action",slug:"监听激活分类-触发获取新闻action",normalizedTitle:"监听激活分类，触发获取新闻action",charIndex:13914},{level:3,title:"处理显示新闻内容的数据",slug:"处理显示新闻内容的数据",normalizedTitle:"处理显示新闻内容的数据",charIndex:14241}],headersStr:"vuex基础-介绍 vuex基础-初始化功能 vuex基础-state vuex基础-mutations vuex基础-actions vuex基础-getters Vuex中的模块化-Module 为什么会有模块化？ 模块化的简单应用 模块化中的命名空间 vuex案例-搭建黑马头条项目 vuex案例-封装分类组件和频道组件 vuex案例-在vuex中加载分类和频道数据 设计categtory和newlist的vuex模块 分类模块下设置分类数组和当前激活分类 遍历分类数据并判断激活class 封装调用获取分类action,激活第一个分类 定义新闻数据，并封装获取新闻的Action 监听激活分类，触发获取新闻Action 处理显示新闻内容的数据",content:"# vuex基础-介绍\n\n> 为什么会有Vuex ?\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用**集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测**的方式发生变化。\n\n * vuex是采用集中式管理组件依赖的共享数据的一个工具，可以解决不同组件数据共享问题。\n\n\n\n结论\n\n 1. 修改state状态必须通过**mutations**\n 2. **mutations**只能执行同步代码，类似ajax，定时器之类的代码不能在mutations中执行\n 3. 执行异步代码，要通过actions，然后将数据提交给mutations才可以完成\n 4. state的状态即共享数据可以在组件中引用\n 5. 组件中可以调用action\n\n\n# vuex基础-初始化功能\n\n> 建立一个新的脚手架项目, 在项目中应用vuex\n\n$ vue create  demo\n\n\n1\n\n\n> 开始vuex的初始化建立，选择模式时，选择默认模式\n\n初始化：\n\n * 第一步：npm i vuex --save => 安装到**运行时依赖** => 项目上线之后依然使用的依赖 ,开发时依赖 => 开发调试时使用\n\n> 开发时依赖 就是开开发的时候，需要的依赖，运行时依赖，项目上线运行时依然需要的\n\n * 第二步： 在main.js中 import Vuex from 'vuex'\n * 第三步：在main.js中 Vue.use(Vuex) => 调用了 vuex中的 一个install方法\n * 第四步：const store = new Vuex.Store({...配置项})\n * 第五步：在根实例配置 store 选项指向 store 实例对象\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nVue.use(vuex)\nconst store = new Vuex.Store({})\nnew Vue({\n  el: '#app',\n  store\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# vuex基础-state\n\nstate是放置所有公共状态的属性，如果你有一个公共状态数据 ， 你只需要定义在 state对象中\n\n定义state\n\n// 初始化vuex对象\nconst store = new Vuex.Store({\n  state: {\n    // 管理数据\n    count: 0\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 如何在组件中获取count?\n\n原始形式- 插值表达式\n\nApp.vue\n\n组件中可以使用 this.$store 获取到vuex中的store对象实例，可通过state属性属性获取count， 如下\n\n<div> state的数据：{{ $store.state.count }}</div>\n\n\n1\n\n\n计算属性 - 将state属性定义在计算属性中\n\n// 把state中数据，定义在组件内的计算属性中\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n\n\n <div> state的数据：{{ count }}</div>\n\n\n1\n\n\n辅助函数 - mapState\n\n> mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便用法\n\n用法 ： 第一步：导入mapState\n\nimport { mapState } from 'vuex'\n\n\n1\n\n\n第二步：采用数组形式引入state属性\n\nmapState(['count']) \n\n\n1\n\n\n> 上面代码的最终得到的是 类似\n\ncount () {\n    return this.$store.state.count\n}\n\n\n1\n2\n3\n\n\n第三步：利用延展运算符将导出的状态映射给计算属性\n\n  computed: {\n    ...mapState(['count'])\n  }\n\n\n1\n2\n3\n\n\n <div> state的数据：{{ count }}</div>\n\n\n1\n\n\n\n# vuex基础-mutations\n\n> state数据的修改只能通过mutations，并且mutations必须是同步更新，目的是形成**数据快照**\n\n数据快照：一次mutation的执行，立刻得到一种视图状态，因为是立刻，所以必须是同步\n\n定义mutations\n\nconst store  = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  // 定义mutations\n  mutations: {\n     \n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n格式说明\n\nmutations是一个对象，对象中存放修改state的方法\n\nmutations: {\n    // 方法里参数 第一个参数是当前store的state属性\n    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷\n    addCount (state) {\n      state.count += 1\n    }\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 如何在组件中调用mutations\n\n原始形式-$store\n\n> 新建组件child-a.vue，内容为一个button按钮，点击按钮调用mutations\n\n<template>\n  <button @click=\"addCount\">+1</button>\n</template>\n\n<script>\nexport default {\n    methods: {\n    //   调用方法\n      addCount () {\n         // 调用store中的mutations 提交给muations\n        // commit('muations名称', 2)\n        this.$store.commit('addCount', 10)  // 直接调用mutations\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n带参数的传递\n\n    addCount (state, payload) {\n        state.count += payload\n    }\n    this.$store.commit('addCount', 10)\n\n\n1\n2\n3\n4\n\n\n辅助函数 - mapMutations\n\n> mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入\n\nimport  { mapMutations } from 'vuex'\nmethods: {\n    ...mapMutations(['addCount'])\n}\n\n\n1\n2\n3\n4\n\n\n> 上面代码的含义是将mutations的方法导入了methods中，等同于\n\nmethods: {\n      // commit(方法名, 载荷参数)\n      addCount () {\n          this.$store.commit('addCount')\n      }\n }\n\n\n1\n2\n3\n4\n5\n6\n\n\n此时，就可以直接通过this.addCount调用了\n\n<button @click=\"addCount(100)\">+100</button>\n\n\n1\n\n\n但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中\n\n\n# vuex基础-actions\n\n> state是存放数据的，mutations是同步更新数据，actions则负责进行异步操作\n\n定义actions\n\n actions: {\n  //  获取异步的数据 context表示当前的store的实例 可以通过 context.state 获取状态 也可以通过context.commit 来提交mutations， 也可以 context.diapatch调用其他的action\n    getAsyncCount (context) {\n      setTimeout(function(){\n        // 一秒钟之后 要给一个数 去修改state\n        context.commit('addCount', 123)\n      }, 1000)\n    }\n } \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n原始调用 - $store\n\n addAsyncCount () {\n     this.$store.dispatch('getAsyncCount')\n }\n\n\n1\n2\n3\n\n\n传参调用\n\n addAsyncCount () {\n     this.$store.dispatch('getAsyncCount', 123)\n }\n\n\n1\n2\n3\n\n\n辅助函数 -mapActions\n\n> actions也有辅助函数，可以将action导入到组件中\n\nimport { mapActions } from 'vuex'\nmethods: {\n    ...mapActions(['getAsyncCount'])\n}\n\n\n1\n2\n3\n4\n\n\n直接通过 this.方法就可以调用\n\n<button @click=\"getAsyncCount(111)\">+异步</button>\n\n\n1\n\n\n\n# vuex基础-getters\n\n> 除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters\n\n例如，state中定义了list，为1-10的数组，\n\nstate: {\n    list: [1,2,3,4,5,6,7,8,9,10]\n}\n\n\n1\n2\n3\n\n\n组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它\n\n定义getters\n\n  getters: {\n    // getters函数的第一个参数是 state\n    // 必须要有返回值\n     filterList:  state =>  state.list.filter(item => item > 5)\n  }\n\n\n1\n2\n3\n4\n5\n\n\n使用getters\n\n原始方式 -$store\n\n<div>{{ $store.getters.filterList }}</div>\n\n\n1\n\n\n辅助函数 - mapGetters\n\ncomputed: {\n    ...mapGetters(['filterList'])\n}\n\n\n1\n2\n3\n\n\n <div>{{ filterList }}</div>\n\n\n1\n\n\n\n# Vuex中的模块化-Module\n\n\n# 为什么会有模块化？\n\n> 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护\n\n由此，又有了Vuex的模块化\n\n\n\n\n# 模块化的简单应用\n\n应用\n\n定义两个模块 user 和 setting\n\nuser中管理用户的状态 token\n\nsetting中管理 应用的名称 name\n\nconst store  = new Vuex.Store({\n  modules: {\n    user: {\n       state: {\n         token: '12345'\n       }\n    },\n    setting: {\n      state: {\n         name: 'Vuex实例'\n      }\n    }\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n定义child-b组件，分别显示用户的token和应用名称name\n\n<template>\n  <div>\n      <div>用户token {{ $store.state.user.token }}</div>\n      <div>网站名称 {{ $store.state.setting.name }}</div>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n请注意： 此时要获取子模块的状态 需要通过 $store.state.模块名称.属性名 来获取\n\n> 看着获取有点麻烦，我们可以通过之前学过的getters来改变一下\n\n getters: {\n   token: state => state.user.token,\n   name: state => state.setting.name\n } \n\n\n1\n2\n3\n4\n\n\n请注意：这个getters是根级别的getters哦\n\n通过mapGetters引用\n\n computed: {\n       ...mapGetters(['token', 'name'])\n }\n\n\n1\n2\n3\n\n\n\n# 模块化中的命名空间\n\n命名空间 namespaced\n\n> 这里注意理解\n\n默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n\n> 这句话的意思是 刚才的user模块还是setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用 如\n\n\n\n  user: {\n       state: {\n         token: '12345'\n       },\n       mutations: {\n        //  这里的state表示的是user的state\n         updateToken (state) {\n            state.token = 678910\n         }\n       }\n    },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过mapMutations调用\n\n methods: {\n       ...mapMutations(['updateToken'])\n  }\n <button @click=\"updateToken\">修改token</button>\n\n\n1\n2\n3\n4\n\n\n> 但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置\n\n高封闭性？可以理解成 一家人如果分家了，此时，你的爸妈可以随意的进出分给你的小家，你觉得自己没什么隐私了，我们可以给自己的房门加一道锁（命名空间 namespaced）,你的父母再也不能进出你的小家了\n\n如\n\n  user: {\n       namespaced: true,\n       state: {\n         token: '12345'\n       },\n       mutations: {\n        //  这里的state表示的是user的state\n         updateToken (state) {\n            state.token = 678910\n         }\n       }\n    },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n使用带命名空间的模块 action/mutations\n\n方案1：直接调用-带上模块的属性名路径\n\ntest () {\n   this.$store.dispatch('user/updateToken') // 直接调用方法\n}\n\n\n1\n2\n3\n\n\n方案2：辅助函数-带上模块的属性名路径\n\n  methods: {\n       ...mapMutations(['user/updateToken']),\n       test () {\n           this['user/updateToken']()\n       }\n   }\n  <button @click=\"test\">修改token</button>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n方案3： createNamespacedHelpers 创建基于某个命名空间辅助函数\n\nimport { mapGetters, createNamespacedHelpers } from 'vuex'\nconst { mapMutations } = createNamespacedHelpers('user')\n<button @click=\"updateToken\">修改token2</button>\n\n\n1\n2\n3\n\n\n> 关于Vuex的更多用法，后续在项目中讲解\n\n\n# vuex案例-搭建黑马头条项目\n\n接下来，通过一个案例来使用Vuex介入我们的数据管理\n\n> 通过vue-cli脚手架搭建项目\n\n$ vue create toutiao  #创建项目\n\n\n1\n\n\n> 选择 vuex / eslint（stanadard） / pre-cssprocesser (less) 确定\n\n在main.js中引入样式(该样式在资源/vuex样式中，拷贝到styles目录下)\n\nimport './styles/index.css'\n\n\n1\n\n\n拷贝图片资源到assets目录下（在资源/vuex样式目录下的图片）\n\n在App.vue中拷贝基本结构\n\n <div id=\"app\">\n      <ul class=\"catagtory\">\n        <li class='select'>开发者资讯</li>\n        <li>ios</li>\n        <li>c++</li>\n        <li>android</li>\n        <li>css</li>\n        <li>数据库</li>\n        <li>区块链</li>\n        <li>go</li>\n        <li>产品</li>\n        <li>后端</li>\n        <li>linux</li>\n        <li>人工智能</li>\n        <li>php</li>\n        <li>javascript</li>\n        <li>架构</li>\n        <li>前端</li>\n        <li>python</li>\n        <li>java</li>\n        <li>算法</li>\n        <li>面试</li>\n        <li>科技动态</li>\n        <li>js</li>\n        <li>设计</li>\n        <li>数码产品</li>\n        <li>html</li>\n        <li>软件测试</li>\n        <li>测试开发</li>\n      </ul>\n      <div class=\"list\">\n        <div class=\"article_item\">\n          <h3 class=\"van-ellipsis\">python数据预处理 ：数据标准化</h3>\n          <div class=\"img_box\">\n            <img src=\"@/assets/back.jpg\"\n            class=\"w100\" />\n          </div>\n          \x3c!----\x3e\n          <div class=\"info_box\">\n            <span>13552285417</span>\n            <span>0评论</span>\n            <span>2018-11-29T17:02:09</span>\n          </div>\n        </div>\n      </div>\n    </div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# vuex案例-封装分类组件和频道组件\n\n为了更好的区分组件之间的职责，我们将上方的频道和下方的列表封装成不同的组件\n\ncomponents/catagtory.vue\n\n<template>    \n   <ul class=\"catagtory\">\n        <li class='select'>开发者资讯</li>\n        <li>ios</li>\n        <li>c++</li>\n        <li>android</li>\n        <li>css</li>\n        <li>数据库</li>\n        <li>区块链</li>\n        <li>go</li>\n        <li>产品</li>\n        <li>后端</li>\n        <li>linux</li>\n        <li>人工智能</li>\n        <li>php</li>\n        <li>javascript</li>\n        <li>架构</li>\n        <li>前端</li>\n        <li>python</li>\n        <li>java</li>\n        <li>算法</li>\n        <li>面试</li>\n        <li>科技动态</li>\n        <li>js</li>\n        <li>设计</li>\n        <li>数码产品</li>\n        <li>html</li>\n        <li>软件测试</li>\n        <li>测试开发</li>\n      </ul>\n</template>    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ncomponents/new-list.vue\n\n<template> \n  <div class=\"list\">\n        <div class=\"article_item\">\n          <h3 class=\"van-ellipsis\">python数据预处理 ：数据标准化</h3>\n          <div class=\"img_box\">\n             <img src=\"@/assets/back.jpg\"\n            class=\"w100\" />\n          </div>\n          \x3c!----\x3e\n          <div class=\"info_box\">\n            <span>13552285417</span>\n            <span>0评论</span>\n            <span>2018-11-29T17:02:09</span>\n          </div>\n        </div>\n      </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在App.vue中引入并使用\n\n<template>\n \x3c!-- app.vue是根组件 --\x3e\n  <div id=\"app\">\n    <catagtory />\n    <new-list />\n  </div>\n</template>\n<script>\nimport Catagtory from './components/catagtory'\nimport NewList from './components/new-list'\n\nexport default {\n  components: {\n    Catagtory, NewList\n  }\n}\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# vuex案例-在vuex中加载分类和频道数据\n\n\n# 设计categtory和newlist的vuex模块\n\n安装请求数据的工具 axios\n\n$ npm i axios\n\n\n1\n\n\n接口\n\n获取频道列表\n\nhttp://ttapi.research.itcast.cn/app/v1_0/channels\n\n获取频道头条\n\nhttp://ttapi.research.itcast.cn/app/v1_1/articles?channel_id=频道id&timestamp=时间戳&with_top=1\n\n> 我们采用模块化的管理模式，建立一个专门的模块来管理分类和新闻数据\n\n在store目录下新建目录modules， 新建 catagtory.js和newlist.js\n\n模块结构\n\nexport default {\n  namespaced: true,\n  state: {},\n  mutations: {},\n  actions: {}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在store/index.js中引入定义的两个模块\n\nimport catagtory from './modules/catagtory'\nimport newlist from './modules/newlist'\n export default new Vuex.Store({\n  state: {\n  },\n  mutations: {\n  },\n  actions: {\n  },\n  modules: {\n    catagtory,\n    newlist\n  }\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 分类模块下设置分类数组和当前激活分类\n\n在catagtory的 state中定义分类频道列表和当前激活\n\nstate: {\n    catagtory: [],\n    currentCatagtory: ''\n}\n\n\n1\n2\n3\n4\n\n\n定义更新频道列表的mutations\n\nmutations: {\n  updateCatagtory (state, payload) {\n      state.catagtory = payload // 更新分类数据\n   },\n   updateCurrentCatagtory (state, payload) {\n      state.currentCatagtory = payload\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通过getters建立对于分类数据和当前分类的快捷访问\n\nexport default new Vuex.Store({\n  state: {\n  },\n  mutations: {\n  },\n  actions: {\n  },\n  modules: {\n    catagtory,\n    newlist\n  },\n  getters: {\n    catagtory: state => state.catagtory.catagtory, // 建立快捷访问\n    currentCatagtory: state => state.catagtory.currentCatagtory\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 遍历分类数据并判断激活class\n\n分类组件遍历vuex数据\n\nimport { mapGetters } from 'vuex'\ncomputed: {\n    ...mapGetters(['catagtory', 'currentCatagtroy'])\n},\n\n\n1\n2\n3\n4\n\n\n <ul class=\"catagtory\">\n    <li :class=\"{ select: currentCatagtory === item.id }\" v-for=\"item in catagtory\"  :key=\"item.id\">{{ item.name }}</li>\n </ul>\n\n\n1\n2\n3\n\n\n\n# 封装调用获取分类action,激活第一个分类\n\n定义获取频道列表的action, 将第一个频道激活\n\n  actions: {\n    async  getCatagtory (context) {\n      const { data: { data: { channels } } } = await                  axios.get('http://ttapi.research.itcast.cn/app/v1_0/channels')\n      context.commit('updateCatagtory', channels)\n      context.commit('updateCurrentCatagtory', channels[0].id)\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n初始化catagtory时调用action\n\nimport { mapGetters } from 'vuex'\n\nexport default {\n  computed: {\n    ...mapGetters(['catagtory'])\n  },\n  created () {\n    this.$store.dispatch('catagtory/getCatagtory')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n点击分类时，触发分类切换\n\n <li @click=\"$store.commit('catagtory/updateCurrentCatagtory', item.id)\" :class=\"{ select: currentCatagtroy === item.id }\" v-for=\"item in catagtory\"  :key=\"item.id\">{{ item.name }}</li>\n\n\n\n1\n2\n\n\n\n# 定义新闻数据，并封装获取新闻的Action\n\n在newlist.js中定义获取头条内容的数据\n\nstate: {\n   allData: {}\n}\n\n\n1\n2\n3\n\n\n定义更新头条内容的mutations\n\n  mutations: {\n    // payload 载荷  { 1: [], 2: [], 3: [], 4}\n    updateList (state, { currentCatagtory, list }) {\n      // 不是响应式的\n      // state.allData[currentCatagtory] = list // 这样做事大错特错第  感觉不到变化 就不会通知组件\n      state.allData = { ...state.allData, [currentCatagtory]: list }\n      // 这句代码的含义 就相当于 在一个新的对象后面追加了一个属性  更新某个属性的内容\n    }\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n定义根据分类标识获取新闻的action\n\n  actions: {\n    // 获取新闻列表数据\n    // 分类id只能通过传递的方式传进来\n    async getNewList (context, cataId) {\n      const { data: { data: { results } } } = await axios.get(`http://ttapi.research.itcast.cn/app/v1_1/articles?channel_id=${cataId}&timestamp=${Date.now()}&with_top=1`)\n      // results是新闻列表\n      context.commit('updateList', { currentCatagtory: cataId, list: results })\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 监听激活分类，触发获取新闻Action\n\n在new-list组件中，引入当前分类的id，监视其改变，一旦改变，触发获取新闻的action\n\nimport { mapGetters } from 'vuex'\nexport default {\n  computed: {\n    ...mapGetters(['currentCatagtroy'])\n  },\n  watch: {\n    currentCatagtory (newValue) {\n      this.$store.dispatch('newlist/getNewList', newValue)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 处理显示新闻内容的数据\n\n定义当前显示列表的getters\n\ngetters: {\n    currentList: state => state.newlist.allData[state.catagtory.currentCatagtory] || []\n}\n\n\n1\n2\n3\n\n\n修改new-list内容\n\n<template>\n     <div class=\"list\">\n        <div class=\"article_item\" v-for=\"item in currentList\" :key=\"item.art_id\">\n          <h3 class=\"van-ellipsis\">{{ item.title }}</h3>\n          <div class=\"img_box\" v-if=\"item.cover.type === 1\">\n            <img :src=\"item.cover.images[0]\"\n            class=\"w100\" />\n          </div>\n          <div class=\"img_box\" v-else-if=\"item.cover.type === 3\">\n            <img :src=\"item.cover.images[0]\"\n            class=\"w33\" />\n             <img :src=\"item.cover.images[1]\"\n            class=\"w33\" />\n             <img :src=\"item.cover.images[2]\"\n            class=\"w33\" />\n          </div>\n          \x3c!----\x3e\n          <div class=\"info_box\">\n            <span>{{ item.aut_name }}</span>\n            <span>{{ item.comm_count }}评论</span>\n            <span>{{ item.pubdate }}</span>\n          </div>\n        </div>\n      </div>\n</template>\n\n<script>\n// 引入当前激活的分类id\nimport { mapGetters } from 'vuex'\nexport default {\n  computed: {\n    ...mapGetters(['currentCatagtory', 'currentList'])\n  },\n  watch: {\n    currentCatagtory (newValue) {\n      // newValue是当前最新的激活的id\n      this.$store.dispatch('newlist/getNewList', newValue)\n    }\n  }\n}\n<\/script>\n\n<style>\n\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n",normalizedContent:"# vuex基础-介绍\n\n> 为什么会有vuex ?\n\nvuex 是一个专为 vue.js 应用程序开发的状态管理模式。它采用**集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测**的方式发生变化。\n\n * vuex是采用集中式管理组件依赖的共享数据的一个工具，可以解决不同组件数据共享问题。\n\n\n\n结论\n\n 1. 修改state状态必须通过**mutations**\n 2. **mutations**只能执行同步代码，类似ajax，定时器之类的代码不能在mutations中执行\n 3. 执行异步代码，要通过actions，然后将数据提交给mutations才可以完成\n 4. state的状态即共享数据可以在组件中引用\n 5. 组件中可以调用action\n\n\n# vuex基础-初始化功能\n\n> 建立一个新的脚手架项目, 在项目中应用vuex\n\n$ vue create  demo\n\n\n1\n\n\n> 开始vuex的初始化建立，选择模式时，选择默认模式\n\n初始化：\n\n * 第一步：npm i vuex --save => 安装到**运行时依赖** => 项目上线之后依然使用的依赖 ,开发时依赖 => 开发调试时使用\n\n> 开发时依赖 就是开开发的时候，需要的依赖，运行时依赖，项目上线运行时依然需要的\n\n * 第二步： 在main.js中 import vuex from 'vuex'\n * 第三步：在main.js中 vue.use(vuex) => 调用了 vuex中的 一个install方法\n * 第四步：const store = new vuex.store({...配置项})\n * 第五步：在根实例配置 store 选项指向 store 实例对象\n\nimport vue from 'vue'\nimport vuex from 'vuex'\nvue.use(vuex)\nconst store = new vuex.store({})\nnew vue({\n  el: '#app',\n  store\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# vuex基础-state\n\nstate是放置所有公共状态的属性，如果你有一个公共状态数据 ， 你只需要定义在 state对象中\n\n定义state\n\n// 初始化vuex对象\nconst store = new vuex.store({\n  state: {\n    // 管理数据\n    count: 0\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 如何在组件中获取count?\n\n原始形式- 插值表达式\n\napp.vue\n\n组件中可以使用 this.$store 获取到vuex中的store对象实例，可通过state属性属性获取count， 如下\n\n<div> state的数据：{{ $store.state.count }}</div>\n\n\n1\n\n\n计算属性 - 将state属性定义在计算属性中\n\n// 把state中数据，定义在组件内的计算属性中\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n\n\n <div> state的数据：{{ count }}</div>\n\n\n1\n\n\n辅助函数 - mapstate\n\n> mapstate是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便用法\n\n用法 ： 第一步：导入mapstate\n\nimport { mapstate } from 'vuex'\n\n\n1\n\n\n第二步：采用数组形式引入state属性\n\nmapstate(['count']) \n\n\n1\n\n\n> 上面代码的最终得到的是 类似\n\ncount () {\n    return this.$store.state.count\n}\n\n\n1\n2\n3\n\n\n第三步：利用延展运算符将导出的状态映射给计算属性\n\n  computed: {\n    ...mapstate(['count'])\n  }\n\n\n1\n2\n3\n\n\n <div> state的数据：{{ count }}</div>\n\n\n1\n\n\n\n# vuex基础-mutations\n\n> state数据的修改只能通过mutations，并且mutations必须是同步更新，目的是形成**数据快照**\n\n数据快照：一次mutation的执行，立刻得到一种视图状态，因为是立刻，所以必须是同步\n\n定义mutations\n\nconst store  = new vuex.store({\n  state: {\n    count: 0\n  },\n  // 定义mutations\n  mutations: {\n     \n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n格式说明\n\nmutations是一个对象，对象中存放修改state的方法\n\nmutations: {\n    // 方法里参数 第一个参数是当前store的state属性\n    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷\n    addcount (state) {\n      state.count += 1\n    }\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 如何在组件中调用mutations\n\n原始形式-$store\n\n> 新建组件child-a.vue，内容为一个button按钮，点击按钮调用mutations\n\n<template>\n  <button @click=\"addcount\">+1</button>\n</template>\n\n<script>\nexport default {\n    methods: {\n    //   调用方法\n      addcount () {\n         // 调用store中的mutations 提交给muations\n        // commit('muations名称', 2)\n        this.$store.commit('addcount', 10)  // 直接调用mutations\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n带参数的传递\n\n    addcount (state, payload) {\n        state.count += payload\n    }\n    this.$store.commit('addcount', 10)\n\n\n1\n2\n3\n4\n\n\n辅助函数 - mapmutations\n\n> mapmutations和mapstate很像，它把位于mutations中的方法提取了出来，我们可以将它导入\n\nimport  { mapmutations } from 'vuex'\nmethods: {\n    ...mapmutations(['addcount'])\n}\n\n\n1\n2\n3\n4\n\n\n> 上面代码的含义是将mutations的方法导入了methods中，等同于\n\nmethods: {\n      // commit(方法名, 载荷参数)\n      addcount () {\n          this.$store.commit('addcount')\n      }\n }\n\n\n1\n2\n3\n4\n5\n6\n\n\n此时，就可以直接通过this.addcount调用了\n\n<button @click=\"addcount(100)\">+100</button>\n\n\n1\n\n\n但是请注意： vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中\n\n\n# vuex基础-actions\n\n> state是存放数据的，mutations是同步更新数据，actions则负责进行异步操作\n\n定义actions\n\n actions: {\n  //  获取异步的数据 context表示当前的store的实例 可以通过 context.state 获取状态 也可以通过context.commit 来提交mutations， 也可以 context.diapatch调用其他的action\n    getasynccount (context) {\n      settimeout(function(){\n        // 一秒钟之后 要给一个数 去修改state\n        context.commit('addcount', 123)\n      }, 1000)\n    }\n } \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n原始调用 - $store\n\n addasynccount () {\n     this.$store.dispatch('getasynccount')\n }\n\n\n1\n2\n3\n\n\n传参调用\n\n addasynccount () {\n     this.$store.dispatch('getasynccount', 123)\n }\n\n\n1\n2\n3\n\n\n辅助函数 -mapactions\n\n> actions也有辅助函数，可以将action导入到组件中\n\nimport { mapactions } from 'vuex'\nmethods: {\n    ...mapactions(['getasynccount'])\n}\n\n\n1\n2\n3\n4\n\n\n直接通过 this.方法就可以调用\n\n<button @click=\"getasynccount(111)\">+异步</button>\n\n\n1\n\n\n\n# vuex基础-getters\n\n> 除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters\n\n例如，state中定义了list，为1-10的数组，\n\nstate: {\n    list: [1,2,3,4,5,6,7,8,9,10]\n}\n\n\n1\n2\n3\n\n\n组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它\n\n定义getters\n\n  getters: {\n    // getters函数的第一个参数是 state\n    // 必须要有返回值\n     filterlist:  state =>  state.list.filter(item => item > 5)\n  }\n\n\n1\n2\n3\n4\n5\n\n\n使用getters\n\n原始方式 -$store\n\n<div>{{ $store.getters.filterlist }}</div>\n\n\n1\n\n\n辅助函数 - mapgetters\n\ncomputed: {\n    ...mapgetters(['filterlist'])\n}\n\n\n1\n2\n3\n\n\n <div>{{ filterlist }}</div>\n\n\n1\n\n\n\n# vuex中的模块化-module\n\n\n# 为什么会有模块化？\n\n> 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，vuex会变得越来越难以维护\n\n由此，又有了vuex的模块化\n\n\n\n\n# 模块化的简单应用\n\n应用\n\n定义两个模块 user 和 setting\n\nuser中管理用户的状态 token\n\nsetting中管理 应用的名称 name\n\nconst store  = new vuex.store({\n  modules: {\n    user: {\n       state: {\n         token: '12345'\n       }\n    },\n    setting: {\n      state: {\n         name: 'vuex实例'\n      }\n    }\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n定义child-b组件，分别显示用户的token和应用名称name\n\n<template>\n  <div>\n      <div>用户token {{ $store.state.user.token }}</div>\n      <div>网站名称 {{ $store.state.setting.name }}</div>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n请注意： 此时要获取子模块的状态 需要通过 $store.state.模块名称.属性名 来获取\n\n> 看着获取有点麻烦，我们可以通过之前学过的getters来改变一下\n\n getters: {\n   token: state => state.user.token,\n   name: state => state.setting.name\n } \n\n\n1\n2\n3\n4\n\n\n请注意：这个getters是根级别的getters哦\n\n通过mapgetters引用\n\n computed: {\n       ...mapgetters(['token', 'name'])\n }\n\n\n1\n2\n3\n\n\n\n# 模块化中的命名空间\n\n命名空间 namespaced\n\n> 这里注意理解\n\n默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n\n> 这句话的意思是 刚才的user模块还是setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用 如\n\n\n\n  user: {\n       state: {\n         token: '12345'\n       },\n       mutations: {\n        //  这里的state表示的是user的state\n         updatetoken (state) {\n            state.token = 678910\n         }\n       }\n    },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n通过mapmutations调用\n\n methods: {\n       ...mapmutations(['updatetoken'])\n  }\n <button @click=\"updatetoken\">修改token</button>\n\n\n1\n2\n3\n4\n\n\n> 但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置\n\n高封闭性？可以理解成 一家人如果分家了，此时，你的爸妈可以随意的进出分给你的小家，你觉得自己没什么隐私了，我们可以给自己的房门加一道锁（命名空间 namespaced）,你的父母再也不能进出你的小家了\n\n如\n\n  user: {\n       namespaced: true,\n       state: {\n         token: '12345'\n       },\n       mutations: {\n        //  这里的state表示的是user的state\n         updatetoken (state) {\n            state.token = 678910\n         }\n       }\n    },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n使用带命名空间的模块 action/mutations\n\n方案1：直接调用-带上模块的属性名路径\n\ntest () {\n   this.$store.dispatch('user/updatetoken') // 直接调用方法\n}\n\n\n1\n2\n3\n\n\n方案2：辅助函数-带上模块的属性名路径\n\n  methods: {\n       ...mapmutations(['user/updatetoken']),\n       test () {\n           this['user/updatetoken']()\n       }\n   }\n  <button @click=\"test\">修改token</button>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n方案3： createnamespacedhelpers 创建基于某个命名空间辅助函数\n\nimport { mapgetters, createnamespacedhelpers } from 'vuex'\nconst { mapmutations } = createnamespacedhelpers('user')\n<button @click=\"updatetoken\">修改token2</button>\n\n\n1\n2\n3\n\n\n> 关于vuex的更多用法，后续在项目中讲解\n\n\n# vuex案例-搭建黑马头条项目\n\n接下来，通过一个案例来使用vuex介入我们的数据管理\n\n> 通过vue-cli脚手架搭建项目\n\n$ vue create toutiao  #创建项目\n\n\n1\n\n\n> 选择 vuex / eslint（stanadard） / pre-cssprocesser (less) 确定\n\n在main.js中引入样式(该样式在资源/vuex样式中，拷贝到styles目录下)\n\nimport './styles/index.css'\n\n\n1\n\n\n拷贝图片资源到assets目录下（在资源/vuex样式目录下的图片）\n\n在app.vue中拷贝基本结构\n\n <div id=\"app\">\n      <ul class=\"catagtory\">\n        <li class='select'>开发者资讯</li>\n        <li>ios</li>\n        <li>c++</li>\n        <li>android</li>\n        <li>css</li>\n        <li>数据库</li>\n        <li>区块链</li>\n        <li>go</li>\n        <li>产品</li>\n        <li>后端</li>\n        <li>linux</li>\n        <li>人工智能</li>\n        <li>php</li>\n        <li>javascript</li>\n        <li>架构</li>\n        <li>前端</li>\n        <li>python</li>\n        <li>java</li>\n        <li>算法</li>\n        <li>面试</li>\n        <li>科技动态</li>\n        <li>js</li>\n        <li>设计</li>\n        <li>数码产品</li>\n        <li>html</li>\n        <li>软件测试</li>\n        <li>测试开发</li>\n      </ul>\n      <div class=\"list\">\n        <div class=\"article_item\">\n          <h3 class=\"van-ellipsis\">python数据预处理 ：数据标准化</h3>\n          <div class=\"img_box\">\n            <img src=\"@/assets/back.jpg\"\n            class=\"w100\" />\n          </div>\n          \x3c!----\x3e\n          <div class=\"info_box\">\n            <span>13552285417</span>\n            <span>0评论</span>\n            <span>2018-11-29t17:02:09</span>\n          </div>\n        </div>\n      </div>\n    </div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# vuex案例-封装分类组件和频道组件\n\n为了更好的区分组件之间的职责，我们将上方的频道和下方的列表封装成不同的组件\n\ncomponents/catagtory.vue\n\n<template>    \n   <ul class=\"catagtory\">\n        <li class='select'>开发者资讯</li>\n        <li>ios</li>\n        <li>c++</li>\n        <li>android</li>\n        <li>css</li>\n        <li>数据库</li>\n        <li>区块链</li>\n        <li>go</li>\n        <li>产品</li>\n        <li>后端</li>\n        <li>linux</li>\n        <li>人工智能</li>\n        <li>php</li>\n        <li>javascript</li>\n        <li>架构</li>\n        <li>前端</li>\n        <li>python</li>\n        <li>java</li>\n        <li>算法</li>\n        <li>面试</li>\n        <li>科技动态</li>\n        <li>js</li>\n        <li>设计</li>\n        <li>数码产品</li>\n        <li>html</li>\n        <li>软件测试</li>\n        <li>测试开发</li>\n      </ul>\n</template>    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ncomponents/new-list.vue\n\n<template> \n  <div class=\"list\">\n        <div class=\"article_item\">\n          <h3 class=\"van-ellipsis\">python数据预处理 ：数据标准化</h3>\n          <div class=\"img_box\">\n             <img src=\"@/assets/back.jpg\"\n            class=\"w100\" />\n          </div>\n          \x3c!----\x3e\n          <div class=\"info_box\">\n            <span>13552285417</span>\n            <span>0评论</span>\n            <span>2018-11-29t17:02:09</span>\n          </div>\n        </div>\n      </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在app.vue中引入并使用\n\n<template>\n \x3c!-- app.vue是根组件 --\x3e\n  <div id=\"app\">\n    <catagtory />\n    <new-list />\n  </div>\n</template>\n<script>\nimport catagtory from './components/catagtory'\nimport newlist from './components/new-list'\n\nexport default {\n  components: {\n    catagtory, newlist\n  }\n}\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# vuex案例-在vuex中加载分类和频道数据\n\n\n# 设计categtory和newlist的vuex模块\n\n安装请求数据的工具 axios\n\n$ npm i axios\n\n\n1\n\n\n接口\n\n获取频道列表\n\nhttp://ttapi.research.itcast.cn/app/v1_0/channels\n\n获取频道头条\n\nhttp://ttapi.research.itcast.cn/app/v1_1/articles?channel_id=频道id&timestamp=时间戳&with_top=1\n\n> 我们采用模块化的管理模式，建立一个专门的模块来管理分类和新闻数据\n\n在store目录下新建目录modules， 新建 catagtory.js和newlist.js\n\n模块结构\n\nexport default {\n  namespaced: true,\n  state: {},\n  mutations: {},\n  actions: {}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在store/index.js中引入定义的两个模块\n\nimport catagtory from './modules/catagtory'\nimport newlist from './modules/newlist'\n export default new vuex.store({\n  state: {\n  },\n  mutations: {\n  },\n  actions: {\n  },\n  modules: {\n    catagtory,\n    newlist\n  }\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 分类模块下设置分类数组和当前激活分类\n\n在catagtory的 state中定义分类频道列表和当前激活\n\nstate: {\n    catagtory: [],\n    currentcatagtory: ''\n}\n\n\n1\n2\n3\n4\n\n\n定义更新频道列表的mutations\n\nmutations: {\n  updatecatagtory (state, payload) {\n      state.catagtory = payload // 更新分类数据\n   },\n   updatecurrentcatagtory (state, payload) {\n      state.currentcatagtory = payload\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通过getters建立对于分类数据和当前分类的快捷访问\n\nexport default new vuex.store({\n  state: {\n  },\n  mutations: {\n  },\n  actions: {\n  },\n  modules: {\n    catagtory,\n    newlist\n  },\n  getters: {\n    catagtory: state => state.catagtory.catagtory, // 建立快捷访问\n    currentcatagtory: state => state.catagtory.currentcatagtory\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 遍历分类数据并判断激活class\n\n分类组件遍历vuex数据\n\nimport { mapgetters } from 'vuex'\ncomputed: {\n    ...mapgetters(['catagtory', 'currentcatagtroy'])\n},\n\n\n1\n2\n3\n4\n\n\n <ul class=\"catagtory\">\n    <li :class=\"{ select: currentcatagtory === item.id }\" v-for=\"item in catagtory\"  :key=\"item.id\">{{ item.name }}</li>\n </ul>\n\n\n1\n2\n3\n\n\n\n# 封装调用获取分类action,激活第一个分类\n\n定义获取频道列表的action, 将第一个频道激活\n\n  actions: {\n    async  getcatagtory (context) {\n      const { data: { data: { channels } } } = await                  axios.get('http://ttapi.research.itcast.cn/app/v1_0/channels')\n      context.commit('updatecatagtory', channels)\n      context.commit('updatecurrentcatagtory', channels[0].id)\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n初始化catagtory时调用action\n\nimport { mapgetters } from 'vuex'\n\nexport default {\n  computed: {\n    ...mapgetters(['catagtory'])\n  },\n  created () {\n    this.$store.dispatch('catagtory/getcatagtory')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n点击分类时，触发分类切换\n\n <li @click=\"$store.commit('catagtory/updatecurrentcatagtory', item.id)\" :class=\"{ select: currentcatagtroy === item.id }\" v-for=\"item in catagtory\"  :key=\"item.id\">{{ item.name }}</li>\n\n\n\n1\n2\n\n\n\n# 定义新闻数据，并封装获取新闻的action\n\n在newlist.js中定义获取头条内容的数据\n\nstate: {\n   alldata: {}\n}\n\n\n1\n2\n3\n\n\n定义更新头条内容的mutations\n\n  mutations: {\n    // payload 载荷  { 1: [], 2: [], 3: [], 4}\n    updatelist (state, { currentcatagtory, list }) {\n      // 不是响应式的\n      // state.alldata[currentcatagtory] = list // 这样做事大错特错第  感觉不到变化 就不会通知组件\n      state.alldata = { ...state.alldata, [currentcatagtory]: list }\n      // 这句代码的含义 就相当于 在一个新的对象后面追加了一个属性  更新某个属性的内容\n    }\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n定义根据分类标识获取新闻的action\n\n  actions: {\n    // 获取新闻列表数据\n    // 分类id只能通过传递的方式传进来\n    async getnewlist (context, cataid) {\n      const { data: { data: { results } } } = await axios.get(`http://ttapi.research.itcast.cn/app/v1_1/articles?channel_id=${cataid}&timestamp=${date.now()}&with_top=1`)\n      // results是新闻列表\n      context.commit('updatelist', { currentcatagtory: cataid, list: results })\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 监听激活分类，触发获取新闻action\n\n在new-list组件中，引入当前分类的id，监视其改变，一旦改变，触发获取新闻的action\n\nimport { mapgetters } from 'vuex'\nexport default {\n  computed: {\n    ...mapgetters(['currentcatagtroy'])\n  },\n  watch: {\n    currentcatagtory (newvalue) {\n      this.$store.dispatch('newlist/getnewlist', newvalue)\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 处理显示新闻内容的数据\n\n定义当前显示列表的getters\n\ngetters: {\n    currentlist: state => state.newlist.alldata[state.catagtory.currentcatagtory] || []\n}\n\n\n1\n2\n3\n\n\n修改new-list内容\n\n<template>\n     <div class=\"list\">\n        <div class=\"article_item\" v-for=\"item in currentlist\" :key=\"item.art_id\">\n          <h3 class=\"van-ellipsis\">{{ item.title }}</h3>\n          <div class=\"img_box\" v-if=\"item.cover.type === 1\">\n            <img :src=\"item.cover.images[0]\"\n            class=\"w100\" />\n          </div>\n          <div class=\"img_box\" v-else-if=\"item.cover.type === 3\">\n            <img :src=\"item.cover.images[0]\"\n            class=\"w33\" />\n             <img :src=\"item.cover.images[1]\"\n            class=\"w33\" />\n             <img :src=\"item.cover.images[2]\"\n            class=\"w33\" />\n          </div>\n          \x3c!----\x3e\n          <div class=\"info_box\">\n            <span>{{ item.aut_name }}</span>\n            <span>{{ item.comm_count }}评论</span>\n            <span>{{ item.pubdate }}</span>\n          </div>\n        </div>\n      </div>\n</template>\n\n<script>\n// 引入当前激活的分类id\nimport { mapgetters } from 'vuex'\nexport default {\n  computed: {\n    ...mapgetters(['currentcatagtory', 'currentlist'])\n  },\n  watch: {\n    currentcatagtory (newvalue) {\n      // newvalue是当前最新的激活的id\n      this.$store.dispatch('newlist/getnewlist', newvalue)\n    }\n  }\n}\n<\/script>\n\n<style>\n\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"React入门",frontmatter:{title:"React入门",date:"2022-11-29T15:50:03.000Z",permalink:"/pages/9b7e40/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.React%E5%85%A5%E9%97%A8.html",relativePath:"02.软件框架/06.react/01.React入门.md",key:"v-65e592f2",path:"/pages/9b7e40/",headers:[{level:2,title:"React",slug:"react",normalizedTitle:"react",charIndex:2},{level:2,title:"虚拟DOM和Diff算法",slug:"虚拟dom和diff算法",normalizedTitle:"虚拟dom和diff算法",charIndex:12},{level:2,title:"react开发依赖",slug:"react开发依赖",normalizedTitle:"react开发依赖",charIndex:1096}],headersStr:"React 虚拟DOM和Diff算法 react开发依赖",content:"# React\n\n\n# 虚拟DOM和Diff算法\n\n虚拟DOM\n\n问题描述：假设我们的数据发生一点点的变化，也会被强制重建整顿DOM树，这么做，会涉及到很多元素的重绘和重排，导致性能浪费严重\n\n解决上述问题思路：实现按需更行页面上的元素即可。也就是说，把需要修改的元素，所对应的 DOM 元素重新构建；其它没有变化的数据，所对应的 DOM 节点不需要被强制更新\n\n具体实现方案：只需要拿到页面更新前的 内存中的DOM树，同时再拿到页面更新前新渲染出来的内存DOM树；然后，对比这两颗新旧DOM树，找到那些需要被重新创建和修改的元素即可。这样就能实现DOM的按需更新\n\n如何拿到这两颗DOM树： 如果要拿到浏览器私有的DOM树，那我们必须调用浏览器提供的相关JS的API才行。但是浏览器没有提供相关的API，那我们可以自己模拟这两颗新旧DOM树\n\n如何自己模拟这两颗新旧DOM树： 这里涉及到手动模拟DOM树的原理：使用JS创建一个对象，用和这个对象来模拟每一个DOM节点；然后在每个DOM节点中，有提供了类似于children这样的属性来描述当前子节点。这样的话，当DOM节点形成了嵌套关系，就模拟出了一颗DOM树\n\n总结\n\n * 虚拟DOM的本质：使用 JS 对象模拟DOM树。\n * 虚拟DOM的目的：为了实现 DOM 节点的高效更新。\n\ndiff算法\n\n怎么实现 两颗新旧DOM树的对比呢，这里就涉及到diff算法\n\ntree diff ： 新旧DOM树，逐层对比的方式，就叫做 tree diff。每当我们从前到后，把所有层的节点对比完后，必须能够找到哪些需要被更新的元素\n\ncomponent diff ：在对比每一层的时候，组件之间的对比，叫做 component diff 。当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换被移除的位置\n\nelement diff ： 在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff\n\nkey ： key 这个属性，可以把页面上的DOM节点和虚拟DOM中的对象，做一层关联关系\n\n声明式编程\n\n声明式编程是目前整个大前端开发的模式：Vue、React、Flutter、SwitfUI\n\n它允许我们 只需要维护自己的状态，当状态改变时，react 可以根据最新的状态去渲染我们的UI界面\n\n组件化开发\n\n组件化开发页面目前前端的流行趋势，我们会将复杂的界面拆分成一个个小的组件\n\n如何合理的进行组件的划分和设计\n\n\n# react开发依赖\n\n * react\n * react-dom\n * babel\n\nReact18 之前渲染用法\n\nReactDOM.render(<h2></h2>,document.querey)",normalizedContent:"# react\n\n\n# 虚拟dom和diff算法\n\n虚拟dom\n\n问题描述：假设我们的数据发生一点点的变化，也会被强制重建整顿dom树，这么做，会涉及到很多元素的重绘和重排，导致性能浪费严重\n\n解决上述问题思路：实现按需更行页面上的元素即可。也就是说，把需要修改的元素，所对应的 dom 元素重新构建；其它没有变化的数据，所对应的 dom 节点不需要被强制更新\n\n具体实现方案：只需要拿到页面更新前的 内存中的dom树，同时再拿到页面更新前新渲染出来的内存dom树；然后，对比这两颗新旧dom树，找到那些需要被重新创建和修改的元素即可。这样就能实现dom的按需更新\n\n如何拿到这两颗dom树： 如果要拿到浏览器私有的dom树，那我们必须调用浏览器提供的相关js的api才行。但是浏览器没有提供相关的api，那我们可以自己模拟这两颗新旧dom树\n\n如何自己模拟这两颗新旧dom树： 这里涉及到手动模拟dom树的原理：使用js创建一个对象，用和这个对象来模拟每一个dom节点；然后在每个dom节点中，有提供了类似于children这样的属性来描述当前子节点。这样的话，当dom节点形成了嵌套关系，就模拟出了一颗dom树\n\n总结\n\n * 虚拟dom的本质：使用 js 对象模拟dom树。\n * 虚拟dom的目的：为了实现 dom 节点的高效更新。\n\ndiff算法\n\n怎么实现 两颗新旧dom树的对比呢，这里就涉及到diff算法\n\ntree diff ： 新旧dom树，逐层对比的方式，就叫做 tree diff。每当我们从前到后，把所有层的节点对比完后，必须能够找到哪些需要被更新的元素\n\ncomponent diff ：在对比每一层的时候，组件之间的对比，叫做 component diff 。当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换被移除的位置\n\nelement diff ： 在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff\n\nkey ： key 这个属性，可以把页面上的dom节点和虚拟dom中的对象，做一层关联关系\n\n声明式编程\n\n声明式编程是目前整个大前端开发的模式：vue、react、flutter、switfui\n\n它允许我们 只需要维护自己的状态，当状态改变时，react 可以根据最新的状态去渲染我们的ui界面\n\n组件化开发\n\n组件化开发页面目前前端的流行趋势，我们会将复杂的界面拆分成一个个小的组件\n\n如何合理的进行组件的划分和设计\n\n\n# react开发依赖\n\n * react\n * react-dom\n * babel\n\nreact18 之前渲染用法\n\nreactdom.render(<h2></h2>,document.querey)",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"react快速开始",frontmatter:{title:"react快速开始",date:"2022-12-01T19:34:45.000Z",permalink:"/pages/5082ac/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.heima/01.react%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B.html",relativePath:"02.软件框架/06.react/01.heima/01.react快速开始.md",key:"v-2939de45",path:"/pages/5082ac/",headers:[{level:2,title:"React概述",slug:"react概述",normalizedTitle:"react概述",charIndex:2},{level:4,title:"JSX",slug:"jsx",normalizedTitle:"jsx",charIndex:214},{level:2,title:"脚手架快速入门",slug:"脚手架快速入门",normalizedTitle:"脚手架快速入门",charIndex:393},{level:2,title:"JSX基本使用",slug:"jsx基本使用",normalizedTitle:"jsx基本使用",charIndex:625},{level:4,title:"使用步骤",slug:"使用步骤",normalizedTitle:"使用步骤",charIndex:636},{level:4,title:"为什么在脚手架中可以使用JSX语法",slug:"为什么在脚手架中可以使用jsx语法",normalizedTitle:"为什么在脚手架中可以使用jsx语法",charIndex:779},{level:4,title:"注意点",slug:"注意点",normalizedTitle:"注意点",charIndex:947},{level:2,title:"JXS基本语法",slug:"jxs基本语法",normalizedTitle:"jxs基本语法",charIndex:1105},{level:4,title:"嵌入JS表达式",slug:"嵌入js表达式",normalizedTitle:"嵌入js表达式",charIndex:1187},{level:5,title:"注意点",slug:"注意点-2",normalizedTitle:"注意点",charIndex:947},{level:4,title:"条件渲染",slug:"条件渲染",normalizedTitle:"条件渲染",charIndex:1392},{level:4,title:"列表渲染",slug:"列表渲染",normalizedTitle:"列表渲染",charIndex:1634},{level:4,title:"样式处理",slug:"样式处理",normalizedTitle:"样式处理",charIndex:2067},{level:5,title:"行内样式 -style",slug:"行内样式-style",normalizedTitle:"行内样式 -style",charIndex:2075},{level:5,title:"类名 -className",slug:"类名-classname",normalizedTitle:"类名 -classname",charIndex:2238},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:2482},{level:2,title:"React组件",slug:"react组件",normalizedTitle:"react组件",charIndex:2653},{level:3,title:"函数创建组件",slug:"函数创建组件",normalizedTitle:"函数创建组件",charIndex:2749},{level:4,title:"示例demo",slug:"示例demo",normalizedTitle:"示例demo",charIndex:2860},{level:3,title:"类组件",slug:"类组件",normalizedTitle:"类组件",charIndex:3052},{level:4,title:"示例demo",slug:"示例demo-2",normalizedTitle:"示例demo",charIndex:2860},{level:3,title:"抽离成单独的JS文件",slug:"抽离成单独的js文件",normalizedTitle:"抽离成单独的js文件",charIndex:3493},{level:4,title:"示例demo",slug:"示例demo-3",normalizedTitle:"示例demo",charIndex:2860},{level:2,title:"React事件处理",slug:"react事件处理",normalizedTitle:"react事件处理",charIndex:3989},{level:3,title:"事件绑定",slug:"事件绑定",normalizedTitle:"事件绑定",charIndex:4003},{level:4,title:"示例demo",slug:"示例demo-4",normalizedTitle:"示例demo",charIndex:2860},{level:4,title:"小结",slug:"小结-2",normalizedTitle:"小结",charIndex:2482},{level:3,title:"事件对象",slug:"事件对象",normalizedTitle:"事件对象",charIndex:4496},{level:4,title:"示例demo",slug:"示例demo-5",normalizedTitle:"示例demo",charIndex:2860},{level:3,title:"支持的事件",slug:"支持的事件",normalizedTitle:"支持的事件",charIndex:4984},{level:2,title:"有状态组件和无状态组件",slug:"有状态组件和无状态组件",normalizedTitle:"有状态组件和无状态组件",charIndex:7022},{level:2,title:"State和SetState",slug:"state和setstate",normalizedTitle:"state和setstate",charIndex:7136},{level:3,title:"state基本使用",slug:"state基本使用",normalizedTitle:"state基本使用",charIndex:7155},{level:4,title:"示例demo",slug:"示例demo-6",normalizedTitle:"示例demo",charIndex:2860},{level:3,title:"setState() 修改状态",slug:"setstate-修改状态",normalizedTitle:"setstate() 修改状态",charIndex:7631},{level:4,title:"示例demo",slug:"示例demo-7",normalizedTitle:"示例demo",charIndex:2860},{level:4,title:"小结",slug:"小结-3",normalizedTitle:"小结",charIndex:2482},{level:2,title:"事件绑定this指向",slug:"事件绑定this指向",normalizedTitle:"事件绑定this指向",charIndex:8350},{level:3,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:8365},{level:3,title:"利用bind方法",slug:"利用bind方法",normalizedTitle:"利用bind方法",charIndex:8397},{level:3,title:"class的实例方法",slug:"class的实例方法",normalizedTitle:"class的实例方法",charIndex:8746},{level:3,title:"小结",slug:"小结-4",normalizedTitle:"小结",charIndex:2482}],headersStr:"React概述 JSX 脚手架快速入门 JSX基本使用 使用步骤 为什么在脚手架中可以使用JSX语法 注意点 JXS基本语法 嵌入JS表达式 注意点 条件渲染 列表渲染 样式处理 行内样式 -style 类名 -className 小结 React组件 函数创建组件 示例demo 类组件 示例demo 抽离成单独的JS文件 示例demo React事件处理 事件绑定 示例demo 小结 事件对象 示例demo 支持的事件 有状态组件和无状态组件 State和SetState state基本使用 示例demo setState() 修改状态 示例demo 小结 事件绑定this指向 箭头函数 利用bind方法 class的实例方法 小结",content:"# React概述\n\nReact是一个用于构建用户界面的javaScript库，起源于facebook的内部项目，后续在13年开源了出来\n\n * 声明式\n\n你只需要描述UI看起来是什么样式，就跟写HTML一样，React负责渲染UI\n\n * 基于组件\n\n组件时React最重要的内容，组件表示页面中的部分内容\n\n * 学习一次，随处使用\n\n使用React可以开发Web应用，使用React可以开发移动端，可以开发VR应用\n\n# JSX\n\n由于通过createElement()方法创建的React元素有一些问题，代码比较繁琐，结构不直观，无法一眼看出描述的结构，不优雅，用户体验不爽\n\nJSX概述\n\nJSX是JavaScript XML 的简写，表示在JavaScript代码中写HTML格式的代码\n\n优势：声明式语法更加直观，与HTML结构相同，降低了学习成本，提升开发效率\n\n\n# 脚手架快速入门\n\nnpx create-react-app project-name\n\n输出 helloworld\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nlet h1 = React.createElement('h1',null,'我是标题')\nReactDOM.render(h1,document.getElementById('root'))\n\n\n1\n2\n3\n4\n\n\n\n# JSX基本使用\n\n# 使用步骤\n\n * 使用JSX语法创建react元素\n\nlet h1 = <h1>我是通过JSX创建的元素</h1>\n\n\n1\n\n * 使用ReactDOM来渲染元素\n\nReactDOM.render(h1,document.getElementById('root'))\n\n\n1\n\n\n# 为什么在脚手架中可以使用JSX语法\n\n * JSX 不是标准的ECMAScript语法，它是ECMAScript的语法拓展\n * 需要使用babel编译处理后，才能在浏览器环境中使用\n * create-react-app脚手架中已经默认有该配置，无需手动配置\n * 编译JSX语法的包： @bable/preset-react\n\n# 注意点\n\n * React元素的属性名使用驼峰命名法\n * 特殊属性名：class -> className，for -> htmlFor，tabindex -> tabIndex\n * 如果没有子节点的React元素可以用 /> 来结束\n * 推荐：使用 小括号包裹JSX，从而避免JS中自动插入分号报错\n\n\n# JXS基本语法\n\nJSX是来描述页面的结构，我们一般在编写业务逻辑渲染页面的时候，需要涉及到传递值，调用函数，判断条件，循环等，这一些在JSX中都能得到支持\n\n# 嵌入JS表达式\n\n语法：{JavaScritp表达式}\n\n例子：\n\nlet content = '插入的内容'\nlet h1 = <h1>我是通过JSX创建的元素+ {content}</h1>\n\n\n1\n2\n\n\n# 注意点\n\n * 只要是合法的js表达式都可以进行嵌入\n * JSX自身也是js表达式\n * 注意：js中的对象是一个例外，一般只会出现在style属性中\n * 注意：在{}中不能出现语句\n\n# 条件渲染\n\n根据不同的条件来渲染不同的JSX结构\n\nlet isLoading = true\nlet loading = ()=>{\n    if(isLoading){\n        return <div>Loading...</div>\n    }\n    return <div>加载完成</div>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以发现，写JSX的条件渲染与我们之前编写代码的逻辑是差不多的，根据不同的判断逻辑，返回不同的 JSX结构，然后渲染到页面中\n\n# 列表渲染\n\n * 如果需要渲染一组数据，我们应该使用数组的 map () 方法\n * 注意：渲染列表的时候需要添加key属性，key属性的值要保证唯一\n * 原则：map()遍历谁，就给谁添加key属性\n * 注意：尽量避免使用索引号作为key\n\nlet arr = [{\n    id:1,\n    name:'三国演义'\n},{\n    id:2,\n    name:'水浒传'\n},{\n    id:3,\n    name:'西游记'\n},{\n    id:4,\n    name:'红楼梦'\n}]\nlet ul = (<ul>\n    {arr.map(item => <li key={item.id}>{item.name}</li>)}\n</ul>)\nReactDOM.render(ul,document.getElementById('root'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 样式处理\n\n# 行内样式 -style\n\n在style里面我们通过对象的方式传递数据\n\n<li key={item.id} style={{'color': 'red',\"backgroundColor\": 'pink'}}>{item.name}</li>\n\n\n1\n\n\n这种方式比较的麻烦，不方便进行阅读，而且还会导致代码比较的繁琐\n\n# 类名 -className\n\n创建CSS文件编写样式代码\n\n.container {\n    text-align: center\n}\n\n\n1\n2\n3\n\n\n在js中进行引入，然后设置类名即可\n\nimport './css/index.css'\n\n<li className='container' key={item.id} style={{'color': 'red',\"backgroundColor\": 'pink'}}>{item.name}</li>\n\n\n1\n2\n3\n\n\n\n# 小结\n\n * JSX是React的核心内容\n * JSX表示在JS代码中写HTML结构，是React声明式的体现\n * 使用JSX配合嵌入的JS表达式、条件渲染、列表渲染、可以描述任意UI结构\n * 推荐使用className的方式给JSX添加样式\n * React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能\n\n\n# React组件\n\n * 组件是React的一等公民，使用React就是在用组件\n * 组件表示页面中的部分功能\n * 组合多个组件实现完整的页面功能\n * 特点：可复用、独立、可组合\n\n\n# 函数创建组件\n\n * 函数组件：使用JS的函数创建组件\n * **约定1：**函数名称必须以大写字母开头\n * **约定2：**函数组件必须有返回值，表示该组件的结构\n * 如果返回值为null，表示不渲染任何内容\n\n# 示例demo\n\n编写函数组件\n\nfunction Hello() {\n    return (\n        <div>这是第一个函数组件</div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n\n\n利用ReactDOM.render()进行渲染\n\nReactDOM.render(<Hello />,document.getElementById('root'))\n\n\n1\n\n\n\n# 类组件\n\n * 使用ES6语法的class创建的组件\n * 约定1：类名称也必须要大写字母开头\n * 约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法或者属性\n * 约定3：类组件必须提供 render 方法\n * 约定4：render方法中必须要有return返回值\n\n# 示例demo\n\n创建class类，继承React.Component，在里面提供render方法，在return里面返回内容\n\nclass Hello extends React.Component{\n    render(){\n        return (\n            <div>这是第一个类组件</div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过ReactDOM进行渲染\n\nReactDOM.render(<Hello />,document.getElementById('root'))\n\n\n1\n\n\n\n# 抽离成单独的JS文件\n\n * 思考：项目中组件多了之后，该如何组织这些组件？\n * 选择一：将所有的组件放在同一个JS文件中\n * 选择二：将每个组件放到单独的JS文件中\n * 组件作为一个独立的个体，一般都会放到一个单独的JS文件中\n\n# 示例demo\n\n * 创建Hello.js\n * 在Hello.js 中导入React，创建组件，在Hello.js中导出\n\nimport React from 'react'\n\nexport default class extends React.Component {\n    render(){\n        return (\n            <div>单独抽离出来的 Hello</div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 在index.js中导入Hello组件，渲染到页面\n\nimport Hello from './js/Hello'\nReactDOM.render(<Hello />,document.getElementById('root'))\n\n\n1\n2\n\n\n\n# React事件处理\n\n\n# 事件绑定\n\n * React事件绑定语法与DOM事件语法相似\n * 语法：on+事件名称=事件处理函数，比如 onClick = function(){}\n * 注意：React事件采用驼峰命名法\n\n# 示例demo\n\nexport default class extends React.Component {\n    clickHandle(e){\n        console.log('点了')\n    }\n    render(){\n        return (\n            <div><button onClick = {this.clickHandle}>点我点我点我</button></div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 小结\n\n * 在React中绑定事件与原生很类似\n * 需要注意点在于，在React绑定事件需要遵循驼峰命名法\n * 类组件与函数组件绑定事件是差不多的，只是在类组件中绑定事件函数的时候需要用到this，代表指向当前的类的引用，在函数中不需要调用this\n\n\n# 事件对象\n\n * 可以通过事件处理函数的参数获取到事件对象\n * React中的事件对象叫做：合成事件\n * 合成事件：兼容所有浏览器，无需担心跨浏览器兼容问题\n * 除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation()和 preventDefault()\n * 如果你想获取到原生事件对象，可以通过 nativeEvent 属性来进行获取\n\n# 示例demo\n\nexport default class extends React.Component {\n    clickHandle(e){\n        // 获取原生事件对象\n        console.log(e.nativeEvent)\n    }\n    render(){\n        return (\n            <div><button onClick = {this.clickHandle}>点我点我点我</button></div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 支持的事件\n\n * Clipboard Events 剪切板事件\n   \n   * 事件名 ：onCopy onCut onPaste\n   * 属性 ：DOMDataTransfer clipboardData\n\n * compositionEvent 复合事件\n   \n   * 事件名： onCompositionEnd onCompositionStart onCompositionUpdate\n   * 属性： string data\n\n * Keyboard Events 键盘事件\n   \n   * 事件名：onKeyDown onKeyPress onKeyUp\n   * 属性： 例如 number keyCode 太多就不一一列举\n\n * Focus Events 焦点事件 （这些焦点事件在 React DOM 上的所有元素都有效，不只是表单元素）\n   \n   * 事件名： onFocus onBlur\n   * 属性： DOMEventTarget relatedTarget\n\n * Form Events 表单事件\n   \n   * 事件名： onChange onInput onInvalid onSubmit\n\n * Mouse Events 鼠标事件\n   \n   * 事件名：\n     \n     onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit\n     onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave\n     onMouseMove onMouseOut onMouseOver onMouseUp\n     \n     \n     1\n     2\n     3\n     \n\n * Pointer Events 指针事件\n   \n   * 事件名：\n     \n     onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture\n     onLostPointerCapture onPointerEnter onPointerLeave onPointerOver onPointerOut\n     \n     \n     1\n     2\n     \n\n * Selection Events 选择事件\n   \n   * 事件名：onSelect\n\n * Touch Events 触摸事件\n   \n   * 事件名：onTouchCancel onTouchEnd onTouchMove onTouchStart\n\n * UI Events UI 事件\n   \n   * 事件名： onScroll\n\n * Wheel Events 滚轮事件\n   \n   * 事件名：onWheel\n   \n   * 属性：\n     \n     number deltaMode\n     number deltaX\n     number deltaY\n     number deltaZ\n     \n     \n     1\n     2\n     3\n     4\n     \n\n * Media Events 媒体事件\n   \n   * 事件名：\n     \n     onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted\n     onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay\n     onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend\n     onTimeUpdate onVolumeChange onWaiting\n     \n     \n     1\n     2\n     3\n     4\n     \n\n * Image Events 图像事件\n   \n   * 事件名：onLoad onError\n\n * Animation Events 动画事件\n   \n   * 事件名：onAnimationStart onAnimationEnd onAnimationIteration\n\n * Transition Events 过渡事件\n   \n   * 事件名：onTransitionEnd\n\n * Other Events 其他事件\n   \n   * 事件名： onToggle\n\n\n# 有状态组件和无状态组件\n\n * 函数组件又叫做 无状态组件，类组件又叫做 有状态组件\n * 状态(state) 即数据\n * 函数组件没有自己的状态，只负责数据展示\n * 类组件有自己的状态，负责更新UI，让页面动起来\n\n\n# State和SetState\n\n\n# state基本使用\n\n * 状态(state)即数据，是组件内部的私有数据，只能在组件内部使用\n * state的值是对象，表示一个组件中可以有多个数据\n * 通过this.state来获取状态\n\n# 示例demo\n\nexport default class extends React.Component {\n    constructor(){\n        super()\n\n        // 第一种初始化方式\n        this.state = {\n            count : 0\n        }\n    }\n    // 第二种初始化方式\n    state = {\n        count:1\n    }\n    render(){\n        return (\n            <div>计数器 :{this.state.count}</div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# setState() 修改状态\n\n * 状态是可变的\n * 语法：this.setState({要修改的数据})\n * 注意：不要直接修改state中的值，这是错误的\n * setState() 作用：1.修改 state 2.更新UI\n * 思想：数据驱动视图\n\n# 示例demo\n\nexport default class extends React.Component {\n    // 第二种初始化方式\n    state = {\n        count:1\n    }\n    render(){\n        return (\n            <div>\n                <div>计数器 :{this.state.count}</div>\n                <button onClick={() => {\n                     this.setState({\n            \t \t\tcount: this.state.count+1\n           \t\t\t  })   \n                }}>+1</button>\n            </div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 小结\n\n * 修改state里面的值我们需要通过 this.setState() 来进行修改\n * React底层会有监听，一旦我们调用了setState导致了数据的变化，就会重新调用一次render方法，重新渲染当前组件\n\n\n# 事件绑定this指向\n\n\n# 箭头函数\n\n * 利用箭头函数自身不绑定this的特点\n\n\n# 利用bind方法\n\n利用原型bind方法是可以更改函数里面this的指向的，所以我们可以在构造中调用bind方法，然后把返回的值赋值给我们的函数即可\n\nclass App extends React.Component {\n  constructor() {\n    super()\n\t...\n    // 通过bind方法改变了当前函数中this的指向\n    this.onIncrement = this.onIncrement.bind(this)\n  }\n  // 事件处理程序\n  onIncrement() {\n    ...\n  }\n\n  render() {\n    ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# class的实例方法\n\n * 利用箭头函数形式的class实例方法\n * 注意：该语法是实验性语法，但是，由于babel的存在可以使用\n\n  // 事件处理程序\n  onIncrement = () => {\n    console.log('事件处理程序中的this：', this)\n    this.setState({\n      count: this.state.count + 1\n    })\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 小结\n\n * 推荐：使用class的实例方法，也是依赖箭头函数不绑定this的原因",normalizedContent:"# react概述\n\nreact是一个用于构建用户界面的javascript库，起源于facebook的内部项目，后续在13年开源了出来\n\n * 声明式\n\n你只需要描述ui看起来是什么样式，就跟写html一样，react负责渲染ui\n\n * 基于组件\n\n组件时react最重要的内容，组件表示页面中的部分内容\n\n * 学习一次，随处使用\n\n使用react可以开发web应用，使用react可以开发移动端，可以开发vr应用\n\n# jsx\n\n由于通过createelement()方法创建的react元素有一些问题，代码比较繁琐，结构不直观，无法一眼看出描述的结构，不优雅，用户体验不爽\n\njsx概述\n\njsx是javascript xml 的简写，表示在javascript代码中写html格式的代码\n\n优势：声明式语法更加直观，与html结构相同，降低了学习成本，提升开发效率\n\n\n# 脚手架快速入门\n\nnpx create-react-app project-name\n\n输出 helloworld\n\nimport react from 'react'\nimport reactdom from 'react-dom'\nlet h1 = react.createelement('h1',null,'我是标题')\nreactdom.render(h1,document.getelementbyid('root'))\n\n\n1\n2\n3\n4\n\n\n\n# jsx基本使用\n\n# 使用步骤\n\n * 使用jsx语法创建react元素\n\nlet h1 = <h1>我是通过jsx创建的元素</h1>\n\n\n1\n\n * 使用reactdom来渲染元素\n\nreactdom.render(h1,document.getelementbyid('root'))\n\n\n1\n\n\n# 为什么在脚手架中可以使用jsx语法\n\n * jsx 不是标准的ecmascript语法，它是ecmascript的语法拓展\n * 需要使用babel编译处理后，才能在浏览器环境中使用\n * create-react-app脚手架中已经默认有该配置，无需手动配置\n * 编译jsx语法的包： @bable/preset-react\n\n# 注意点\n\n * react元素的属性名使用驼峰命名法\n * 特殊属性名：class -> classname，for -> htmlfor，tabindex -> tabindex\n * 如果没有子节点的react元素可以用 /> 来结束\n * 推荐：使用 小括号包裹jsx，从而避免js中自动插入分号报错\n\n\n# jxs基本语法\n\njsx是来描述页面的结构，我们一般在编写业务逻辑渲染页面的时候，需要涉及到传递值，调用函数，判断条件，循环等，这一些在jsx中都能得到支持\n\n# 嵌入js表达式\n\n语法：{javascritp表达式}\n\n例子：\n\nlet content = '插入的内容'\nlet h1 = <h1>我是通过jsx创建的元素+ {content}</h1>\n\n\n1\n2\n\n\n# 注意点\n\n * 只要是合法的js表达式都可以进行嵌入\n * jsx自身也是js表达式\n * 注意：js中的对象是一个例外，一般只会出现在style属性中\n * 注意：在{}中不能出现语句\n\n# 条件渲染\n\n根据不同的条件来渲染不同的jsx结构\n\nlet isloading = true\nlet loading = ()=>{\n    if(isloading){\n        return <div>loading...</div>\n    }\n    return <div>加载完成</div>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以发现，写jsx的条件渲染与我们之前编写代码的逻辑是差不多的，根据不同的判断逻辑，返回不同的 jsx结构，然后渲染到页面中\n\n# 列表渲染\n\n * 如果需要渲染一组数据，我们应该使用数组的 map () 方法\n * 注意：渲染列表的时候需要添加key属性，key属性的值要保证唯一\n * 原则：map()遍历谁，就给谁添加key属性\n * 注意：尽量避免使用索引号作为key\n\nlet arr = [{\n    id:1,\n    name:'三国演义'\n},{\n    id:2,\n    name:'水浒传'\n},{\n    id:3,\n    name:'西游记'\n},{\n    id:4,\n    name:'红楼梦'\n}]\nlet ul = (<ul>\n    {arr.map(item => <li key={item.id}>{item.name}</li>)}\n</ul>)\nreactdom.render(ul,document.getelementbyid('root'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 样式处理\n\n# 行内样式 -style\n\n在style里面我们通过对象的方式传递数据\n\n<li key={item.id} style={{'color': 'red',\"backgroundcolor\": 'pink'}}>{item.name}</li>\n\n\n1\n\n\n这种方式比较的麻烦，不方便进行阅读，而且还会导致代码比较的繁琐\n\n# 类名 -classname\n\n创建css文件编写样式代码\n\n.container {\n    text-align: center\n}\n\n\n1\n2\n3\n\n\n在js中进行引入，然后设置类名即可\n\nimport './css/index.css'\n\n<li classname='container' key={item.id} style={{'color': 'red',\"backgroundcolor\": 'pink'}}>{item.name}</li>\n\n\n1\n2\n3\n\n\n\n# 小结\n\n * jsx是react的核心内容\n * jsx表示在js代码中写html结构，是react声明式的体现\n * 使用jsx配合嵌入的js表达式、条件渲染、列表渲染、可以描述任意ui结构\n * 推荐使用classname的方式给jsx添加样式\n * react完全利用js语言自身的能力来编写ui，而不是造轮子增强html功能\n\n\n# react组件\n\n * 组件是react的一等公民，使用react就是在用组件\n * 组件表示页面中的部分功能\n * 组合多个组件实现完整的页面功能\n * 特点：可复用、独立、可组合\n\n\n# 函数创建组件\n\n * 函数组件：使用js的函数创建组件\n * **约定1：**函数名称必须以大写字母开头\n * **约定2：**函数组件必须有返回值，表示该组件的结构\n * 如果返回值为null，表示不渲染任何内容\n\n# 示例demo\n\n编写函数组件\n\nfunction hello() {\n    return (\n        <div>这是第一个函数组件</div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n\n\n利用reactdom.render()进行渲染\n\nreactdom.render(<hello />,document.getelementbyid('root'))\n\n\n1\n\n\n\n# 类组件\n\n * 使用es6语法的class创建的组件\n * 约定1：类名称也必须要大写字母开头\n * 约定2：类组件应该继承react.component父类，从而可以使用父类中提供的方法或者属性\n * 约定3：类组件必须提供 render 方法\n * 约定4：render方法中必须要有return返回值\n\n# 示例demo\n\n创建class类，继承react.component，在里面提供render方法，在return里面返回内容\n\nclass hello extends react.component{\n    render(){\n        return (\n            <div>这是第一个类组件</div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过reactdom进行渲染\n\nreactdom.render(<hello />,document.getelementbyid('root'))\n\n\n1\n\n\n\n# 抽离成单独的js文件\n\n * 思考：项目中组件多了之后，该如何组织这些组件？\n * 选择一：将所有的组件放在同一个js文件中\n * 选择二：将每个组件放到单独的js文件中\n * 组件作为一个独立的个体，一般都会放到一个单独的js文件中\n\n# 示例demo\n\n * 创建hello.js\n * 在hello.js 中导入react，创建组件，在hello.js中导出\n\nimport react from 'react'\n\nexport default class extends react.component {\n    render(){\n        return (\n            <div>单独抽离出来的 hello</div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 在index.js中导入hello组件，渲染到页面\n\nimport hello from './js/hello'\nreactdom.render(<hello />,document.getelementbyid('root'))\n\n\n1\n2\n\n\n\n# react事件处理\n\n\n# 事件绑定\n\n * react事件绑定语法与dom事件语法相似\n * 语法：on+事件名称=事件处理函数，比如 onclick = function(){}\n * 注意：react事件采用驼峰命名法\n\n# 示例demo\n\nexport default class extends react.component {\n    clickhandle(e){\n        console.log('点了')\n    }\n    render(){\n        return (\n            <div><button onclick = {this.clickhandle}>点我点我点我</button></div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 小结\n\n * 在react中绑定事件与原生很类似\n * 需要注意点在于，在react绑定事件需要遵循驼峰命名法\n * 类组件与函数组件绑定事件是差不多的，只是在类组件中绑定事件函数的时候需要用到this，代表指向当前的类的引用，在函数中不需要调用this\n\n\n# 事件对象\n\n * 可以通过事件处理函数的参数获取到事件对象\n * react中的事件对象叫做：合成事件\n * 合成事件：兼容所有浏览器，无需担心跨浏览器兼容问题\n * 除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stoppropagation()和 preventdefault()\n * 如果你想获取到原生事件对象，可以通过 nativeevent 属性来进行获取\n\n# 示例demo\n\nexport default class extends react.component {\n    clickhandle(e){\n        // 获取原生事件对象\n        console.log(e.nativeevent)\n    }\n    render(){\n        return (\n            <div><button onclick = {this.clickhandle}>点我点我点我</button></div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 支持的事件\n\n * clipboard events 剪切板事件\n   \n   * 事件名 ：oncopy oncut onpaste\n   * 属性 ：domdatatransfer clipboarddata\n\n * compositionevent 复合事件\n   \n   * 事件名： oncompositionend oncompositionstart oncompositionupdate\n   * 属性： string data\n\n * keyboard events 键盘事件\n   \n   * 事件名：onkeydown onkeypress onkeyup\n   * 属性： 例如 number keycode 太多就不一一列举\n\n * focus events 焦点事件 （这些焦点事件在 react dom 上的所有元素都有效，不只是表单元素）\n   \n   * 事件名： onfocus onblur\n   * 属性： domeventtarget relatedtarget\n\n * form events 表单事件\n   \n   * 事件名： onchange oninput oninvalid onsubmit\n\n * mouse events 鼠标事件\n   \n   * 事件名：\n     \n     onclick oncontextmenu ondoubleclick ondrag ondragend ondragenter ondragexit\n     ondragleave ondragover ondragstart ondrop onmousedown onmouseenter onmouseleave\n     onmousemove onmouseout onmouseover onmouseup\n     \n     \n     1\n     2\n     3\n     \n\n * pointer events 指针事件\n   \n   * 事件名：\n     \n     onpointerdown onpointermove onpointerup onpointercancel ongotpointercapture\n     onlostpointercapture onpointerenter onpointerleave onpointerover onpointerout\n     \n     \n     1\n     2\n     \n\n * selection events 选择事件\n   \n   * 事件名：onselect\n\n * touch events 触摸事件\n   \n   * 事件名：ontouchcancel ontouchend ontouchmove ontouchstart\n\n * ui events ui 事件\n   \n   * 事件名： onscroll\n\n * wheel events 滚轮事件\n   \n   * 事件名：onwheel\n   \n   * 属性：\n     \n     number deltamode\n     number deltax\n     number deltay\n     number deltaz\n     \n     \n     1\n     2\n     3\n     4\n     \n\n * media events 媒体事件\n   \n   * 事件名：\n     \n     onabort oncanplay oncanplaythrough ondurationchange onemptied onencrypted\n     onended onerror onloadeddata onloadedmetadata onloadstart onpause onplay\n     onplaying onprogress onratechange onseeked onseeking onstalled onsuspend\n     ontimeupdate onvolumechange onwaiting\n     \n     \n     1\n     2\n     3\n     4\n     \n\n * image events 图像事件\n   \n   * 事件名：onload onerror\n\n * animation events 动画事件\n   \n   * 事件名：onanimationstart onanimationend onanimationiteration\n\n * transition events 过渡事件\n   \n   * 事件名：ontransitionend\n\n * other events 其他事件\n   \n   * 事件名： ontoggle\n\n\n# 有状态组件和无状态组件\n\n * 函数组件又叫做 无状态组件，类组件又叫做 有状态组件\n * 状态(state) 即数据\n * 函数组件没有自己的状态，只负责数据展示\n * 类组件有自己的状态，负责更新ui，让页面动起来\n\n\n# state和setstate\n\n\n# state基本使用\n\n * 状态(state)即数据，是组件内部的私有数据，只能在组件内部使用\n * state的值是对象，表示一个组件中可以有多个数据\n * 通过this.state来获取状态\n\n# 示例demo\n\nexport default class extends react.component {\n    constructor(){\n        super()\n\n        // 第一种初始化方式\n        this.state = {\n            count : 0\n        }\n    }\n    // 第二种初始化方式\n    state = {\n        count:1\n    }\n    render(){\n        return (\n            <div>计数器 :{this.state.count}</div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# setstate() 修改状态\n\n * 状态是可变的\n * 语法：this.setstate({要修改的数据})\n * 注意：不要直接修改state中的值，这是错误的\n * setstate() 作用：1.修改 state 2.更新ui\n * 思想：数据驱动视图\n\n# 示例demo\n\nexport default class extends react.component {\n    // 第二种初始化方式\n    state = {\n        count:1\n    }\n    render(){\n        return (\n            <div>\n                <div>计数器 :{this.state.count}</div>\n                <button onclick={() => {\n                     this.setstate({\n            \t \t\tcount: this.state.count+1\n           \t\t\t  })   \n                }}>+1</button>\n            </div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 小结\n\n * 修改state里面的值我们需要通过 this.setstate() 来进行修改\n * react底层会有监听，一旦我们调用了setstate导致了数据的变化，就会重新调用一次render方法，重新渲染当前组件\n\n\n# 事件绑定this指向\n\n\n# 箭头函数\n\n * 利用箭头函数自身不绑定this的特点\n\n\n# 利用bind方法\n\n利用原型bind方法是可以更改函数里面this的指向的，所以我们可以在构造中调用bind方法，然后把返回的值赋值给我们的函数即可\n\nclass app extends react.component {\n  constructor() {\n    super()\n\t...\n    // 通过bind方法改变了当前函数中this的指向\n    this.onincrement = this.onincrement.bind(this)\n  }\n  // 事件处理程序\n  onincrement() {\n    ...\n  }\n\n  render() {\n    ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# class的实例方法\n\n * 利用箭头函数形式的class实例方法\n * 注意：该语法是实验性语法，但是，由于babel的存在可以使用\n\n  // 事件处理程序\n  onincrement = () => {\n    console.log('事件处理程序中的this：', this)\n    this.setstate({\n      count: this.state.count + 1\n    })\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 小结\n\n * 推荐：使用class的实例方法，也是依赖箭头函数不绑定this的原因",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"react受控和非受控组件",frontmatter:{title:"react受控和非受控组件",date:"2022-12-01T20:10:46.000Z",permalink:"/pages/e67f9a/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.heima/02.react%E5%8F%97%E6%8E%A7%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6.html",relativePath:"02.软件框架/06.react/01.heima/02.react受控和非受控组件.md",key:"v-005bcdbb",path:"/pages/e67f9a/",headers:[{level:2,title:"受控组件",slug:"受控组件",normalizedTitle:"受控组件",charIndex:2},{level:4,title:"使用步骤",slug:"使用步骤",normalizedTitle:"使用步骤",charIndex:164},{level:4,title:"示例demo",slug:"示例demo",normalizedTitle:"示例demo",charIndex:241},{level:4,title:"多表单元素优化",slug:"多表单元素优化",normalizedTitle:"多表单元素优化",charIndex:959},{level:5,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:166},{level:5,title:"示例demo",slug:"示例demo-2",normalizedTitle:"示例demo",charIndex:241},{level:2,title:"非受控组件",slug:"非受控组件",normalizedTitle:"非受控组件",charIndex:1529},{level:4,title:"使用步骤",slug:"使用步骤-2",normalizedTitle:"使用步骤",charIndex:164},{level:2,title:"评论列表案例",slug:"评论列表案例",normalizedTitle:"评论列表案例",charIndex:2152},{level:3,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:2163},{level:3,title:"搭建评论列表的模板",slug:"搭建评论列表的模板",normalizedTitle:"搭建评论列表的模板",charIndex:2267},{level:3,title:"渲染评论列表",slug:"渲染评论列表",normalizedTitle:"渲染评论列表",charIndex:2172},{level:3,title:"渲染暂无评论",slug:"渲染暂无评论",normalizedTitle:"渲染暂无评论",charIndex:4181},{level:3,title:"获取评论信息",slug:"获取评论信息",normalizedTitle:"获取评论信息",charIndex:2212},{level:3,title:"发表评论",slug:"发表评论",normalizedTitle:"发表评论",charIndex:2239}],headersStr:"受控组件 使用步骤 示例demo 多表单元素优化 步骤 示例demo 非受控组件 使用步骤 评论列表案例 需求分析 搭建评论列表的模板 渲染评论列表 渲染暂无评论 获取评论信息 发表评论",content:"# 受控组件\n\n * HTML中的表单元素是可输入的，也就是有自己的可变状态\n * 而React中可变状态通常保存在state中，并且只能通过setState() 方法来修改\n * React讲state与表单元素值value绑定在一起，有state的值来控制表单元素的值\n * 受控组件：值受到react控制的表单元素\n\n# 使用步骤\n\n * 在state中添加一个状态，作为表单元素的value值\n * 给表单元素绑定change事件，将表单元素的值设置为state的值\n\n# 示例demo\n\nclass App extends React.Component {\n    constructor(){\n        super()\n        this.inputChange = this.inputChange.bind(this)\n    }\n    state = {\n        txt : ''\n    }\n    inputChange(e){\n       this.setState({\n           txt: e.target.value\n       })\n    }\n    render(){\n        console.log(this.state);\n        \n        return (\n            <div>\n                {/* 把state的值设置给输入框的value，绑定change事件，这样用户在输入内容的时候调用相应函数，在函数里面把当前设置的值赋值给state，从而达到数据的统一 */}\n                <input type=\"text\" value={this.state.txt} onChange={this.inputChange}/>\n            </div>\n        )\n    }\n}\nReactDOM.render(<App />,document.getElementById('root'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 多表单元素优化\n\n * 问题：每个表单元素都有一个单独的事件处理函数，这样太繁琐\n * 优化：使用一个事件处理程序同时处理多个表单元素\n\n# 步骤\n\n * 给表单元素添加name属性（用来区分是哪一个表单），名称与state相同（用来更新数据的）\n * 根据表单内容来获取对应值\n * 在change事件处理程序中通过 [name] 来修改对应的state\n\n# 示例demo\n\ninputChange(e){\n   let target = e.target;\n   let value = target.type == 'checkbox' ? target.checked : target.value;\n   this.setState({\n       [e.target.name]: value\n   })\n}\n<input type=\"text\" value={this.state.txt} name=\"txt\" onChange={this.inputChange}/>\n<input type=\"checkbox\" value={this.state.isChecked} name=\"isChecked\" onChange={this.inputChange}/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 非受控组件\n\n * 说明：借助于ref，使用元素DOM方式获取表单元素值\n * ref的作用：获取DOM或者组件\n\n# 使用步骤\n\n * 调用 React.createRef() 方法创建ref对象\n * 将创建好的 ref 对象添加到文本框中\n * 通过ref对象获取到文本框的值\n\nclass App extends React.Component {\n    constructor(){\n        super()\n        \n        //创建 ref\n        this.txtRef = React.createRef()\n    }\n    // 获取文本框的值\n    getTxt =() => {\n        console.log(this.txtRef.current.value)\n    }\n    render(){\n        return (\n          <div>\n            <input type =\"text\" ref={this.txtRef} />\n            <button onClick ={this.getTxt}>获取值</button>\n          </div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 评论列表案例\n\n\n# 需求分析\n\n * 渲染评论列表（列表渲染）\n * 没有评论数据时渲染：暂无评论（条件渲染）\n * 获取评论信息，包括评论人和评论内容（受控组件）\n * 发表评论，更新评论列表（setState()）\n\n\n# 搭建评论列表的模板\n\n * 结构\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n/* \n  评论列表案例\n\n  comments: [\n    { id: 1, name: 'jack', content: '沙发！！！' },\n    { id: 2, name: 'rose', content: '板凳~' },\n    { id: 3, name: 'tom', content: '楼主好人' }\n  ]\n*/\n\nimport './index.css'\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"app\">\n        <div>\n          <input className=\"user\" type=\"text\" placeholder=\"请输入评论人\" />\n          <br />\n          <textarea\n            className=\"content\"\n            cols=\"30\"\n            rows=\"10\"\n            placeholder=\"请输入评论内容\"\n          />\n          <br />\n          <button>发表评论</button>\n        </div>\n\n        <div className=\"no-comment\">暂无评论，快去评论吧~</div>\n        <ul>\n          <li>\n            <h3>评论人：jack</h3>\n            <p>评论内容：沙发！！！</p>\n          </li>\n        </ul>\n      </div>\n    )\n  }\n}\n\n// 渲染组件\nReactDOM.render(<App />, document.getElementById('root'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 样式\n\n.app {\n  width: 300px;\n  padding: 10px;\n  border: 1px solid #999;\n}\n\n.user {\n  width: 100%;\n  box-sizing: border-box;\n  margin-bottom: 10px;\n}\n\n.content {\n  width: 100%;\n  box-sizing: border-box;\n  margin-bottom: 10px;\n}\n\n.no-comment {\n  text-align: center;\n  margin-top: 30px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 渲染评论列表\n\n * 在state中初始化评论列表数据\n\n  state = {\n    comments: [\n      { id: 1, name: 'jack', content: '沙发！！！' },\n      { id: 2, name: 'rose', content: '板凳~' },\n      { id: 3, name: 'tom', content: '楼主好人' }\n    ]\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 使用数组的map方法遍历state中的列表数据\n * 给每一个被遍历的li元素添加key属性\n * 在render方法里的ul节点下嵌入表达式\n\n{\n  this.state.comments.map(item => {\n    return (\n       <li key={item.id}>\n          <h3>{item.name}</h3>\n          <p>{item.content}</p>\n       </li>\n    )\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 渲染暂无评论\n\n * 判断列表数据的长度是否为0\n\n * 如果为0，则渲染暂无评论\n\n * 如果不为0，那么渲染列表数据\n\n * 在jsx中大量写逻辑会导致很臃肿，所以我们可以把条件渲染的逻辑抽取成一个函数\n\n/**\n * 条件渲染，这里抽取出来了，这样在结构中不会很混乱\n */\nrenderList(){\n  if (this.state.comments.length === 0) {\n    return (<div className=\"no-comment\">暂无评论，快去评论吧~</div>)\n  } else {\n    return (\n      <ul> {\n        this.state.comments.map(item => {\n          return (\n            <li key={item.id}>\n              <h3>{item.name}</h3>\n              <p>{item.content}</p>\n            </li>\n          )\n        })\n      }\n      </ul>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 在render的return方法里面调用这个函数即可\n\nrender() {\n  return (\n    <div>\n      ...\n      {/* 通过条件渲染来判断是否显示暂无评论 */}\n      {this.renderList()}\n    </div>\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 获取评论信息\n\n * 通过受控组件来获取内容\n * 初始化用户名和用户内容的state\n\nuserName: '',\nuserContent: ''\n\n\n1\n2\n\n * 在结构中，把表单元素的value与state进行绑定，还需要绑定name属性和onChange属性\n\n<input className=\"user\" type=\"text\" placeholder=\"请输入评论人\" value={this.state.userName} name=\"userName\" onChange={this.handleForm}/>\n<br />\n<textarea\n  className=\"content\"\n  cols=\"30\"\n  rows=\"10\"\n  placeholder=\"请输入评论内容\"\n  value={this.state.userContent}\n  name=\"userContent\"\n  onChange={this.handleForm}\n/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 在handleFrom函数中利用setState来让数据保持一致\n\n  handleForm = (e) => {\n     this.setState({\n       [e.target.name] : e.target.value\n     })\n  }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 发表评论\n\n * 给按钮绑定事件\n * 在事件处理程序中，通过state获取评论信息\n * 将评论信息添加到state中，利用setState来更新页面\n * 添加评论前需要判断用户是否输入内容\n * 添加评论后，需要情况文本框用户输入的值\n\nhandleClick = (e) => {\n  // 拿到用户输入的内容\n  let {userName,userContent} = this.state\n  if(userName.trim()==='' || userContent.trim() === ''){\n      alert('请输入内容')\n      return\n  }\n  // 利用数组拓展运算符来进行数据的拼接，把用户输入的存放在数组的第一个位置\n  let newComments = [{\n    id: this.state.comments.length+1,\n    name: userName,\n    content: userContent\n  },...this.state.comments]\n  this.setState({\n    comments: newComments,\n    userName:'',\n    userContent: ''\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# 受控组件\n\n * html中的表单元素是可输入的，也就是有自己的可变状态\n * 而react中可变状态通常保存在state中，并且只能通过setstate() 方法来修改\n * react讲state与表单元素值value绑定在一起，有state的值来控制表单元素的值\n * 受控组件：值受到react控制的表单元素\n\n# 使用步骤\n\n * 在state中添加一个状态，作为表单元素的value值\n * 给表单元素绑定change事件，将表单元素的值设置为state的值\n\n# 示例demo\n\nclass app extends react.component {\n    constructor(){\n        super()\n        this.inputchange = this.inputchange.bind(this)\n    }\n    state = {\n        txt : ''\n    }\n    inputchange(e){\n       this.setstate({\n           txt: e.target.value\n       })\n    }\n    render(){\n        console.log(this.state);\n        \n        return (\n            <div>\n                {/* 把state的值设置给输入框的value，绑定change事件，这样用户在输入内容的时候调用相应函数，在函数里面把当前设置的值赋值给state，从而达到数据的统一 */}\n                <input type=\"text\" value={this.state.txt} onchange={this.inputchange}/>\n            </div>\n        )\n    }\n}\nreactdom.render(<app />,document.getelementbyid('root'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 多表单元素优化\n\n * 问题：每个表单元素都有一个单独的事件处理函数，这样太繁琐\n * 优化：使用一个事件处理程序同时处理多个表单元素\n\n# 步骤\n\n * 给表单元素添加name属性（用来区分是哪一个表单），名称与state相同（用来更新数据的）\n * 根据表单内容来获取对应值\n * 在change事件处理程序中通过 [name] 来修改对应的state\n\n# 示例demo\n\ninputchange(e){\n   let target = e.target;\n   let value = target.type == 'checkbox' ? target.checked : target.value;\n   this.setstate({\n       [e.target.name]: value\n   })\n}\n<input type=\"text\" value={this.state.txt} name=\"txt\" onchange={this.inputchange}/>\n<input type=\"checkbox\" value={this.state.ischecked} name=\"ischecked\" onchange={this.inputchange}/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 非受控组件\n\n * 说明：借助于ref，使用元素dom方式获取表单元素值\n * ref的作用：获取dom或者组件\n\n# 使用步骤\n\n * 调用 react.createref() 方法创建ref对象\n * 将创建好的 ref 对象添加到文本框中\n * 通过ref对象获取到文本框的值\n\nclass app extends react.component {\n    constructor(){\n        super()\n        \n        //创建 ref\n        this.txtref = react.createref()\n    }\n    // 获取文本框的值\n    gettxt =() => {\n        console.log(this.txtref.current.value)\n    }\n    render(){\n        return (\n          <div>\n            <input type =\"text\" ref={this.txtref} />\n            <button onclick ={this.gettxt}>获取值</button>\n          </div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 评论列表案例\n\n\n# 需求分析\n\n * 渲染评论列表（列表渲染）\n * 没有评论数据时渲染：暂无评论（条件渲染）\n * 获取评论信息，包括评论人和评论内容（受控组件）\n * 发表评论，更新评论列表（setstate()）\n\n\n# 搭建评论列表的模板\n\n * 结构\n\nimport react from 'react'\nimport reactdom from 'react-dom'\n\n/* \n  评论列表案例\n\n  comments: [\n    { id: 1, name: 'jack', content: '沙发！！！' },\n    { id: 2, name: 'rose', content: '板凳~' },\n    { id: 3, name: 'tom', content: '楼主好人' }\n  ]\n*/\n\nimport './index.css'\n\nclass app extends react.component {\n  render() {\n    return (\n      <div classname=\"app\">\n        <div>\n          <input classname=\"user\" type=\"text\" placeholder=\"请输入评论人\" />\n          <br />\n          <textarea\n            classname=\"content\"\n            cols=\"30\"\n            rows=\"10\"\n            placeholder=\"请输入评论内容\"\n          />\n          <br />\n          <button>发表评论</button>\n        </div>\n\n        <div classname=\"no-comment\">暂无评论，快去评论吧~</div>\n        <ul>\n          <li>\n            <h3>评论人：jack</h3>\n            <p>评论内容：沙发！！！</p>\n          </li>\n        </ul>\n      </div>\n    )\n  }\n}\n\n// 渲染组件\nreactdom.render(<app />, document.getelementbyid('root'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n * 样式\n\n.app {\n  width: 300px;\n  padding: 10px;\n  border: 1px solid #999;\n}\n\n.user {\n  width: 100%;\n  box-sizing: border-box;\n  margin-bottom: 10px;\n}\n\n.content {\n  width: 100%;\n  box-sizing: border-box;\n  margin-bottom: 10px;\n}\n\n.no-comment {\n  text-align: center;\n  margin-top: 30px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 渲染评论列表\n\n * 在state中初始化评论列表数据\n\n  state = {\n    comments: [\n      { id: 1, name: 'jack', content: '沙发！！！' },\n      { id: 2, name: 'rose', content: '板凳~' },\n      { id: 3, name: 'tom', content: '楼主好人' }\n    ]\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 使用数组的map方法遍历state中的列表数据\n * 给每一个被遍历的li元素添加key属性\n * 在render方法里的ul节点下嵌入表达式\n\n{\n  this.state.comments.map(item => {\n    return (\n       <li key={item.id}>\n          <h3>{item.name}</h3>\n          <p>{item.content}</p>\n       </li>\n    )\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 渲染暂无评论\n\n * 判断列表数据的长度是否为0\n\n * 如果为0，则渲染暂无评论\n\n * 如果不为0，那么渲染列表数据\n\n * 在jsx中大量写逻辑会导致很臃肿，所以我们可以把条件渲染的逻辑抽取成一个函数\n\n/**\n * 条件渲染，这里抽取出来了，这样在结构中不会很混乱\n */\nrenderlist(){\n  if (this.state.comments.length === 0) {\n    return (<div classname=\"no-comment\">暂无评论，快去评论吧~</div>)\n  } else {\n    return (\n      <ul> {\n        this.state.comments.map(item => {\n          return (\n            <li key={item.id}>\n              <h3>{item.name}</h3>\n              <p>{item.content}</p>\n            </li>\n          )\n        })\n      }\n      </ul>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 在render的return方法里面调用这个函数即可\n\nrender() {\n  return (\n    <div>\n      ...\n      {/* 通过条件渲染来判断是否显示暂无评论 */}\n      {this.renderlist()}\n    </div>\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 获取评论信息\n\n * 通过受控组件来获取内容\n * 初始化用户名和用户内容的state\n\nusername: '',\nusercontent: ''\n\n\n1\n2\n\n * 在结构中，把表单元素的value与state进行绑定，还需要绑定name属性和onchange属性\n\n<input classname=\"user\" type=\"text\" placeholder=\"请输入评论人\" value={this.state.username} name=\"username\" onchange={this.handleform}/>\n<br />\n<textarea\n  classname=\"content\"\n  cols=\"30\"\n  rows=\"10\"\n  placeholder=\"请输入评论内容\"\n  value={this.state.usercontent}\n  name=\"usercontent\"\n  onchange={this.handleform}\n/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 在handlefrom函数中利用setstate来让数据保持一致\n\n  handleform = (e) => {\n     this.setstate({\n       [e.target.name] : e.target.value\n     })\n  }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 发表评论\n\n * 给按钮绑定事件\n * 在事件处理程序中，通过state获取评论信息\n * 将评论信息添加到state中，利用setstate来更新页面\n * 添加评论前需要判断用户是否输入内容\n * 添加评论后，需要情况文本框用户输入的值\n\nhandleclick = (e) => {\n  // 拿到用户输入的内容\n  let {username,usercontent} = this.state\n  if(username.trim()==='' || usercontent.trim() === ''){\n      alert('请输入内容')\n      return\n  }\n  // 利用数组拓展运算符来进行数据的拼接，把用户输入的存放在数组的第一个位置\n  let newcomments = [{\n    id: this.state.comments.length+1,\n    name: username,\n    content: usercontent\n  },...this.state.comments]\n  this.setstate({\n    comments: newcomments,\n    username:'',\n    usercontent: ''\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"react组件通信",frontmatter:{title:"react组件通信",date:"2022-12-01T20:25:51.000Z",permalink:"/pages/d4ac65/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.heima/03.react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",relativePath:"02.软件框架/06.react/01.heima/03.react组件通信.md",key:"v-2df0fd98",path:"/pages/d4ac65/",headers:[{level:2,title:"React组件通信",slug:"react组件通信",normalizedTitle:"react组件通信",charIndex:2},{level:2,title:"组件通讯介绍",slug:"组件通讯介绍",normalizedTitle:"组件通讯介绍",charIndex:86},{level:2,title:"组件的props",slug:"组件的props",normalizedTitle:"组件的props",charIndex:237},{level:2,title:"组件通讯的三种方式",slug:"组件通讯的三种方式",normalizedTitle:"组件通讯的三种方式",charIndex:915},{level:2,title:"父组件传递数据给子组件",slug:"父组件传递数据给子组件",normalizedTitle:"父组件传递数据给子组件",charIndex:929},{level:2,title:"子组件传递数据给父组件",slug:"子组件传递数据给父组件",normalizedTitle:"子组件传递数据给父组件",charIndex:1368},{level:2,title:"兄弟组件传递",slug:"兄弟组件传递",normalizedTitle:"兄弟组件传递",charIndex:2116},{level:4,title:"示例demo",slug:"示例demo",normalizedTitle:"示例demo",charIndex:2245},{level:2,title:"Context",slug:"context",normalizedTitle:"context",charIndex:4002},{level:3,title:"使用步骤",slug:"使用步骤",normalizedTitle:"使用步骤",charIndex:4074},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:4687},{level:2,title:"props",slug:"props",normalizedTitle:"props",charIndex:20},{level:3,title:"children属性",slug:"children属性",normalizedTitle:"children属性",charIndex:4822},{level:3,title:"props校验",slug:"props校验",normalizedTitle:"props校验",charIndex:74},{level:4,title:"使用步骤",slug:"使用步骤-2",normalizedTitle:"使用步骤",charIndex:4074},{level:4,title:"常见的约束规则",slug:"常见的约束规则",normalizedTitle:"常见的约束规则",charIndex:5358}],headersStr:"React组件通信 组件通讯介绍 组件的props 组件通讯的三种方式 父组件传递数据给子组件 子组件传递数据给父组件 兄弟组件传递 示例demo Context 使用步骤 小结 props children属性 props校验 使用步骤 常见的约束规则",content:"# React组件通信\n\n * 能够使用props接收数据\n * 能够实现父子组件之间的通讯\n * 能够实现兄弟组件之间的通讯\n * 能够给组件添加props校验\n\n\n# 组件通讯介绍\n\n组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通，这个过程就是组件通讯\n\n\n# 组件的props\n\n * 组件时封闭的，要接受外部数据应该通过props来实现\n * props的作用：接收传递给组件的数据\n * 传递数据：给组件标签添加属性\n\n<Hello name=\"jack\" age={19} />\n\n\n1\n\n\n接收数据：函数组件通过 参数 props接收数据，类组件通过 this.props接收数据\n\n * 函数组件获取\n   \n   function Hello(props){\n     return (<div>{props.name}</div>)\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 类组件获取\n   \n   class Hello extend React.Componet{\n     render(){\n       return(\n       \t<div>{this.props.name}</div>\n       )\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 可以给组件传递任意类型的数据\n\n * props是只读属性，不能对值进行修改\n\n * 注意：使用类组件时，如果写了构造函数，应该将props传递给super(),否则，无法在构造函数中获取到props，其他的地方是可以拿到的\n\nclass Hello extend React.Componet{\n  constructor(props){\n    super(props)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 组件通讯的三种方式\n\n\n# 父组件传递数据给子组件\n\n * 父组件提供要传递的state数据\n * 给子组件标签添加属性，值为state中的数据\n * 子组件中通过props接收父组件中传递的数据\n\nclass Parent extends React.Componet{\n  state = {lastName:'yuan'}\n\trender(){\n    return (\n    \t<div>\n      \t<Child name={this.state.lastName}></Child>\n      </div>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nChild\n\nclass Child extends React.Componet{\n\trender(){\n    return (\n    \t<div>\n      \t{this.props.name}\n      </div>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 子组件传递数据给父组件\n\n * 利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数\n * 父组件提供一个回调函数，用来接收数据\n * 将该函数作为属性的值，传递给子组件\n\nclass Parent extends React.Componet{\n  state = {lastName:'yuan'}\n\tgetChildMsg = (msg)=>{\n    console.log(msg)\n  }\n\trender(){\n    return (\n    \t<div>\n      \t<Child getMsg = {this.getChildMsg}></Child>\n      </div>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n * 子组件通过props调用回调函数\n   \n   class Child extends React.Componet{\n      state = {lastName:'yuan'}\n     handleClick = ()=>{\n       this.props.getMsg(this.state.lastName)\n     }\n   \trender(){\n       return (\n       \t<button onClick={this.handleClick}>\n         \t传递数据给父组件\n         </button>\n       )\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 兄弟组件传递\n\n * 将共享状态(数据)提升到最近的公共父组件中，由公共父组件管理这个状态\n * 这个称为状态提升\n * 公共父组件职责：1. 提供共享状态 2.提供操作共享状态的方法\n * 要通讯的子组件只需要通过props接收状态或操作状态的方法\n\n# 示例demo\n\n * 定义布局结构，一个Counter里面包含两个子组件，一个是计数器的提示，一个是按钮\n\nclass Counter extends React.Component {\n    render() {\n        return (<div>\n            <Child1 />\n            <Child2 />\n        </div>\n        )\n    }\n}\nclass Child1 extends React.Component {\n    render() {\n        return (\n            <h1>计数器：</h1>\n        )\n    }\n}\nclass Child2 extends React.Component {\n    render() {\n        return (\n            <button>+1</button>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 在父组件里定义共享状态，把这个状态传递给第一个子组件\n\nclass Counter extends React.Component {\n    // 提供共享的状态\n    state = {\n        count: 0\n    }\n    render() {\n        return (<div>\n            {/* 把状态提供给第一个子组件 */}\n            <Child1 count={this.state.count}/>\n            <Child2 />\n        </div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 在第一个子组件里面就能通过props获取到\n\nclass Child1 extends React.Component {\n    render() {\n        return (\n            <h1>计数器：{this.props.count}</h1>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 在父组件中提供共享方法，通过属性传递给第二个子组件，方便第二个子组件来进行调用\n\n    // 提供共享方法\n    onIncrement = (res) => {\n        // 只要第二个子组件调用了这个函数，就会执行里面代码\n        this.setState({\n            count: this.state.count + res\n        })\n    }\n    render() {\n        return (<div>\n            ...\n            {/* 把共享方法提供给第二个子组件 */}\n            <Child2 onIncrement={this.onIncrement} />\n        </div>\n        )\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 在第二个子组件里面通过props来获取到对应函数，然后进行调用\n\nclass Child2 extends React.Component {\n    handleClick = () => {\n        // 这里一旦调用，就会执行父组件里面 onIncrement函数\n        this.props.onIncrement(2)\n    }\n    render() {\n        return (\n            <button onClick={this.handleClick}>+</button>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Context\n\n如果出现层级比较多的情况下（例如：爷爷传递数据给孙子），我们会使用Context来进行传递\n\n作用： 跨组件传递数据\n\n\n# 使用步骤\n\n * 调用 React.createContext() 创建 Provider(提供数据) 和 Consumer(消费数据) 两个组件\n   \n   const {Provider,Consumer}  = React.createContext()\n   \n   \n   1\n   \n\n * 使用Provider 组件作为父节点\n   \n   <Provider>\n   \t<div className = \"App\">\n     \t<Child1/>\n     </div>\n   </Provider>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 设置value属性，表示要传递的数据\n   \n   <Provider value= \"yuan\">\n   \n   \n   1\n   \n\n * 哪一层想要接收数据，就用Consumer进行包裹，在里面回调函数中的参数就是传递过来的值\n   \n   <Consumer>\n   \t{\n       (data)=>{\n       \t<span>\n         \tdata参数接收为:-- {data}\n         </span>\n     \t}\n     }\n   </Consumer>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 小结\n\n * 如果两个组件相隔层级比较多，可以使用Context实现组件通讯\n * Context提供了两个组件：Provider 和 Consumer\n * Provider组件： 用来提供数据\n * Consumer组件： 用来消费数据\n\n\n# props\n\n\n# children属性\n\n * children属性： 表示组件标签的子节点，当组件标签有子节点时，props就会有该属性\n * children属性与普通的props一样，值可以使任意值（文本、react元素、组件、甚至是函数）\n\n\n# props校验\n\n * 对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据，简单来说就是组件调用者可能不知道组件封装着需要什么样的数据\n * 如果传入的数据不对，可能会导致报错\n * 关键问题：组件的使用者不知道需要传递什么样的数据\n * props校验：允许在创建组件的时候，指定props的类型、格式等\n * 作用：捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性\n\n# 使用步骤\n\n * 安装包 prop-types (yarn add prop-types | npm i props-types)\n * 导入prop-types 包\n * 使用组件名.propTypes={} 来给组件的props添加校验规则\n * 校验规则通过PropTypes对象来指定\n\nApp.propTypes = {\n  colors:PropTypes.array\n}\n\n\n1\n2\n3\n\n\n# 常见的约束规则\n\n * 创建的类型： array、bool、func、number、object、string\n * React元素类型：element\n * 必填项：isRequired\n * 特定结构的对象： shape({})\n * 更多的[约束规则](",normalizedContent:"# react组件通信\n\n * 能够使用props接收数据\n * 能够实现父子组件之间的通讯\n * 能够实现兄弟组件之间的通讯\n * 能够给组件添加props校验\n\n\n# 组件通讯介绍\n\n组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通，这个过程就是组件通讯\n\n\n# 组件的props\n\n * 组件时封闭的，要接受外部数据应该通过props来实现\n * props的作用：接收传递给组件的数据\n * 传递数据：给组件标签添加属性\n\n<hello name=\"jack\" age={19} />\n\n\n1\n\n\n接收数据：函数组件通过 参数 props接收数据，类组件通过 this.props接收数据\n\n * 函数组件获取\n   \n   function hello(props){\n     return (<div>{props.name}</div>)\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 类组件获取\n   \n   class hello extend react.componet{\n     render(){\n       return(\n       \t<div>{this.props.name}</div>\n       )\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 可以给组件传递任意类型的数据\n\n * props是只读属性，不能对值进行修改\n\n * 注意：使用类组件时，如果写了构造函数，应该将props传递给super(),否则，无法在构造函数中获取到props，其他的地方是可以拿到的\n\nclass hello extend react.componet{\n  constructor(props){\n    super(props)\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 组件通讯的三种方式\n\n\n# 父组件传递数据给子组件\n\n * 父组件提供要传递的state数据\n * 给子组件标签添加属性，值为state中的数据\n * 子组件中通过props接收父组件中传递的数据\n\nclass parent extends react.componet{\n  state = {lastname:'yuan'}\n\trender(){\n    return (\n    \t<div>\n      \t<child name={this.state.lastname}></child>\n      </div>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nchild\n\nclass child extends react.componet{\n\trender(){\n    return (\n    \t<div>\n      \t{this.props.name}\n      </div>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 子组件传递数据给父组件\n\n * 利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数\n * 父组件提供一个回调函数，用来接收数据\n * 将该函数作为属性的值，传递给子组件\n\nclass parent extends react.componet{\n  state = {lastname:'yuan'}\n\tgetchildmsg = (msg)=>{\n    console.log(msg)\n  }\n\trender(){\n    return (\n    \t<div>\n      \t<child getmsg = {this.getchildmsg}></child>\n      </div>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n * 子组件通过props调用回调函数\n   \n   class child extends react.componet{\n      state = {lastname:'yuan'}\n     handleclick = ()=>{\n       this.props.getmsg(this.state.lastname)\n     }\n   \trender(){\n       return (\n       \t<button onclick={this.handleclick}>\n         \t传递数据给父组件\n         </button>\n       )\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n\n# 兄弟组件传递\n\n * 将共享状态(数据)提升到最近的公共父组件中，由公共父组件管理这个状态\n * 这个称为状态提升\n * 公共父组件职责：1. 提供共享状态 2.提供操作共享状态的方法\n * 要通讯的子组件只需要通过props接收状态或操作状态的方法\n\n# 示例demo\n\n * 定义布局结构，一个counter里面包含两个子组件，一个是计数器的提示，一个是按钮\n\nclass counter extends react.component {\n    render() {\n        return (<div>\n            <child1 />\n            <child2 />\n        </div>\n        )\n    }\n}\nclass child1 extends react.component {\n    render() {\n        return (\n            <h1>计数器：</h1>\n        )\n    }\n}\nclass child2 extends react.component {\n    render() {\n        return (\n            <button>+1</button>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * 在父组件里定义共享状态，把这个状态传递给第一个子组件\n\nclass counter extends react.component {\n    // 提供共享的状态\n    state = {\n        count: 0\n    }\n    render() {\n        return (<div>\n            {/* 把状态提供给第一个子组件 */}\n            <child1 count={this.state.count}/>\n            <child2 />\n        </div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 在第一个子组件里面就能通过props获取到\n\nclass child1 extends react.component {\n    render() {\n        return (\n            <h1>计数器：{this.props.count}</h1>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 在父组件中提供共享方法，通过属性传递给第二个子组件，方便第二个子组件来进行调用\n\n    // 提供共享方法\n    onincrement = (res) => {\n        // 只要第二个子组件调用了这个函数，就会执行里面代码\n        this.setstate({\n            count: this.state.count + res\n        })\n    }\n    render() {\n        return (<div>\n            ...\n            {/* 把共享方法提供给第二个子组件 */}\n            <child2 onincrement={this.onincrement} />\n        </div>\n        )\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 在第二个子组件里面通过props来获取到对应函数，然后进行调用\n\nclass child2 extends react.component {\n    handleclick = () => {\n        // 这里一旦调用，就会执行父组件里面 onincrement函数\n        this.props.onincrement(2)\n    }\n    render() {\n        return (\n            <button onclick={this.handleclick}>+</button>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# context\n\n如果出现层级比较多的情况下（例如：爷爷传递数据给孙子），我们会使用context来进行传递\n\n作用： 跨组件传递数据\n\n\n# 使用步骤\n\n * 调用 react.createcontext() 创建 provider(提供数据) 和 consumer(消费数据) 两个组件\n   \n   const {provider,consumer}  = react.createcontext()\n   \n   \n   1\n   \n\n * 使用provider 组件作为父节点\n   \n   <provider>\n   \t<div classname = \"app\">\n     \t<child1/>\n     </div>\n   </provider>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 设置value属性，表示要传递的数据\n   \n   <provider value= \"yuan\">\n   \n   \n   1\n   \n\n * 哪一层想要接收数据，就用consumer进行包裹，在里面回调函数中的参数就是传递过来的值\n   \n   <consumer>\n   \t{\n       (data)=>{\n       \t<span>\n         \tdata参数接收为:-- {data}\n         </span>\n     \t}\n     }\n   </consumer>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 小结\n\n * 如果两个组件相隔层级比较多，可以使用context实现组件通讯\n * context提供了两个组件：provider 和 consumer\n * provider组件： 用来提供数据\n * consumer组件： 用来消费数据\n\n\n# props\n\n\n# children属性\n\n * children属性： 表示组件标签的子节点，当组件标签有子节点时，props就会有该属性\n * children属性与普通的props一样，值可以使任意值（文本、react元素、组件、甚至是函数）\n\n\n# props校验\n\n * 对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据，简单来说就是组件调用者可能不知道组件封装着需要什么样的数据\n * 如果传入的数据不对，可能会导致报错\n * 关键问题：组件的使用者不知道需要传递什么样的数据\n * props校验：允许在创建组件的时候，指定props的类型、格式等\n * 作用：捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性\n\n# 使用步骤\n\n * 安装包 prop-types (yarn add prop-types | npm i props-types)\n * 导入prop-types 包\n * 使用组件名.proptypes={} 来给组件的props添加校验规则\n * 校验规则通过proptypes对象来指定\n\napp.proptypes = {\n  colors:proptypes.array\n}\n\n\n1\n2\n3\n\n\n# 常见的约束规则\n\n * 创建的类型： array、bool、func、number、object、string\n * react元素类型：element\n * 必填项：isrequired\n * 特定结构的对象： shape({})\n * 更多的[约束规则](",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"react生命周期",frontmatter:{title:"react生命周期",date:"2022-12-01T20:55:08.000Z",permalink:"/pages/a33ce9/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.heima/04.react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"02.软件框架/06.react/01.heima/04.react生命周期.md",key:"v-dc1e1c72",path:"/pages/a33ce9/",headers:[{level:2,title:"组件生命周期",slug:"组件生命周期",normalizedTitle:"组件生命周期",charIndex:2},{level:3,title:"创建时（挂载阶段）",slug:"创建时-挂载阶段",normalizedTitle:"创建时（挂载阶段）",charIndex:199},{level:3,title:"更新时",slug:"更新时",normalizedTitle:"更新时",charIndex:245},{level:3,title:"卸载时",slug:"卸载时",normalizedTitle:"卸载时",charIndex:332},{level:3,title:"不常用钩子函数",slug:"不常用钩子函数",normalizedTitle:"不常用钩子函数",charIndex:369},{level:5,title:"getDerivedStateFromProps()",slug:"getderivedstatefromprops",normalizedTitle:"getderivedstatefromprops()",charIndex:380},{level:5,title:"shouldComponentUpdate()",slug:"shouldcomponentupdate",normalizedTitle:"shouldcomponentupdate()",charIndex:539},{level:5,title:"getSnapshotBeforeUpdate()",slug:"getsnapshotbeforeupdate",normalizedTitle:"getsnapshotbeforeupdate()",charIndex:742},{level:2,title:"render-props模式",slug:"render-props模式",normalizedTitle:"render-props模式",charIndex:952},{level:3,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:971},{level:3,title:"React组件复用概述",slug:"react组件复用概述",normalizedTitle:"react组件复用概述",charIndex:1029},{level:3,title:"思路分析",slug:"思路分析",normalizedTitle:"思路分析",charIndex:1222},{level:3,title:"使用步骤",slug:"使用步骤",normalizedTitle:"使用步骤",charIndex:1020},{level:3,title:"示例demo",slug:"示例demo",normalizedTitle:"示例demo",charIndex:1672},{level:3,title:"children代替render属性",slug:"children代替render属性",normalizedTitle:"children代替render属性",charIndex:2529},{level:2,title:"高阶组件",slug:"高阶组件",normalizedTitle:"高阶组件",charIndex:1159},{level:3,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:1038},{level:3,title:"思路分析",slug:"思路分析-2",normalizedTitle:"思路分析",charIndex:1222},{level:3,title:"使用步骤",slug:"使用步骤-2",normalizedTitle:"使用步骤",charIndex:1020},{level:3,title:"设置displayName",slug:"设置displayname",normalizedTitle:"设置displayname",charIndex:4859}],headersStr:"组件生命周期 创建时（挂载阶段） 更新时 卸载时 不常用钩子函数 getDerivedStateFromProps() shouldComponentUpdate() getSnapshotBeforeUpdate() render-props模式 目标 React组件复用概述 思路分析 使用步骤 示例demo children代替render属性 高阶组件 概述 思路分析 使用步骤 设置displayName",content:"# 组件生命周期\n\n * 说出组件生命周期对应的钩子函数\n * 钩子函数调用的时机\n\n意义：组件的生命周期有助于理解组件的运行方式，完成更复杂的组件功能、分析组件错误原因等\n\n组件的生命周期： 组件从被创建到挂载到页面中运行，再到组件不在时卸载的过程\n\n生命周期的每个阶段总是伴随着一些方法调用，这些方法就是生命周期的钩子函数\n\n构造函数的作用：为开发人员在不同阶段操作组件提供了实际\n\n\n\n\n# 创建时（挂载阶段）\n\n * 执行时机：组件创建时（页面加载时）\n * 执行顺序\n\n\n\n\n# 更新时\n\n执行时机：setState()、 forceUpdate()、 组件接收到新的props\n\n说明：以上三者任意一种变化，组件就会重新渲染\n\n执行顺序：\n\n\n\n\n# 卸载时\n\n执行时机：组件从页面中消失\n\n作用：用来做清理操作\n\n\n\n\n# 不常用钩子函数\n\n# getDerivedStateFromProps()\n\n * getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容\n * 不管原因是什么，都会在每次渲染前触发此方法\n\n# shouldComponentUpdate()\n\n * 根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染\n * 当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true\n\n# getSnapshotBeforeUpdate()\n\n * getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()\n * 此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等\n\n\n# render-props模式\n\n\n# 目标\n\n * 知道render-props模式有什么作用\n * 能够说出render-props的使用步骤\n\n\n# React组件复用概述\n\n * 思考：如果两个组件中的部分功能相似或相同，该如何处理？\n * 处理方式：复用相似的功能\n * 复用什么？\n   * state\n   * 操作state的方法\n * 两种方式：\n   * render props模式\n   * 高阶组件（HOC）\n * 注意： 这两种方式不是新的API，而是利用React自身特点的编码技巧，演化而成的固定模式\n\n\n# 思路分析\n\n思路：将要复用的state和操作state的方法封装到一个组件中\n\n * 如何拿到该组件中复用的state\n   \n   * 在使用组件时，添加一个值为函数的prop，通过函数参数来获取\n     \n     <Mouse render = {mouse=>{}}\n     \n     \n     1\n     \n\n * 如何渲染到任意的UI\n   \n   * 使用该函数的返回值作为要渲染的UI内容\n     \n     <Mouse render = {mouse=>{\n         <p>{mouse.x},{mouse.y}</p>\n       }}\n     \n     \n     1\n     2\n     3\n     \n\n\n# 使用步骤\n\n * 创建Mouse组件，在组件中提供复用的逻辑代码\n * 将要复用的状态作为 props.render(state)方法的参数，暴露到组件外部\n * 使用props.render() 的返回值作为要渲染的内容\n\n\n# 示例demo\n\nclass Mouse extends React.Component {\n    // 鼠标位置状态\n    state = {\n        x: 0,\n        y: 0\n    }\n\n    // 监听鼠标移动事件\n    componentDidMount(){\n        window.addEventListener('mousemove',this.handleMouseMove)\n    }\n    handleMouseMove = e => {\n        this.setState({\n            x: e.clientX,\n            y: e.clientY\n        })\n    }\n    render(){\n        // 向外界提供当前子组件里面的数据\n        return this.props.render(this.state)\n    }\n}\nclass App extends React.Component {\n    render() {\n        return (\n            <div>\n                App\n                <Mouse render={mouse => {\n                    return <p>X{mouse.x}Y{mouse.y}</p>\n                }}/>\n            </div>\n        )\n    }\n}\nReactDOM.render(<App />,document.getElementById('root'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# children代替render属性\n\n * 注意：并不是该模式叫 render props就必须使用名为render的prop，实际上可以使用任意名称的prop\n * 把prop是一个函数并且告诉组件要渲染什么内容的技术叫做： render props模式\n * 推荐：使用childre代替render属性\n\n<Mouse>\n\t{({x,y})=>{x},{y}}\n</Mouse>\nthis.props.children(this.state)\n\n\n1\n2\n3\n4\n\n\n\n# 高阶组件\n\n * 知道高阶组件的作用\n * 能够说出高阶的使用步骤\n\n\n# 概述\n\n * 目的：实现状态逻辑复用\n * 采用 包装模式\n * 手机：获取保护功能\n * 手机壳：提供保护功能\n * 高阶组件就相当于手机壳，通过包装组件，增强组件功能\n\n\n# 思路分析\n\n * 高阶组件(HOC、Higher-Order Component) 是一个函数，接收要包装的组件，返回增强后的组件\n   \n   const EnhancedComponent = withHOC(WrappedComponent)\n   \n   \n   1\n   \n\n * 高阶组件内部创建了一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给被包装组件WrappedComponent\n   \n   class Mouse extends React.Component{\n     render(){\n       return <WrappedComponent{...this.state}>\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 使用步骤\n\n * 创建一个函数，名称约定以with开头\n * 指定函数参数，参数应该以大写字母开头\n * 在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回\n * 在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件\n * 调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面\n\n包装函数\n\n// 定义一个函数，在函数内部创建一个相应类组件\nfunction withMouse(WrappedComponent) {\n    // 该组件提供复用状态逻辑\n    class Mouse extends React.Component {\n        state = {\n            x: 0,\n            y: 0\n        }\n        // 事件的处理函数\n        handleMouseMove = (e) => {\n            this.setState({\n                x: e.clientX,\n                y: e.clientY\n            })\n        }\n        // 当组件挂载的时候进行事件绑定\n        componentDidMount() {\n            window.addEventListener('mousemove', this.handleMouseMove)\n        }\n        // 当组件移除时候解绑事件\n        componentWillUnmount() {\n            window.removeEventListener('mousemove', this.handleMouseMove)\n        }\n        render() {\n            // 在render函数里面返回传递过来的组件，把当前组件的状态设置进去\n            return <WrappedComponent {...this.state} />\n        }\n    }\n    return Mouse\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n哪个组件需要加强，通过调用withMouse这个函数，然后把返回的值设置到父组件中即可\n\nfunction Position(props) {\n    return (\n        <p>\n            X:{props.x}\n            Y:{props.y}\n        </p>\n    )\n}\n// 把position 组件来进行包装\nlet MousePosition = withMouse(Position)\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    render() {\n        return (\n            <div>\n                高阶组件\n                <MousePosition></MousePosition>\n            </div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 设置displayName\n\n * 使用高阶组件存在的问题：得到两个组件的名称相同\n * 原因：默认情况下，React使用组件名称作为displayName\n * 解决方式：为高阶组件设置displayName，便于调试时区分不同的组件\n * displayName的作用：用于设置调试信息(React Developer Tools信息)\n * 设置方式：",normalizedContent:"# 组件生命周期\n\n * 说出组件生命周期对应的钩子函数\n * 钩子函数调用的时机\n\n意义：组件的生命周期有助于理解组件的运行方式，完成更复杂的组件功能、分析组件错误原因等\n\n组件的生命周期： 组件从被创建到挂载到页面中运行，再到组件不在时卸载的过程\n\n生命周期的每个阶段总是伴随着一些方法调用，这些方法就是生命周期的钩子函数\n\n构造函数的作用：为开发人员在不同阶段操作组件提供了实际\n\n\n\n\n# 创建时（挂载阶段）\n\n * 执行时机：组件创建时（页面加载时）\n * 执行顺序\n\n\n\n\n# 更新时\n\n执行时机：setstate()、 forceupdate()、 组件接收到新的props\n\n说明：以上三者任意一种变化，组件就会重新渲染\n\n执行顺序：\n\n\n\n\n# 卸载时\n\n执行时机：组件从页面中消失\n\n作用：用来做清理操作\n\n\n\n\n# 不常用钩子函数\n\n# getderivedstatefromprops()\n\n * getderivedstatefromprops 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容\n * 不管原因是什么，都会在每次渲染前触发此方法\n\n# shouldcomponentupdate()\n\n * 根据 shouldcomponentupdate() 的返回值，判断 react 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染\n * 当 props 或 state 发生变化时，shouldcomponentupdate() 会在渲染执行之前被调用。返回值默认为 true\n\n# getsnapshotbeforeupdate()\n\n * getsnapshotbeforeupdate() 在最近一次渲染输出（提交到 dom 节点）之前调用。它使得组件能在发生更改之前从 dom 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentdidupdate()\n * 此用法并不常见，但它可能出现在 ui 处理中，如需要以特殊方式处理滚动位置的聊天线程等\n\n\n# render-props模式\n\n\n# 目标\n\n * 知道render-props模式有什么作用\n * 能够说出render-props的使用步骤\n\n\n# react组件复用概述\n\n * 思考：如果两个组件中的部分功能相似或相同，该如何处理？\n * 处理方式：复用相似的功能\n * 复用什么？\n   * state\n   * 操作state的方法\n * 两种方式：\n   * render props模式\n   * 高阶组件（hoc）\n * 注意： 这两种方式不是新的api，而是利用react自身特点的编码技巧，演化而成的固定模式\n\n\n# 思路分析\n\n思路：将要复用的state和操作state的方法封装到一个组件中\n\n * 如何拿到该组件中复用的state\n   \n   * 在使用组件时，添加一个值为函数的prop，通过函数参数来获取\n     \n     <mouse render = {mouse=>{}}\n     \n     \n     1\n     \n\n * 如何渲染到任意的ui\n   \n   * 使用该函数的返回值作为要渲染的ui内容\n     \n     <mouse render = {mouse=>{\n         <p>{mouse.x},{mouse.y}</p>\n       }}\n     \n     \n     1\n     2\n     3\n     \n\n\n# 使用步骤\n\n * 创建mouse组件，在组件中提供复用的逻辑代码\n * 将要复用的状态作为 props.render(state)方法的参数，暴露到组件外部\n * 使用props.render() 的返回值作为要渲染的内容\n\n\n# 示例demo\n\nclass mouse extends react.component {\n    // 鼠标位置状态\n    state = {\n        x: 0,\n        y: 0\n    }\n\n    // 监听鼠标移动事件\n    componentdidmount(){\n        window.addeventlistener('mousemove',this.handlemousemove)\n    }\n    handlemousemove = e => {\n        this.setstate({\n            x: e.clientx,\n            y: e.clienty\n        })\n    }\n    render(){\n        // 向外界提供当前子组件里面的数据\n        return this.props.render(this.state)\n    }\n}\nclass app extends react.component {\n    render() {\n        return (\n            <div>\n                app\n                <mouse render={mouse => {\n                    return <p>x{mouse.x}y{mouse.y}</p>\n                }}/>\n            </div>\n        )\n    }\n}\nreactdom.render(<app />,document.getelementbyid('root'))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# children代替render属性\n\n * 注意：并不是该模式叫 render props就必须使用名为render的prop，实际上可以使用任意名称的prop\n * 把prop是一个函数并且告诉组件要渲染什么内容的技术叫做： render props模式\n * 推荐：使用childre代替render属性\n\n<mouse>\n\t{({x,y})=>{x},{y}}\n</mouse>\nthis.props.children(this.state)\n\n\n1\n2\n3\n4\n\n\n\n# 高阶组件\n\n * 知道高阶组件的作用\n * 能够说出高阶的使用步骤\n\n\n# 概述\n\n * 目的：实现状态逻辑复用\n * 采用 包装模式\n * 手机：获取保护功能\n * 手机壳：提供保护功能\n * 高阶组件就相当于手机壳，通过包装组件，增强组件功能\n\n\n# 思路分析\n\n * 高阶组件(hoc、higher-order component) 是一个函数，接收要包装的组件，返回增强后的组件\n   \n   const enhancedcomponent = withhoc(wrappedcomponent)\n   \n   \n   1\n   \n\n * 高阶组件内部创建了一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给被包装组件wrappedcomponent\n   \n   class mouse extends react.component{\n     render(){\n       return <wrappedcomponent{...this.state}>\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 使用步骤\n\n * 创建一个函数，名称约定以with开头\n * 指定函数参数，参数应该以大写字母开头\n * 在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回\n * 在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件\n * 调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面\n\n包装函数\n\n// 定义一个函数，在函数内部创建一个相应类组件\nfunction withmouse(wrappedcomponent) {\n    // 该组件提供复用状态逻辑\n    class mouse extends react.component {\n        state = {\n            x: 0,\n            y: 0\n        }\n        // 事件的处理函数\n        handlemousemove = (e) => {\n            this.setstate({\n                x: e.clientx,\n                y: e.clienty\n            })\n        }\n        // 当组件挂载的时候进行事件绑定\n        componentdidmount() {\n            window.addeventlistener('mousemove', this.handlemousemove)\n        }\n        // 当组件移除时候解绑事件\n        componentwillunmount() {\n            window.removeeventlistener('mousemove', this.handlemousemove)\n        }\n        render() {\n            // 在render函数里面返回传递过来的组件，把当前组件的状态设置进去\n            return <wrappedcomponent {...this.state} />\n        }\n    }\n    return mouse\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n哪个组件需要加强，通过调用withmouse这个函数，然后把返回的值设置到父组件中即可\n\nfunction position(props) {\n    return (\n        <p>\n            x:{props.x}\n            y:{props.y}\n        </p>\n    )\n}\n// 把position 组件来进行包装\nlet mouseposition = withmouse(position)\n\nclass app extends react.component {\n    constructor(props) {\n        super(props)\n    }\n    render() {\n        return (\n            <div>\n                高阶组件\n                <mouseposition></mouseposition>\n            </div>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 设置displayname\n\n * 使用高阶组件存在的问题：得到两个组件的名称相同\n * 原因：默认情况下，react使用组件名称作为displayname\n * 解决方式：为高阶组件设置displayname，便于调试时区分不同的组件\n * displayname的作用：用于设置调试信息(react developer tools信息)\n * 设置方式：",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"react路由",frontmatter:{title:"react路由",date:"2022-12-02T20:44:14.000Z",permalink:"/pages/f24f8d/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.heima/05.react%E8%B7%AF%E7%94%B1.html",relativePath:"02.软件框架/06.react/01.heima/05.react路由.md",key:"v-03002f20",path:"/pages/f24f8d/",headers:[{level:2,title:"React路由基础",slug:"react路由基础",normalizedTitle:"react路由基础",charIndex:2},{level:2,title:"React路由介绍",slug:"react路由介绍",normalizedTitle:"react路由介绍",charIndex:102},{level:3,title:"使用步骤",slug:"使用步骤",normalizedTitle:"使用步骤",charIndex:318},{level:3,title:"常用组件说明",slug:"常用组件说明",normalizedTitle:"常用组件说明",charIndex:828},{level:3,title:"路由的执行过程",slug:"路由的执行过程",normalizedTitle:"路由的执行过程",charIndex:1223},{level:3,title:"编程式导航",slug:"编程式导航",normalizedTitle:"编程式导航",charIndex:68},{level:3,title:"默认路由",slug:"默认路由",normalizedTitle:"默认路由",charIndex:1713},{level:3,title:"匹配模式",slug:"匹配模式",normalizedTitle:"匹配模式",charIndex:93},{level:4,title:"模糊匹配模式",slug:"模糊匹配模式",normalizedTitle:"模糊匹配模式",charIndex:1819},{level:4,title:"精准匹配",slug:"精准匹配",normalizedTitle:"精准匹配",charIndex:1933}],headersStr:"React路由基础 React路由介绍 使用步骤 常用组件说明 路由的执行过程 编程式导航 默认路由 匹配模式 模糊匹配模式 精准匹配",content:"# React路由基础\n\n * 能够说出React路由的作用\n * 能够掌握-react-router-dom的基本使用\n * 能够使用编程式导航跳转路由\n * 能够知道React路由的匹配模式\n\n\n# React路由介绍\n\n现代的前端应用大多数是SPA（单页应用程序），也就是只有一个HTML页面的应用程序。因为它的用户体验更好、对服务器压力更小，所以更受欢迎。为了有效的使用单个页面来管理多页面的功能，前端路由应运而生。\n\n * 前端路由功能：让用户从一个视图（页面）导航到另一个视图（页面）\n * 前端路由是一套映射规则，在React中，是URL路径与组件的对应关系\n * 使用React路由简单来说，就是配置路径和组件\n\n\n# 使用步骤\n\n * 导入路由的三个核心组件： Router / Route / Link\n   \n   import {BrowserRouter as Router, Route, Link} from 'react-router-dom'\n   \n   \n   1\n   \n\n * 使用Router 组件包裹整个应用\n   \n   <Router>\n   \t<div className=\"App\"></div>\n   </Router>\n   \n   \n   1\n   2\n   3\n   \n\n * 使用Link组件作为导航菜单（路由入口）\n   \n   <Link to=\"/frist\">页面</Link>\n   \n   \n   1\n   \n\n * 使用Route组件配置路由规则和要展示的组件（路由出口）\n   \n   <Router>\n   \t<div className=\"App\"></div>\n     <Router path=\"/frist\" component ={Page}></Router>\n   </Router>\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# 常用组件说明\n\n * **Router组件：**包裹整个应用，一个React应用只需要使用一次\n   * 两种常用的Router： HashRouter和BrowserRouter\n   * HashRouter： 使用URL的哈希值实现 （localhost:3000/#/first）\n   * 推荐 BrowserRouter：使用H5的history API实现（localhost3000/first）\n * **Link组件：**用于指定导航链接（a标签）\n   * 最终Link会编译成a标签，而to属性会被编译成 a标签的href属性\n * **Route组件：**指定路由展示组件相关信息\n   * path属性：路由规则，这里需要跟Link组件里面to属性的值一致\n   * component属性：展示的组件\n   * Route写在哪，渲染出来的组件就在哪\n\n\n# 路由的执行过程\n\n * 当我们点击Link组件的时候，修改了浏览器地址栏中的url\n * React路由监听地址栏url的变化\n * React路由内部遍历所有的Route组件，拿着Route里面path规则与pathname进行匹配\n * 当路由规则（path）能够匹配地址栏中的pathname时，就展示该Route组件的内容\n\n\n# 编程式导航\n\n * **场景：**点击登陆按钮，登陆成功后，通过代码跳转到后台首页，如何实现？\n * **编程式导航：**通过JS代码来实现页面跳转\n * history是React路由提供的，用于获取浏览器历史记录的相关信息\n * **push(path)：**跳转到某个页面，参数path表示要跳转的路径\n * go(n)：前进或后退功能，参数n表示前进或后退页面数量\n\nclass Login extends Component {\n  handleLogin = ()=>{\n    this.props.history.push('/home')\n  }\n  render(){...}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 默认路由\n\n * 现在的路由都是通过点击导航菜单后展示的，如果进入页面的时候就主动触发路由呢\n * 默认路由：表示进入页面时就会匹配的路由\n * 默认路由：只需要把path设置为 '/'\n\n\n# 匹配模式\n\n# 模糊匹配模式\n\n * 当Link组件的to属性值为 '/login' 时候，为什么默认路由也被匹配成功？\n * 默认情况下，React路由是模糊匹配模式\n * 模糊匹配规则：只要pathname以path开头就会匹配成功\n\n# 精准匹配\n\n * 默认路由认可情况下都会展示，如果避免这种问题？\n * 给Route组件添加exact属性，让其变为精准匹配模式\n * 精确匹配：只有当path和pathname完全匹配时才会展示改路由",normalizedContent:"# react路由基础\n\n * 能够说出react路由的作用\n * 能够掌握-react-router-dom的基本使用\n * 能够使用编程式导航跳转路由\n * 能够知道react路由的匹配模式\n\n\n# react路由介绍\n\n现代的前端应用大多数是spa（单页应用程序），也就是只有一个html页面的应用程序。因为它的用户体验更好、对服务器压力更小，所以更受欢迎。为了有效的使用单个页面来管理多页面的功能，前端路由应运而生。\n\n * 前端路由功能：让用户从一个视图（页面）导航到另一个视图（页面）\n * 前端路由是一套映射规则，在react中，是url路径与组件的对应关系\n * 使用react路由简单来说，就是配置路径和组件\n\n\n# 使用步骤\n\n * 导入路由的三个核心组件： router / route / link\n   \n   import {browserrouter as router, route, link} from 'react-router-dom'\n   \n   \n   1\n   \n\n * 使用router 组件包裹整个应用\n   \n   <router>\n   \t<div classname=\"app\"></div>\n   </router>\n   \n   \n   1\n   2\n   3\n   \n\n * 使用link组件作为导航菜单（路由入口）\n   \n   <link to=\"/frist\">页面</link>\n   \n   \n   1\n   \n\n * 使用route组件配置路由规则和要展示的组件（路由出口）\n   \n   <router>\n   \t<div classname=\"app\"></div>\n     <router path=\"/frist\" component ={page}></router>\n   </router>\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# 常用组件说明\n\n * **router组件：**包裹整个应用，一个react应用只需要使用一次\n   * 两种常用的router： hashrouter和browserrouter\n   * hashrouter： 使用url的哈希值实现 （localhost:3000/#/first）\n   * 推荐 browserrouter：使用h5的history api实现（localhost3000/first）\n * **link组件：**用于指定导航链接（a标签）\n   * 最终link会编译成a标签，而to属性会被编译成 a标签的href属性\n * **route组件：**指定路由展示组件相关信息\n   * path属性：路由规则，这里需要跟link组件里面to属性的值一致\n   * component属性：展示的组件\n   * route写在哪，渲染出来的组件就在哪\n\n\n# 路由的执行过程\n\n * 当我们点击link组件的时候，修改了浏览器地址栏中的url\n * react路由监听地址栏url的变化\n * react路由内部遍历所有的route组件，拿着route里面path规则与pathname进行匹配\n * 当路由规则（path）能够匹配地址栏中的pathname时，就展示该route组件的内容\n\n\n# 编程式导航\n\n * **场景：**点击登陆按钮，登陆成功后，通过代码跳转到后台首页，如何实现？\n * **编程式导航：**通过js代码来实现页面跳转\n * history是react路由提供的，用于获取浏览器历史记录的相关信息\n * **push(path)：**跳转到某个页面，参数path表示要跳转的路径\n * go(n)：前进或后退功能，参数n表示前进或后退页面数量\n\nclass login extends component {\n  handlelogin = ()=>{\n    this.props.history.push('/home')\n  }\n  render(){...}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 默认路由\n\n * 现在的路由都是通过点击导航菜单后展示的，如果进入页面的时候就主动触发路由呢\n * 默认路由：表示进入页面时就会匹配的路由\n * 默认路由：只需要把path设置为 '/'\n\n\n# 匹配模式\n\n# 模糊匹配模式\n\n * 当link组件的to属性值为 '/login' 时候，为什么默认路由也被匹配成功？\n * 默认情况下，react路由是模糊匹配模式\n * 模糊匹配规则：只要pathname以path开头就会匹配成功\n\n# 精准匹配\n\n * 默认路由认可情况下都会展示，如果避免这种问题？\n * 给route组件添加exact属性，让其变为精准匹配模式\n * 精确匹配：只有当path和pathname完全匹配时才会展示改路由",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"react的hooks",frontmatter:{title:"react的hooks",date:"2022-12-03T22:06:12.000Z",permalink:"/pages/361177/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.heima/06.react%E7%9A%84hooks.html",relativePath:"02.软件框架/06.react/01.heima/06.react的hooks.md",key:"v-ade772bc",path:"/pages/361177/",headers:[{level:2,title:"Hooks",slug:"hooks",normalizedTitle:"hooks",charIndex:2},{level:2,title:"hooks优势",slug:"hooks优势",normalizedTitle:"hooks优势",charIndex:305},{level:2,title:"hooks基本使用",slug:"hooks基本使用",normalizedTitle:"hooks基本使用",charIndex:638},{level:3,title:"useState ()",slug:"usestate",normalizedTitle:"usestate ()",charIndex:652},{level:3,title:"使用规则",slug:"使用规则",normalizedTitle:"使用规则",charIndex:1404},{level:3,title:"useEffect ()",slug:"useeffect",normalizedTitle:"useeffect ()",charIndex:1601},{level:3,title:"清理副作用",slug:"清理副作用",normalizedTitle:"清理副作用",charIndex:2972},{level:3,title:"发送网络请求",slug:"发送网络请求",normalizedTitle:"发送网络请求",charIndex:3483},{level:2,title:"useRef ()",slug:"useref",normalizedTitle:"useref ()",charIndex:4180},{level:2,title:"useContext ()",slug:"usecontext",normalizedTitle:"usecontext ()",charIndex:4688},{level:2,title:"React-memo ()",slug:"react-memo",normalizedTitle:"react-memo ()",charIndex:5815},{level:3,title:"浅层对比",slug:"浅层对比",normalizedTitle:"浅层对比",charIndex:7412}],headersStr:"Hooks hooks优势 hooks基本使用 useState () 使用规则 useEffect () 清理副作用 发送网络请求 useRef () useContext () React-memo () 浅层对比",content:"# Hooks\n\nHooks 是 React v16.8 新增功能\n\n作用：为函数组件提供状态、生命周期等原本 class 组件中提供的 React 功能， Hooks 为函数组件钩入 class 组件的特征\n\nR16.8 组件开发模式的对比\n\n * 之前： class组件（提供状态） + 函数组件（展示内容）\n\n * 之后：\n   \n   * class组件（提供状态） + 函数组件（展示内容）\n   * Hooks （提供状态） + 函数组件（展示内容）\n   \n   混用了以上两种方式\n   \n   注意： 有了 hooks ，不能再把函数组件成为无状态组件，hooks 为函数提供了状态\n\n\n# hooks优势\n\n * 组件的逻辑逻辑复用，HOCs、render-props重构组件结构，导致组件形成了 JSX 嵌套地狱的问题\n * class 组件自身的问题\n   * class中的this指向问题\n   * 相互关联且需要对照修改的代码被拆分到不同生命周期函数中\n   * 不利于代码压缩和优化，也不利于 TS 的类型推导\n\n 1. Hooks 只能在函数组件中使用，避免了 class 组件的问题\n 2. 复用组件状态逻辑，而无需更改组件层次结构\n 3. 根据功能而不是基于生命周期方法强制进行代码分割\n 4. 抛开 React 赋予的概念来说，Hooks 就是一些普通的函数\n 5. 具有更好的 TS 类型推导，tree-shaking 友好\n\n\n# hooks基本使用\n\n\n# useState ()\n\n * 使用场景：当你想要在函数组件中，使用组件状态时，就要使用 useState Hooks\n * 作用：为函数组件提供状态\n\n使用示例\n\nimport {useState} from 'react'\nconst Count = ()=>{\n    const stateArray = useState(0)\n    const [state,setState] = stateArray[0]\n    return (\n     <div>\n        state\n     \t<button onClick={()=>setState(state+1)}>click</button>   \n     </div>\n    )\n}\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n状态的读取和修改\n\n读取状态：该方法提供的状态，是函数内部的局部变量，可以在函数内的任意位置使用\n\n修改状态： setCount 是一个函数，参数表示：新的状态值\n\n组件更新的过程\n\n函数组件使用 useState 后的执行过程，以及状态值的变化\n\n组件第一次渲染\n\n 1. 从头开始是执行该组件的代码逻辑\n 2. 调用 useState(0) 将传入的参数作为状态初始值\n 3. 渲染组件时，此时，获取到的状态值为\n\n选进第二次渲染\n\n 1. 点击按钮，调用 setCount(count+1) 修改状态，因为状态发生改变，所以，该组件会重新渲染\n 2. 组件重新渲染时，会再次执行该组件中的代码逻辑\n 3. 再次调用 useState(0) , 此时 React 内部会拿到最新值而非初始值\n 4. 再次渲染组件，此时获取到的组件的状态值为最新值\n\n\n# 使用规则\n\n注意：React Hooks 只能直接出现在 函数组件 中，不能嵌套在 if/for 其它 函数中\n\nReact Hooks` 必须每次组件渲染时，按照相同的顺序来调用所有的 `Hooks\n\n\n1\n\n * 为什么会有这样的规则？因为 React 是按照 Hooks 的调用顺序来识别每一个 Hook ，如果每次调用的顺序不一样，导致 React 无法知道哪一个是 Hook\n\n\n# useEffect ()\n\n作用：处理函数组件中的副作用\n\n对 React 组件来说，著作用就是根据数据流渲染 UI ，除此之外的都是副作用 . 如：数据请求 、动手修改 DOM 、localSorage 操作等\n\n基本使用\n\nimport {useEffect} from 'react'\nuseEffect(()=>{\n  document.litle = `当前点击次数 ${count} 次`\n}, , )\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n\n\n参数1：回调函数，就是在该函数中写会产生副作用的代码\n\n执行实际：该 effect 会在组件渲染后以及组件更新后执行\n\n相当于 ： componentDidMount + componentDidUpdate\n\n依赖项\n\n描述：如果组件中有另一个状态，另一个状态状态更新，函数中的回调函数也会执行\n\n性能优化：跳过不必要的执行，只在 count 变化时，才执行相应的 effect\n\nuseEffect(()=>{\n  document.litle = `当前点击次数 ${count} 次`\n},[count])\n\nJS\n\n\n1\n2\n3\n4\n5\n\n\n参数2 ： 可选的，可以传入一个数组，数组中的元素为副作用函数的依赖性 . 表示只有在依赖性改变时，才会重新执行 effect\n\n空数组：该 effect 只会在组件第一次渲染后执行 ，相当于componentDidMount\n\n// 触发时机：1 第一次渲染会执行 2 每次组件重新渲染都会再次执行\n// componentDidMount + ComponentDidUpdate\nuseEffect(() => {})\n\n// componentDidMount\n// 触发时机：只在组件第一次渲染时执行\nuseEffect(() => {}, [])\n\n// componentDidMount + componentDidUpdate(判断)\n// 触发时机：1 第一次渲染会执行 2 当 count 变化时会再次执行\nuseEffect(() => {}, [count])\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注意： 不要对 useEffect 的依赖项撒谎\n\nconst App = () => {\n  const [count, setCount] = useState(0)\n  useEffect(() => {\n    document.title = '点击了' + count + '次'\n  }, [])\n  return (\n    <div>\n      <h1>计数器：{count}</h1>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n      <hr />\n    </div>\n  )\n}\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n会在点击时没有效果产生\n\n> useEffect完全指南：https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\n\n\n# 清理副作用\n\n在我们只想在 React 更新 DOM 之后运行一些额外的代码 ，比如 订阅外部数据源，开启定时器看，注册时间。。这种情况下，清除工作是非常重要的，可以防止内存泄露\n\nuseEffect(() => {\n  const handleResize = () => {}\n  window.addEventListener('resize', handleResize)\n  return () => window.removeEventListener('resize', handleResize)\n}, [])\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\neffect 回调函数的返回值，可选的，返回的是一个清理函数，用来执行事件解绑清理等操作\n\n执行时机\n\n * 组件卸载之前\n * 重新执行 effect 回调函数之前\n\n相当于 componentDidMount+ componentWillUnmount\n\n推荐：一个 useEffect 只处理一个功能，有多个功能时，使用多次 useEffect\n\n优势：根据业务逻辑来拆分，相同功能的业务逻辑放在一起，而不是根据生命周期方法来拆分代码\n\n\n# 发送网络请求\n\nuseEffect(() => {\n  // 是否取消本次请求\n  let didCancel = false\n\n  async function fetchMyAPI() {\n    let url = 'http://something/' + productId\n    let config = {}\n    const response = await myFetch(url)\n    // 如果开启其他请求，就忽略本次（过时）的请求结果\n    if (!didCancel) {\n      console.log(response)\n    }\n  }\n\n  fetchMyAPI()\n  return () => { didCancel = true } // 取消本次请求\n}, [productId])\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * effect 只能是一个同步函数，不能使用 async\n * 因为 effect 的返回值应该是一个清理函数，react 会在组件卸载或者 effect 的依赖项变化时重新执行，但是如果 effect 是 async 的，此时返回值对象是 promise ，无法保证清理函数被立即调用\n * 为了使用 async/await 语法，可以在 effect 内部创建 async 函数并调用\n\n注意\n\n如果网络请求函数内访访问数据，可能会导致网络请求函数无线循环调用的问题，因为 effect 的执行是在数据发生更新时候去执行的\n\n\n# useRef ()\n\n使用场景：在 React 中进行 DOM 操作时，用来获取 DOM\n\n作用：返回一个带有 current 属性的可变对象，通过该对象进行 DOM 操作了\n\nconst inputRef = useRef(null)\n\nJS\n\n\n1\n2\n3\n\n\n使用\n\nconst App = () => {\n  const inputRef = useRef(null)\n  const add = () => {\n    console.log(inputRef.current.value)\n  }\n  return (\n    <section className=\"todoapp\">\n      <input type=\"text\" placeholder=\"请输入内容\" ref={inputRef} />{' '}\n      <button onClick={add}>添加</button>\n    </section>\n  )\n}\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注意：useRef 不仅仅可以用于操作 DOM ， 还可以操作组件\n\n\n# useContext ()\n\n使用场景：跨组件共享通信\n\nContext 作用：实现跨组件传递数据，而不必在每个级别手动传递 props，简化组件之间的数据传递过程\n\nconst Context = createContext(defaultValue)\nconst value = useContext(conText)\n\nJS\n\n\n1\n2\n3\n4\n\n\nContext 对象包含了两个组件\n\n * <Context.Provider value> 通过 value 属性提供数据\n * <Context.Consumer> 通过 render-props 模式，在 JSX 中获取Context 提供的数据\n\n在函数组件中，获取 Context 中的值，需需要配合 Context 一起使用而 useContext 和 Context.Consumer 的区别在于：获取数据的位置不同\n\n示例\n\nimport React, { useState, useContext } from 'react'\nconst Context = React.createContext()\nconst App = () => {\n  const [color, setColor] = useState('red')\n  return (\n    <Context.Provider value={color}>\n      <div>\n        <h1>我是根组件</h1>\n        <div>颜色：{color}</div>\n        <button onClick={() => setColor('yellow')}>修改</button>\n        <Father></Father>\n      </div>\n    </Context.Provider>\n  )\n}\n\nconst Father = () => {\n  return (\n    <div>\n      <h3>我是父组件</h3>\n      <Child></Child>\n    </div>\n  )\n}\n\nconst Child = () => {\n  const color = useContext(Context)\n  return (\n    <div>\n      <h5>我是子组件--{color}</h5>\n    </div>\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# React-memo ()\n\n使用场景：在父组件的状态更新的时候，子组件就会无条件的一起更新\n\n渲染过程\n\n * 子组件 props 变化时更新过程：组件代码执行 -> JSX Diff(配合虚拟 DOM) -> 渲染(变化后的内容)\n * 子组件无变化更新过程：代码组件执行 -> JSX Diff (配合虚拟DOM)\n\n为了提升性能，优化不必要的无变化子组件更新，这种情况就可以使用 React.memo 高阶组件\n\nimport { useState } from 'react'\nimport ReactDOM from 'react-dom'\n\nconst Child2 = ({ count }) => {\n  console.log('Child2 子组件代码执行了')\n  return <div style={{ backgroundColor: '#abc' }}>子组件2：{count}</div>\n}\n\nconst Child1 = () => {\n  console.log('Child1 子组件代码执行了')\n  return <div style={{ backgroundColor: '#def' }}>子组件1</div>\n}\n\nconst App = () => {\n  const [count, setCount] = useState(0)\n\n  return (\n    <div style={{ backgroundColor: 'pink', padding: 10 }}>\n      <h1>计数器：{count}</h1>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n      <hr />\n\n      {/* 子组件 */}\n      <Child1 />\n      <br />\n      <Child2 count={count} />\n    </div>\n  )\n}\n\nReactDOM.render(<App />, document.getElementById('root'))\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n此示例，在子组件2更新时， 子组件1也会执行更新\n\nmemo 作用：记忆上一次的更新渲染结果，在 props 没有变化时复用该结果，避免函数不必要的更新\n\n使用示例\n\nimport { useState, memo } from 'react' //导入\nconst Child2 = memo(({ count }) => {\n  console.log('Child2 子组件代码执行了')\n  return <div style={{ backgroundColor: '#abc' }}>子组件2：{count}</div>\n})\n\nconst Child1 = memo(() => {\n  console.log('Child1 子组件代码执行了')\n  return <div style={{ backgroundColor: '#def' }}>子组件1</div>\n})\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 参数：需要被记忆的组件，不必要更新的组件\n * 返回值： React 记住的 Child 组件\n\n原理：通过检查对比更新前后 props 是否相同，来决定是否复用上一次的渲染结果\n\n注意： 不是所有的组件都适用 memo，需要经常更新渲染的组件使用 memo 性能反而会降低\n\n\n# 浅层对比\n\n默认情况下，React.memo 只会对更新前后的 props 进行浅对比\n\n也就是说，对于对象类型的 prop 来说，只会比较引用(地址)\n\nimport { useState, memo } from 'react'\nimport ReactDOM from 'react-dom'\n\nconst Child2 = memo(({ count }) => {\n  console.log('Child2 子组件代码执行了')\n  return <div style={{ backgroundColor: '#abc' }}>子组件2：{count}</div>\n})\n\nconst Child1 = memo(({ obj }) => {\n  console.log('Child1 子组件代码执行了')\n  return (\n    <div style={{ backgroundColor: '#def' }}>\n      子组件1 id:{obj.id} name:{obj.name} age:{obj.age}\n    </div>\n  )\n})\n\nconst App = () => {\n  const [count, setCount] = useState(0)\n  const obj = {\n    name: 'yd',\n    id: 11,\n    age: 22,\n  }\n  return (\n    <div style={{ backgroundColor: 'pink', padding: 10 }}>\n      <h1>计数器：{count}</h1>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n      <hr />\n      {/* 子组件 */}\n      <Child1 obj={obj} />\n      <br />\n      <Child2 count={count} />\n    </div>\n  )\n}\n\nJS\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n此处传入的参数为 引用数据类型 ，所以在会浅层的对比地址是否发生变化所以在每次更新组件时，创建的 obj 的地址是不同的所以在更新 DOM 也会更新此组件\n\n可以使用 React.memo 的第二个参数手动控制比较\n\nReact.memo(Child,function areEqual(prevProps,nextProps){\n  return preProps === nextProps\n})\n\nJS\n\n\n1\n2\n3\n4\n5\n\n\n如果返回为 true 表示记住不渲染组件，如果返回 false 表示渲染该组件\n\n更好的解决方法\n\n * useCallback Hook：记住函数的引用，在组件每次更新时返回相同引用的函数。\n * useMemo Hook：记住任意数据（数值、对象、函数等），在组件每次更新时返回相同引用的数据【功能之一】",normalizedContent:"# hooks\n\nhooks 是 react v16.8 新增功能\n\n作用：为函数组件提供状态、生命周期等原本 class 组件中提供的 react 功能， hooks 为函数组件钩入 class 组件的特征\n\nr16.8 组件开发模式的对比\n\n * 之前： class组件（提供状态） + 函数组件（展示内容）\n\n * 之后：\n   \n   * class组件（提供状态） + 函数组件（展示内容）\n   * hooks （提供状态） + 函数组件（展示内容）\n   \n   混用了以上两种方式\n   \n   注意： 有了 hooks ，不能再把函数组件成为无状态组件，hooks 为函数提供了状态\n\n\n# hooks优势\n\n * 组件的逻辑逻辑复用，hocs、render-props重构组件结构，导致组件形成了 jsx 嵌套地狱的问题\n * class 组件自身的问题\n   * class中的this指向问题\n   * 相互关联且需要对照修改的代码被拆分到不同生命周期函数中\n   * 不利于代码压缩和优化，也不利于 ts 的类型推导\n\n 1. hooks 只能在函数组件中使用，避免了 class 组件的问题\n 2. 复用组件状态逻辑，而无需更改组件层次结构\n 3. 根据功能而不是基于生命周期方法强制进行代码分割\n 4. 抛开 react 赋予的概念来说，hooks 就是一些普通的函数\n 5. 具有更好的 ts 类型推导，tree-shaking 友好\n\n\n# hooks基本使用\n\n\n# usestate ()\n\n * 使用场景：当你想要在函数组件中，使用组件状态时，就要使用 usestate hooks\n * 作用：为函数组件提供状态\n\n使用示例\n\nimport {usestate} from 'react'\nconst count = ()=>{\n    const statearray = usestate(0)\n    const [state,setstate] = statearray[0]\n    return (\n     <div>\n        state\n     \t<button onclick={()=>setstate(state+1)}>click</button>   \n     </div>\n    )\n}\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n状态的读取和修改\n\n读取状态：该方法提供的状态，是函数内部的局部变量，可以在函数内的任意位置使用\n\n修改状态： setcount 是一个函数，参数表示：新的状态值\n\n组件更新的过程\n\n函数组件使用 usestate 后的执行过程，以及状态值的变化\n\n组件第一次渲染\n\n 1. 从头开始是执行该组件的代码逻辑\n 2. 调用 usestate(0) 将传入的参数作为状态初始值\n 3. 渲染组件时，此时，获取到的状态值为\n\n选进第二次渲染\n\n 1. 点击按钮，调用 setcount(count+1) 修改状态，因为状态发生改变，所以，该组件会重新渲染\n 2. 组件重新渲染时，会再次执行该组件中的代码逻辑\n 3. 再次调用 usestate(0) , 此时 react 内部会拿到最新值而非初始值\n 4. 再次渲染组件，此时获取到的组件的状态值为最新值\n\n\n# 使用规则\n\n注意：react hooks 只能直接出现在 函数组件 中，不能嵌套在 if/for 其它 函数中\n\nreact hooks` 必须每次组件渲染时，按照相同的顺序来调用所有的 `hooks\n\n\n1\n\n * 为什么会有这样的规则？因为 react 是按照 hooks 的调用顺序来识别每一个 hook ，如果每次调用的顺序不一样，导致 react 无法知道哪一个是 hook\n\n\n# useeffect ()\n\n作用：处理函数组件中的副作用\n\n对 react 组件来说，著作用就是根据数据流渲染 ui ，除此之外的都是副作用 . 如：数据请求 、动手修改 dom 、localsorage 操作等\n\n基本使用\n\nimport {useeffect} from 'react'\nuseeffect(()=>{\n  document.litle = `当前点击次数 ${count} 次`\n}, , )\n\njs\n\n\n1\n2\n3\n4\n5\n6\n\n\n参数1：回调函数，就是在该函数中写会产生副作用的代码\n\n执行实际：该 effect 会在组件渲染后以及组件更新后执行\n\n相当于 ： componentdidmount + componentdidupdate\n\n依赖项\n\n描述：如果组件中有另一个状态，另一个状态状态更新，函数中的回调函数也会执行\n\n性能优化：跳过不必要的执行，只在 count 变化时，才执行相应的 effect\n\nuseeffect(()=>{\n  document.litle = `当前点击次数 ${count} 次`\n},[count])\n\njs\n\n\n1\n2\n3\n4\n5\n\n\n参数2 ： 可选的，可以传入一个数组，数组中的元素为副作用函数的依赖性 . 表示只有在依赖性改变时，才会重新执行 effect\n\n空数组：该 effect 只会在组件第一次渲染后执行 ，相当于componentdidmount\n\n// 触发时机：1 第一次渲染会执行 2 每次组件重新渲染都会再次执行\n// componentdidmount + componentdidupdate\nuseeffect(() => {})\n\n// componentdidmount\n// 触发时机：只在组件第一次渲染时执行\nuseeffect(() => {}, [])\n\n// componentdidmount + componentdidupdate(判断)\n// 触发时机：1 第一次渲染会执行 2 当 count 变化时会再次执行\nuseeffect(() => {}, [count])\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n注意： 不要对 useeffect 的依赖项撒谎\n\nconst app = () => {\n  const [count, setcount] = usestate(0)\n  useeffect(() => {\n    document.title = '点击了' + count + '次'\n  }, [])\n  return (\n    <div>\n      <h1>计数器：{count}</h1>\n      <button onclick={() => setcount(count + 1)}>+1</button>\n      <hr />\n    </div>\n  )\n}\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n会在点击时没有效果产生\n\n> useeffect完全指南：https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/\n\n\n# 清理副作用\n\n在我们只想在 react 更新 dom 之后运行一些额外的代码 ，比如 订阅外部数据源，开启定时器看，注册时间。。这种情况下，清除工作是非常重要的，可以防止内存泄露\n\nuseeffect(() => {\n  const handleresize = () => {}\n  window.addeventlistener('resize', handleresize)\n  return () => window.removeeventlistener('resize', handleresize)\n}, [])\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\neffect 回调函数的返回值，可选的，返回的是一个清理函数，用来执行事件解绑清理等操作\n\n执行时机\n\n * 组件卸载之前\n * 重新执行 effect 回调函数之前\n\n相当于 componentdidmount+ componentwillunmount\n\n推荐：一个 useeffect 只处理一个功能，有多个功能时，使用多次 useeffect\n\n优势：根据业务逻辑来拆分，相同功能的业务逻辑放在一起，而不是根据生命周期方法来拆分代码\n\n\n# 发送网络请求\n\nuseeffect(() => {\n  // 是否取消本次请求\n  let didcancel = false\n\n  async function fetchmyapi() {\n    let url = 'http://something/' + productid\n    let config = {}\n    const response = await myfetch(url)\n    // 如果开启其他请求，就忽略本次（过时）的请求结果\n    if (!didcancel) {\n      console.log(response)\n    }\n  }\n\n  fetchmyapi()\n  return () => { didcancel = true } // 取消本次请求\n}, [productid])\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * effect 只能是一个同步函数，不能使用 async\n * 因为 effect 的返回值应该是一个清理函数，react 会在组件卸载或者 effect 的依赖项变化时重新执行，但是如果 effect 是 async 的，此时返回值对象是 promise ，无法保证清理函数被立即调用\n * 为了使用 async/await 语法，可以在 effect 内部创建 async 函数并调用\n\n注意\n\n如果网络请求函数内访访问数据，可能会导致网络请求函数无线循环调用的问题，因为 effect 的执行是在数据发生更新时候去执行的\n\n\n# useref ()\n\n使用场景：在 react 中进行 dom 操作时，用来获取 dom\n\n作用：返回一个带有 current 属性的可变对象，通过该对象进行 dom 操作了\n\nconst inputref = useref(null)\n\njs\n\n\n1\n2\n3\n\n\n使用\n\nconst app = () => {\n  const inputref = useref(null)\n  const add = () => {\n    console.log(inputref.current.value)\n  }\n  return (\n    <section classname=\"todoapp\">\n      <input type=\"text\" placeholder=\"请输入内容\" ref={inputref} />{' '}\n      <button onclick={add}>添加</button>\n    </section>\n  )\n}\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注意：useref 不仅仅可以用于操作 dom ， 还可以操作组件\n\n\n# usecontext ()\n\n使用场景：跨组件共享通信\n\ncontext 作用：实现跨组件传递数据，而不必在每个级别手动传递 props，简化组件之间的数据传递过程\n\nconst context = createcontext(defaultvalue)\nconst value = usecontext(context)\n\njs\n\n\n1\n2\n3\n4\n\n\ncontext 对象包含了两个组件\n\n * <context.provider value> 通过 value 属性提供数据\n * <context.consumer> 通过 render-props 模式，在 jsx 中获取context 提供的数据\n\n在函数组件中，获取 context 中的值，需需要配合 context 一起使用而 usecontext 和 context.consumer 的区别在于：获取数据的位置不同\n\n示例\n\nimport react, { usestate, usecontext } from 'react'\nconst context = react.createcontext()\nconst app = () => {\n  const [color, setcolor] = usestate('red')\n  return (\n    <context.provider value={color}>\n      <div>\n        <h1>我是根组件</h1>\n        <div>颜色：{color}</div>\n        <button onclick={() => setcolor('yellow')}>修改</button>\n        <father></father>\n      </div>\n    </context.provider>\n  )\n}\n\nconst father = () => {\n  return (\n    <div>\n      <h3>我是父组件</h3>\n      <child></child>\n    </div>\n  )\n}\n\nconst child = () => {\n  const color = usecontext(context)\n  return (\n    <div>\n      <h5>我是子组件--{color}</h5>\n    </div>\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# react-memo ()\n\n使用场景：在父组件的状态更新的时候，子组件就会无条件的一起更新\n\n渲染过程\n\n * 子组件 props 变化时更新过程：组件代码执行 -> jsx diff(配合虚拟 dom) -> 渲染(变化后的内容)\n * 子组件无变化更新过程：代码组件执行 -> jsx diff (配合虚拟dom)\n\n为了提升性能，优化不必要的无变化子组件更新，这种情况就可以使用 react.memo 高阶组件\n\nimport { usestate } from 'react'\nimport reactdom from 'react-dom'\n\nconst child2 = ({ count }) => {\n  console.log('child2 子组件代码执行了')\n  return <div style={{ backgroundcolor: '#abc' }}>子组件2：{count}</div>\n}\n\nconst child1 = () => {\n  console.log('child1 子组件代码执行了')\n  return <div style={{ backgroundcolor: '#def' }}>子组件1</div>\n}\n\nconst app = () => {\n  const [count, setcount] = usestate(0)\n\n  return (\n    <div style={{ backgroundcolor: 'pink', padding: 10 }}>\n      <h1>计数器：{count}</h1>\n      <button onclick={() => setcount(count + 1)}>+1</button>\n      <hr />\n\n      {/* 子组件 */}\n      <child1 />\n      <br />\n      <child2 count={count} />\n    </div>\n  )\n}\n\nreactdom.render(<app />, document.getelementbyid('root'))\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n此示例，在子组件2更新时， 子组件1也会执行更新\n\nmemo 作用：记忆上一次的更新渲染结果，在 props 没有变化时复用该结果，避免函数不必要的更新\n\n使用示例\n\nimport { usestate, memo } from 'react' //导入\nconst child2 = memo(({ count }) => {\n  console.log('child2 子组件代码执行了')\n  return <div style={{ backgroundcolor: '#abc' }}>子组件2：{count}</div>\n})\n\nconst child1 = memo(() => {\n  console.log('child1 子组件代码执行了')\n  return <div style={{ backgroundcolor: '#def' }}>子组件1</div>\n})\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 参数：需要被记忆的组件，不必要更新的组件\n * 返回值： react 记住的 child 组件\n\n原理：通过检查对比更新前后 props 是否相同，来决定是否复用上一次的渲染结果\n\n注意： 不是所有的组件都适用 memo，需要经常更新渲染的组件使用 memo 性能反而会降低\n\n\n# 浅层对比\n\n默认情况下，react.memo 只会对更新前后的 props 进行浅对比\n\n也就是说，对于对象类型的 prop 来说，只会比较引用(地址)\n\nimport { usestate, memo } from 'react'\nimport reactdom from 'react-dom'\n\nconst child2 = memo(({ count }) => {\n  console.log('child2 子组件代码执行了')\n  return <div style={{ backgroundcolor: '#abc' }}>子组件2：{count}</div>\n})\n\nconst child1 = memo(({ obj }) => {\n  console.log('child1 子组件代码执行了')\n  return (\n    <div style={{ backgroundcolor: '#def' }}>\n      子组件1 id:{obj.id} name:{obj.name} age:{obj.age}\n    </div>\n  )\n})\n\nconst app = () => {\n  const [count, setcount] = usestate(0)\n  const obj = {\n    name: 'yd',\n    id: 11,\n    age: 22,\n  }\n  return (\n    <div style={{ backgroundcolor: 'pink', padding: 10 }}>\n      <h1>计数器：{count}</h1>\n      <button onclick={() => setcount(count + 1)}>+1</button>\n      <hr />\n      {/* 子组件 */}\n      <child1 obj={obj} />\n      <br />\n      <child2 count={count} />\n    </div>\n  )\n}\n\njs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n此处传入的参数为 引用数据类型 ，所以在会浅层的对比地址是否发生变化所以在每次更新组件时，创建的 obj 的地址是不同的所以在更新 dom 也会更新此组件\n\n可以使用 react.memo 的第二个参数手动控制比较\n\nreact.memo(child,function areequal(prevprops,nextprops){\n  return preprops === nextprops\n})\n\njs\n\n\n1\n2\n3\n4\n5\n\n\n如果返回为 true 表示记住不渲染组件，如果返回 false 表示渲染该组件\n\n更好的解决方法\n\n * usecallback hook：记住函数的引用，在组件每次更新时返回相同引用的函数。\n * usememo hook：记住任意数据（数值、对象、函数等），在组件每次更新时返回相同引用的数据【功能之一】",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"react生态redux",frontmatter:{title:"react生态redux",date:"2022-12-05T09:23:52.000Z",permalink:"/pages/bfa1be/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.heima/07.react%E7%94%9F%E6%80%81redux.html",relativePath:"02.软件框架/06.react/01.heima/07.react生态redux.md",key:"v-5b48707e",path:"/pages/bfa1be/",headers:[{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:2},{level:2,title:"react-redux",slug:"react-redux",normalizedTitle:"react-redux",charIndex:703},{level:2,title:"项目结构",slug:"项目结构",normalizedTitle:"项目结构",charIndex:1230},{level:2,title:"redux中间件",slug:"redux中间件",normalizedTitle:"redux中间件",charIndex:1827},{level:2,title:"redux-devtools-exension",slug:"redux-devtools-exension",normalizedTitle:"redux-devtools-exension",charIndex:2496}],headersStr:"基本使用 react-redux 项目结构 redux中间件 redux-devtools-exension",content:"# 基本使用\n\nyarn add redux\n\n * action、action-creator\n * reduce\n * store\n\nacion\n\n{\n  type:\"add\",\n  payload:10\n}\nconst actionCreate = payload=>{\n  return {\n    type:'add',\n    payload\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nreducer\n\nconst reducer = (prevState,action)=>{\n  return newState\n}\nconst reducer = (state,action)=>{\n  switch(action.type){\n    case 'add':\n      return ;\n    case 'remove':\n      return ;\n    default:\n      return state\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstore\n\nconst store = createStore(reducer)\n\nstore.dispatch(action)\n\nconst state = store.getState()\n\nconst unSubscribe = store.subscribe(()=>{\n  console.log(store.getState())\n})\n\nunSubscibe()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# react-redux\n\nReact-Redux ：React接入Redux\n\n使用 hooks 的写法\n\n * yarn add react-redux\n\n * 导入 Provider 组件 ：import {Provider} from \"react-redux\"\n\n * 包裹整个应用程序\n   \n   <Provider store={store}>\n   \t<App/>\n   </Provider>\n   \n   \n   1\n   2\n   3\n   \n\n * 设置好store的值\n\nuseSelector\n\n相当于 ：store.getState()\n\nimport {useSelector} from \"react-redux\"\nconst count = useSelector (state=>state.list)\n\n\n1\n2\n\n\nuseDispatch\n\n相当于：store.dispatch(action)\n\nimport {useDispatch} from \"react-redux\"\n\nconst dispatch = useDiapatch()\n\ndispatch(action)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 项目结构\n\n推荐使用的 redux 管理结构\n\n - store\n   - actions\t//创建 actions\n   - reducers  // 创建 reducers\n   - index.js //创建 store\n\n\n1\n2\n3\n4\n\n\n集中管理 ActionType ——利于维护项目\n\n使用 domain/action（功能/动作） 进行分类处理\n\n * 创建 actionType 目录\n * 声明 actiontype 并导出\n * 使用\n\nconst add = \"counter/add\"\nconst remove = \"conter/remove\"\n\nexport {add,remove} \n\n\n1\n2\n3\n4\n\n\nimport * as types = \"\"\ntype: types.add\n//...\n\n\n1\n2\n3\n\n\n拆分 Reducer\n\ncombineReducers 函数\n\nimport {combineReducers} from 'redux'\n\n\nconst aRuducer = ()=>{}\nconst bRuducer = ()=>{}\n\nconst rootReducer = combineReducers({\n  a: aReducer,\n  b: bReducer\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# redux中间件\n\nrudux-logger\n\nimport {createStore,applyMiddleWare} from 'redux'\nimport logger from 'redux-logger'\nimport rootReducer from './reducers'\n\nconst store = createStore(rootReducer,applyMiddleware(logger))\n\n\n1\n2\n3\n4\n5\n\n\nredux-thunk\n\n处理异步操作\n\n使用 redux-thunk 中间件后，action 既可以是对象，也可以是函数\n\nconst funAsync = ()=>{\n  return (dispatch,getState)=>{\n    //...Async\n  }\n}\ndispatch(funAsync())//函数\n\n\n1\n2\n3\n4\n5\n6\n\n\nimport thunk from 'redux-thunk'\n\nconst store = createStore(rootReducer,applyMiddleware(thunk,logger))\n\n\n//使用 index.js\n\nexport const funAysnc = ()=>{\n  return (dispatch)=>{\n    setTimeout(()=>{\n      \n    },1000)\n  }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# redux-devtools-exension\n\nimport thunk from 'redux-thunk'\nimport { composeWithDevTools } from 'redux-devtools-extension'\n\nconst store = createStore(reducer, composeWithDevTools(applyMiddleware(thunk)))\n\nexport default store\n\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"# 基本使用\n\nyarn add redux\n\n * action、action-creator\n * reduce\n * store\n\nacion\n\n{\n  type:\"add\",\n  payload:10\n}\nconst actioncreate = payload=>{\n  return {\n    type:'add',\n    payload\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nreducer\n\nconst reducer = (prevstate,action)=>{\n  return newstate\n}\nconst reducer = (state,action)=>{\n  switch(action.type){\n    case 'add':\n      return ;\n    case 'remove':\n      return ;\n    default:\n      return state\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstore\n\nconst store = createstore(reducer)\n\nstore.dispatch(action)\n\nconst state = store.getstate()\n\nconst unsubscribe = store.subscribe(()=>{\n  console.log(store.getstate())\n})\n\nunsubscibe()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# react-redux\n\nreact-redux ：react接入redux\n\n使用 hooks 的写法\n\n * yarn add react-redux\n\n * 导入 provider 组件 ：import {provider} from \"react-redux\"\n\n * 包裹整个应用程序\n   \n   <provider store={store}>\n   \t<app/>\n   </provider>\n   \n   \n   1\n   2\n   3\n   \n\n * 设置好store的值\n\nuseselector\n\n相当于 ：store.getstate()\n\nimport {useselector} from \"react-redux\"\nconst count = useselector (state=>state.list)\n\n\n1\n2\n\n\nusedispatch\n\n相当于：store.dispatch(action)\n\nimport {usedispatch} from \"react-redux\"\n\nconst dispatch = usediapatch()\n\ndispatch(action)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 项目结构\n\n推荐使用的 redux 管理结构\n\n - store\n   - actions\t//创建 actions\n   - reducers  // 创建 reducers\n   - index.js //创建 store\n\n\n1\n2\n3\n4\n\n\n集中管理 actiontype ——利于维护项目\n\n使用 domain/action（功能/动作） 进行分类处理\n\n * 创建 actiontype 目录\n * 声明 actiontype 并导出\n * 使用\n\nconst add = \"counter/add\"\nconst remove = \"conter/remove\"\n\nexport {add,remove} \n\n\n1\n2\n3\n4\n\n\nimport * as types = \"\"\ntype: types.add\n//...\n\n\n1\n2\n3\n\n\n拆分 reducer\n\ncombinereducers 函数\n\nimport {combinereducers} from 'redux'\n\n\nconst aruducer = ()=>{}\nconst bruducer = ()=>{}\n\nconst rootreducer = combinereducers({\n  a: areducer,\n  b: breducer\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# redux中间件\n\nrudux-logger\n\nimport {createstore,applymiddleware} from 'redux'\nimport logger from 'redux-logger'\nimport rootreducer from './reducers'\n\nconst store = createstore(rootreducer,applymiddleware(logger))\n\n\n1\n2\n3\n4\n5\n\n\nredux-thunk\n\n处理异步操作\n\n使用 redux-thunk 中间件后，action 既可以是对象，也可以是函数\n\nconst funasync = ()=>{\n  return (dispatch,getstate)=>{\n    //...async\n  }\n}\ndispatch(funasync())//函数\n\n\n1\n2\n3\n4\n5\n6\n\n\nimport thunk from 'redux-thunk'\n\nconst store = createstore(rootreducer,applymiddleware(thunk,logger))\n\n\n//使用 index.js\n\nexport const funaysnc = ()=>{\n  return (dispatch)=>{\n    settimeout(()=>{\n      \n    },1000)\n  }\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# redux-devtools-exension\n\nimport thunk from 'redux-thunk'\nimport { composewithdevtools } from 'redux-devtools-extension'\n\nconst store = createstore(reducer, composewithdevtools(applymiddleware(thunk)))\n\nexport default store\n\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"react生态router",frontmatter:{title:"react生态router",date:"2022-12-06T15:46:02.000Z",permalink:"/pages/6cbc7a/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/01.heima/08.react%E7%94%9F%E6%80%81router.html",relativePath:"02.软件框架/06.react/01.heima/08.react生态router.md",key:"v-e342d2e6",path:"/pages/6cbc7a/",headers:[{level:2,title:"Router",slug:"router",normalizedTitle:"router",charIndex:2},{level:2,title:"编程式导航",slug:"编程式导航",normalizedTitle:"编程式导航",charIndex:116}],headersStr:"Router 编程式导航",content:"# Router\n\nyarn add react-router-dom@5\n\nimport {BrowserRouter as Router,Route,Link} from 'react-router-dom'\n\n\n1\n\n\n\n# 编程式导航\n\n目标：能够按钮的点击事件中跳转路由\n\n内容：\n\n * 场景：点击登录按钮，登录成功后，通过代码跳转到后台首页，如何实现？\n * 编程式导航：通过 JS 代码来实现页面跳转\n * 可以通过 useHistory hook 来拿到路由提供的 history 对象，用于获取浏览器历史记录的相关信息。常用操作：\n   * push(path)：跳转到某个页面，参数 path 表示要跳转的路径\n   * replace(patch)：跳转到某个页面，会替换当前的历史记录\n   * go(n)： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页）\n\nimport { useHistory } from 'react-router-dom'\n\nconst Login = () => {\n  const history = useHistory()\n  \n\tconst onLogin = () => {\n    // ...\n    history.push('/home')\n  }\n  return (\n  \t<button onClick={onLogin}>登录</button>\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\npush(path)和 replace(path) 跳转路由的区别：\n\n浏览器会自动记录访问过来的页面路径，可以简单的把理解为通过一个 数组 来记录的。\n\n比如：我们访问了 3 个页面：['/login', '/home', '/search']，当前所在页面为：'/search'\n\n 1. 此时，如果我们又通过 push('/a') 方法访问了一个新页面：'/a'，此时，就相当于往数组中 push 了一条数据，\n    \n    * 那么，访问该页面后，浏览器中的记录为：['/login', '/home', '/search', '/a']\n\n 2. 此时，如果我们又通过 replace('/a') 方法访问了一个新页面：'/a'，此时，就相当于把当前页面地址，替换为 '/a'\n    \n    * 那么，访问该页面后，浏览器中的记录为：['/login', '/home', '/a']",normalizedContent:"# router\n\nyarn add react-router-dom@5\n\nimport {browserrouter as router,route,link} from 'react-router-dom'\n\n\n1\n\n\n\n# 编程式导航\n\n目标：能够按钮的点击事件中跳转路由\n\n内容：\n\n * 场景：点击登录按钮，登录成功后，通过代码跳转到后台首页，如何实现？\n * 编程式导航：通过 js 代码来实现页面跳转\n * 可以通过 usehistory hook 来拿到路由提供的 history 对象，用于获取浏览器历史记录的相关信息。常用操作：\n   * push(path)：跳转到某个页面，参数 path 表示要跳转的路径\n   * replace(patch)：跳转到某个页面，会替换当前的历史记录\n   * go(n)： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页）\n\nimport { usehistory } from 'react-router-dom'\n\nconst login = () => {\n  const history = usehistory()\n  \n\tconst onlogin = () => {\n    // ...\n    history.push('/home')\n  }\n  return (\n  \t<button onclick={onlogin}>登录</button>\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\npush(path)和 replace(path) 跳转路由的区别：\n\n浏览器会自动记录访问过来的页面路径，可以简单的把理解为通过一个 数组 来记录的。\n\n比如：我们访问了 3 个页面：['/login', '/home', '/search']，当前所在页面为：'/search'\n\n 1. 此时，如果我们又通过 push('/a') 方法访问了一个新页面：'/a'，此时，就相当于往数组中 push 了一条数据，\n    \n    * 那么，访问该页面后，浏览器中的记录为：['/login', '/home', '/search', '/a']\n\n 2. 此时，如果我们又通过 replace('/a') 方法访问了一个新页面：'/a'，此时，就相当于把当前页面地址，替换为 '/a'\n    \n    * 那么，访问该页面后，浏览器中的记录为：['/login', '/home', '/a']",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"核心概念",frontmatter:{title:"核心概念",date:"2022-12-05T09:15:08.000Z",permalink:"/pages/424a10/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/04.react%E5%AE%98%E6%96%B9/01.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html",relativePath:"02.软件框架/06.react/04.react官方/01.核心概念.md",key:"v-10b4fbfc",path:"/pages/424a10/",headers:[{level:2,title:"核心概念",slug:"核心概念",normalizedTitle:"核心概念",charIndex:2},{level:2,title:"JSX简介",slug:"jsx简介",normalizedTitle:"jsx简介",charIndex:11},{level:3,title:"为什么使用 JSX？",slug:"为什么使用-jsx",normalizedTitle:"为什么使用 jsx？",charIndex:297},{level:3,title:"在 JSX 中嵌入表达式",slug:"在-jsx-中嵌入表达式",normalizedTitle:"在 jsx 中嵌入表达式",charIndex:651},{level:3,title:"JSX 也是一个表达式",slug:"jsx-也是一个表达式",normalizedTitle:"jsx 也是一个表达式",charIndex:1295},{level:3,title:"JSX 中指定属性",slug:"jsx-中指定属性",normalizedTitle:"jsx 中指定属性",charIndex:1591},{level:3,title:"使用 JSX 指定子元素",slug:"使用-jsx-指定子元素",normalizedTitle:"使用 jsx 指定子元素",charIndex:2049},{level:3,title:"JSX 防止注入攻击",slug:"jsx-防止注入攻击",normalizedTitle:"jsx 防止注入攻击",charIndex:2288},{level:3,title:"JSX 表示对象",slug:"jsx-表示对象",normalizedTitle:"jsx 表示对象",charIndex:2563},{level:2,title:"元素渲染",slug:"元素渲染",normalizedTitle:"元素渲染",charIndex:261},{level:3,title:"将一个元素渲染为 DOM",slug:"将一个元素渲染为-dom",normalizedTitle:"将一个元素渲染为 dom",charIndex:3480},{level:3,title:"更新已渲染的元素",slug:"更新已渲染的元素",normalizedTitle:"更新已渲染的元素",charIndex:3926},{level:3,title:"React 只更新它需要更新的部分",slug:"react-只更新它需要更新的部分",normalizedTitle:"react 只更新它需要更新的部分",charIndex:4557},{level:2,title:"组件 & Props",slug:"组件-props",normalizedTitle:"组件 &amp; props",charIndex:null},{level:3,title:"函数组件与 class 组件",slug:"函数组件与-class-组件",normalizedTitle:"函数组件与 class 组件",charIndex:4930},{level:3,title:"渲染组件",slug:"渲染组件",normalizedTitle:"渲染组件",charIndex:5364},{level:3,title:"组合组件",slug:"组合组件",normalizedTitle:"组合组件",charIndex:6246},{level:3,title:"提取组件",slug:"提取组件",normalizedTitle:"提取组件",charIndex:6748},{level:3,title:"Props 的只读性",slug:"props-的只读性",normalizedTitle:"props 的只读性",charIndex:8972},{level:2,title:"State & 生命周期",slug:"state-生命周期",normalizedTitle:"state &amp; 生命周期",charIndex:null},{level:3,title:"将函数组件转换成 class 组件",slug:"将函数组件转换成-class-组件",normalizedTitle:"将函数组件转换成 class 组件",charIndex:10607},{level:3,title:"向 class 组件中添加局部的 state",slug:"向-class-组件中添加局部的-state",normalizedTitle:"向 class 组件中添加局部的 state",charIndex:11200},{level:3,title:"将生命周期方法添加到 Class 中",slug:"将生命周期方法添加到-class-中",normalizedTitle:"将生命周期方法添加到 class 中",charIndex:12591},{level:3,title:"正确地使用 State",slug:"正确地使用-state",normalizedTitle:"正确地使用 state",charIndex:15091},{level:3,title:"不要直接修改 State",slug:"不要直接修改-state",normalizedTitle:"不要直接修改 state",charIndex:15132},{level:3,title:"State 的更新可能是异步的",slug:"state-的更新可能是异步的",normalizedTitle:"state 的更新可能是异步的",charIndex:15317},{level:3,title:"State 的更新会被合并",slug:"state-的更新会被合并",normalizedTitle:"state 的更新会被合并",charIndex:15902},{level:3,title:"数据是向下流动的",slug:"数据是向下流动的",normalizedTitle:"数据是向下流动的",charIndex:16513},{level:2,title:"事件处理",slug:"事件处理",normalizedTitle:"事件处理",charIndex:17393},{level:3,title:"向事件处理程序传递参数",slug:"向事件处理程序传递参数",normalizedTitle:"向事件处理程序传递参数",charIndex:20117},{level:2,title:"条件渲染",slug:"条件渲染",normalizedTitle:"条件渲染",charIndex:20493},{level:3,title:"元素变量",slug:"元素变量",normalizedTitle:"元素变量",charIndex:21229},{level:3,title:"与运算符 &&",slug:"与运算符",normalizedTitle:"与运算符 &amp;&amp;",charIndex:null},{level:3,title:"三目运算符",slug:"三目运算符",normalizedTitle:"三目运算符",charIndex:23656},{level:3,title:"阻止组件渲染",slug:"阻止组件渲染",normalizedTitle:"阻止组件渲染",charIndex:24299},{level:2,title:"列表 & Key",slug:"列表-key",normalizedTitle:"列表 &amp; key",charIndex:null},{level:3,title:"渲染多个组件",slug:"渲染多个组件",normalizedTitle:"渲染多个组件",charIndex:25700},{level:3,title:"基础列表组件",slug:"基础列表组件",normalizedTitle:"基础列表组件",charIndex:26039},{level:3,title:"key",slug:"key",normalizedTitle:"key",charIndex:26479},{level:3,title:"用 key 提取组件",slug:"用-key-提取组件",normalizedTitle:"用 key 提取组件",charIndex:27614},{level:3,title:"key 值在兄弟节点之间必须唯一",slug:"key-值在兄弟节点之间必须唯一",normalizedTitle:"key 值在兄弟节点之间必须唯一",charIndex:28629},{level:3,title:"在 JSX 中嵌入 map()",slug:"在-jsx-中嵌入-map",normalizedTitle:"在 jsx 中嵌入 map()",charIndex:29711},{level:2,title:"表单",slug:"表单",normalizedTitle:"表单",charIndex:6295},{level:3,title:"受控组件",slug:"受控组件",normalizedTitle:"受控组件",charIndex:30794},{level:3,title:"textarea 标签",slug:"textarea-标签",normalizedTitle:"textarea 标签",charIndex:32083},{level:3,title:"select 标签",slug:"select-标签",normalizedTitle:"select 标签",charIndex:33082},{level:3,title:"文件 input 标签",slug:"文件-input-标签",normalizedTitle:"文件 input 标签",charIndex:34649},{level:3,title:"处理多个输入",slug:"处理多个输入",normalizedTitle:"处理多个输入",charIndex:34843},{level:3,title:"受控输入空值",slug:"受控输入空值",normalizedTitle:"受控输入空值",charIndex:36275},{level:3,title:"受控组件的替代品",slug:"受控组件的替代品",normalizedTitle:"受控组件的替代品",charIndex:36591},{level:3,title:"成熟的解决方案",slug:"成熟的解决方案",normalizedTitle:"成熟的解决方案",charIndex:36763},{level:2,title:"状态提升",slug:"状态提升",normalizedTitle:"状态提升",charIndex:36870},{level:3,title:"添加第二个输入框",slug:"添加第二个输入框",normalizedTitle:"添加第二个输入框",charIndex:37977},{level:3,title:"编写转换函数",slug:"编写转换函数",normalizedTitle:"编写转换函数",charIndex:39229},{level:3,title:"状态提升",slug:"状态提升-2",normalizedTitle:"状态提升",charIndex:36870},{level:3,title:"学习小结",slug:"学习小结",normalizedTitle:"学习小结",charIndex:45430},{level:2,title:"组合 vs 继承",slug:"组合-vs-继承",normalizedTitle:"组合 vs 继承",charIndex:46074},{level:3,title:"包含关系",slug:"包含关系",normalizedTitle:"包含关系",charIndex:46193},{level:3,title:"特例关系",slug:"特例关系",normalizedTitle:"特例关系",charIndex:47616},{level:3,title:"那么继承呢？",slug:"那么继承呢",normalizedTitle:"那么继承呢？",charIndex:49268},{level:2,title:"React哲学",slug:"react哲学",normalizedTitle:"react哲学",charIndex:49508},{level:3,title:"从设计稿开始",slug:"从设计稿开始",normalizedTitle:"从设计稿开始",charIndex:49794},{level:3,title:"第一步：将设计好的 UI 划分为组件层级",slug:"第一步-将设计好的-ui-划分为组件层级",normalizedTitle:"第一步：将设计好的 ui 划分为组件层级",charIndex:50386},{level:3,title:"第二步：用 React 创建一个静态版本",slug:"第二步-用-react-创建一个静态版本",normalizedTitle:"第二步：用 react 创建一个静态版本",charIndex:51446},{level:3,title:"补充说明: 有关 props 和 state",slug:"补充说明-有关-props-和-state",normalizedTitle:"补充说明: 有关 props 和 state",charIndex:52329},{level:3,title:"第三步：确定 UI state 的最小（且完整）表示",slug:"第三步-确定-ui-state-的最小-且完整-表示",normalizedTitle:"第三步：确定 ui state 的最小（且完整）表示",charIndex:52467},{level:3,title:"第四步：确定 state 放置的位置",slug:"第四步-确定-state-放置的位置",normalizedTitle:"第四步：确定 state 放置的位置",charIndex:53210},{level:3,title:"第五步：添加反向数据流",slug:"第五步-添加反向数据流",normalizedTitle:"第五步：添加反向数据流",charIndex:54171},{level:3,title:"这就是全部了",slug:"这就是全部了",normalizedTitle:"这就是全部了",charIndex:54772},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"核心概念 JSX简介 为什么使用 JSX？ 在 JSX 中嵌入表达式 JSX 也是一个表达式 JSX 中指定属性 使用 JSX 指定子元素 JSX 防止注入攻击 JSX 表示对象 元素渲染 将一个元素渲染为 DOM 更新已渲染的元素 React 只更新它需要更新的部分 组件 & Props 函数组件与 class 组件 渲染组件 组合组件 提取组件 Props 的只读性 State & 生命周期 将函数组件转换成 class 组件 向 class 组件中添加局部的 state 将生命周期方法添加到 Class 中 正确地使用 State 不要直接修改 State State 的更新可能是异步的 State 的更新会被合并 数据是向下流动的 事件处理 向事件处理程序传递参数 条件渲染 元素变量 与运算符 && 三目运算符 阻止组件渲染 列表 & Key 渲染多个组件 基础列表组件 key 用 key 提取组件 key 值在兄弟节点之间必须唯一 在 JSX 中嵌入 map() 表单 受控组件 textarea 标签 select 标签 文件 input 标签 处理多个输入 受控输入空值 受控组件的替代品 成熟的解决方案 状态提升 添加第二个输入框 编写转换函数 状态提升 学习小结 组合 vs 继承 包含关系 特例关系 那么继承呢？ React哲学 从设计稿开始 第一步：将设计好的 UI 划分为组件层级 第二步：用 React 创建一个静态版本 补充说明: 有关 props 和 state 第三步：确定 UI state 的最小（且完整）表示 第四步：确定 state 放置的位置 第五步：添加反向数据流 这就是全部了 ",content:'# 核心概念\n\n\n# JSX简介\n\n设想如下变量声明：\n\nconst element = <h1>Hello, world!</h1>;\n\n\n1\n\n\n这个有趣的标签语法既不是字符串也不是 HTML。\n\n它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模板语言，但它具有 JavaScript 的全部功能。\n\nJSX 可以生成 React “元素”。我们将在下一章节中探讨如何将这些元素渲染为 DOM。下面我们看下学习 JSX 所需的基础知识。\n\n\n# 为什么使用 JSX？\n\nReact 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。\n\nReact 并没有采用将标记与逻辑分离到不同文件这种人为的分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。我们将在后面章节中深入学习组件。如果你还没有适应在 JS 中使用标记语言，这个会议讨论应该可以说服你。\n\nReact 不强制要求使用 JSX，但是大多数人发现，在 JavaScript 代码中将 JSX 和 UI 放在一起时，会在视觉上有辅助作用。它还可以使 React 显示更多有用的错误和警告消息。\n\n搞清楚这个问题后，我们就开始学习 JSX 吧！\n\n\n# 在 JSX 中嵌入表达式\n\n在下面的例子中，我们声明了一个名为 name 的变量，然后在 JSX 中使用它，并将它包裹在大括号中：\n\nconst name = \'Josh Perez\';const element = <h1>Hello, {name}</h1>;\n\n\n1\n\n\n在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式。\n\n在下面的示例中，我们将调用 JavaScript 函数 formatName(user) 的结果，并将结果嵌入到 <h1> 元素中。\n\nfunction formatName(user) {\n  return user.firstName + \' \' + user.lastName;\n}\n\nconst user = {\n  firstName: \'Harper\',\n  lastName: \'Perez\'\n};\n\nconst element = (\n  <h1>\n    Hello, {formatName(user)}!  </h1>\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 CodePen 上试试\n\n为了便于阅读，我们会将 JSX 拆分为多行。同时，我们建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到自动插入分号陷阱。\n\n\n# JSX 也是一个表达式\n\n在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。\n\n也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：\n\nfunction getGreeting(user) {\n  if (user) {\n    return <h1>Hello, {formatName(user)}!</h1>;  }\n  return <h1>Hello, Stranger.</h1>;}\n\n\n1\n2\n3\n4\n\n\n\n# JSX 中指定属性\n\n你可以通过使用引号，来将属性值指定为字符串字面量：\n\nconst element = <a href="https://www.reactjs.org"> link </a>;\n\n\n1\n\n\n也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：\n\nconst element = <img src={user.avatarUrl}></img>;\n\n\n1\n\n\n在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。\n\n> 警告：\n> \n> 因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。\n> \n> 例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。\n\n\n# 使用 JSX 指定子元素\n\n假如一个标签里面没有内容，你可以使用 /> 来闭合标签，就像 XML 语法一样：\n\nconst element = <img src={user.avatarUrl} />;\n\n\n1\n\n\nJSX 标签里能够包含很多子元素:\n\nconst element = (\n  <div>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </div>\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# JSX 防止注入攻击\n\n你可以安全地在 JSX 当中插入用户输入内容：\n\nconst title = response.potentiallyMaliciousInput;\n// 直接使用是安全的：\nconst element = <h1>{title}</h1>;\n\n\n1\n2\n3\n\n\nReact DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。\n\n\n# JSX 表示对象\n\nBabel 会把 JSX 转译成一个名为 React.createElement() 函数调用。\n\n以下两种示例代码完全等效：\n\nconst element = (\n  <h1 className="greeting">\n    Hello, world!\n  </h1>\n);\nconst element = React.createElement(\n  \'h1\',\n  {className: \'greeting\'},\n  \'Hello, world!\'\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nReact.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：\n\n// 注意：这是简化过的结构\nconst element = {\n  type: \'h1\',\n  props: {\n    className: \'greeting\',\n    children: \'Hello, world!\'\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。\n\n我们将在下一章节中探讨如何将 React 元素渲染为 DOM。\n\n> 提示：\n> \n> 我们推荐在你使用的编辑器中，使用 “Babel” 提供的语言定义，来正确地高亮显示 ES6 和 JSX 代码。\n\n\n# 元素渲染\n\n元素是构成 React 应用的最小砖块。\n\n元素描述了你在屏幕上想看到的内容。\n\nconst element = <h1>Hello, world</h1>;\n\n\n1\n\n\n与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。\n\n> 注意：\n> \n> 你可能会将元素与另一个被熟知的概念——“组件”混淆起来。我们会在下一个章节介绍组件。组件是由元素构成的。我们强烈建议你不要觉得繁琐而跳过本章节，应当深入阅读这一章节。\n\n\n# 将一个元素渲染为 DOM\n\n假设你的 HTML 文件某处有一个 <div>：\n\n<div id="root"></div>\n\n\n1\n\n\n我们将其称为“根” DOM 节点，因为该节点内的所有内容都将由 React DOM 管理。\n\n仅使用 React 构建的应用通常只有单一的根 DOM 节点。如果你在将 React 集成进一个已有应用，那么你可以在应用中包含任意多的独立根 DOM 节点。\n\n想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.createRoot()：\n\nconst root = ReactDOM.createRoot(\n  document.getElementById(\'root\')\n);\nconst element = <h1>Hello, world</h1>;\nroot.render(element);\n\n\n1\n2\n3\n4\n5\n\n\n在 CodePen 上试试\n\n页面上会展示出 “Hello, world”。\n\n\n# 更新已渲染的元素\n\nReact 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。\n\n根据我们已有的知识，更新 UI 唯一的方式是创建一个全新的元素，并将其传入 root.render()。\n\n考虑一个计时器的例子：\n\nconst root = ReactDOM.createRoot(\n  document.getElementById(\'root\')\n);\n\nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  root.render(element);}\n\nsetInterval(tick, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在 CodePen 上试试\n\n这个例子会在 setInterval() 回调函数，每秒都调用 root.render()。\n\n> 注意：\n> \n> 在实践中，大多数 React 应用只会调用一次 root.render()。在下一个章节，我们将学习如何将这些代码封装到有状态组件中。\n> \n> 我们建议你不要跳跃着阅读，因为每个话题都是紧密联系的。\n\n\n# React 只更新它需要更新的部分\n\nReact DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。\n\n你可以通过查看 上一个例子 来确认这一点。\n\n\n\n尽管每一秒我们都会新建一个描述整个 UI 树的元素，React DOM 只会更新实际改变了的内容，也就是例子中的文本节点。\n\n根据我们的经验，应该专注于 UI 在任意给定时刻的状态，而不是一视同仁地随着时间修改整个界面。\n\n\n# 组件 & Props\n\n组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。本指南旨在介绍组件的相关理念。你可以参考详细组件 API。\n\n组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。\n\n\n# 函数组件与 class 组件\n\n定义组件最简单的方式就是编写 JavaScript 函数：\n\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\n\n1\n2\n3\n\n\n该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。\n\n你同时还可以使用 ES6 的 class 来定义组件：\n\nclass Welcome extends React.Component {\n  render() {\n    return <h1>Hello, {this.props.name}</h1>;\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n上述两个组件在 React 里是等效的。\n\n我们将在下一章节中讨论关于函数组件和 class 组件的额外特性。\n\n\n# 渲染组件\n\n之前，我们遇到的 React 元素都只是 DOM 标签：\n\nconst element = <div />;\n\n\n1\n\n\n不过，React 元素也可以是用户自定义的组件：\n\nconst element = <Welcome name="Sara" />;\n\n\n1\n\n\n当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。\n\n例如，这段代码会在页面上渲染 “Hello, Sara”：\n\nfunction Welcome(props) {  return <h1>Hello, {props.name}</h1>;\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\nconst element = <Welcome name="Sara" />;root.render(element);\n\n\n1\n2\n3\n4\n5\n\n\n在 CodePen 上试试\n\n让我们来回顾一下这个例子中发生了什么：\n\n 1. 我们调用 root.render() 函数，并传入 <Welcome name="Sara" /> 作为参数。\n 2. React 调用 Welcome 组件，并将 {name: \'Sara\'} 作为 props 传入。\n 3. Welcome 组件将 <h1>Hello, Sara</h1> 元素作为返回值。\n 4. React DOM 将 DOM 高效地更新为 <h1>Hello, Sara</h1>。\n\n> 注意： 组件名称必须以大写字母开头。\n> \n> React 会将以小写字母开头的组件视为原生 DOM 标签。例如，<div /> 代表 HTML 的 div 标签，而 <Welcome /> 则代表一个组件，并且需在作用域内使用 Welcome。\n> \n> 你可以在深入 JSX 中了解更多关于此规范的原因。\n\n\n# 组合组件\n\n组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。\n\n例如，我们可以创建一个可以多次渲染 Welcome 组件的 App 组件：\n\nfunction Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name="Sara" />      <Welcome name="Cahal" />      <Welcome name="Edite" />    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 CodePen 上试试\n\n通常来说，每个新的 React 应用程序的顶层组件都是 App 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 Button 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。\n\n\n# 提取组件\n\n将组件拆分为更小的组件。\n\n例如，参考如下 Comment 组件：\n\nfunction Comment(props) {\n  return (\n    <div className="Comment">\n      <div className="UserInfo">\n        <img className="Avatar"\n          src={props.author.avatarUrl}\n          alt={props.author.name}\n        />\n        <div className="UserInfo-name">\n          {props.author.name}\n        </div>\n      </div>\n      <div className="Comment-text">\n        {props.text}\n      </div>\n      <div className="Comment-date">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在 CodePen 上试试\n\n该组件用于描述一个社交媒体网站上的评论功能，它接收 author（对象），text （字符串）以及 date（日期）作为 props。\n\n该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。\n\n首先，我们将提取 Avatar 组件：\n\nfunction Avatar(props) {\n  return (\n    <img className="Avatar"      src={props.user.avatarUrl}      alt={props.user.name}    />  );\n}\n\n\n1\n2\n3\n4\n\n\nAvatar 不需知道它在 Comment 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：user，而不是 author。\n\n我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。\n\n我们现在针对 Comment 做些微小调整：\n\nfunction Comment(props) {\n  return (\n    <div className="Comment">\n      <div className="UserInfo">\n        <Avatar user={props.author} />        <div className="UserInfo-name">\n          {props.author.name}\n        </div>\n      </div>\n      <div className="Comment-text">\n        {props.text}\n      </div>\n      <div className="Comment-date">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n接下来，我们将提取 UserInfo 组件，该组件在用户名旁渲染 Avatar 组件：\n\nfunction UserInfo(props) {\n  return (\n    <div className="UserInfo">      <Avatar user={props.user} />      <div className="UserInfo-name">        {props.user.name}      </div>    </div>  );\n}\n\n\n1\n2\n3\n4\n\n\n进一步简化 Comment 组件：\n\nfunction Comment(props) {\n  return (\n    <div className="Comment">\n      <UserInfo user={props.author} />      <div className="Comment-text">\n        {props.text}\n      </div>\n      <div className="Comment-date">\n        {formatDate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在 CodePen 上试试\n\n最初看上去，提取组件可能是一件繁重的工作，但是，在大型应用中，构建可复用组件库是完全值得的。根据经验来看，如果 UI 中有一部分被多次使用（Button，Panel，Avatar），或者组件本身就足够复杂（App，FeedStory，Comment），那么它就是一个可提取出独立组件的候选项。\n\n\n# Props 的只读性\n\n组件无论是使用函数声明还是通过 class 声明，都绝不能修改自身的 props。来看下这个 sum 函数：\n\nfunction sum(a, b) {\n  return a + b;\n}\n\n\n1\n2\n3\n\n\n这样的函数被称为“纯函数”，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。\n\n相反，下面这个函数则不是纯函数，因为它更改了自己的入参：\n\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n\n\n1\n2\n3\n\n\nReact 非常灵活，但它也有一个严格的规则：\n\n所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\n\n当然，应用程序的 UI 是动态的，并会伴随着时间的推移而变化。在下一章节中，我们将介绍一种新的概念，称之为 “state”。在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。\n\n\n# State & 生命周期\n\nState更新可能是异步的\n\n要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个state作为第一个参数，将此此更新被应用时的 props 作为第二个参数\n\n本页面介绍了 React 组件中 state 和生命周期的概念。你可以查阅详细的组件 API 参考文档。\n\n请参考前一章节中时钟的例子。在元素渲染章节中，我们只了解了一种更新 UI 界面的方法。通过调用 root.render() 来修改我们想要渲染的元素：\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\n  \nfunction tick() {\n  const element = (\n    <div>\n      <h1>Hello, world!</h1>\n      <h2>It is {new Date().toLocaleTimeString()}.</h2>\n    </div>\n  );\n  root.render(element);}\n\nsetInterval(tick, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在 CodePen 上尝试\n\n在本章节中，我们将学习如何封装真正可复用的 Clock 组件。它将设置自己的计时器并每秒更新一次。\n\n我们可以从封装时钟的外观开始：\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\n\nfunction Clock(props) {\n  return (\n    <div>      <h1>Hello, world!</h1>      <h2>It is {props.date.toLocaleTimeString()}.</h2>    </div>  );\n}\n\nfunction tick() {\n  root.render(<Clock date={new Date()} />);}\n\nsetInterval(tick, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在 CodePen 上尝试\n\n然而，它忽略了一个关键的技术细节：Clock 组件需要设置一个计时器，并且需要每秒更新 UI。\n\n理想情况下，我们希望只编写一次代码，便可以让 Clock 组件自我更新：\n\nroot.render(<Clock />);\n\n\n1\n\n\n我们需要在 Clock 组件中添加 “state” 来实现这个功能。\n\nState 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。\n\n\n# 将函数组件转换成 class 组件\n\n通过以下五步将 Clock 的函数组件转成 class 组件：\n\n 1. 创建一个同名的 ES6 class，并且继承于 React.Component。\n 2. 添加一个空的 render() 方法。\n 3. 将函数体移动到 render() 方法之中。\n 4. 在 render() 方法中使用 this.props 替换 props。\n 5. 删除剩余的空函数声明。\n\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 CodePen 上尝试\n\n现在 Clock 组件被定义为 class，而不是函数。\n\n每次组件更新时 render 方法都会被调用，但只要在相同的 DOM 节点中渲染 <Clock /> ，就仅有一个 Clock 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。\n\n\n# 向 class 组件中添加局部的 state\n\n我们通过以下三步将 date 从 props 移动到 state 中：\n\n 1. 把 render() 方法中的 this.props.date 替换成 this.state.date ：\n\nclass Clock extends React.Component {\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 1. 添加一个 class 构造函数，然后在该函数中为 this.state 赋初值：\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n通过以下方式将 props 传递到父类的构造函数中：\n\n  constructor(props) {\n    super(props);    this.state = {date: new Date()};\n  }\n\n\n1\n2\n3\n\n\nClass 组件应该始终使用 props 参数来调用父类的构造函数。\n\n 1. 移除 <Clock /> 元素中的 date 属性：\n\nroot.render(<Clock />);\n\n\n1\n\n\n我们之后会将计时器相关的代码添加到组件中。\n\n代码如下：\n\nclass Clock extends React.Component {\n  constructor(props) {    super(props);    this.state = {date: new Date()};  }\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\nroot.render(<Clock />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 CodePen 上尝试\n\n接下来，我们会设置 Clock 的计时器并每秒更新它。\n\n\n# 将生命周期方法添加到 Class 中\n\n在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的。\n\n当 Clock 组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器。这在 React 中被称为“挂载（mount）”。\n\n同时，当 DOM 中 Clock 组件被删除的时候，应该清除计时器。这在 React 中被称为“卸载（unmount）”。\n\n我们可以为 class 组件声明一些特殊的方法，当组件挂载或卸载时就会去执行这些方法：\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {  }\n  componentWillUnmount() {  }\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这些方法叫做“生命周期方法”。\n\ncomponentDidMount() 方法会在组件已经被渲染到 DOM 中后运行，所以，最好在这里设置计时器：\n\n  componentDidMount() {\n    this.timerID = setInterval(      () => this.tick(),      1000    );  }\n\n\n1\n2\n\n\n接下来把计时器的 ID 保存在 this 之中（this.timerID）。\n\n尽管 this.props 和 this.state 是 React 本身设置的，且都拥有特殊的含义，但是其实你可以向 class 中随意添加不参与数据流（比如计时器 ID）的额外字段。\n\n我们会在 componentWillUnmount() 生命周期方法中清除计时器：\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);  }\n\n\n1\n2\n\n\n最后，我们会实现一个叫 tick() 的方法，Clock 组件每秒都会调用它。\n\n使用 this.setState() 来时刻更新组件 state：\n\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {    this.setState({      date: new Date()    });  }\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\nroot.render(<Clock />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n在 CodePen 上尝试\n\n现在时钟每秒都会刷新。\n\n让我们来快速概括一下发生了什么和这些方法的调用顺序：\n\n 1. 当 <Clock /> 被传给 root.render()的时候，React 会调用 Clock 组件的构造函数。因为 Clock 需要显示当前的时间，所以它会用一个包含当前时间的对象来初始化 this.state。我们会在之后更新 state。\n 2. 之后 React 会调用组件的 render() 方法。这就是 React 确定该在页面上展示什么的方式。然后 React 更新 DOM 来匹配 Clock 渲染的输出。\n 3. 当 Clock 的输出被插入到 DOM 中后，React 就会调用 ComponentDidMount() 生命周期方法。在这个方法中，Clock 组件向浏览器请求设置一个计时器来每秒调用一次组件的 tick() 方法。\n 4. 浏览器每秒都会调用一次 tick() 方法。 在这方法之中，Clock 组件会通过调用 setState() 来计划进行一次 UI 更新。得益于 setState() 的调用，React 能够知道 state 已经改变了，然后会重新调用 render() 方法来确定页面上该显示什么。这一次，render() 方法中的 this.state.date 就不一样了，如此一来就会渲染输出更新过的时间。React 也会相应的更新 DOM。\n 5. 一旦 Clock 组件从 DOM 中被移除，React 就会调用 componentWillUnmount() 生命周期方法，这样计时器就停止了。\n\n\n# 正确地使用 State\n\n关于 setState() 你应该了解三件事：\n\n\n# 不要直接修改 State\n\n例如，此代码不会重新渲染组件：\n\n// Wrong\nthis.state.comment = \'Hello\';\n\n\n1\n2\n\n\n而是应该使用 setState():\n\n// Correct\nthis.setState({comment: \'Hello\'});\n\n\n1\n2\n\n\n构造函数是唯一可以给 this.state 赋值的地方。\n\n\n# State 的更新可能是异步的\n\n出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。\n\n因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。\n\n例如，此代码可能会无法更新计数器：\n\n// Wrong\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});\n\n\n1\n2\n3\n4\n\n\n要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：\n\n// Correct\nthis.setState((state, props) => ({\n  counter: state.counter + props.increment\n}));\n\n\n1\n2\n3\n4\n\n\n上面使用了箭头函数，不过使用普通的函数也同样可以：\n\n// Correct\nthis.setState(function(state, props) {\n  return {\n    counter: state.counter + props.increment\n  };\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# State 的更新会被合并\n\n当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。\n\n例如，你的 state 包含几个独立的变量：\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      posts: [],      comments: []    };\n  }\n\n\n1\n2\n3\n4\n5\n\n\n然后你可以分别调用 setState() 来单独地更新它们：\n\n  componentDidMount() {\n    fetchPosts().then(response => {\n      this.setState({\n        posts: response.posts      });\n    });\n\n    fetchComments().then(response => {\n      this.setState({\n        comments: response.comments      });\n    });\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。\n\n\n# 数据是向下流动的\n\n不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。\n\n这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。\n\n组件可以选择把它的 state 作为 props 向下传递到它的子组件中：\n\n<FormattedDate date={this.state.date} />\n\n\n1\n\n\nFormattedDate 组件会在其 props 中接收参数 date，但是组件本身无法知道它是来自于 Clock 的 state，或是 Clock 的 props，还是手动输入的：\n\nfunction FormattedDate(props) {\n  return <h2>It is {props.date.toLocaleTimeString()}.</h2>;\n}\n\n\n1\n2\n3\n\n\n在 CodePen 上尝试\n\n这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。\n\n如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。\n\n为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 Clock 的 App 组件：\n\nfunction App() {\n  return (\n    <div>\n      <Clock />      <Clock />      <Clock />    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 CodePen 上尝试\n\n每个 Clock 组件都会单独设置它自己的计时器并且更新它。\n\n在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。\n\n\n# 事件处理\n\nReact 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同：\n\n * React 事件的命名采用小驼峰式（camelCase），而不是纯小写。\n * 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。\n\n例如，传统的 HTML：\n\n<button onclick="activateLasers()">\n  Activate Lasers\n</button>\n\n\n1\n2\n3\n\n\n在 React 中略微不同：\n\n<button onClick={activateLasers}>  Activate Lasers\n</button>\n\n\n1\n2\n\n\n在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式地使用 preventDefault。例如，传统的 HTML 中阻止表单的默认提交行为，你可以这样写：\n\n<form onsubmit="console.log(\'You clicked submit.\'); return false">\n  <button type="submit">Submit</button>\n</form>\n\n\n1\n2\n3\n\n\n在 React 中，可能是这样的：\n\nfunction Form() {\n  function handleSubmit(e) {\n    e.preventDefault();    console.log(\'You clicked submit.\');\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <button type="submit">Submit</button>\n    </form>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在这里，e 是一个合成事件。React 根据 W3C 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。如果想了解更多，请查看 SyntheticEvent 参考指南。\n\n使用 React 时，你一般不需要使用 addEventListener 为已创建的 DOM 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。\n\n当你使用 ES6 class 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 Toggle 组件会渲染一个让用户切换开关状态的按钮：\n\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n\n    // 为了在回调中使用 `this`，这个绑定是必不可少的    this.handleClick = this.handleClick.bind(this);  }\n\n  handleClick() {    this.setState(prevState => ({      isToggleOn: !prevState.isToggleOn    }));  }\n  render() {\n    return (\n      <button onClick={this.handleClick}>        {this.state.isToggleOn ? \'ON\' : \'OFF\'}\n      </button>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在 CodePen 上尝试\n\n你必须谨慎对待 JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。\n\n这并不是 React 特有的行为；这其实与 JavaScript 函数工作原理有关。通常情况下，如果你没有在方法后面添加 ()，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。\n\n如果觉得使用 bind 很麻烦，这里有两种方式可以解决。你可以使用 public class fields 语法 to correctly bind callbacks:\n\nclass LoggingButton extends React.Component {\n  // This syntax ensures `this` is bound within handleClick.  handleClick = () => {    console.log(\'this is:\', this);  };  render() {\n    return (\n      <button onClick={this.handleClick}>\n        Click me\n      </button>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nCreate React App 默认启用此语法。\n\n如果你没有使用 class fields 语法，你可以在回调中使用箭头函数：\n\nclass LoggingButton extends React.Component {\n  handleClick() {\n    console.log(\'this is:\', this);\n  }\n\n  render() {\n    // 此语法确保 `handleClick` 内的 `this` 已被绑定。    return (      <button onClick={() => this.handleClick()}>        Click me\n      </button>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。\n\n\n# 向事件处理程序传递参数\n\n在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：\n\n<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n\n\n1\n2\n\n\n上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。\n\n在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。\n\n\n# 条件渲染\n\n在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。\n\nReact 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 if 或者条件运算符去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。\n\n观察这两个组件:\n\nfunction UserGreeting(props) {\n  return <h1>Welcome back!</h1>;\n}\n\nfunction GuestGreeting(props) {\n  return <h1>Please sign up.</h1>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n再创建一个 Greeting 组件，它会根据用户是否登录来决定显示上面的哪一个组件。\n\nfunction Greeting(props) {\n  const isLoggedIn = props.isLoggedIn;\n  if (isLoggedIn) {    return <UserGreeting />;  }  return <GuestGreeting />;}\nconst root = ReactDOM.createRoot(document.getElementById(\'root\')); \n// Try changing to isLoggedIn={true}:\nroot.render(<Greeting isLoggedIn={false} />);\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 CodePen 上尝试\n\n这个示例根据 isLoggedIn 的值来渲染不同的问候语。\n\n\n# 元素变量\n\n你可以使用变量来储存元素。 它可以帮助你有条件地渲染组件的一部分，而其他的渲染部分并不会因此而改变。\n\n观察这两个组件，它们分别代表了注销和登录按钮：\n\nfunction LoginButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Login\n    </button>\n  );\n}\n\nfunction LogoutButton(props) {\n  return (\n    <button onClick={props.onClick}>\n      Logout\n    </button>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在下面的示例中，我们将创建一个名叫 LoginControl 的有状态的组件。\n\n它将根据当前的状态来渲染 <LoginButton /> 或者 <LogoutButton />。同时它还会渲染上一个示例中的 <Greeting />。\n\nclass LoginControl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.handleLogoutClick = this.handleLogoutClick.bind(this);\n    this.state = {isLoggedIn: false};\n  }\n\n  handleLoginClick() {\n    this.setState({isLoggedIn: true});\n  }\n\n  handleLogoutClick() {\n    this.setState({isLoggedIn: false});\n  }\n\n  render() {\n    const isLoggedIn = this.state.isLoggedIn;\n    let button;\n    if (isLoggedIn) {      button = <LogoutButton onClick={this.handleLogoutClick} />;    } else {      button = <LoginButton onClick={this.handleLoginClick} />;    }\n    return (\n      <div>\n        <Greeting isLoggedIn={isLoggedIn} />        {button}      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\')); \nroot.render(<LoginControl />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在 CodePen 上尝试\n\n声明一个变量并使用 if 语句进行条件渲染是不错的方式，但有时你可能会想使用更为简洁的语法。接下来，我们将介绍几种在 JSX 中内联条件渲染的方法。\n\n\n# 与运算符 &&\n\n通过花括号包裹代码，你可以在 JSX 中嵌入表达式。这也包括 JavaScript 中的逻辑与 (&&) 运算符。它可以很方便地进行元素的条件渲染：\n\nfunction Mailbox(props) {\n  const unreadMessages = props.unreadMessages;\n  return (\n    <div>\n      <h1>Hello!</h1>\n      {unreadMessages.length > 0 &&        <h2>          You have {unreadMessages.length} unread messages.        </h2>      }    </div>\n  );\n}\n\nconst messages = [\'React\', \'Re: React\', \'Re:Re: React\'];\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\')); \nroot.render(<Mailbox unreadMessages={messages} />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 CodePen 上尝试\n\n之所以能这样做，是因为在 JavaScript 中，true && expression 总是会返回 expression, 而 false && expression 总是会返回 false。\n\n因此，如果条件是 true，&& 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。\n\n请注意，falsy 表达式 会使 && 后面的元素被跳过，但会返回 falsy 表达式的值。在下面示例中，render 方法的返回值是 <div>0</div>。\n\nrender() {\n  const count = 0;  return (\n    <div>\n      {count && <h1>Messages: {count}</h1>}    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 三目运算符\n\n另一种内联条件渲染的方法是使用 JavaScript 中的三目运算符 condition ? true : false。\n\n在下面这个示例中，我们用它来条件渲染一小段文本\n\nrender() {\n  const isLoggedIn = this.state.isLoggedIn;\n  return (\n    <div>\n      The user is <b>{isLoggedIn ? \'currently\' : \'not\'}</b> logged in.    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同样的，它也可以用于较为复杂的表达式中，虽然看起来不是很直观：\n\nrender() {\n  const isLoggedIn = this.state.isLoggedIn;\n  return (\n    <div>\n      {isLoggedIn        ? <LogoutButton onClick={this.handleLogoutClick} />\n        : <LoginButton onClick={this.handleLoginClick} />      }\n    </div>  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n就像在 JavaScript 中一样，你可以根据团队的习惯来选择可读性更高的代码风格。需要注意的是，如果条件变得过于复杂，那你应该考虑如何提取组件。\n\n\n# 阻止组件渲染\n\n在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。\n\n下面的示例中，<WarningBanner /> 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染:\n\nfunction WarningBanner(props) {\n  if (!props.warn) {    return null;  }\n  return (\n    <div className="warning">\n      Warning!\n    </div>\n  );\n}\n\nclass Page extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {showWarning: true};\n    this.handleToggleClick = this.handleToggleClick.bind(this);\n  }\n\n  handleToggleClick() {\n    this.setState(state => ({\n      showWarning: !state.showWarning\n    }));\n  }\n\n  render() {\n    return (\n      <div>\n        <WarningBanner warn={this.state.showWarning} />        <button onClick={this.handleToggleClick}>\n          {this.state.showWarning ? \'Hide\' : \'Show\'}\n        </button>\n      </div>\n    );\n  }\n}\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\')); \nroot.render(<Page />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n在 CodePen 上尝试\n\n在组件的 render 方法中返回 null 并不会影响组件的生命周期。例如，上面这个示例中，componentDidUpdate 依然会被调用。\n\n\n# 列表 & Key\n\n首先，让我们看下在 Javascript 中如何转化列表。\n\n如下代码，我们使用 map() 函数让数组中的每一项变双倍，然后我们得到了一个新的列表 doubled 并打印出来：\n\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map((number) => number * 2);console.log(doubled);\n\n\n1\n2\n\n\n代码打印出 [2, 4, 6, 8, 10]。\n\n在 React 中，把数组转化为元素列表的过程是相似的。\n\n\n# 渲染多个组件\n\n你可以通过使用 {} 在 JSX 内构建一个元素集合。\n\n下面，我们使用 Javascript 中的 map() 方法来遍历 numbers 数组。将数组中的每个元素变成 <li> 标签，最后我们将得到的数组赋值给 listItems：\n\nconst numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =>  <li>{number}</li>);\n\n\n1\n2\n\n\n然后，我们可以将整个 listItems 插入到 <ul> 元素中：\n\n<ul>{listItems}</ul>\n\n\n1\n\n\n在 CodePen 上尝试\n\n这段代码生成了一个 1 到 5 的项目符号列表。\n\n\n# 基础列表组件\n\n通常你需要在一个组件中渲染列表。\n\n我们可以把前面的例子重构成一个组件，这个组件接收 numbers 数组作为参数并输出一个元素列表。\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>    <li>{number}</li>  );  return (\n    <ul>{listItems}</ul>  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\nroot.render(<NumberList numbers={numbers} />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当我们运行这段代码，将会看到一个警告 a key should be provided for list items，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。我们将在下一节讨论这是为什么。\n\n让我们来给每个列表元素分配一个 key 属性来解决上面的那个警告：\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li key={number.toString()}>      {number}\n    </li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 CodePen 上尝试\n\n\n# key\n\nkey 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。\n\nconst numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =>\n  <li key={number.toString()}>    {number}\n  </li>\n);\n\n\n1\n2\n3\n4\n5\n\n\n一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key：\n\nconst todoItems = todos.map((todo) =>\n  <li key={todo.id}>    {todo.text}\n  </li>\n);\n\n\n1\n2\n3\n4\n\n\n当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：\n\nconst todoItems = todos.map((todo, index) =>\n  // Only do this if items have no stable IDs  <li key={index}>    {todo.text}\n  </li>\n);\n\n\n1\n2\n3\n4\n\n\n如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。可以看看 Robin Pokorny 的深度解析使用索引作为 key 的负面影响这一篇文章。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。\n\n要是你有兴趣了解更多的话，这里有一篇文章深入解析为什么 key 是必须的可以参考。\n\n\n# 用 key 提取组件\n\n元素的 key 只有放在就近的数组上下文中才有意义。\n\n比方说，如果你提取出一个 ListItem 组件，你应该把 key 保留在数组中的这个 <ListItem /> 元素上，而不是放在 ListItem 组件中的 <li> 元素上。\n\n例子：不正确的使用 key 的方式\n\nfunction ListItem(props) {\n  const value = props.value;\n  return (\n    // 错误！你不需要在这里指定 key：    <li key={value.toString()}>      {value}\n    </li>\n  );\n}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // 错误！元素的 key 应该在这里指定：    <ListItem value={number} />  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n例子：正确的使用 key 的方式\n\nfunction ListItem(props) {\n  // 正确！这里不需要指定 key：  return <li>{props.value}</li>;}\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // 正确！key 应该在数组的上下文中被指定    <ListItem key={number.toString()} value={number} />  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 CodePen 上尝试\n\n一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性。\n\n\n# key 值在兄弟节点之间必须唯一\n\n数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：\n\nfunction Blog(props) {\n  const sidebar = (    <ul>\n      {props.posts.map((post) =>\n        <li key={post.id}>          {post.title}\n        </li>\n      )}\n    </ul>\n  );\n  const content = props.posts.map((post) =>    <div key={post.id}>      <h3>{post.title}</h3>\n      <p>{post.content}</p>\n    </div>\n  );\n  return (\n    <div>\n      {sidebar}      <hr />\n      {content}    </div>\n  );\n}\n\nconst posts = [\n  {id: 1, title: \'Hello World\', content: \'Welcome to learning React!\'},\n  {id: 2, title: \'Installation\', content: \'You can install React from npm.\'}\n];\n\nconst root = ReactDOM.createRoot(document.getElementById(\'root\'));\nroot.render(<Blog posts={posts} />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在 CodePen 上尝试\n\nkey 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：\n\nconst content = posts.map((post) =>\n  <Post\n    key={post.id}    id={post.id}    title={post.title} />\n);\n\n\n1\n2\n3\n4\n\n\n上面例子中，Post 组件可以读出 props.id，但是不能读出 props.key。\n\n\n# 在 JSX 中嵌入 map()\n\n在上面的例子中，我们声明了一个单独的 listItems 变量并将其包含在 JSX 中：\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>    <ListItem key={number.toString()}              value={number} />  );  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nJSX 允许在大括号中嵌入任何表达式，所以我们可以内联 map() 返回的结果：\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  return (\n    <ul>\n      {numbers.map((number) =>        <ListItem key={number.toString()}                  value={number} />      )}    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在 CodePen 上尝试\n\n这么做有时可以使你的代码更清晰，但有时这种风格也会被滥用。就像在 JavaScript 中一样，何时需要为了可读性提取出一个变量，这完全取决于你。但请记住，如果一个 map() 嵌套了太多层级，那可能就是你提取组件的一个好时机。\n\n\n# 表单\n\n在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 HTML 表单只接受一个名称：\n\n<form>\n  <label>\n    名字:\n    <input type="text" name="name" />\n  </label>\n  <input type="submit" value="提交" />\n</form>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n此表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。\n\n\n# 受控组件\n\n在 HTML 中，表单元素（如<input>、 <textarea> 和 <select>）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。\n\n我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。\n\n例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：\n\nclass NameForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: \'\'};\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {    this.setState({value: event.target.value});  }\n  handleSubmit(event) {\n    alert(\'提交的名字: \' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>        <label>\n          名字:\n          <input type="text" value={this.state.value} onChange={this.handleChange} />        </label>\n        <input type="submit" value="提交" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n在 CodePen 上尝试\n\n由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。\n\n对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。\n\n\n# textarea 标签\n\n在 HTML 中, <textarea> 元素通过其子元素定义其文本:\n\n<textarea>\n  你好， 这是在 text area 里的文本\n</textarea>\n\n\n1\n2\n3\n\n\n而在 React 中，<textarea> 使用 value 属性代替。这样，可以使得使用 <textarea> 的表单和使用单行 input 的表单非常类似：\n\nclass EssayForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {      value: \'请撰写一篇关于你喜欢的 DOM 元素的文章.\'    };\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {    this.setState({value: event.target.value});  }\n  handleSubmit(event) {\n    alert(\'提交的文章: \' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          文章:\n          <textarea value={this.state.value} onChange={this.handleChange} />        </label>\n        <input type="submit" value="提交" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n请注意，this.state.value 初始化于构造函数中，因此文本区域默认有初值。\n\n\n# select 标签\n\n在 HTML 中，<select> 创建下拉列表标签。例如，如下 HTML 创建了水果相关的下拉列表：\n\n<select>\n  <option value="grapefruit">葡萄柚</option>\n  <option value="lime">酸橙</option>\n  <option selected value="coconut">椰子</option>\n  <option value="mango">芒果</option>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n\n\n请注意，由于 selected 属性的缘故，椰子选项默认被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：\n\nclass FlavorForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: \'coconut\'};\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleChange(event) {    this.setState({value: event.target.value});  }\n  handleSubmit(event) {\n    alert(\'你喜欢的风味是: \' + this.state.value);\n    event.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          选择你喜欢的风味:\n          <select value={this.state.value} onChange={this.handleChange}>            <option value="grapefruit">葡萄柚</option>\n            <option value="lime">酸橙</option>\n            <option value="coconut">椰子</option>\n            <option value="mango">芒果</option>\n          </select>\n        </label>\n        <input type="submit" value="提交" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n在 CodePen 上尝试\n\n总的来说，这使得 <input type="text">, <textarea> 和 <select> 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。\n\n> 注意\n> \n> 你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项：\n> \n> <select multiple={true} value={[\'B\', \'C\']}>\n> \n> \n> 1\n\n\n# 文件 input 标签\n\n在 HTML 中，<input type="file"> 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 File API 进行控制。\n\n<input type="file" />\n\n\n1\n\n\n因为它的 value 只读，所以它是 React 中的一个非受控组件。将与其他非受控组件在后续文档中一起讨论。\n\n\n# 处理多个输入\n\n当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。\n\n例如：\n\nclass Reservation extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isGoing: true,\n      numberOfGuests: 2\n    };\n\n    this.handleInputChange = this.handleInputChange.bind(this);\n  }\n\n  handleInputChange(event) {\n    const target = event.target;\n    const value = target.type === \'checkbox\' ? target.checked : target.value;\n    const name = target.name;\n    this.setState({\n      [name]: value    });\n  }\n\n  render() {\n    return (\n      <form>\n        <label>\n          参与:\n          <input\n            name="isGoing"            type="checkbox"\n            checked={this.state.isGoing}\n            onChange={this.handleInputChange} />\n        </label>\n        <br />\n        <label>\n          来宾人数:\n          <input\n            name="numberOfGuests"            type="number"\n            value={this.state.numberOfGuests}\n            onChange={this.handleInputChange} />\n        </label>\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n在 CodePen 上尝试\n\n这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值：\n\n例如：\n\nthis.setState({\n  [name]: value});\n\n\n1\n2\n\n\n等同 ES5:\n\nvar partialState = {};\npartialState[name] = value;this.setState(partialState);\n\n\n1\n2\n\n\n另外，由于 setState() 自动将部分 state 合并到当前 state, 只需调用它更改部分 state 即可。\n\n\n# 受控输入空值\n\n在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。\n\n下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）\n\nReactDOM.createRoot(mountNode).render(<input value="hi" />);\n\nsetTimeout(function() {\n  ReactDOM.createRoot(mountNode).render(<input value={null} />);\n}, 1000);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 受控组件的替代品\n\n有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件, 这是实现输入表单的另一种方式。\n\n\n# 成熟的解决方案\n\n如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 Formik 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。\n\n\n# 状态提升\n\n通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。让我们看看它是如何运作的。\n\n在本节中，我们将创建一个用于计算水在给定温度下是否会沸腾的温度计算器。\n\n我们将从一个名为 BoilingVerdict 的组件开始，它接受 celsius 温度作为一个 prop，并据此打印出该温度是否足以将水煮沸的结果。\n\nfunction BoilingVerdict(props) {\n  if (props.celsius >= 100) {\n    return <p>The water would boil.</p>;  }\n  return <p>The water would not boil.</p>;}\n\n\n1\n2\n3\n4\n\n\n接下来, 我们创建一个名为 Calculator 的组件。它渲染一个用于输入温度的 <input>，并将其值保存在 this.state.temperature 中。\n\n另外, 它根据当前输入值渲染 BoilingVerdict 组件。\n\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {temperature: \'\'};  }\n\n  handleChange(e) {\n    this.setState({temperature: e.target.value});  }\n\n  render() {\n    const temperature = this.state.temperature;    return (\n      <fieldset>\n        <legend>Enter temperature in Celsius:</legend>\n        <input          value={temperature}          onChange={this.handleChange} />        <BoilingVerdict          celsius={parseFloat(temperature)} />      </fieldset>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在 CodePen 上尝试\n\n\n# 添加第二个输入框\n\n我们的新需求是，在已有摄氏温度输入框的基础上，我们提供华氏度的输入框，并保持两个输入框的数据同步。\n\n我们先从 Calculator 组件中抽离出 TemperatureInput 组件，然后为其添加一个新的 scale prop，它可以是 "c" 或是 "f"：\n\nconst scaleNames = {  c: \'Celsius\',  f: \'Fahrenheit\'};\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {temperature: \'\'};\n  }\n\n  handleChange(e) {\n    this.setState({temperature: e.target.value});\n  }\n\n  render() {\n    const temperature = this.state.temperature;\n    const scale = this.props.scale;    return (\n      <fieldset>\n        <legend>Enter temperature in {scaleNames[scale]}:</legend>        <input value={temperature}\n               onChange={this.handleChange} />\n      </fieldset>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n我们现在可以修改 Calculator 组件让它渲染两个独立的温度输入框组件：\n\nclass Calculator extends React.Component {\n  render() {\n    return (\n      <div>\n        <TemperatureInput scale="c" />        <TemperatureInput scale="f" />      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在 CodePen 上尝试\n\n我们现在有了两个输入框，但当你在其中一个输入温度时，另一个并不会更新。这与我们的要求相矛盾：我们希望让它们保持同步。\n\n另外，我们也不能通过 Calculator 组件展示 BoilingVerdict 组件的渲染结果。因为 Calculator 组件并不知道隐藏在 TemperatureInput 组件中的当前温度是多少。\n\n\n# 编写转换函数\n\n首先，我们将编写两个可以在摄氏度与华氏度之间相互转换的函数：\n\nfunction toCelsius(fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nfunction toFahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上述两个函数仅做数值转换。而我们将编写另一个函数，它接受字符串类型的 temperature 和转换函数作为参数并返回一个字符串。我们将使用它来依据一个输入框的值计算出另一个输入框的值。\n\n当输入 temperature 的值无效时，函数返回空字符串，反之，则返回保留三位小数并四舍五入后的转换结果：\n\nfunction tryConvert(temperature, convert) {\n  const input = parseFloat(temperature);\n  if (Number.isNaN(input)) {\n    return \'\';\n  }\n  const output = convert(input);\n  const rounded = Math.round(output * 1000) / 1000;\n  return rounded.toString();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n例如，tryConvert(\'abc\', toCelsius) 返回一个空字符串，而 tryConvert(\'10.22\', toFahrenheit) 返回 \'50.396\'。\n\n\n# 状态提升\n\n到目前为止, 两个 TemperatureInput 组件均在各自内部的 state 中相互独立地保存着各自的数据。\n\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {temperature: \'\'};  }\n\n  handleChange(e) {\n    this.setState({temperature: e.target.value});  }\n\n  render() {\n    const temperature = this.state.temperature;    // ...  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然而，我们希望两个输入框内的数值彼此能够同步。当我们更新摄氏度输入框内的数值时，华氏度输入框内应当显示转换后的华氏温度，反之亦然。\n\n在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”。接下来，我们将 TemperatureInput 组件中的 state 移动至 Calculator 组件中去。\n\n如果 Calculator 组件拥有了共享的 state，它将成为两个温度输入框中当前温度的“数据源”。它能够使得两个温度输入框的数值彼此保持一致。由于两个 TemperatureInput 组件的 props 均来自共同的父组件 Calculator，因此两个输入框中的内容将始终保持一致。\n\n让我们看看这是如何一步一步实现的。\n\n首先，我们将 TemperatureInput 组件中的 this.state.temperature 替换为 this.props.temperature。现在，我们先假定 this.props.temperature 已经存在，尽管将来我们需要通过 Calculator 组件将其传入：\n\n  render() {\n    // Before: const temperature = this.state.temperature;\n    const temperature = this.props.temperature;    // ...\n\n\n1\n2\n3\n\n\n我们知道 props 是只读的。当 temperature 存在于 TemperatureInput 组件的 state 中时，组件调用 this.setState() 便可修改它。然而，temperature 是由父组件传入的 prop，TemperatureInput 组件便失去了对它的控制权。\n\n在 React 中，这个问题通常是通过使用“受控组件”来解决的。与 DOM 中的 <input> 接受 value 和 onChange 一样，自定义的 TemperatureInput 组件接受 temperature 和 onTemperatureChange 这两个来自父组件 Calculator 的 props。\n\n现在，当 TemperatureInput 组件想更新温度时，需调用 this.props.onTemperatureChange 来更新它：\n\n  handleChange(e) {\n    // Before: this.setState({temperature: e.target.value});\n    this.props.onTemperatureChange(e.target.value);    // ...\n\n\n1\n2\n3\n\n\n> 注意：\n> \n> 自定义组件中的 temperature 和 onTemperatureChange 这两个 prop 的命名没有任何特殊含义。我们可以给它们取其它任意的名字，例如，把它们命名为 value 和 onChange 就是一种习惯。\n\nonTemperatureChange 的 prop 和 temperature 的 prop 一样，均由父组件 Calculator 提供。它通过修改父组件自身的内部 state 来处理数据的变化，进而使用新的数值重新渲染两个输入框。我们将很快看到修改后的 Calculator 组件效果。\n\n在深入研究 Calculator 组件的变化之前，让我们回顾一下 TemperatureInput 组件的变化。我们移除组件自身的 state，通过使用 this.props.temperature 替代 this.state.temperature 来读取温度数据。当我们想要响应数据改变时，我们需要调用 Calculator 组件提供的 this.props.onTemperatureChange()，而不再使用 this.setState()。\n\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onTemperatureChange(e.target.value);  }\n\n  render() {\n    const temperature = this.props.temperature;    const scale = this.props.scale;\n    return (\n      <fieldset>\n        <legend>Enter temperature in {scaleNames[scale]}:</legend>\n        <input value={temperature}\n               onChange={this.handleChange} />\n      </fieldset>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n现在，让我们把目光转向 Calculator 组件。\n\n我们会把当前输入的 temperature 和 scale 保存在组件内部的 state 中。这个 state 就是从两个输入框组件中“提升”而来的，并且它将用作两个输入框组件的共同“数据源”。这是我们为了渲染两个输入框所需要的所有数据的最小表示。\n\n例如，当我们在摄氏度输入框中键入 37 时，Calculator 组件中的 state 将会是：\n\n{\n  temperature: \'37\',\n  scale: \'c\'\n}\n\n\n1\n2\n3\n4\n\n\n如果我们之后修改华氏度的输入框中的内容为 212 时，Calculator 组件中的 state 将会是：\n\n{\n  temperature: \'212\',\n  scale: \'f\'\n}\n\n\n1\n2\n3\n4\n\n\n我们可以存储两个输入框中的值，但这并不是必要的。我们只需要存储最近修改的温度及其计量单位即可，根据当前的 temperature 和 scale 就可以计算出另一个输入框的值。\n\n由于两个输入框中的数值由同一个 state 计算而来，因此它们始终保持同步：\n\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.state = {temperature: \'\', scale: \'c\'};  }\n\n  handleCelsiusChange(temperature) {\n    this.setState({scale: \'c\', temperature});  }\n\n  handleFahrenheitChange(temperature) {\n    this.setState({scale: \'f\', temperature});  }\n\n  render() {\n    const scale = this.state.scale;    const temperature = this.state.temperature;    const celsius = scale === \'f\' ? tryConvert(temperature, toCelsius) : temperature;    const fahrenheit = scale === \'c\' ? tryConvert(temperature, toFahrenheit) : temperature;\n    return (\n      <div>\n        <TemperatureInput\n          scale="c"\n          temperature={celsius}          onTemperatureChange={this.handleCelsiusChange} />        <TemperatureInput\n          scale="f"\n          temperature={fahrenheit}          onTemperatureChange={this.handleFahrenheitChange} />        <BoilingVerdict\n          celsius={parseFloat(celsius)} />      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在 CodePen 上尝试\n\n现在无论你编辑哪个输入框中的内容，Calculator 组件中的 this.state.temperature 和 this.state.scale 均会被更新。其中一个输入框保留用户的输入并取值，另一个输入框始终基于这个值显示转换后的结果。\n\n让我们来重新梳理一下当你对输入框内容进行编辑时会发生些什么：\n\n * React 会调用 DOM 中 <input> 的 onChange 方法。在本实例中，它是 TemperatureInput 组件的 handleChange 方法。\n * TemperatureInput 组件中的 handleChange 方法会调用 this.props.onTemperatureChange()，并传入新输入的值作为参数。其 props 诸如 onTemperatureChange 之类，均由父组件 Calculator 提供。\n * 起初渲染时，用于摄氏度输入的子组件 TemperatureInput 中的 onTemperatureChange 方法与 Calculator 组件中的 handleCelsiusChange 方法相同，而，用于华氏度输入的子组件 TemperatureInput 中的 onTemperatureChange 方法与 Calculator 组件中的 handleFahrenheitChange 方法相同。因此，无论哪个输入框被编辑都会调用 Calculator 组件中对应的方法。\n * 在这些方法内部，Calculator 组件通过使用新的输入值与当前输入框对应的温度计量单位来调用 this.setState() 进而请求 React 重新渲染自己本身。\n * React 调用 Calculator 组件的 render 方法得到组件的 UI 呈现。温度转换在这时进行，两个输入框中的数值通过当前输入温度和其计量单位来重新计算获得。\n * React 使用 Calculator 组件提供的新 props 分别调用两个 TemperatureInput 子组件的 render 方法来获取子组件的 UI 呈现。\n * React 调用 BoilingVerdict 组件的 render 方法，并将摄氏温度值以组件 props 方式传入。\n * React DOM 根据输入值匹配水是否沸腾，并将结果更新至 DOM。我们刚刚编辑的输入框接收其当前值，另一个输入框内容更新为转换后的温度值。\n\n得益于每次的更新都经历相同的步骤，两个输入框的内容才能始终保持同步。\n\n\n# 学习小结\n\n在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。\n\n虽然提升 state 方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离 bug 所需的工作量将会变少。由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。\n\n如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。举个例子，本例中我们没有将 celsiusValue 和 fahrenheitValue 一起保存，而是仅保存了最后修改的 temperature 和它的 scale。这是因为另一个输入框的温度值始终可以通过这两个值以及组件的 render() 方法获得。这使得我们能够清除输入框内容，亦或是，在不损失用户操作的输入框内数值精度的前提下对另一个输入框内的转换数值做四舍五入的操作。\n\n当你在 UI 中发现错误时，可以使用 React 开发者工具 来检查问题组件的 props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的那个组件。这使得你能够追踪到产生 bug 的源头：\n\n\n\n\n# 组合 vs 继承\n\nReact 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用。\n\n在这篇文档中，我们将考虑初学 React 的开发人员使用继承时经常会遇到的一些问题，并展示如何通过组合思想来解决这些问题。\n\n\n# 包含关系\n\n有些组件无法提前知晓它们子组件的具体内容。在 Sidebar（侧边栏）和 Dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。\n\n我们建议这些组件使用一个特殊的 children prop 来将他们的子组件传递到渲染结果中：\n\nfunction FancyBorder(props) {\n  return (\n    <div className={\'FancyBorder FancyBorder-\' + props.color}>\n      {props.children}    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。\n\nfunction WelcomeDialog() {\n  return (\n    <FancyBorder color="blue">\n      <h1 className="Dialog-title">        Welcome      </h1>      <p className="Dialog-message">        Thank you for visiting our spacecraft!      </p>    </FancyBorder>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 CodePen 上尝试\n\n<FancyBorder> JSX 标签中的所有内容都会作为一个 children prop 传递给 FancyBorder 组件。因为 FancyBorder 将 {props.children} 渲染在一个 <div> 中，被传递的这些子组件最终都会出现在输出结果中。\n\n少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 children，而是自行约定：将所需内容传入 props，并使用相应的 prop。\n\nfunction SplitPane(props) {\n  return (\n    <div className="SplitPane">\n      <div className="SplitPane-left">\n        {props.left}      </div>\n      <div className="SplitPane-right">\n        {props.right}      </div>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <SplitPane\n      left={\n        <Contacts />      }\n      right={\n        <Chat />      } />\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在 CodePen 上尝试\n\n<Contacts /> 和 <Chat /> 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。这种方法可能使你想起别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。\n\n\n# 特例关系\n\n有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 WelcomeDialog 可以说是 Dialog 的特殊实例。\n\n在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：\n\nfunction Dialog(props) {\n  return (\n    <FancyBorder color="blue">\n      <h1 className="Dialog-title">\n        {props.title}      </h1>\n      <p className="Dialog-message">\n        {props.message}      </p>\n    </FancyBorder>\n  );\n}\n\nfunction WelcomeDialog() {\n  return (\n    <Dialog      title="Welcome"      message="Thank you for visiting our spacecraft!" />  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在 CodePen 上尝试\n\n组合也同样适用于以 class 形式定义的组件。\n\nfunction Dialog(props) {\n  return (\n    <FancyBorder color="blue">\n      <h1 className="Dialog-title">\n        {props.title}\n      </h1>\n      <p className="Dialog-message">\n        {props.message}\n      </p>\n      {props.children}    </FancyBorder>\n  );\n}\n\nclass SignUpDialog extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSignUp = this.handleSignUp.bind(this);\n    this.state = {login: \'\'};\n  }\n\n  render() {\n    return (\n      <Dialog title="Mars Exploration Program"\n              message="How should we refer to you?">\n        <input value={this.state.login}               onChange={this.handleChange} />        <button onClick={this.handleSignUp}>          Sign Me Up!        </button>      </Dialog>\n    );\n  }\n\n  handleChange(e) {\n    this.setState({login: e.target.value});\n  }\n\n  handleSignUp() {\n    alert(`Welcome aboard, ${this.state.login}!`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n在 CodePen 上尝试\n\n\n# 那么继承呢？\n\n在 Facebook，我们在成百上千个组件中使用 React。我们并没有发现需要使用继承来构建组件层次的情况。\n\nProps 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。\n\n如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。\n\n\n# React哲学\n\n 1. 将设计好的UI划分成组件层级\n 2. 用 React 创建一个静态版本\n 3. 确定 UI state 的最小且完整表示\n 4. 确定 state 放置的位置\n 5. 添加反向数据流\n 6. that\'s it\n\n我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。\n\nReact 最棒的部分之一是引导我们思考如何构建一个应用。在这篇文档中，我们将会通过 React 构建一个可搜索的产品数据表格来更深刻地领会 React 哲学。\n\n\n# 从设计稿开始\n\n假设我们已经有了一个返回 JSON 的 API，以及设计师提供的组件设计稿。如下所示：\n\n\n\n该 JSON API 会返回以下数据：\n\n[\n  {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},\n  {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},\n  {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},\n  {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},\n  {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},\n  {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 第一步：将设计好的 UI 划分为组件层级\n\n首先，你需要在设计稿上用方框圈出每一个组件（包括它们的子组件），并且以合适的名称命名。如果你是和设计师一起完成此任务，那么他们可能已经做过类似的工作，所以请和他们进行交流！他们的 Photoshop 的图层名称可能最终就是你编写的 React 组件的名称！\n\n但你如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据单一功能原则来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。\n\n在实践中，因为你经常是在向用户展示 JSON 数据模型，所以如果你的模型设计得恰当，UI（或者说组件结构）便会与数据模型一一对应，这是因为 UI 和数据模型都会倾向于遵守相同的信息结构。将 UI 分离为组件，其中每个组件需与数据模型的某部分匹配。\n\n\n\n你会看到我们的应用中包含五个组件。我们已经将每个组件展示的数据标注为了斜体。图片中的序号与下方列表中的序号对应。\n\n 1. FilterableProductTable (橙色): 是整个示例应用的整体\n 2. SearchBar (蓝色): 接受所有的用户输入\n 3. ProductTable (绿色): 展示数据内容并根据用户输入筛选结果\n 4. ProductCategoryRow (天蓝色): 为每一个产品类别展示标题\n 5. ProductRow (红色): 每一行展示一个产品\n\n你可能注意到，ProductTable 的表头（包含 “Name” 和 “Price” 的那一部分）并未单独成为一个组件。这仅仅是一种偏好选择，如何处理这一问题也一直存在争论。就这个示例而言，因为表头只起到了渲染数据集合的作用——这与 ProductTable 是一致的，所以我们仍然将其保留为 ProductTable 的一部分。但是，如果表头过于复杂（例如，我们需为其添加排序功能），那么将它作为一个独立的 ProductTableHeader 组件就显得很有必要了。\n\n现在我们已经确定了设计稿中应该包含的组件，接下来我们将把它们描述为更加清晰的层级。设计稿中被其他组件包含的子组件，在层级上应该作为其子节点。\n\n * FilterableProductTable\n   * SearchBar\n   * ProductTable\n     * ProductCategoryRow\n     * ProductRow\n\n\n# 第二步：用 React 创建一个静态版本\n\n参阅 CodePen 上的 React 哲学：第二步。\n\n现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。最好将渲染 UI 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。我们会在接下来的代码中体会到其中的区别。\n\n在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 props 传入所需的数据。props 是父组件向子组件传递数据的方式。即使你已经熟悉了 state 的概念，也完全不应该使用 state 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。\n\n你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件（比如 FilterableProductTable），自下而上意味着从最基本的组件开始编写（比如 ProductRow）。当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。\n\n到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。由于我们构建的是静态版本，所以这些组件目前只需提供 render() 方法用于渲染。最顶层的组件 FilterableProductTable 通过 props 接受你的数据模型。如果你的数据模型发生了改变，再次调用 root.render()，UI 就会相应地被更新。数据模型变化、调用 render() 方法、UI 相应变化，这个过程并不复杂，因此很容易看清楚 UI 是如何被更新的，以及是在哪里被更新的。React 单向数据流（也叫单向绑定）的思想使得组件模块化，易于快速开发。\n\n如果你在完成这一步骤时遇到了困难，可以参阅 React 文档。\n\n\n# 补充说明: 有关 props 和 state\n\n在 React 中，有两类“模型”数据：props 和 state。清楚地理解两者的区别是十分重要的；如果你不太有把握，可以参阅 React 官方文档。你也可以查看 FAQ: state 与 props 的区别是什么？\n\n\n# 第三步：确定 UI state 的最小（且完整）表示\n\n想要使你的 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过实现 state 来完成这个任务。\n\n为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 DRY: Don’t Repeat Yourself。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。\n\n我们的示例应用拥有如下数据：\n\n * 包含所有产品的原始列表\n * 用户输入的搜索词\n * 复选框是否选中的值\n * 经过搜索筛选的产品列表\n\n通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：\n\n 1. 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。\n 2. 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。\n 3. 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。\n\n包含所有产品的原始列表是经由 props 传入的，所以它不是 state；搜索词和复选框的值应该是 state，因为它们随时间会发生改变且无法由其他数据计算而来；经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。\n\n综上所述，属于 state 的有：\n\n * 用户输入的搜索词\n * 复选框是否选中的值\n\n\n# 第四步：确定 state 放置的位置\n\n参阅 CodePen 上的 React 哲学：第四步。\n\n我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。\n\n注意：React 中的数据流是单向的，并顺着组件层级从上往下传递。哪个组件应该拥有某个 state 这件事，对初学者来说往往是最难理解的部分。尽管这可能在一开始不是那么清晰，但你可以尝试通过以下步骤来判断：\n\n对于应用中的每一个 state：\n\n * 找到根据这个 state 进行渲染的所有组件。\n * 找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。\n * 该共同所有者组件或者比它层级更高的组件应该拥有该 state。\n * 如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。\n\n根据以上策略重新考虑我们的示例应用：\n\n * ProductTable 需要根据 state 筛选产品列表。SearchBar 需要展示搜索词和复选框的状态。\n * 他们的共同所有者是 FilterableProductTable。\n * 因此，搜索词和复选框的值应该很自然地存放在 FilterableProductTable 组件中。\n\n很好，我们已经决定把这些 state 存放在 FilterableProductTable 组件中。首先，将实例属性 this.state = {filterText: \'\', inStockOnly: false} 添加到 FilterableProductTable 的 constructor 中，设置应用的初始 state；接着，将 filterText 和 inStockOnly 作为 props 传入 ProductTable 和 SearchBar；最后，用这些 props 筛选 ProductTable 中的产品信息，并设置 SearchBar 的表单值。\n\n你现在可以看到应用的变化了：将 filterText 设置为 "ball" 并刷新应用，你能发现表格中的数据已经更新了。\n\n\n# 第五步：添加反向数据流\n\n参阅 CodePen 上的 React 哲学：第五步。\n\n到目前为止，我们已经借助自上而下传递的 props 和 state 渲染了一个应用。现在，我们将尝试让数据反向传递：处于较低层级的表单组件更新较高层级的 FilterableProductTable 中的 state。\n\nReact 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。\n\n如果你尝试在上一个示例的搜索框中输入或勾选复选框（步骤 4），React 不会产生任何响应。这是正常的，因为我们之前已经将 input 的值设置为了从 FilterableProductTable 的 state 传递而来的固定值。\n\n让我们重新梳理一下需要实现的功能：每当用户改变表单的值，我们需要改变 state 来反映用户的当前输入。由于 state 只能由拥有它们的组件进行更改，FilterableProductTable 必须将一个能够触发 state 改变的回调函数（callback）传递给 SearchBar。我们可以使用输入框的 onChange 事件来监视用户输入的变化，并通知 FilterableProductTable 传递给 SearchBar 的回调函数。然后该回调函数将调用 setState()，从而更新应用。\n\n\n# 这就是全部了\n\n希望这篇文档能够帮助你建立起构建 React 组件和应用的一般概念。尽管你可能需要编写更多的代码，但是别忘了：比起写，代码更多地是给人看的。我们一起构建的这个模块化示例应用的代码就很易于阅读。当你开始构建更大的组件库时，你会意识到这种代码模块化和清晰度的重要性。并且随着代码重用程度的加深，你的代码行数也会显著地减少。😃\n\n\n#',normalizedContent:'# 核心概念\n\n\n# jsx简介\n\n设想如下变量声明：\n\nconst element = <h1>hello, world!</h1>;\n\n\n1\n\n\n这个有趣的标签语法既不是字符串也不是 html。\n\n它被称为 jsx，是一个 javascript 的语法扩展。我们建议在 react 中配合使用 jsx，jsx 可以很好地描述 ui 应该呈现出它应有交互的本质形式。jsx 可能会使人联想到模板语言，但它具有 javascript 的全部功能。\n\njsx 可以生成 react “元素”。我们将在下一章节中探讨如何将这些元素渲染为 dom。下面我们看下学习 jsx 所需的基础知识。\n\n\n# 为什么使用 jsx？\n\nreact 认为渲染逻辑本质上与其他 ui 逻辑内在耦合，比如，在 ui 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 ui，以及需要在 ui 中展示准备好的数据。\n\nreact 并没有采用将标记与逻辑分离到不同文件这种人为的分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。我们将在后面章节中深入学习组件。如果你还没有适应在 js 中使用标记语言，这个会议讨论应该可以说服你。\n\nreact 不强制要求使用 jsx，但是大多数人发现，在 javascript 代码中将 jsx 和 ui 放在一起时，会在视觉上有辅助作用。它还可以使 react 显示更多有用的错误和警告消息。\n\n搞清楚这个问题后，我们就开始学习 jsx 吧！\n\n\n# 在 jsx 中嵌入表达式\n\n在下面的例子中，我们声明了一个名为 name 的变量，然后在 jsx 中使用它，并将它包裹在大括号中：\n\nconst name = \'josh perez\';const element = <h1>hello, {name}</h1>;\n\n\n1\n\n\n在 jsx 语法中，你可以在大括号内放置任何有效的 javascript 表达式。例如，2 + 2，user.firstname 或 formatname(user) 都是有效的 javascript 表达式。\n\n在下面的示例中，我们将调用 javascript 函数 formatname(user) 的结果，并将结果嵌入到 <h1> 元素中。\n\nfunction formatname(user) {\n  return user.firstname + \' \' + user.lastname;\n}\n\nconst user = {\n  firstname: \'harper\',\n  lastname: \'perez\'\n};\n\nconst element = (\n  <h1>\n    hello, {formatname(user)}!  </h1>\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 codepen 上试试\n\n为了便于阅读，我们会将 jsx 拆分为多行。同时，我们建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到自动插入分号陷阱。\n\n\n# jsx 也是一个表达式\n\n在编译之后，jsx 表达式会被转为普通 javascript 函数调用，并且对其取值后得到 javascript 对象。\n\n也就是说，你可以在 if 语句和 for 循环的代码块中使用 jsx，将 jsx 赋值给变量，把 jsx 当作参数传入，以及从函数中返回 jsx：\n\nfunction getgreeting(user) {\n  if (user) {\n    return <h1>hello, {formatname(user)}!</h1>;  }\n  return <h1>hello, stranger.</h1>;}\n\n\n1\n2\n3\n4\n\n\n\n# jsx 中指定属性\n\n你可以通过使用引号，来将属性值指定为字符串字面量：\n\nconst element = <a href="https://www.reactjs.org"> link </a>;\n\n\n1\n\n\n也可以使用大括号，来在属性值中插入一个 javascript 表达式：\n\nconst element = <img src={user.avatarurl}></img>;\n\n\n1\n\n\n在属性中嵌入 javascript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。\n\n> 警告：\n> \n> 因为 jsx 语法上更接近 javascript 而不是 html，所以 react dom 使用 camelcase（小驼峰命名）来定义属性的名称，而不使用 html 属性名称的命名约定。\n> \n> 例如，jsx 里的 class 变成了 classname，而 tabindex 则变为 tabindex。\n\n\n# 使用 jsx 指定子元素\n\n假如一个标签里面没有内容，你可以使用 /> 来闭合标签，就像 xml 语法一样：\n\nconst element = <img src={user.avatarurl} />;\n\n\n1\n\n\njsx 标签里能够包含很多子元素:\n\nconst element = (\n  <div>\n    <h1>hello!</h1>\n    <h2>good to see you here.</h2>\n  </div>\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# jsx 防止注入攻击\n\n你可以安全地在 jsx 当中插入用户输入内容：\n\nconst title = response.potentiallymaliciousinput;\n// 直接使用是安全的：\nconst element = <h1>{title}</h1>;\n\n\n1\n2\n3\n\n\nreact dom 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 xss（cross-site-scripting, 跨站脚本）攻击。\n\n\n# jsx 表示对象\n\nbabel 会把 jsx 转译成一个名为 react.createelement() 函数调用。\n\n以下两种示例代码完全等效：\n\nconst element = (\n  <h1 classname="greeting">\n    hello, world!\n  </h1>\n);\nconst element = react.createelement(\n  \'h1\',\n  {classname: \'greeting\'},\n  \'hello, world!\'\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreact.createelement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：\n\n// 注意：这是简化过的结构\nconst element = {\n  type: \'h1\',\n  props: {\n    classname: \'greeting\',\n    children: \'hello, world!\'\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这些对象被称为 “react 元素”。它们描述了你希望在屏幕上看到的内容。react 通过读取这些对象，然后使用它们来构建 dom 以及保持随时更新。\n\n我们将在下一章节中探讨如何将 react 元素渲染为 dom。\n\n> 提示：\n> \n> 我们推荐在你使用的编辑器中，使用 “babel” 提供的语言定义，来正确地高亮显示 es6 和 jsx 代码。\n\n\n# 元素渲染\n\n元素是构成 react 应用的最小砖块。\n\n元素描述了你在屏幕上想看到的内容。\n\nconst element = <h1>hello, world</h1>;\n\n\n1\n\n\n与浏览器的 dom 元素不同，react 元素是创建开销极小的普通对象。react dom 会负责更新 dom 来与 react 元素保持一致。\n\n> 注意：\n> \n> 你可能会将元素与另一个被熟知的概念——“组件”混淆起来。我们会在下一个章节介绍组件。组件是由元素构成的。我们强烈建议你不要觉得繁琐而跳过本章节，应当深入阅读这一章节。\n\n\n# 将一个元素渲染为 dom\n\n假设你的 html 文件某处有一个 <div>：\n\n<div id="root"></div>\n\n\n1\n\n\n我们将其称为“根” dom 节点，因为该节点内的所有内容都将由 react dom 管理。\n\n仅使用 react 构建的应用通常只有单一的根 dom 节点。如果你在将 react 集成进一个已有应用，那么你可以在应用中包含任意多的独立根 dom 节点。\n\n想要将一个 react 元素渲染到根 dom 节点中，只需把它们一起传入 reactdom.createroot()：\n\nconst root = reactdom.createroot(\n  document.getelementbyid(\'root\')\n);\nconst element = <h1>hello, world</h1>;\nroot.render(element);\n\n\n1\n2\n3\n4\n5\n\n\n在 codepen 上试试\n\n页面上会展示出 “hello, world”。\n\n\n# 更新已渲染的元素\n\nreact 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 ui。\n\n根据我们已有的知识，更新 ui 唯一的方式是创建一个全新的元素，并将其传入 root.render()。\n\n考虑一个计时器的例子：\n\nconst root = reactdom.createroot(\n  document.getelementbyid(\'root\')\n);\n\nfunction tick() {\n  const element = (\n    <div>\n      <h1>hello, world!</h1>\n      <h2>it is {new date().tolocaletimestring()}.</h2>\n    </div>\n  );\n  root.render(element);}\n\nsetinterval(tick, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在 codepen 上试试\n\n这个例子会在 setinterval() 回调函数，每秒都调用 root.render()。\n\n> 注意：\n> \n> 在实践中，大多数 react 应用只会调用一次 root.render()。在下一个章节，我们将学习如何将这些代码封装到有状态组件中。\n> \n> 我们建议你不要跳跃着阅读，因为每个话题都是紧密联系的。\n\n\n# react 只更新它需要更新的部分\n\nreact dom 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 dom 达到预期的状态。\n\n你可以通过查看 上一个例子 来确认这一点。\n\n\n\n尽管每一秒我们都会新建一个描述整个 ui 树的元素，react dom 只会更新实际改变了的内容，也就是例子中的文本节点。\n\n根据我们的经验，应该专注于 ui 在任意给定时刻的状态，而不是一视同仁地随着时间修改整个界面。\n\n\n# 组件 & props\n\n组件允许你将 ui 拆分为独立可复用的代码片段，并对每个片段进行独立构思。本指南旨在介绍组件的相关理念。你可以参考详细组件 api。\n\n组件，从概念上类似于 javascript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 react 元素。\n\n\n# 函数组件与 class 组件\n\n定义组件最简单的方式就是编写 javascript 函数：\n\nfunction welcome(props) {\n  return <h1>hello, {props.name}</h1>;\n}\n\n\n1\n2\n3\n\n\n该函数是一个有效的 react 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 react 元素。这类组件被称为“函数组件”，因为它本质上就是 javascript 函数。\n\n你同时还可以使用 es6 的 class 来定义组件：\n\nclass welcome extends react.component {\n  render() {\n    return <h1>hello, {this.props.name}</h1>;\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n上述两个组件在 react 里是等效的。\n\n我们将在下一章节中讨论关于函数组件和 class 组件的额外特性。\n\n\n# 渲染组件\n\n之前，我们遇到的 react 元素都只是 dom 标签：\n\nconst element = <div />;\n\n\n1\n\n\n不过，react 元素也可以是用户自定义的组件：\n\nconst element = <welcome name="sara" />;\n\n\n1\n\n\n当 react 元素为用户自定义组件时，它会将 jsx 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。\n\n例如，这段代码会在页面上渲染 “hello, sara”：\n\nfunction welcome(props) {  return <h1>hello, {props.name}</h1>;\n}\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\'));\nconst element = <welcome name="sara" />;root.render(element);\n\n\n1\n2\n3\n4\n5\n\n\n在 codepen 上试试\n\n让我们来回顾一下这个例子中发生了什么：\n\n 1. 我们调用 root.render() 函数，并传入 <welcome name="sara" /> 作为参数。\n 2. react 调用 welcome 组件，并将 {name: \'sara\'} 作为 props 传入。\n 3. welcome 组件将 <h1>hello, sara</h1> 元素作为返回值。\n 4. react dom 将 dom 高效地更新为 <h1>hello, sara</h1>。\n\n> 注意： 组件名称必须以大写字母开头。\n> \n> react 会将以小写字母开头的组件视为原生 dom 标签。例如，<div /> 代表 html 的 div 标签，而 <welcome /> 则代表一个组件，并且需在作用域内使用 welcome。\n> \n> 你可以在深入 jsx 中了解更多关于此规范的原因。\n\n\n# 组合组件\n\n组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 react 应用程序中，这些通常都会以组件的形式表示。\n\n例如，我们可以创建一个可以多次渲染 welcome 组件的 app 组件：\n\nfunction welcome(props) {\n  return <h1>hello, {props.name}</h1>;\n}\n\nfunction app() {\n  return (\n    <div>\n      <welcome name="sara" />      <welcome name="cahal" />      <welcome name="edite" />    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 codepen 上试试\n\n通常来说，每个新的 react 应用程序的顶层组件都是 app 组件。但是，如果你将 react 集成到现有的应用程序中，你可能需要使用像 button 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。\n\n\n# 提取组件\n\n将组件拆分为更小的组件。\n\n例如，参考如下 comment 组件：\n\nfunction comment(props) {\n  return (\n    <div classname="comment">\n      <div classname="userinfo">\n        <img classname="avatar"\n          src={props.author.avatarurl}\n          alt={props.author.name}\n        />\n        <div classname="userinfo-name">\n          {props.author.name}\n        </div>\n      </div>\n      <div classname="comment-text">\n        {props.text}\n      </div>\n      <div classname="comment-date">\n        {formatdate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在 codepen 上试试\n\n该组件用于描述一个社交媒体网站上的评论功能，它接收 author（对象），text （字符串）以及 date（日期）作为 props。\n\n该组件由于嵌套的关系，变得难以维护，且很难复用它的各个部分。因此，让我们从中提取一些组件出来。\n\n首先，我们将提取 avatar 组件：\n\nfunction avatar(props) {\n  return (\n    <img classname="avatar"      src={props.user.avatarurl}      alt={props.user.name}    />  );\n}\n\n\n1\n2\n3\n4\n\n\navatar 不需知道它在 comment 组件内部是如何渲染的。因此，我们给它的 props 起了一个更通用的名字：user，而不是 author。\n\n我们建议从组件自身的角度命名 props，而不是依赖于调用组件的上下文命名。\n\n我们现在针对 comment 做些微小调整：\n\nfunction comment(props) {\n  return (\n    <div classname="comment">\n      <div classname="userinfo">\n        <avatar user={props.author} />        <div classname="userinfo-name">\n          {props.author.name}\n        </div>\n      </div>\n      <div classname="comment-text">\n        {props.text}\n      </div>\n      <div classname="comment-date">\n        {formatdate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n接下来，我们将提取 userinfo 组件，该组件在用户名旁渲染 avatar 组件：\n\nfunction userinfo(props) {\n  return (\n    <div classname="userinfo">      <avatar user={props.user} />      <div classname="userinfo-name">        {props.user.name}      </div>    </div>  );\n}\n\n\n1\n2\n3\n4\n\n\n进一步简化 comment 组件：\n\nfunction comment(props) {\n  return (\n    <div classname="comment">\n      <userinfo user={props.author} />      <div classname="comment-text">\n        {props.text}\n      </div>\n      <div classname="comment-date">\n        {formatdate(props.date)}\n      </div>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在 codepen 上试试\n\n最初看上去，提取组件可能是一件繁重的工作，但是，在大型应用中，构建可复用组件库是完全值得的。根据经验来看，如果 ui 中有一部分被多次使用（button，panel，avatar），或者组件本身就足够复杂（app，feedstory，comment），那么它就是一个可提取出独立组件的候选项。\n\n\n# props 的只读性\n\n组件无论是使用函数声明还是通过 class 声明，都绝不能修改自身的 props。来看下这个 sum 函数：\n\nfunction sum(a, b) {\n  return a + b;\n}\n\n\n1\n2\n3\n\n\n这样的函数被称为“纯函数”，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。\n\n相反，下面这个函数则不是纯函数，因为它更改了自己的入参：\n\nfunction withdraw(account, amount) {\n  account.total -= amount;\n}\n\n\n1\n2\n3\n\n\nreact 非常灵活，但它也有一个严格的规则：\n\n所有 react 组件都必须像纯函数一样保护它们的 props 不被更改。\n\n当然，应用程序的 ui 是动态的，并会伴随着时间的推移而变化。在下一章节中，我们将介绍一种新的概念，称之为 “state”。在不违反上述规则的情况下，state 允许 react 组件随用户操作、网络响应或者其他变化而动态更改输出内容。\n\n\n# state & 生命周期\n\nstate更新可能是异步的\n\n要解决这个问题，可以让 setstate() 接收一个函数而不是一个对象。这个函数用上一个state作为第一个参数，将此此更新被应用时的 props 作为第二个参数\n\n本页面介绍了 react 组件中 state 和生命周期的概念。你可以查阅详细的组件 api 参考文档。\n\n请参考前一章节中时钟的例子。在元素渲染章节中，我们只了解了一种更新 ui 界面的方法。通过调用 root.render() 来修改我们想要渲染的元素：\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\'));\n  \nfunction tick() {\n  const element = (\n    <div>\n      <h1>hello, world!</h1>\n      <h2>it is {new date().tolocaletimestring()}.</h2>\n    </div>\n  );\n  root.render(element);}\n\nsetinterval(tick, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在 codepen 上尝试\n\n在本章节中，我们将学习如何封装真正可复用的 clock 组件。它将设置自己的计时器并每秒更新一次。\n\n我们可以从封装时钟的外观开始：\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\'));\n\nfunction clock(props) {\n  return (\n    <div>      <h1>hello, world!</h1>      <h2>it is {props.date.tolocaletimestring()}.</h2>    </div>  );\n}\n\nfunction tick() {\n  root.render(<clock date={new date()} />);}\n\nsetinterval(tick, 1000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在 codepen 上尝试\n\n然而，它忽略了一个关键的技术细节：clock 组件需要设置一个计时器，并且需要每秒更新 ui。\n\n理想情况下，我们希望只编写一次代码，便可以让 clock 组件自我更新：\n\nroot.render(<clock />);\n\n\n1\n\n\n我们需要在 clock 组件中添加 “state” 来实现这个功能。\n\nstate 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。\n\n\n# 将函数组件转换成 class 组件\n\n通过以下五步将 clock 的函数组件转成 class 组件：\n\n 1. 创建一个同名的 es6 class，并且继承于 react.component。\n 2. 添加一个空的 render() 方法。\n 3. 将函数体移动到 render() 方法之中。\n 4. 在 render() 方法中使用 this.props 替换 props。\n 5. 删除剩余的空函数声明。\n\nclass clock extends react.component {\n  render() {\n    return (\n      <div>\n        <h1>hello, world!</h1>\n        <h2>it is {this.props.date.tolocaletimestring()}.</h2>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 codepen 上尝试\n\n现在 clock 组件被定义为 class，而不是函数。\n\n每次组件更新时 render 方法都会被调用，但只要在相同的 dom 节点中渲染 <clock /> ，就仅有一个 clock 组件的 class 实例被创建使用。这就使得我们可以使用如 state 或生命周期方法等很多其他特性。\n\n\n# 向 class 组件中添加局部的 state\n\n我们通过以下三步将 date 从 props 移动到 state 中：\n\n 1. 把 render() 方法中的 this.props.date 替换成 this.state.date ：\n\nclass clock extends react.component {\n  render() {\n    return (\n      <div>\n        <h1>hello, world!</h1>\n        <h2>it is {this.state.date.tolocaletimestring()}.</h2>      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 1. 添加一个 class 构造函数，然后在该函数中为 this.state 赋初值：\n\nclass clock extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new date()};  }\n\n  render() {\n    return (\n      <div>\n        <h1>hello, world!</h1>\n        <h2>it is {this.state.date.tolocaletimestring()}.</h2>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n通过以下方式将 props 传递到父类的构造函数中：\n\n  constructor(props) {\n    super(props);    this.state = {date: new date()};\n  }\n\n\n1\n2\n3\n\n\nclass 组件应该始终使用 props 参数来调用父类的构造函数。\n\n 1. 移除 <clock /> 元素中的 date 属性：\n\nroot.render(<clock />);\n\n\n1\n\n\n我们之后会将计时器相关的代码添加到组件中。\n\n代码如下：\n\nclass clock extends react.component {\n  constructor(props) {    super(props);    this.state = {date: new date()};  }\n  render() {\n    return (\n      <div>\n        <h1>hello, world!</h1>\n        <h2>it is {this.state.date.tolocaletimestring()}.</h2>      </div>\n    );\n  }\n}\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\'));\nroot.render(<clock />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 codepen 上尝试\n\n接下来，我们会设置 clock 的计时器并每秒更新它。\n\n\n# 将生命周期方法添加到 class 中\n\n在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的。\n\n当 clock 组件第一次被渲染到 dom 中的时候，就为其设置一个计时器。这在 react 中被称为“挂载（mount）”。\n\n同时，当 dom 中 clock 组件被删除的时候，应该清除计时器。这在 react 中被称为“卸载（unmount）”。\n\n我们可以为 class 组件声明一些特殊的方法，当组件挂载或卸载时就会去执行这些方法：\n\nclass clock extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new date()};\n  }\n\n  componentdidmount() {  }\n  componentwillunmount() {  }\n  render() {\n    return (\n      <div>\n        <h1>hello, world!</h1>\n        <h2>it is {this.state.date.tolocaletimestring()}.</h2>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这些方法叫做“生命周期方法”。\n\ncomponentdidmount() 方法会在组件已经被渲染到 dom 中后运行，所以，最好在这里设置计时器：\n\n  componentdidmount() {\n    this.timerid = setinterval(      () => this.tick(),      1000    );  }\n\n\n1\n2\n\n\n接下来把计时器的 id 保存在 this 之中（this.timerid）。\n\n尽管 this.props 和 this.state 是 react 本身设置的，且都拥有特殊的含义，但是其实你可以向 class 中随意添加不参与数据流（比如计时器 id）的额外字段。\n\n我们会在 componentwillunmount() 生命周期方法中清除计时器：\n\n  componentwillunmount() {\n    clearinterval(this.timerid);  }\n\n\n1\n2\n\n\n最后，我们会实现一个叫 tick() 的方法，clock 组件每秒都会调用它。\n\n使用 this.setstate() 来时刻更新组件 state：\n\nclass clock extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new date()};\n  }\n\n  componentdidmount() {\n    this.timerid = setinterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n  componentwillunmount() {\n    clearinterval(this.timerid);\n  }\n\n  tick() {    this.setstate({      date: new date()    });  }\n  render() {\n    return (\n      <div>\n        <h1>hello, world!</h1>\n        <h2>it is {this.state.date.tolocaletimestring()}.</h2>\n      </div>\n    );\n  }\n}\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\'));\nroot.render(<clock />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n在 codepen 上尝试\n\n现在时钟每秒都会刷新。\n\n让我们来快速概括一下发生了什么和这些方法的调用顺序：\n\n 1. 当 <clock /> 被传给 root.render()的时候，react 会调用 clock 组件的构造函数。因为 clock 需要显示当前的时间，所以它会用一个包含当前时间的对象来初始化 this.state。我们会在之后更新 state。\n 2. 之后 react 会调用组件的 render() 方法。这就是 react 确定该在页面上展示什么的方式。然后 react 更新 dom 来匹配 clock 渲染的输出。\n 3. 当 clock 的输出被插入到 dom 中后，react 就会调用 componentdidmount() 生命周期方法。在这个方法中，clock 组件向浏览器请求设置一个计时器来每秒调用一次组件的 tick() 方法。\n 4. 浏览器每秒都会调用一次 tick() 方法。 在这方法之中，clock 组件会通过调用 setstate() 来计划进行一次 ui 更新。得益于 setstate() 的调用，react 能够知道 state 已经改变了，然后会重新调用 render() 方法来确定页面上该显示什么。这一次，render() 方法中的 this.state.date 就不一样了，如此一来就会渲染输出更新过的时间。react 也会相应的更新 dom。\n 5. 一旦 clock 组件从 dom 中被移除，react 就会调用 componentwillunmount() 生命周期方法，这样计时器就停止了。\n\n\n# 正确地使用 state\n\n关于 setstate() 你应该了解三件事：\n\n\n# 不要直接修改 state\n\n例如，此代码不会重新渲染组件：\n\n// wrong\nthis.state.comment = \'hello\';\n\n\n1\n2\n\n\n而是应该使用 setstate():\n\n// correct\nthis.setstate({comment: \'hello\'});\n\n\n1\n2\n\n\n构造函数是唯一可以给 this.state 赋值的地方。\n\n\n# state 的更新可能是异步的\n\n出于性能考虑，react 可能会把多个 setstate() 调用合并成一个调用。\n\n因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。\n\n例如，此代码可能会无法更新计数器：\n\n// wrong\nthis.setstate({\n  counter: this.state.counter + this.props.increment,\n});\n\n\n1\n2\n3\n4\n\n\n要解决这个问题，可以让 setstate() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：\n\n// correct\nthis.setstate((state, props) => ({\n  counter: state.counter + props.increment\n}));\n\n\n1\n2\n3\n4\n\n\n上面使用了箭头函数，不过使用普通的函数也同样可以：\n\n// correct\nthis.setstate(function(state, props) {\n  return {\n    counter: state.counter + props.increment\n  };\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# state 的更新会被合并\n\n当你调用 setstate() 的时候，react 会把你提供的对象合并到当前的 state。\n\n例如，你的 state 包含几个独立的变量：\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      posts: [],      comments: []    };\n  }\n\n\n1\n2\n3\n4\n5\n\n\n然后你可以分别调用 setstate() 来单独地更新它们：\n\n  componentdidmount() {\n    fetchposts().then(response => {\n      this.setstate({\n        posts: response.posts      });\n    });\n\n    fetchcomments().then(response => {\n      this.setstate({\n        comments: response.comments      });\n    });\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里的合并是浅合并，所以 this.setstate({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。\n\n\n# 数据是向下流动的\n\n不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。\n\n这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。\n\n组件可以选择把它的 state 作为 props 向下传递到它的子组件中：\n\n<formatteddate date={this.state.date} />\n\n\n1\n\n\nformatteddate 组件会在其 props 中接收参数 date，但是组件本身无法知道它是来自于 clock 的 state，或是 clock 的 props，还是手动输入的：\n\nfunction formatteddate(props) {\n  return <h2>it is {props.date.tolocaletimestring()}.</h2>;\n}\n\n\n1\n2\n3\n\n\n在 codepen 上尝试\n\n这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 ui 只能影响树中“低于”它们的组件。\n\n如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。\n\n为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 clock 的 app 组件：\n\nfunction app() {\n  return (\n    <div>\n      <clock />      <clock />      <clock />    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 codepen 上尝试\n\n每个 clock 组件都会单独设置它自己的计时器并且更新它。\n\n在 react 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。\n\n\n# 事件处理\n\nreact 元素的事件处理和 dom 元素的很相似，但是有一点语法上的不同：\n\n * react 事件的命名采用小驼峰式（camelcase），而不是纯小写。\n * 使用 jsx 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。\n\n例如，传统的 html：\n\n<button onclick="activatelasers()">\n  activate lasers\n</button>\n\n\n1\n2\n3\n\n\n在 react 中略微不同：\n\n<button onclick={activatelasers}>  activate lasers\n</button>\n\n\n1\n2\n\n\n在 react 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式地使用 preventdefault。例如，传统的 html 中阻止表单的默认提交行为，你可以这样写：\n\n<form onsubmit="console.log(\'you clicked submit.\'); return false">\n  <button type="submit">submit</button>\n</form>\n\n\n1\n2\n3\n\n\n在 react 中，可能是这样的：\n\nfunction form() {\n  function handlesubmit(e) {\n    e.preventdefault();    console.log(\'you clicked submit.\');\n  }\n\n  return (\n    <form onsubmit={handlesubmit}>\n      <button type="submit">submit</button>\n    </form>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在这里，e 是一个合成事件。react 根据 w3c 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。react 事件与原生事件不完全相同。如果想了解更多，请查看 syntheticevent 参考指南。\n\n使用 react 时，你一般不需要使用 addeventlistener 为已创建的 dom 元素添加监听器。事实上，你只需要在该元素初始渲染的时候添加监听器即可。\n\n当你使用 es6 class 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 toggle 组件会渲染一个让用户切换开关状态的按钮：\n\nclass toggle extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {istoggleon: true};\n\n    // 为了在回调中使用 `this`，这个绑定是必不可少的    this.handleclick = this.handleclick.bind(this);  }\n\n  handleclick() {    this.setstate(prevstate => ({      istoggleon: !prevstate.istoggleon    }));  }\n  render() {\n    return (\n      <button onclick={this.handleclick}>        {this.state.istoggleon ? \'on\' : \'off\'}\n      </button>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在 codepen 上尝试\n\n你必须谨慎对待 jsx 回调函数中的 this，在 javascript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleclick 并把它传入了 onclick，当你调用这个函数的时候 this 的值为 undefined。\n\n这并不是 react 特有的行为；这其实与 javascript 函数工作原理有关。通常情况下，如果你没有在方法后面添加 ()，例如 onclick={this.handleclick}，你应该为这个方法绑定 this。\n\n如果觉得使用 bind 很麻烦，这里有两种方式可以解决。你可以使用 public class fields 语法 to correctly bind callbacks:\n\nclass loggingbutton extends react.component {\n  // this syntax ensures `this` is bound within handleclick.  handleclick = () => {    console.log(\'this is:\', this);  };  render() {\n    return (\n      <button onclick={this.handleclick}>\n        click me\n      </button>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ncreate react app 默认启用此语法。\n\n如果你没有使用 class fields 语法，你可以在回调中使用箭头函数：\n\nclass loggingbutton extends react.component {\n  handleclick() {\n    console.log(\'this is:\', this);\n  }\n\n  render() {\n    // 此语法确保 `handleclick` 内的 `this` 已被绑定。    return (      <button onclick={() => this.handleclick()}>        click me\n      </button>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n此语法问题在于每次渲染 loggingbutton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。\n\n\n# 向事件处理程序传递参数\n\n在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 id，以下两种方式都可以向事件处理函数传递参数：\n\n<button onclick={(e) => this.deleterow(id, e)}>delete row</button>\n<button onclick={this.deleterow.bind(this, id)}>delete row</button>\n\n\n1\n2\n\n\n上述两种方式是等价的，分别通过箭头函数和 function.prototype.bind 来实现。\n\n在这两种情况下，react 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。\n\n\n# 条件渲染\n\n在 react 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。\n\nreact 中的条件渲染和 javascript 中的一样，使用 javascript 运算符 if 或者条件运算符去创建元素来表现当前的状态，然后让 react 根据它们来更新 ui。\n\n观察这两个组件:\n\nfunction usergreeting(props) {\n  return <h1>welcome back!</h1>;\n}\n\nfunction guestgreeting(props) {\n  return <h1>please sign up.</h1>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n再创建一个 greeting 组件，它会根据用户是否登录来决定显示上面的哪一个组件。\n\nfunction greeting(props) {\n  const isloggedin = props.isloggedin;\n  if (isloggedin) {    return <usergreeting />;  }  return <guestgreeting />;}\nconst root = reactdom.createroot(document.getelementbyid(\'root\')); \n// try changing to isloggedin={true}:\nroot.render(<greeting isloggedin={false} />);\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 codepen 上尝试\n\n这个示例根据 isloggedin 的值来渲染不同的问候语。\n\n\n# 元素变量\n\n你可以使用变量来储存元素。 它可以帮助你有条件地渲染组件的一部分，而其他的渲染部分并不会因此而改变。\n\n观察这两个组件，它们分别代表了注销和登录按钮：\n\nfunction loginbutton(props) {\n  return (\n    <button onclick={props.onclick}>\n      login\n    </button>\n  );\n}\n\nfunction logoutbutton(props) {\n  return (\n    <button onclick={props.onclick}>\n      logout\n    </button>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在下面的示例中，我们将创建一个名叫 logincontrol 的有状态的组件。\n\n它将根据当前的状态来渲染 <loginbutton /> 或者 <logoutbutton />。同时它还会渲染上一个示例中的 <greeting />。\n\nclass logincontrol extends react.component {\n  constructor(props) {\n    super(props);\n    this.handleloginclick = this.handleloginclick.bind(this);\n    this.handlelogoutclick = this.handlelogoutclick.bind(this);\n    this.state = {isloggedin: false};\n  }\n\n  handleloginclick() {\n    this.setstate({isloggedin: true});\n  }\n\n  handlelogoutclick() {\n    this.setstate({isloggedin: false});\n  }\n\n  render() {\n    const isloggedin = this.state.isloggedin;\n    let button;\n    if (isloggedin) {      button = <logoutbutton onclick={this.handlelogoutclick} />;    } else {      button = <loginbutton onclick={this.handleloginclick} />;    }\n    return (\n      <div>\n        <greeting isloggedin={isloggedin} />        {button}      </div>\n    );\n  }\n}\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\')); \nroot.render(<logincontrol />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在 codepen 上尝试\n\n声明一个变量并使用 if 语句进行条件渲染是不错的方式，但有时你可能会想使用更为简洁的语法。接下来，我们将介绍几种在 jsx 中内联条件渲染的方法。\n\n\n# 与运算符 &&\n\n通过花括号包裹代码，你可以在 jsx 中嵌入表达式。这也包括 javascript 中的逻辑与 (&&) 运算符。它可以很方便地进行元素的条件渲染：\n\nfunction mailbox(props) {\n  const unreadmessages = props.unreadmessages;\n  return (\n    <div>\n      <h1>hello!</h1>\n      {unreadmessages.length > 0 &&        <h2>          you have {unreadmessages.length} unread messages.        </h2>      }    </div>\n  );\n}\n\nconst messages = [\'react\', \'re: react\', \'re:re: react\'];\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\')); \nroot.render(<mailbox unreadmessages={messages} />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 codepen 上尝试\n\n之所以能这样做，是因为在 javascript 中，true && expression 总是会返回 expression, 而 false && expression 总是会返回 false。\n\n因此，如果条件是 true，&& 右侧的元素就会被渲染，如果是 false，react 会忽略并跳过它。\n\n请注意，falsy 表达式 会使 && 后面的元素被跳过，但会返回 falsy 表达式的值。在下面示例中，render 方法的返回值是 <div>0</div>。\n\nrender() {\n  const count = 0;  return (\n    <div>\n      {count && <h1>messages: {count}</h1>}    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 三目运算符\n\n另一种内联条件渲染的方法是使用 javascript 中的三目运算符 condition ? true : false。\n\n在下面这个示例中，我们用它来条件渲染一小段文本\n\nrender() {\n  const isloggedin = this.state.isloggedin;\n  return (\n    <div>\n      the user is <b>{isloggedin ? \'currently\' : \'not\'}</b> logged in.    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同样的，它也可以用于较为复杂的表达式中，虽然看起来不是很直观：\n\nrender() {\n  const isloggedin = this.state.isloggedin;\n  return (\n    <div>\n      {isloggedin        ? <logoutbutton onclick={this.handlelogoutclick} />\n        : <loginbutton onclick={this.handleloginclick} />      }\n    </div>  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n就像在 javascript 中一样，你可以根据团队的习惯来选择可读性更高的代码风格。需要注意的是，如果条件变得过于复杂，那你应该考虑如何提取组件。\n\n\n# 阻止组件渲染\n\n在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。\n\n下面的示例中，<warningbanner /> 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染:\n\nfunction warningbanner(props) {\n  if (!props.warn) {    return null;  }\n  return (\n    <div classname="warning">\n      warning!\n    </div>\n  );\n}\n\nclass page extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {showwarning: true};\n    this.handletoggleclick = this.handletoggleclick.bind(this);\n  }\n\n  handletoggleclick() {\n    this.setstate(state => ({\n      showwarning: !state.showwarning\n    }));\n  }\n\n  render() {\n    return (\n      <div>\n        <warningbanner warn={this.state.showwarning} />        <button onclick={this.handletoggleclick}>\n          {this.state.showwarning ? \'hide\' : \'show\'}\n        </button>\n      </div>\n    );\n  }\n}\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\')); \nroot.render(<page />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n在 codepen 上尝试\n\n在组件的 render 方法中返回 null 并不会影响组件的生命周期。例如，上面这个示例中，componentdidupdate 依然会被调用。\n\n\n# 列表 & key\n\n首先，让我们看下在 javascript 中如何转化列表。\n\n如下代码，我们使用 map() 函数让数组中的每一项变双倍，然后我们得到了一个新的列表 doubled 并打印出来：\n\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map((number) => number * 2);console.log(doubled);\n\n\n1\n2\n\n\n代码打印出 [2, 4, 6, 8, 10]。\n\n在 react 中，把数组转化为元素列表的过程是相似的。\n\n\n# 渲染多个组件\n\n你可以通过使用 {} 在 jsx 内构建一个元素集合。\n\n下面，我们使用 javascript 中的 map() 方法来遍历 numbers 数组。将数组中的每个元素变成 <li> 标签，最后我们将得到的数组赋值给 listitems：\n\nconst numbers = [1, 2, 3, 4, 5];\nconst listitems = numbers.map((number) =>  <li>{number}</li>);\n\n\n1\n2\n\n\n然后，我们可以将整个 listitems 插入到 <ul> 元素中：\n\n<ul>{listitems}</ul>\n\n\n1\n\n\n在 codepen 上尝试\n\n这段代码生成了一个 1 到 5 的项目符号列表。\n\n\n# 基础列表组件\n\n通常你需要在一个组件中渲染列表。\n\n我们可以把前面的例子重构成一个组件，这个组件接收 numbers 数组作为参数并输出一个元素列表。\n\nfunction numberlist(props) {\n  const numbers = props.numbers;\n  const listitems = numbers.map((number) =>    <li>{number}</li>  );  return (\n    <ul>{listitems}</ul>  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nconst root = reactdom.createroot(document.getelementbyid(\'root\'));\nroot.render(<numberlist numbers={numbers} />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当我们运行这段代码，将会看到一个警告 a key should be provided for list items，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。我们将在下一节讨论这是为什么。\n\n让我们来给每个列表元素分配一个 key 属性来解决上面的那个警告：\n\nfunction numberlist(props) {\n  const numbers = props.numbers;\n  const listitems = numbers.map((number) =>\n    <li key={number.tostring()}>      {number}\n    </li>\n  );\n  return (\n    <ul>{listitems}</ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 codepen 上尝试\n\n\n# key\n\nkey 帮助 react 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。\n\nconst numbers = [1, 2, 3, 4, 5];\nconst listitems = numbers.map((number) =>\n  <li key={number.tostring()}>    {number}\n  </li>\n);\n\n\n1\n2\n3\n4\n5\n\n\n一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key：\n\nconst todoitems = todos.map((todo) =>\n  <li key={todo.id}>    {todo.text}\n  </li>\n);\n\n\n1\n2\n3\n4\n\n\n当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：\n\nconst todoitems = todos.map((todo, index) =>\n  // only do this if items have no stable ids  <li key={index}>    {todo.text}\n  </li>\n);\n\n\n1\n2\n3\n4\n\n\n如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。可以看看 robin pokorny 的深度解析使用索引作为 key 的负面影响这一篇文章。如果你选择不指定显式的 key 值，那么 react 将默认使用索引用作为列表项目的 key 值。\n\n要是你有兴趣了解更多的话，这里有一篇文章深入解析为什么 key 是必须的可以参考。\n\n\n# 用 key 提取组件\n\n元素的 key 只有放在就近的数组上下文中才有意义。\n\n比方说，如果你提取出一个 listitem 组件，你应该把 key 保留在数组中的这个 <listitem /> 元素上，而不是放在 listitem 组件中的 <li> 元素上。\n\n例子：不正确的使用 key 的方式\n\nfunction listitem(props) {\n  const value = props.value;\n  return (\n    // 错误！你不需要在这里指定 key：    <li key={value.tostring()}>      {value}\n    </li>\n  );\n}\n\nfunction numberlist(props) {\n  const numbers = props.numbers;\n  const listitems = numbers.map((number) =>\n    // 错误！元素的 key 应该在这里指定：    <listitem value={number} />  );\n  return (\n    <ul>\n      {listitems}\n    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n例子：正确的使用 key 的方式\n\nfunction listitem(props) {\n  // 正确！这里不需要指定 key：  return <li>{props.value}</li>;}\n\nfunction numberlist(props) {\n  const numbers = props.numbers;\n  const listitems = numbers.map((number) =>\n    // 正确！key 应该在数组的上下文中被指定    <listitem key={number.tostring()} value={number} />  );\n  return (\n    <ul>\n      {listitems}\n    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 codepen 上尝试\n\n一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性。\n\n\n# key 值在兄弟节点之间必须唯一\n\n数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：\n\nfunction blog(props) {\n  const sidebar = (    <ul>\n      {props.posts.map((post) =>\n        <li key={post.id}>          {post.title}\n        </li>\n      )}\n    </ul>\n  );\n  const content = props.posts.map((post) =>    <div key={post.id}>      <h3>{post.title}</h3>\n      <p>{post.content}</p>\n    </div>\n  );\n  return (\n    <div>\n      {sidebar}      <hr />\n      {content}    </div>\n  );\n}\n\nconst posts = [\n  {id: 1, title: \'hello world\', content: \'welcome to learning react!\'},\n  {id: 2, title: \'installation\', content: \'you can install react from npm.\'}\n];\n\nconst root = reactdom.createroot(document.getelementbyid(\'root\'));\nroot.render(<blog posts={posts} />);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在 codepen 上尝试\n\nkey 会传递信息给 react ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：\n\nconst content = posts.map((post) =>\n  <post\n    key={post.id}    id={post.id}    title={post.title} />\n);\n\n\n1\n2\n3\n4\n\n\n上面例子中，post 组件可以读出 props.id，但是不能读出 props.key。\n\n\n# 在 jsx 中嵌入 map()\n\n在上面的例子中，我们声明了一个单独的 listitems 变量并将其包含在 jsx 中：\n\nfunction numberlist(props) {\n  const numbers = props.numbers;\n  const listitems = numbers.map((number) =>    <listitem key={number.tostring()}              value={number} />  );  return (\n    <ul>\n      {listitems}\n    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\njsx 允许在大括号中嵌入任何表达式，所以我们可以内联 map() 返回的结果：\n\nfunction numberlist(props) {\n  const numbers = props.numbers;\n  return (\n    <ul>\n      {numbers.map((number) =>        <listitem key={number.tostring()}                  value={number} />      )}    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在 codepen 上尝试\n\n这么做有时可以使你的代码更清晰，但有时这种风格也会被滥用。就像在 javascript 中一样，何时需要为了可读性提取出一个变量，这完全取决于你。但请记住，如果一个 map() 嵌套了太多层级，那可能就是你提取组件的一个好时机。\n\n\n# 表单\n\n在 react 里，html 表单元素的工作方式和其他的 dom 元素有些不同，这是因为表单元素通常会保持一些内部的 state。例如这个纯 html 表单只接受一个名称：\n\n<form>\n  <label>\n    名字:\n    <input type="text" name="name" />\n  </label>\n  <input type="submit" value="提交" />\n</form>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n此表单具有默认的 html 表单行为，即在用户提交表单后浏览到新页面。如果你在 react 中执行相同的代码，它依然有效。但大多数情况下，使用 javascript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。\n\n\n# 受控组件\n\n在 html 中，表单元素（如<input>、 <textarea> 和 <select>）通常自己维护 state，并根据用户输入进行更新。而在 react 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setstate()来更新。\n\n我们可以把两者结合起来，使 react 的 state 成为“唯一数据源”。渲染表单的 react 组件还控制着用户输入过程中表单发生的操作。被 react 以这种方式控制取值的表单输入元素就叫做“受控组件”。\n\n例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：\n\nclass nameform extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {value: \'\'};\n    this.handlechange = this.handlechange.bind(this);\n    this.handlesubmit = this.handlesubmit.bind(this);\n  }\n\n  handlechange(event) {    this.setstate({value: event.target.value});  }\n  handlesubmit(event) {\n    alert(\'提交的名字: \' + this.state.value);\n    event.preventdefault();\n  }\n\n  render() {\n    return (\n      <form onsubmit={this.handlesubmit}>        <label>\n          名字:\n          <input type="text" value={this.state.value} onchange={this.handlechange} />        </label>\n        <input type="submit" value="提交" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n在 codepen 上尝试\n\n由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 react 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 react 的 state，因此显示的值将随着用户输入而更新。\n\n对于受控组件来说，输入的值始终由 react 的 state 驱动。你也可以将 value 传递给其他 ui 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。\n\n\n# textarea 标签\n\n在 html 中, <textarea> 元素通过其子元素定义其文本:\n\n<textarea>\n  你好， 这是在 text area 里的文本\n</textarea>\n\n\n1\n2\n3\n\n\n而在 react 中，<textarea> 使用 value 属性代替。这样，可以使得使用 <textarea> 的表单和使用单行 input 的表单非常类似：\n\nclass essayform extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {      value: \'请撰写一篇关于你喜欢的 dom 元素的文章.\'    };\n    this.handlechange = this.handlechange.bind(this);\n    this.handlesubmit = this.handlesubmit.bind(this);\n  }\n\n  handlechange(event) {    this.setstate({value: event.target.value});  }\n  handlesubmit(event) {\n    alert(\'提交的文章: \' + this.state.value);\n    event.preventdefault();\n  }\n\n  render() {\n    return (\n      <form onsubmit={this.handlesubmit}>\n        <label>\n          文章:\n          <textarea value={this.state.value} onchange={this.handlechange} />        </label>\n        <input type="submit" value="提交" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n请注意，this.state.value 初始化于构造函数中，因此文本区域默认有初值。\n\n\n# select 标签\n\n在 html 中，<select> 创建下拉列表标签。例如，如下 html 创建了水果相关的下拉列表：\n\n<select>\n  <option value="grapefruit">葡萄柚</option>\n  <option value="lime">酸橙</option>\n  <option selected value="coconut">椰子</option>\n  <option value="mango">芒果</option>\n</select>\n\n\n1\n2\n3\n4\n5\n6\n\n\n请注意，由于 selected 属性的缘故，椰子选项默认被选中。react 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：\n\nclass flavorform extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {value: \'coconut\'};\n    this.handlechange = this.handlechange.bind(this);\n    this.handlesubmit = this.handlesubmit.bind(this);\n  }\n\n  handlechange(event) {    this.setstate({value: event.target.value});  }\n  handlesubmit(event) {\n    alert(\'你喜欢的风味是: \' + this.state.value);\n    event.preventdefault();\n  }\n\n  render() {\n    return (\n      <form onsubmit={this.handlesubmit}>\n        <label>\n          选择你喜欢的风味:\n          <select value={this.state.value} onchange={this.handlechange}>            <option value="grapefruit">葡萄柚</option>\n            <option value="lime">酸橙</option>\n            <option value="coconut">椰子</option>\n            <option value="mango">芒果</option>\n          </select>\n        </label>\n        <input type="submit" value="提交" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n在 codepen 上尝试\n\n总的来说，这使得 <input type="text">, <textarea> 和 <select> 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。\n\n> 注意\n> \n> 你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项：\n> \n> <select multiple={true} value={[\'b\', \'c\']}>\n> \n> \n> 1\n\n\n# 文件 input 标签\n\n在 html 中，<input type="file"> 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 javascript 的 file api 进行控制。\n\n<input type="file" />\n\n\n1\n\n\n因为它的 value 只读，所以它是 react 中的一个非受控组件。将与其他非受控组件在后续文档中一起讨论。\n\n\n# 处理多个输入\n\n当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。\n\n例如：\n\nclass reservation extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isgoing: true,\n      numberofguests: 2\n    };\n\n    this.handleinputchange = this.handleinputchange.bind(this);\n  }\n\n  handleinputchange(event) {\n    const target = event.target;\n    const value = target.type === \'checkbox\' ? target.checked : target.value;\n    const name = target.name;\n    this.setstate({\n      [name]: value    });\n  }\n\n  render() {\n    return (\n      <form>\n        <label>\n          参与:\n          <input\n            name="isgoing"            type="checkbox"\n            checked={this.state.isgoing}\n            onchange={this.handleinputchange} />\n        </label>\n        <br />\n        <label>\n          来宾人数:\n          <input\n            name="numberofguests"            type="number"\n            value={this.state.numberofguests}\n            onchange={this.handleinputchange} />\n        </label>\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n在 codepen 上尝试\n\n这里使用了 es6 计算属性名称的语法更新给定输入名称对应的 state 值：\n\n例如：\n\nthis.setstate({\n  [name]: value});\n\n\n1\n2\n\n\n等同 es5:\n\nvar partialstate = {};\npartialstate[name] = value;this.setstate(partialstate);\n\n\n1\n2\n\n\n另外，由于 setstate() 自动将部分 state 合并到当前 state, 只需调用它更改部分 state 即可。\n\n\n# 受控输入空值\n\n在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。\n\n下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）\n\nreactdom.createroot(mountnode).render(<input value="hi" />);\n\nsettimeout(function() {\n  reactdom.createroot(mountnode).render(<input value={null} />);\n}, 1000);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 受控组件的替代品\n\n有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 react 组件传递所有的输入 state。当你将之前的代码库转换为 react 或将 react 应用程序与非 react 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件, 这是实现输入表单的另一种方式。\n\n\n# 成熟的解决方案\n\n如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 formik 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。\n\n\n# 状态提升\n\n通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。让我们看看它是如何运作的。\n\n在本节中，我们将创建一个用于计算水在给定温度下是否会沸腾的温度计算器。\n\n我们将从一个名为 boilingverdict 的组件开始，它接受 celsius 温度作为一个 prop，并据此打印出该温度是否足以将水煮沸的结果。\n\nfunction boilingverdict(props) {\n  if (props.celsius >= 100) {\n    return <p>the water would boil.</p>;  }\n  return <p>the water would not boil.</p>;}\n\n\n1\n2\n3\n4\n\n\n接下来, 我们创建一个名为 calculator 的组件。它渲染一个用于输入温度的 <input>，并将其值保存在 this.state.temperature 中。\n\n另外, 它根据当前输入值渲染 boilingverdict 组件。\n\nclass calculator extends react.component {\n  constructor(props) {\n    super(props);\n    this.handlechange = this.handlechange.bind(this);\n    this.state = {temperature: \'\'};  }\n\n  handlechange(e) {\n    this.setstate({temperature: e.target.value});  }\n\n  render() {\n    const temperature = this.state.temperature;    return (\n      <fieldset>\n        <legend>enter temperature in celsius:</legend>\n        <input          value={temperature}          onchange={this.handlechange} />        <boilingverdict          celsius={parsefloat(temperature)} />      </fieldset>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在 codepen 上尝试\n\n\n# 添加第二个输入框\n\n我们的新需求是，在已有摄氏温度输入框的基础上，我们提供华氏度的输入框，并保持两个输入框的数据同步。\n\n我们先从 calculator 组件中抽离出 temperatureinput 组件，然后为其添加一个新的 scale prop，它可以是 "c" 或是 "f"：\n\nconst scalenames = {  c: \'celsius\',  f: \'fahrenheit\'};\nclass temperatureinput extends react.component {\n  constructor(props) {\n    super(props);\n    this.handlechange = this.handlechange.bind(this);\n    this.state = {temperature: \'\'};\n  }\n\n  handlechange(e) {\n    this.setstate({temperature: e.target.value});\n  }\n\n  render() {\n    const temperature = this.state.temperature;\n    const scale = this.props.scale;    return (\n      <fieldset>\n        <legend>enter temperature in {scalenames[scale]}:</legend>        <input value={temperature}\n               onchange={this.handlechange} />\n      </fieldset>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n我们现在可以修改 calculator 组件让它渲染两个独立的温度输入框组件：\n\nclass calculator extends react.component {\n  render() {\n    return (\n      <div>\n        <temperatureinput scale="c" />        <temperatureinput scale="f" />      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在 codepen 上尝试\n\n我们现在有了两个输入框，但当你在其中一个输入温度时，另一个并不会更新。这与我们的要求相矛盾：我们希望让它们保持同步。\n\n另外，我们也不能通过 calculator 组件展示 boilingverdict 组件的渲染结果。因为 calculator 组件并不知道隐藏在 temperatureinput 组件中的当前温度是多少。\n\n\n# 编写转换函数\n\n首先，我们将编写两个可以在摄氏度与华氏度之间相互转换的函数：\n\nfunction tocelsius(fahrenheit) {\n  return (fahrenheit - 32) * 5 / 9;\n}\n\nfunction tofahrenheit(celsius) {\n  return (celsius * 9 / 5) + 32;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上述两个函数仅做数值转换。而我们将编写另一个函数，它接受字符串类型的 temperature 和转换函数作为参数并返回一个字符串。我们将使用它来依据一个输入框的值计算出另一个输入框的值。\n\n当输入 temperature 的值无效时，函数返回空字符串，反之，则返回保留三位小数并四舍五入后的转换结果：\n\nfunction tryconvert(temperature, convert) {\n  const input = parsefloat(temperature);\n  if (number.isnan(input)) {\n    return \'\';\n  }\n  const output = convert(input);\n  const rounded = math.round(output * 1000) / 1000;\n  return rounded.tostring();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n例如，tryconvert(\'abc\', tocelsius) 返回一个空字符串，而 tryconvert(\'10.22\', tofahrenheit) 返回 \'50.396\'。\n\n\n# 状态提升\n\n到目前为止, 两个 temperatureinput 组件均在各自内部的 state 中相互独立地保存着各自的数据。\n\nclass temperatureinput extends react.component {\n  constructor(props) {\n    super(props);\n    this.handlechange = this.handlechange.bind(this);\n    this.state = {temperature: \'\'};  }\n\n  handlechange(e) {\n    this.setstate({temperature: e.target.value});  }\n\n  render() {\n    const temperature = this.state.temperature;    // ...  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然而，我们希望两个输入框内的数值彼此能够同步。当我们更新摄氏度输入框内的数值时，华氏度输入框内应当显示转换后的华氏温度，反之亦然。\n\n在 react 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”。接下来，我们将 temperatureinput 组件中的 state 移动至 calculator 组件中去。\n\n如果 calculator 组件拥有了共享的 state，它将成为两个温度输入框中当前温度的“数据源”。它能够使得两个温度输入框的数值彼此保持一致。由于两个 temperatureinput 组件的 props 均来自共同的父组件 calculator，因此两个输入框中的内容将始终保持一致。\n\n让我们看看这是如何一步一步实现的。\n\n首先，我们将 temperatureinput 组件中的 this.state.temperature 替换为 this.props.temperature。现在，我们先假定 this.props.temperature 已经存在，尽管将来我们需要通过 calculator 组件将其传入：\n\n  render() {\n    // before: const temperature = this.state.temperature;\n    const temperature = this.props.temperature;    // ...\n\n\n1\n2\n3\n\n\n我们知道 props 是只读的。当 temperature 存在于 temperatureinput 组件的 state 中时，组件调用 this.setstate() 便可修改它。然而，temperature 是由父组件传入的 prop，temperatureinput 组件便失去了对它的控制权。\n\n在 react 中，这个问题通常是通过使用“受控组件”来解决的。与 dom 中的 <input> 接受 value 和 onchange 一样，自定义的 temperatureinput 组件接受 temperature 和 ontemperaturechange 这两个来自父组件 calculator 的 props。\n\n现在，当 temperatureinput 组件想更新温度时，需调用 this.props.ontemperaturechange 来更新它：\n\n  handlechange(e) {\n    // before: this.setstate({temperature: e.target.value});\n    this.props.ontemperaturechange(e.target.value);    // ...\n\n\n1\n2\n3\n\n\n> 注意：\n> \n> 自定义组件中的 temperature 和 ontemperaturechange 这两个 prop 的命名没有任何特殊含义。我们可以给它们取其它任意的名字，例如，把它们命名为 value 和 onchange 就是一种习惯。\n\nontemperaturechange 的 prop 和 temperature 的 prop 一样，均由父组件 calculator 提供。它通过修改父组件自身的内部 state 来处理数据的变化，进而使用新的数值重新渲染两个输入框。我们将很快看到修改后的 calculator 组件效果。\n\n在深入研究 calculator 组件的变化之前，让我们回顾一下 temperatureinput 组件的变化。我们移除组件自身的 state，通过使用 this.props.temperature 替代 this.state.temperature 来读取温度数据。当我们想要响应数据改变时，我们需要调用 calculator 组件提供的 this.props.ontemperaturechange()，而不再使用 this.setstate()。\n\nclass temperatureinput extends react.component {\n  constructor(props) {\n    super(props);\n    this.handlechange = this.handlechange.bind(this);\n  }\n\n  handlechange(e) {\n    this.props.ontemperaturechange(e.target.value);  }\n\n  render() {\n    const temperature = this.props.temperature;    const scale = this.props.scale;\n    return (\n      <fieldset>\n        <legend>enter temperature in {scalenames[scale]}:</legend>\n        <input value={temperature}\n               onchange={this.handlechange} />\n      </fieldset>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n现在，让我们把目光转向 calculator 组件。\n\n我们会把当前输入的 temperature 和 scale 保存在组件内部的 state 中。这个 state 就是从两个输入框组件中“提升”而来的，并且它将用作两个输入框组件的共同“数据源”。这是我们为了渲染两个输入框所需要的所有数据的最小表示。\n\n例如，当我们在摄氏度输入框中键入 37 时，calculator 组件中的 state 将会是：\n\n{\n  temperature: \'37\',\n  scale: \'c\'\n}\n\n\n1\n2\n3\n4\n\n\n如果我们之后修改华氏度的输入框中的内容为 212 时，calculator 组件中的 state 将会是：\n\n{\n  temperature: \'212\',\n  scale: \'f\'\n}\n\n\n1\n2\n3\n4\n\n\n我们可以存储两个输入框中的值，但这并不是必要的。我们只需要存储最近修改的温度及其计量单位即可，根据当前的 temperature 和 scale 就可以计算出另一个输入框的值。\n\n由于两个输入框中的数值由同一个 state 计算而来，因此它们始终保持同步：\n\nclass calculator extends react.component {\n  constructor(props) {\n    super(props);\n    this.handlecelsiuschange = this.handlecelsiuschange.bind(this);\n    this.handlefahrenheitchange = this.handlefahrenheitchange.bind(this);\n    this.state = {temperature: \'\', scale: \'c\'};  }\n\n  handlecelsiuschange(temperature) {\n    this.setstate({scale: \'c\', temperature});  }\n\n  handlefahrenheitchange(temperature) {\n    this.setstate({scale: \'f\', temperature});  }\n\n  render() {\n    const scale = this.state.scale;    const temperature = this.state.temperature;    const celsius = scale === \'f\' ? tryconvert(temperature, tocelsius) : temperature;    const fahrenheit = scale === \'c\' ? tryconvert(temperature, tofahrenheit) : temperature;\n    return (\n      <div>\n        <temperatureinput\n          scale="c"\n          temperature={celsius}          ontemperaturechange={this.handlecelsiuschange} />        <temperatureinput\n          scale="f"\n          temperature={fahrenheit}          ontemperaturechange={this.handlefahrenheitchange} />        <boilingverdict\n          celsius={parsefloat(celsius)} />      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在 codepen 上尝试\n\n现在无论你编辑哪个输入框中的内容，calculator 组件中的 this.state.temperature 和 this.state.scale 均会被更新。其中一个输入框保留用户的输入并取值，另一个输入框始终基于这个值显示转换后的结果。\n\n让我们来重新梳理一下当你对输入框内容进行编辑时会发生些什么：\n\n * react 会调用 dom 中 <input> 的 onchange 方法。在本实例中，它是 temperatureinput 组件的 handlechange 方法。\n * temperatureinput 组件中的 handlechange 方法会调用 this.props.ontemperaturechange()，并传入新输入的值作为参数。其 props 诸如 ontemperaturechange 之类，均由父组件 calculator 提供。\n * 起初渲染时，用于摄氏度输入的子组件 temperatureinput 中的 ontemperaturechange 方法与 calculator 组件中的 handlecelsiuschange 方法相同，而，用于华氏度输入的子组件 temperatureinput 中的 ontemperaturechange 方法与 calculator 组件中的 handlefahrenheitchange 方法相同。因此，无论哪个输入框被编辑都会调用 calculator 组件中对应的方法。\n * 在这些方法内部，calculator 组件通过使用新的输入值与当前输入框对应的温度计量单位来调用 this.setstate() 进而请求 react 重新渲染自己本身。\n * react 调用 calculator 组件的 render 方法得到组件的 ui 呈现。温度转换在这时进行，两个输入框中的数值通过当前输入温度和其计量单位来重新计算获得。\n * react 使用 calculator 组件提供的新 props 分别调用两个 temperatureinput 子组件的 render 方法来获取子组件的 ui 呈现。\n * react 调用 boilingverdict 组件的 render 方法，并将摄氏温度值以组件 props 方式传入。\n * react dom 根据输入值匹配水是否沸腾，并将结果更新至 dom。我们刚刚编辑的输入框接收其当前值，另一个输入框内容更新为转换后的温度值。\n\n得益于每次的更新都经历相同的步骤，两个输入框的内容才能始终保持同步。\n\n\n# 学习小结\n\n在 react 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。\n\n虽然提升 state 方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离 bug 所需的工作量将会变少。由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。\n\n如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。举个例子，本例中我们没有将 celsiusvalue 和 fahrenheitvalue 一起保存，而是仅保存了最后修改的 temperature 和它的 scale。这是因为另一个输入框的温度值始终可以通过这两个值以及组件的 render() 方法获得。这使得我们能够清除输入框内容，亦或是，在不损失用户操作的输入框内数值精度的前提下对另一个输入框内的转换数值做四舍五入的操作。\n\n当你在 ui 中发现错误时，可以使用 react 开发者工具 来检查问题组件的 props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的那个组件。这使得你能够追踪到产生 bug 的源头：\n\n\n\n\n# 组合 vs 继承\n\nreact 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用。\n\n在这篇文档中，我们将考虑初学 react 的开发人员使用继承时经常会遇到的一些问题，并展示如何通过组合思想来解决这些问题。\n\n\n# 包含关系\n\n有些组件无法提前知晓它们子组件的具体内容。在 sidebar（侧边栏）和 dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。\n\n我们建议这些组件使用一个特殊的 children prop 来将他们的子组件传递到渲染结果中：\n\nfunction fancyborder(props) {\n  return (\n    <div classname={\'fancyborder fancyborder-\' + props.color}>\n      {props.children}    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这使得别的组件可以通过 jsx 嵌套，将任意组件作为子组件传递给它们。\n\nfunction welcomedialog() {\n  return (\n    <fancyborder color="blue">\n      <h1 classname="dialog-title">        welcome      </h1>      <p classname="dialog-message">        thank you for visiting our spacecraft!      </p>    </fancyborder>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 codepen 上尝试\n\n<fancyborder> jsx 标签中的所有内容都会作为一个 children prop 传递给 fancyborder 组件。因为 fancyborder 将 {props.children} 渲染在一个 <div> 中，被传递的这些子组件最终都会出现在输出结果中。\n\n少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 children，而是自行约定：将所需内容传入 props，并使用相应的 prop。\n\nfunction splitpane(props) {\n  return (\n    <div classname="splitpane">\n      <div classname="splitpane-left">\n        {props.left}      </div>\n      <div classname="splitpane-right">\n        {props.right}      </div>\n    </div>\n  );\n}\n\nfunction app() {\n  return (\n    <splitpane\n      left={\n        <contacts />      }\n      right={\n        <chat />      } />\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在 codepen 上尝试\n\n<contacts /> 和 <chat /> 之类的 react 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。这种方法可能使你想起别的库中“槽”（slot）的概念，但在 react 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。\n\n\n# 特例关系\n\n有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 welcomedialog 可以说是 dialog 的特殊实例。\n\n在 react 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：\n\nfunction dialog(props) {\n  return (\n    <fancyborder color="blue">\n      <h1 classname="dialog-title">\n        {props.title}      </h1>\n      <p classname="dialog-message">\n        {props.message}      </p>\n    </fancyborder>\n  );\n}\n\nfunction welcomedialog() {\n  return (\n    <dialog      title="welcome"      message="thank you for visiting our spacecraft!" />  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在 codepen 上尝试\n\n组合也同样适用于以 class 形式定义的组件。\n\nfunction dialog(props) {\n  return (\n    <fancyborder color="blue">\n      <h1 classname="dialog-title">\n        {props.title}\n      </h1>\n      <p classname="dialog-message">\n        {props.message}\n      </p>\n      {props.children}    </fancyborder>\n  );\n}\n\nclass signupdialog extends react.component {\n  constructor(props) {\n    super(props);\n    this.handlechange = this.handlechange.bind(this);\n    this.handlesignup = this.handlesignup.bind(this);\n    this.state = {login: \'\'};\n  }\n\n  render() {\n    return (\n      <dialog title="mars exploration program"\n              message="how should we refer to you?">\n        <input value={this.state.login}               onchange={this.handlechange} />        <button onclick={this.handlesignup}>          sign me up!        </button>      </dialog>\n    );\n  }\n\n  handlechange(e) {\n    this.setstate({login: e.target.value});\n  }\n\n  handlesignup() {\n    alert(`welcome aboard, ${this.state.login}!`);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n在 codepen 上尝试\n\n\n# 那么继承呢？\n\n在 facebook，我们在成百上千个组件中使用 react。我们并没有发现需要使用继承来构建组件层次的情况。\n\nprops 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，react 元素以及函数。\n\n如果你想要在组件间复用非 ui 的功能，我们建议将其提取为一个单独的 javascript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。\n\n\n# react哲学\n\n 1. 将设计好的ui划分成组件层级\n 2. 用 react 创建一个静态版本\n 3. 确定 ui state 的最小且完整表示\n 4. 确定 state 放置的位置\n 5. 添加反向数据流\n 6. that\'s it\n\n我们认为，react 是用 javascript 构建快速响应的大型 web 应用程序的首选方式。它在 facebook 和 instagram 上表现优秀。\n\nreact 最棒的部分之一是引导我们思考如何构建一个应用。在这篇文档中，我们将会通过 react 构建一个可搜索的产品数据表格来更深刻地领会 react 哲学。\n\n\n# 从设计稿开始\n\n假设我们已经有了一个返回 json 的 api，以及设计师提供的组件设计稿。如下所示：\n\n\n\n该 json api 会返回以下数据：\n\n[\n  {category: "sporting goods", price: "$49.99", stocked: true, name: "football"},\n  {category: "sporting goods", price: "$9.99", stocked: true, name: "baseball"},\n  {category: "sporting goods", price: "$29.99", stocked: false, name: "basketball"},\n  {category: "electronics", price: "$99.99", stocked: true, name: "ipod touch"},\n  {category: "electronics", price: "$399.99", stocked: false, name: "iphone 5"},\n  {category: "electronics", price: "$199.99", stocked: true, name: "nexus 7"}\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 第一步：将设计好的 ui 划分为组件层级\n\n首先，你需要在设计稿上用方框圈出每一个组件（包括它们的子组件），并且以合适的名称命名。如果你是和设计师一起完成此任务，那么他们可能已经做过类似的工作，所以请和他们进行交流！他们的 photoshop 的图层名称可能最终就是你编写的 react 组件的名称！\n\n但你如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据单一功能原则来判定组件的范围。也就是说，一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。\n\n在实践中，因为你经常是在向用户展示 json 数据模型，所以如果你的模型设计得恰当，ui（或者说组件结构）便会与数据模型一一对应，这是因为 ui 和数据模型都会倾向于遵守相同的信息结构。将 ui 分离为组件，其中每个组件需与数据模型的某部分匹配。\n\n\n\n你会看到我们的应用中包含五个组件。我们已经将每个组件展示的数据标注为了斜体。图片中的序号与下方列表中的序号对应。\n\n 1. filterableproducttable (橙色): 是整个示例应用的整体\n 2. searchbar (蓝色): 接受所有的用户输入\n 3. producttable (绿色): 展示数据内容并根据用户输入筛选结果\n 4. productcategoryrow (天蓝色): 为每一个产品类别展示标题\n 5. productrow (红色): 每一行展示一个产品\n\n你可能注意到，producttable 的表头（包含 “name” 和 “price” 的那一部分）并未单独成为一个组件。这仅仅是一种偏好选择，如何处理这一问题也一直存在争论。就这个示例而言，因为表头只起到了渲染数据集合的作用——这与 producttable 是一致的，所以我们仍然将其保留为 producttable 的一部分。但是，如果表头过于复杂（例如，我们需为其添加排序功能），那么将它作为一个独立的 producttableheader 组件就显得很有必要了。\n\n现在我们已经确定了设计稿中应该包含的组件，接下来我们将把它们描述为更加清晰的层级。设计稿中被其他组件包含的子组件，在层级上应该作为其子节点。\n\n * filterableproducttable\n   * searchbar\n   * producttable\n     * productcategoryrow\n     * productrow\n\n\n# 第二步：用 react 创建一个静态版本\n\n参阅 codepen 上的 react 哲学：第二步。\n\n现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 ui。最好将渲染 ui 和添加交互这两个过程分开。这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。我们会在接下来的代码中体会到其中的区别。\n\n在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 props 传入所需的数据。props 是父组件向子组件传递数据的方式。即使你已经熟悉了 state 的概念，也完全不应该使用 state 构建静态版本。state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。\n\n你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件（比如 filterableproducttable），自下而上意味着从最基本的组件开始编写（比如 productrow）。当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。\n\n到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。由于我们构建的是静态版本，所以这些组件目前只需提供 render() 方法用于渲染。最顶层的组件 filterableproducttable 通过 props 接受你的数据模型。如果你的数据模型发生了改变，再次调用 root.render()，ui 就会相应地被更新。数据模型变化、调用 render() 方法、ui 相应变化，这个过程并不复杂，因此很容易看清楚 ui 是如何被更新的，以及是在哪里被更新的。react 单向数据流（也叫单向绑定）的思想使得组件模块化，易于快速开发。\n\n如果你在完成这一步骤时遇到了困难，可以参阅 react 文档。\n\n\n# 补充说明: 有关 props 和 state\n\n在 react 中，有两类“模型”数据：props 和 state。清楚地理解两者的区别是十分重要的；如果你不太有把握，可以参阅 react 官方文档。你也可以查看 faq: state 与 props 的区别是什么？\n\n\n# 第三步：确定 ui state 的最小（且完整）表示\n\n想要使你的 ui 具备交互功能，需要有触发基础数据模型改变的能力。react 通过实现 state 来完成这个任务。\n\n为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 dry: don’t repeat yourself。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。\n\n我们的示例应用拥有如下数据：\n\n * 包含所有产品的原始列表\n * 用户输入的搜索词\n * 复选框是否选中的值\n * 经过搜索筛选的产品列表\n\n通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：\n\n 1. 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。\n 2. 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。\n 3. 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。\n\n包含所有产品的原始列表是经由 props 传入的，所以它不是 state；搜索词和复选框的值应该是 state，因为它们随时间会发生改变且无法由其他数据计算而来；经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。\n\n综上所述，属于 state 的有：\n\n * 用户输入的搜索词\n * 复选框是否选中的值\n\n\n# 第四步：确定 state 放置的位置\n\n参阅 codepen 上的 react 哲学：第四步。\n\n我们已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。\n\n注意：react 中的数据流是单向的，并顺着组件层级从上往下传递。哪个组件应该拥有某个 state 这件事，对初学者来说往往是最难理解的部分。尽管这可能在一开始不是那么清晰，但你可以尝试通过以下步骤来判断：\n\n对于应用中的每一个 state：\n\n * 找到根据这个 state 进行渲染的所有组件。\n * 找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。\n * 该共同所有者组件或者比它层级更高的组件应该拥有该 state。\n * 如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。\n\n根据以上策略重新考虑我们的示例应用：\n\n * producttable 需要根据 state 筛选产品列表。searchbar 需要展示搜索词和复选框的状态。\n * 他们的共同所有者是 filterableproducttable。\n * 因此，搜索词和复选框的值应该很自然地存放在 filterableproducttable 组件中。\n\n很好，我们已经决定把这些 state 存放在 filterableproducttable 组件中。首先，将实例属性 this.state = {filtertext: \'\', instockonly: false} 添加到 filterableproducttable 的 constructor 中，设置应用的初始 state；接着，将 filtertext 和 instockonly 作为 props 传入 producttable 和 searchbar；最后，用这些 props 筛选 producttable 中的产品信息，并设置 searchbar 的表单值。\n\n你现在可以看到应用的变化了：将 filtertext 设置为 "ball" 并刷新应用，你能发现表格中的数据已经更新了。\n\n\n# 第五步：添加反向数据流\n\n参阅 codepen 上的 react 哲学：第五步。\n\n到目前为止，我们已经借助自上而下传递的 props 和 state 渲染了一个应用。现在，我们将尝试让数据反向传递：处于较低层级的表单组件更新较高层级的 filterableproducttable 中的 state。\n\nreact 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。\n\n如果你尝试在上一个示例的搜索框中输入或勾选复选框（步骤 4），react 不会产生任何响应。这是正常的，因为我们之前已经将 input 的值设置为了从 filterableproducttable 的 state 传递而来的固定值。\n\n让我们重新梳理一下需要实现的功能：每当用户改变表单的值，我们需要改变 state 来反映用户的当前输入。由于 state 只能由拥有它们的组件进行更改，filterableproducttable 必须将一个能够触发 state 改变的回调函数（callback）传递给 searchbar。我们可以使用输入框的 onchange 事件来监视用户输入的变化，并通知 filterableproducttable 传递给 searchbar 的回调函数。然后该回调函数将调用 setstate()，从而更新应用。\n\n\n# 这就是全部了\n\n希望这篇文档能够帮助你建立起构建 react 组件和应用的一般概念。尽管你可能需要编写更多的代码，但是别忘了：比起写，代码更多地是给人看的。我们一起构建的这个模块化示例应用的代码就很易于阅读。当你开始构建更大的组件库时，你会意识到这种代码模块化和清晰度的重要性。并且随着代码重用程度的加深，你的代码行数也会显著地减少。😃\n\n\n#',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"hooks",frontmatter:{title:"hooks",date:"2022-12-05T15:59:40.000Z",permalink:"/pages/69da0f/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/04.react%E5%AE%98%E6%96%B9/02.hooks.html",relativePath:"02.软件框架/06.react/04.react官方/02.hooks.md",key:"v-24441a1e",path:"/pages/69da0f/",headers:[{level:2,title:"Hook简介",slug:"hook简介",normalizedTitle:"hook简介",charIndex:2},{level:3,title:"视频介绍",slug:"视频介绍",normalizedTitle:"视频介绍",charIndex:647},{level:3,title:"没有破坏性改动",slug:"没有破坏性改动",normalizedTitle:"没有破坏性改动",charIndex:764},{level:3,title:"动机",slug:"动机",normalizedTitle:"动机",charIndex:1193},{level:3,title:"在组件之间复用状态逻辑很难",slug:"在组件之间复用状态逻辑很难",normalizedTitle:"在组件之间复用状态逻辑很难",charIndex:1307},{level:3,title:"复杂组件变得难以理解",slug:"复杂组件变得难以理解",normalizedTitle:"复杂组件变得难以理解",charIndex:1748},{level:3,title:"难以理解的 class",slug:"难以理解的-class",normalizedTitle:"难以理解的 class",charIndex:2271},{level:3,title:"渐进策略",slug:"渐进策略",normalizedTitle:"渐进策略",charIndex:967}],headersStr:"Hook简介 视频介绍 没有破坏性改动 动机 在组件之间复用状态逻辑很难 复杂组件变得难以理解 难以理解的 class 渐进策略",content:"# Hook简介\n\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 声明一个新的叫做 “count” 的 state 变量  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nuseState 是我们要学习的第一个 “Hook”，这个例子是简单演示。如果不理解也不用担心。\n\n你将在下一章节正式开始学习 Hook。 这一章节，我们将会解释为什么会在 React 中加入 Hook，以及如何使用 Hook 写出更好的应用。\n\n> 注意\n> \n> React 16.8.0 是第一个支持 Hook 的版本。升级时，请注意更新所有的 package，包括 React DOM。 React Native 从 0.59 版本开始支持 Hook。\n\n\n# 视频介绍\n\n在 React Conf 2018 上，Sophie Alpert 和 Dan Abramov 介绍了 Hook，紧接着 Ryan Florence 演示了如何使用 Hook 重构应用。你可以在这里看到这个视频：\n\n\n# 没有破坏性改动\n\n在我们继续之前，请记住 Hook 是：\n\n * 完全可选的。 你无需重写任何已有代码就可以在一些组件中尝试 Hook。但是如果你不想，你不必现在就去学习或使用 Hook。\n * 100% 向后兼容的。 Hook 不包含任何破坏性改动。\n * 现在可用。 Hook 已发布于 v16.8.0。\n\n没有计划从 React 中移除 class。 你可以在本页底部的章节读到更多关于 Hook 的渐进策略。\n\nHook 不会影响你对 React 概念的理解。 恰恰相反，Hook 为已知的 React 概念提供了更直接的 API：props， state，context，refs 以及生命周期。稍后我们将看到，Hook 还提供了一种更强大的方式来组合他们。\n\n如果不想了解添加 Hook 的具体原因，可以直接跳到下一章节开始学习 Hook！ 当然你也可以继续阅读这一章节来了解原因，并且可以学习到如何在不重写应用的情况下使用 Hook。\n\n\n# 动机\n\nHook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题。无论你正在学习 React，或每天使用，或者更愿尝试另一个和 React 有相似组件模型的框架，你都可能对这些问题似曾相识。\n\n\n# 在组件之间复用状态逻辑很难\n\nReact 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）。如果你使用过 React 一段时间，你也许会熟悉一些解决此类问题的方案，比如 render props 和 高阶组件。但是这类方案需要重新组织你的组件结构，这可能会很麻烦，使你的代码难以理解。如果你在 React DevTools 中观察过 React 应用，你会发现由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管我们可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。\n\n你可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。\n\n具体将在自定义 Hook 中对此展开更多讨论。\n\n\n# 复杂组件变得难以理解\n\n我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。\n\n在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。\n\n为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n\n我们将在使用 Effect Hook 中对此展开更多讨论。\n\n\n# 难以理解的 class\n\n除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 ES2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。\n\n另外，React 已经发布五年了，我们希望它能在下一个五年也与时俱进。就像 Svelte，Angular，Glimmer等其它的库展示的那样，组件预编译会带来巨大的潜力。尤其是在它不局限于模板的时候。最近，我们一直在使用 Prepack 来试验 component folding，也取得了初步成效。但是我们发现使用 class 组件会无意中鼓励开发者使用一些让优化措施无效的方案。class 也给目前的工具带来了一些问题。例如，class 不能很好的压缩，并且会使热重载出现不稳定的情况。因此，我们想提供一个使代码更易于优化的 API。\n\n为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。\n\n> 示例\n> \n> Hook 概览是开始学习 Hook 的不错选择。\n\n\n# 渐进策略\n\n> 总结：没有计划从 React 中移除 class。\n\n大部分 React 开发者会专注于开发产品，而没时间关注每一个新 API 的发布。Hook 还很新，也许等到有更多示例和教程后，再考虑学习或使用它们也不迟。\n\n我们也明白向 React 添加新的原生概念的门槛非常高。我们为好奇的读者准备了详细的征求意见文档，在文档中用更多细节深入讨论了我们推进这件事的动机，也在具体设计决策和相关先进技术上提供了额外的视角。\n\n最重要的是，Hook 和现有代码可以同时工作，你可以渐进式地使用他们。 不用急着迁移到 Hook。我们建议避免任何“大规模重写”，尤其是对于现有的、复杂的 class 组件。开始“用 Hook 的方式思考”前，需要做一些思维上的转变。按照我们的经验，最好先在新的不复杂的组件中尝试使用 Hook，并确保团队中的每一位成员都能适应。在你尝试使用 Hook 后，欢迎给我们提供反馈，无论好坏。\n\n我们准备让 Hook 覆盖所有 class 组件的使用场景，但是**我们将继续为 class 组件提供支持。**在 Facebook，我们有成千上万的组件用 class 书写，我们完全没有重写它们的计划。相反，我们开始在新的代码中同时使用 Hook 和 class。",normalizedContent:"# hook简介\n\nhook 是 react 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 react 特性。\n\nimport react, { usestate } from 'react';\n\nfunction example() {\n  // 声明一个新的叫做 “count” 的 state 变量  const [count, setcount] = usestate(0);\n  return (\n    <div>\n      <p>you clicked {count} times</p>\n      <button onclick={() => setcount(count + 1)}>\n        click me\n      </button>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nusestate 是我们要学习的第一个 “hook”，这个例子是简单演示。如果不理解也不用担心。\n\n你将在下一章节正式开始学习 hook。 这一章节，我们将会解释为什么会在 react 中加入 hook，以及如何使用 hook 写出更好的应用。\n\n> 注意\n> \n> react 16.8.0 是第一个支持 hook 的版本。升级时，请注意更新所有的 package，包括 react dom。 react native 从 0.59 版本开始支持 hook。\n\n\n# 视频介绍\n\n在 react conf 2018 上，sophie alpert 和 dan abramov 介绍了 hook，紧接着 ryan florence 演示了如何使用 hook 重构应用。你可以在这里看到这个视频：\n\n\n# 没有破坏性改动\n\n在我们继续之前，请记住 hook 是：\n\n * 完全可选的。 你无需重写任何已有代码就可以在一些组件中尝试 hook。但是如果你不想，你不必现在就去学习或使用 hook。\n * 100% 向后兼容的。 hook 不包含任何破坏性改动。\n * 现在可用。 hook 已发布于 v16.8.0。\n\n没有计划从 react 中移除 class。 你可以在本页底部的章节读到更多关于 hook 的渐进策略。\n\nhook 不会影响你对 react 概念的理解。 恰恰相反，hook 为已知的 react 概念提供了更直接的 api：props， state，context，refs 以及生命周期。稍后我们将看到，hook 还提供了一种更强大的方式来组合他们。\n\n如果不想了解添加 hook 的具体原因，可以直接跳到下一章节开始学习 hook！ 当然你也可以继续阅读这一章节来了解原因，并且可以学习到如何在不重写应用的情况下使用 hook。\n\n\n# 动机\n\nhook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题。无论你正在学习 react，或每天使用，或者更愿尝试另一个和 react 有相似组件模型的框架，你都可能对这些问题似曾相识。\n\n\n# 在组件之间复用状态逻辑很难\n\nreact 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）。如果你使用过 react 一段时间，你也许会熟悉一些解决此类问题的方案，比如 render props 和 高阶组件。但是这类方案需要重新组织你的组件结构，这可能会很麻烦，使你的代码难以理解。如果你在 react devtools 中观察过 react 应用，你会发现由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管我们可以在 devtools 过滤掉它们，但这说明了一个更深层次的问题：react 需要为共享状态逻辑提供更好的原生途径。\n\n你可以使用 hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。hook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 hook 变得更便捷。\n\n具体将在自定义 hook 中对此展开更多讨论。\n\n\n# 复杂组件变得难以理解\n\n我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentdidmount 和 componentdidupdate 中获取数据。但是，同一个 componentdidmount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentwillunmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。\n\n在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 react 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。\n\n为了解决这个问题，hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n\n我们将在使用 effect hook 中对此展开更多讨论。\n\n\n# 难以理解的 class\n\n除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 react 的一大屏障。你必须去理解 javascript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。如果不使用 es2022 public class fields，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 react 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。\n\n另外，react 已经发布五年了，我们希望它能在下一个五年也与时俱进。就像 svelte，angular，glimmer等其它的库展示的那样，组件预编译会带来巨大的潜力。尤其是在它不局限于模板的时候。最近，我们一直在使用 prepack 来试验 component folding，也取得了初步成效。但是我们发现使用 class 组件会无意中鼓励开发者使用一些让优化措施无效的方案。class 也给目前的工具带来了一些问题。例如，class 不能很好的压缩，并且会使热重载出现不稳定的情况。因此，我们想提供一个使代码更易于优化的 api。\n\n为了解决这些问题，hook 使你在非 class 的情况下可以使用更多的 react 特性。 从概念上讲，react 组件一直更像是函数。而 hook 则拥抱了函数，同时也没有牺牲 react 的精神原则。hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。\n\n> 示例\n> \n> hook 概览是开始学习 hook 的不错选择。\n\n\n# 渐进策略\n\n> 总结：没有计划从 react 中移除 class。\n\n大部分 react 开发者会专注于开发产品，而没时间关注每一个新 api 的发布。hook 还很新，也许等到有更多示例和教程后，再考虑学习或使用它们也不迟。\n\n我们也明白向 react 添加新的原生概念的门槛非常高。我们为好奇的读者准备了详细的征求意见文档，在文档中用更多细节深入讨论了我们推进这件事的动机，也在具体设计决策和相关先进技术上提供了额外的视角。\n\n最重要的是，hook 和现有代码可以同时工作，你可以渐进式地使用他们。 不用急着迁移到 hook。我们建议避免任何“大规模重写”，尤其是对于现有的、复杂的 class 组件。开始“用 hook 的方式思考”前，需要做一些思维上的转变。按照我们的经验，最好先在新的不复杂的组件中尝试使用 hook，并确保团队中的每一位成员都能适应。在你尝试使用 hook 后，欢迎给我们提供反馈，无论好坏。\n\n我们准备让 hook 覆盖所有 class 组件的使用场景，但是**我们将继续为 class 组件提供支持。**在 facebook，我们有成千上万的组件用 class 书写，我们完全没有重写它们的计划。相反，我们开始在新的代码中同时使用 hook 和 class。",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"高级指引",frontmatter:{title:"高级指引",date:"2022-12-05T16:00:01.000Z",permalink:"/pages/acec16/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/04.react%E5%AE%98%E6%96%B9/03.%E9%AB%98%E7%BA%A7%E6%8C%87%E5%BC%95.html",relativePath:"02.软件框架/06.react/04.react官方/03.高级指引.md",key:"v-33468254",path:"/pages/acec16/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"API",frontmatter:{title:"API",date:"2022-12-05T16:00:11.000Z",permalink:"/pages/17f77d/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/02.%E8%BD%AF%E4%BB%B6%E6%A1%86%E6%9E%B6/06.react/04.react%E5%AE%98%E6%96%B9/04.API.html",relativePath:"02.软件框架/06.react/04.react官方/04.API.md",key:"v-30b51d06",path:"/pages/17f77d/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"项目介绍",frontmatter:{title:"项目介绍",date:"2022-11-29T15:26:18.000Z",permalink:"/pages/330866/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/06.%E9%A1%B9%E7%9B%AE/01.%E4%B8%AD%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/01.%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D.html",relativePath:"06.项目/01.中台管理项目/01.项目介绍.md",key:"v-4cac09e4",path:"/pages/330866/",headers:[{level:2,title:"中台系统",slug:"中台系统",normalizedTitle:"中台系统",charIndex:2}],headersStr:"中台系统",content:"# 中台系统",normalizedContent:"# 中台系统",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"index",frontmatter:{title:"index",date:"2022-12-06T14:16:26.000Z",permalink:"/pages/bf4db4/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/06.%E9%A1%B9%E7%9B%AE/04.react%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/01.index.html",relativePath:"06.项目/04.react项目搭建/01.index.md",key:"v-68a34aaa",path:"/pages/bf4db4/",headers:[{level:2,title:"技术栈",slug:"技术栈",normalizedTitle:"技术栈",charIndex:20},{level:2,title:"项目搭建",slug:"项目搭建",normalizedTitle:"项目搭建",charIndex:203},{level:2,title:"安装包",slug:"安装包",normalizedTitle:"安装包",charIndex:1529},{level:3,title:"sass样式",slug:"sass样式",normalizedTitle:"sass样式",charIndex:1537},{level:3,title:"react-router-dom路由",slug:"react-router-dom路由",normalizedTitle:"react-router-dom路由",charIndex:1754}],headersStr:"技术栈 项目搭建 安装包 sass样式 react-router-dom路由",content:"——以 移动端新闻头条项目为例\n\n\n# 技术栈\n\n * 官方脚手架工具：create-react-app\n\n * Hooks\n\n * 状态管理工具：redux\n\n * UI组件库：antd\n\n * 异步请求：axios\n\n * 路由：react-router\n\n * 样式：sass、解决样式问题库 css Modules\n\n * 类型检查： TypeScript\n\n * link：Eslint\n\n\n# 项目搭建\n\n * 脚手架创建命令：npx create-react-app my-app --template typescript\n\n * 调整项目结构\n   \n   基本项目结构\n   \n   /src\n     /assets         项目资源文件，比如，图片 等\n     /components     通用组件\n     /pages          页面\n     /store          Redux 状态仓库\n     /types          TS 类型，包括：接口、redux等类型\n     /utils          工具，比如，token、axios 的封装等\n     App.scss        根组件样式文件\n     App.tsx         根组件\n     index.scss      全局样式\n     index.tsx       项目入口\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * 基础样式设置\n   \n   src/index.tsx 中：\n   \n   import ReactDOM from 'react-dom'\n   import './index.scss'\n   import App from './App'\n   \n   ReactDOM.render(<App />, document.getElementById('root'))\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   src/index.scss 中：\n   \n   html,\n   body {\n     margin: 0;\n     padding: 0;\n   }\n   \n   html,\n   body,\n   #root {\n     height: 100%;\n   }\n   \n   p,\n   h2,\n   h3 {\n     margin: 0;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n   \n   src/App.tsx 中：\n   \n   import './App.scss'\n   \n   function App() {\n     return <div className=\"app\"></div>\n   }\n   \n   export default App\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   src/App.scss 中：\n   \n   .app {\n     height: 100%;\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   注：为了统一操作，直接删除 src 下的所有文件后，再调整\n\n\n# 安装包\n\n\n# sass样式\n\n脚手架内置了 sass，只需要安装相关包即可\n\nyarn add sass;\n\n\n1\n\n\n为了解决样式引入而导致的样式冲突问题\n\n在 react 中这样使用样式文件\n\nimport styles from './index.module.scss'\n\nconst Home = ()=>{\n  return <div className={styles.root}></div>\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# react-router-dom路由\n\n使用 ts 开发，需要对第三方包引入类型声明文件\n\nyarn add react-router-dom@5.3.0\nyarn add @types/react-router-dom -D\n\n\n1\n2\n\n\npages/Login/index.tsx 中：\n\nconst Login = () => {\n  return <div>登录页面</div>\n}\nexport default Login\n\n\n1\n2\n3\n4\n\n\nApp.tsx 中：\n\n// 导入路由\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom'\n\n// 导入页面组件\nimport Login from './pages/Login'\nimport Layout from './pages/Layout'\n\n// 配置路由规则\nfunction App() {\n  return (\n\t\t<Router>\n      <div className=\"app\">\n        <Switch>\n          <Route path=\"/home\" component={Layout} />\n          <Route path=\"/login\" component={Login} />\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n\nexport default App\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"——以 移动端新闻头条项目为例\n\n\n# 技术栈\n\n * 官方脚手架工具：create-react-app\n\n * hooks\n\n * 状态管理工具：redux\n\n * ui组件库：antd\n\n * 异步请求：axios\n\n * 路由：react-router\n\n * 样式：sass、解决样式问题库 css modules\n\n * 类型检查： typescript\n\n * link：eslint\n\n\n# 项目搭建\n\n * 脚手架创建命令：npx create-react-app my-app --template typescript\n\n * 调整项目结构\n   \n   基本项目结构\n   \n   /src\n     /assets         项目资源文件，比如，图片 等\n     /components     通用组件\n     /pages          页面\n     /store          redux 状态仓库\n     /types          ts 类型，包括：接口、redux等类型\n     /utils          工具，比如，token、axios 的封装等\n     app.scss        根组件样式文件\n     app.tsx         根组件\n     index.scss      全局样式\n     index.tsx       项目入口\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * 基础样式设置\n   \n   src/index.tsx 中：\n   \n   import reactdom from 'react-dom'\n   import './index.scss'\n   import app from './app'\n   \n   reactdom.render(<app />, document.getelementbyid('root'))\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   src/index.scss 中：\n   \n   html,\n   body {\n     margin: 0;\n     padding: 0;\n   }\n   \n   html,\n   body,\n   #root {\n     height: 100%;\n   }\n   \n   p,\n   h2,\n   h3 {\n     margin: 0;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n   \n   src/app.tsx 中：\n   \n   import './app.scss'\n   \n   function app() {\n     return <div classname=\"app\"></div>\n   }\n   \n   export default app\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n   \n   src/app.scss 中：\n   \n   .app {\n     height: 100%;\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   注：为了统一操作，直接删除 src 下的所有文件后，再调整\n\n\n# 安装包\n\n\n# sass样式\n\n脚手架内置了 sass，只需要安装相关包即可\n\nyarn add sass;\n\n\n1\n\n\n为了解决样式引入而导致的样式冲突问题\n\n在 react 中这样使用样式文件\n\nimport styles from './index.module.scss'\n\nconst home = ()=>{\n  return <div classname={styles.root}></div>\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# react-router-dom路由\n\n使用 ts 开发，需要对第三方包引入类型声明文件\n\nyarn add react-router-dom@5.3.0\nyarn add @types/react-router-dom -d\n\n\n1\n2\n\n\npages/login/index.tsx 中：\n\nconst login = () => {\n  return <div>登录页面</div>\n}\nexport default login\n\n\n1\n2\n3\n4\n\n\napp.tsx 中：\n\n// 导入路由\nimport { browserrouter as router, route, switch } from 'react-router-dom'\n\n// 导入页面组件\nimport login from './pages/login'\nimport layout from './pages/layout'\n\n// 配置路由规则\nfunction app() {\n  return (\n\t\t<router>\n      <div classname=\"app\">\n        <switch>\n          <route path=\"/home\" component={layout} />\n          <route path=\"/login\" component={login} />\n        </switch>\n      </div>\n    </router>\n  )\n}\n\nexport default app\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"青训营真题day01",frontmatter:{title:"青训营真题day01",date:"2023-02-07T15:17:40.000Z",permalink:"/pages/e0384f/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/07.%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88/01.%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E9%9D%92%E8%AE%AD%E8%90%A5/01.%E9%9D%92%E8%AE%AD%E8%90%A5%E7%9C%9F%E9%A2%98day01.html",relativePath:"07.面试综合/01.字节前端青训营/01.青训营真题day01.md",key:"v-b4ba35be",path:"/pages/e0384f/",headers:[{level:2,title:"青训营真题",slug:"青训营真题",normalizedTitle:"青训营真题",charIndex:2},{level:3,title:"题目一：",slug:"题目一",normalizedTitle:"题目一：",charIndex:12},{level:3,title:"题目二：",slug:"题目二",normalizedTitle:"题目二：",charIndex:1295},{level:3,title:"题目三：",slug:"题目三",normalizedTitle:"题目三：",charIndex:2524},{level:3,title:"题目四：",slug:"题目四",normalizedTitle:"题目四：",charIndex:3336},{level:2,title:"选择题",slug:"选择题",normalizedTitle:"选择题",charIndex:3876}],headersStr:"青训营真题 题目一： 题目二： 题目三： 题目四： 选择题",content:'# 青训营真题\n\n\n# 题目一：\n\n> 给定一个十进制整数字符串，判断它是否是 2 的幂。\n> \n> 示例 1 输入："16"，输出：true\n> \n> 示例 2 输入："101"，输出：false\n> \n> 示例 3 输入："70368744177664"，输出：true\n> \n> 限定语言：C、 C++、Java、Python、JavaScript V8\n\n一个数n是2的幂，当且仅当n是正整数，并且n的二进制中包含1个1，因此我们可以考虑使用位运算，将n的二进制表示中最低位的哪个1提取出来，再判断剩余的数值是否为0即可。\n\n * n&(n-1)=0\n * n&(-n)=n\n\n负数的存储在计算机中按补码规则存储，按位取反后加一， n&(-n) 的结果为 n 时为 2 的幂\n\n4(100) 16(1 0000)\n\nlet isPowerOfTwo = function(n){\n  return n>0&&(n&(n-1))===0\n}\n\n\n1\n2\n3\n\n\nlet isPowerOfTwo = function(n){\n  return n>0&&(n&-n)===n\n}\n\n\n1\n2\n3\n\n\n如果是给定范围的一个数判断\n\n * -2^31 <= n <= 2^31 - 1\n\n只需要判断 n 是否是 2^30 的约数即可\n\nlet isPowerOfTwo = function(n){\n  const BIG = 1<<30\n  return n>0&&BIG%n === 0\n}\n\n\n1\n2\n3\n4\n\n\n自己的题解\n\nvar isPowerOfTwo = function(n) {\n    if(n<1){\n        return false\n    }\n    while(n>1){\n        if(n%2){\n            return false\n        }\n        n/=2\n    }\n    return true\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n扩展题：\n\n幂为4\n\n方法一：\n\n如果n是4的幂，那么该数也是2的幂且二进制中的1出现在偶数个二进制位上\n\n可以构造一个 mask 整数 ，*mask*=(10101010101010101010101010101010)2\n\n与 n 进行与运算，结果为0表示该数为 4 的幂\n\nlet isPowerOfFour = function(n) {\n    return n > 0 && (n & (n - 1)) === 0 && (n & 0xaaaaaaaa) === 0;\n};\n\n\n1\n2\n3\n\n\n方法二：取模\n\nlet isPowerOfFour = function(n) {\n    return n > 0 && (n & (n - 1)) === 0 && n % 3 === 1;\n};\n\n\n1\n2\n3\n\n\n4的幂，除3取模一定为1\n\n总结：\n\n该题型关键解法，在于找到 n&(n-1)=0 的类似规律\n\n\n# 题目二：\n\n> 题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略空格、字母的大小写。\n> \n> 示例 输入："A man, a plan, a canal: Panama"，输出：true\n> \n> 限定语言：C、 C++、Java、Python、JavaScript V8\n\n该类题型解法： 直接使用 reverse()自带回文函数、双指针、栈等\n\n此题，首先需要先去除非字母和数字的字符，后将字母全部转化为小写后进行判断\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar isPalindrome = function(s) {\n  let len = s.length\n  let left = 0 , right = len-1\n  s = s.toLowerCase()\n  while(left<right){\n    if(!isVail(s[left])){\n       left++\n       continue\n    }else if(!isVail(s[right])){\n       right--\n       continue\n    }\n    if(s[left]==s[right]){\n       left++\n       right--\n       continue\n    }\n   \treturn false\n  } \n  return true\n};\n\nlet isVail = function(c){\n  if(c>=\'a\'&&c<=\'z\'){\n     return true\n  }\n  if(c>=\'0\'&&c<=\'9\'){\n     return true\n  }\n  return false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n自己题解\n\n力扣上更简洁的写法\n\nvar isPalindrome = function(s) {\n   s=s.replace(/[^a-zA-Z0-9]/g,"").replace(/\\s/g,"").toLowerCase();\n    let i=0,j=s.length-1;\n    while(i<j){\n        if(s[i]!=s[j]){\n           return false;\n        }\n        i++;\n        j--;\n    }\nreturn true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意：\n\n如果使用 reverse() 函数，会改变原有数组，使用 toString() 进行比较\n\n\n# 题目三：\n\n给你一个字符串 s，找到 s 中最长的回文子串。\n\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n自己的题解，暴力\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    let len = 0;\n    let rs = \'\';\n    for(let i=0;i<=s.length;i++){\n        for(let j=i+1;j<=s.length;j++){\n            //暴力解法\n            let nrs = s.slice(i,j)\n            if(isHW(nrs)){//如果截取的是回文串\n                if(nrs.length>len){\n                    len = nrs.length\n                    rs = nrs\n                }\n            }\n        }\n    }\n    return rs\n};\n\n//判断回文字符串\nlet isHW = function(s){\n    for(let i=0,j=s.length-1;i<j;i++,j--){\n        if(s[i]!==s[j]){\n            return false\n        }\n    }\n    return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n运行效率极差，不学算法碰到类似题目，想破脑袋都想不出啊😭\n\n\n# 题目四：\n\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n滑动窗口\n\n如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的。k+1到rk的字符串显然是不重复的，并且少了原本的第k个字符\n\n解法：当字符串不重复时 right ++ ，当字符串重复是 left++ 进入下一个循环\n\nlet getMax = function(s){\n  if(s.length<=1) return s.length\n  let left = 0, right = 1\n  let max = 0 , rs=[]\n  while(right<s.length){\n  \trs = s.slice(left,right)\n    if(rs.indexOf(s.charAt(right))>-1){\n       left++//开新循环\n       continue\n    }else {\n      right++\n    }\n    max = max > right-left ? max:right-left\n  }\n  return max \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 选择题\n\n 1.  下列哪些是 HTML5 的新特性 ABCD\n     \n     A . 语义标签\n     \n     B . Canvas 绘图\n     \n     C. <audio> 元素\n     \n     D. 增强型表单\n\n 2.  下面可以继承的属性有哪些 ACD\n     \n     A. font-size\n     \n     B. background\n     \n     C. color\n     \n     D. cursor\n\n 3.  对于一条100M的宽带，理论下载速度上限是多少 A\n     \n     A. 12.5MB/s\n     \n     B. 100MB/s\n     \n     C. 10MB/s\n     \n     D. 10Mb.s\n\n 4.  关于 for of 和 for in 的描述，正确的是 A D\n     \n     A. for in 可以循环普通对象\n     \n     B. for of 可以循环普通对象\n     \n     C. 都不可以循环数组\n     \n     D. 都可以循环数组\n\n 5.  关于事件冒泡描述正确的是 A\n     \n     A. 从元素目标向 document 冒泡\n     \n     B. 从 document 向目标元素冒泡\n     \n     C. 从 document 向目标元素冒泡，在从目标元素向 documnet 冒泡\n     \n     D. 以上都不是\n\n 6.  以下哪些 script 标签属性会使脚本有可能在 DOMContentLoaded 事件之后加载 AD\n     \n     A. <script async>\n     \n     B. <script defer>\n     \n     C. <script type="module">\n     \n     D. <script type="module" async>\n\n 7.  以下哪些是 css 块级元素的特性 B D\n     \n     A . 宽度默认由其中的内容决定\n     \n     B . 高度默认由其中的内容决定\n     \n     C . 可以被拆分到多行\n     \n     D . 可以通过height 属性指定高度\n\n 8.  以下关于跨域说法错误的是 A\n     \n     A. http://example.com/a.html 和 https://example.com/b.html 是相同的域名，属于同源\n     \n     B. 跨域资源共享规范中规定了除了GET之外的 HTTP 请求，或者搭配某些 MINI 类型的 POST 请求，浏览器需要先发送一个 OPTIONS 请求\n     \n     C. CSS中通过 @font-face 使用字体也会有跨域问题\n     \n     D. Cookie、LocalStorage 和 IndexedDB 都会受到同源策略的限制\n\n 9.  下列哪些可以实现浏览器存储数据 ABD\n     \n     A. cookie\n     \n     B. localStorage\n     \n     C. session\n     \n     D. sessionStorage\n\n 10. 对以下代码说法正确的是 A\n     \n     let arr = [1,2,3,4,5]\n     let arr2 = [1,,3]\n     \n     \n     1\n     2\n     \n     \n     A. 执行 arr.length = 3 ，此时数组为 [1,2,3]\n     \n     B. 执行 arr[10] = 11 , 此时 arr.length 为 6\n     \n     C. 执行 delete arr[2] ，此时 arr.length 为 4，数组为 [1,2,4,5]\n     \n     D. arr2.length 的长度为 2\n\n 11. 在 css 选择器当中， 优先级排序正确的是 D\n     \n     A. id选择器 > 标签选择器 > 类选择器\n     \n     B. 标签选择器 > 类选择器 > id 选择器\n     \n     C. 类选择器>标签选择器>id选择器\n     \n     D. id选择器>类选择器>标签选择器\n\n 12. 如以下代码所示，给 body 绑定两个事件后，调用 document.body.click() 输出的结果是 A\n     \n     document.body.addEventListener(\'click\',()=>{\n       Promise.resolve().then(()=>{\n         console.log(1)\n       })\n       console.log(2)\n     },false)\n     document.body.addEventListener(\'click\',()=>{\n       Promise.resolve().then(()=>{\n         console.log(3)\n       })\n       console.log(4)\n     },false)\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n     \n     A. 2, 4, 1, 3 B. 2, 1, 4, 3 C. 1, 2, 3, 4 D. 1, 3, 2, 4\n\n 13. 浮动会导致页面的非正常显示，以下几种清除浮动的方法，哪个是不推荐使用的 D\n     \n     A. 在浮动元素末尾添加一个空的标签例如 <div style="clear:both">\n     \n     B. 通过设置父元素 overflow 值为 hidden\n     \n     C. 给父元素添加clearfix类\n     \n     D. 父元素也设置浮动\n\n 14. 以下代码运行结果是 D\n     \n     var f = function (){\n       console.log("1")\n     }\n     function f(){\n       console.log("2")\n     }\n     f();\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n     \n     A. undefined B. 报错 C. 2 D. 1\n\n 15. 下列说法正确的有哪些 A C\n     \n     A. visibility：hidden 表示所占据的空间位置仍然存在，仅为视觉上的完全透明\n     \n     B.display：none 不为被隐藏的对象保留其物理空间\n     \n     C. visibility：hidden 与 display：none 两者没有本质上的区别\n     \n     D. visibility：hidden 回流与重绘\n\n 16. 若主机甲与主机已建立一条 TCP 链接，最大段长 MSS 为 1KB，往反时间RTT为 2ms，则在不出现拥塞的前提下，拥塞窗口用 8KB 增长到 32KB 所需要的最长时长是 D\n     \n     A. 4ms B. 8ms C. 24ms D. 48ms\n\n 17. 以下对HTML标签的使用，哪些是符合语义的 A C\n     \n     A. 使用 table 展示表格数据\n     \n     B. 使用 span 表示按钮\n     \n     C. 使用 article 展示文章内容\n     \n     D. 使用 P 标签展示文章标题\n\n 18. 包过滤防火墙对数据包的过滤依据不包括哪些 C\n     \n     A. 源IP地址\n     \n     B. 源端口号\n     \n     C. MAC地址\n     \n     D. 目标IP地址',normalizedContent:'# 青训营真题\n\n\n# 题目一：\n\n> 给定一个十进制整数字符串，判断它是否是 2 的幂。\n> \n> 示例 1 输入："16"，输出：true\n> \n> 示例 2 输入："101"，输出：false\n> \n> 示例 3 输入："70368744177664"，输出：true\n> \n> 限定语言：c、 c++、java、python、javascript v8\n\n一个数n是2的幂，当且仅当n是正整数，并且n的二进制中包含1个1，因此我们可以考虑使用位运算，将n的二进制表示中最低位的哪个1提取出来，再判断剩余的数值是否为0即可。\n\n * n&(n-1)=0\n * n&(-n)=n\n\n负数的存储在计算机中按补码规则存储，按位取反后加一， n&(-n) 的结果为 n 时为 2 的幂\n\n4(100) 16(1 0000)\n\nlet ispoweroftwo = function(n){\n  return n>0&&(n&(n-1))===0\n}\n\n\n1\n2\n3\n\n\nlet ispoweroftwo = function(n){\n  return n>0&&(n&-n)===n\n}\n\n\n1\n2\n3\n\n\n如果是给定范围的一个数判断\n\n * -2^31 <= n <= 2^31 - 1\n\n只需要判断 n 是否是 2^30 的约数即可\n\nlet ispoweroftwo = function(n){\n  const big = 1<<30\n  return n>0&&big%n === 0\n}\n\n\n1\n2\n3\n4\n\n\n自己的题解\n\nvar ispoweroftwo = function(n) {\n    if(n<1){\n        return false\n    }\n    while(n>1){\n        if(n%2){\n            return false\n        }\n        n/=2\n    }\n    return true\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n扩展题：\n\n幂为4\n\n方法一：\n\n如果n是4的幂，那么该数也是2的幂且二进制中的1出现在偶数个二进制位上\n\n可以构造一个 mask 整数 ，*mask*=(10101010101010101010101010101010)2\n\n与 n 进行与运算，结果为0表示该数为 4 的幂\n\nlet ispoweroffour = function(n) {\n    return n > 0 && (n & (n - 1)) === 0 && (n & 0xaaaaaaaa) === 0;\n};\n\n\n1\n2\n3\n\n\n方法二：取模\n\nlet ispoweroffour = function(n) {\n    return n > 0 && (n & (n - 1)) === 0 && n % 3 === 1;\n};\n\n\n1\n2\n3\n\n\n4的幂，除3取模一定为1\n\n总结：\n\n该题型关键解法，在于找到 n&(n-1)=0 的类似规律\n\n\n# 题目二：\n\n> 题目 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略空格、字母的大小写。\n> \n> 示例 输入："a man, a plan, a canal: panama"，输出：true\n> \n> 限定语言：c、 c++、java、python、javascript v8\n\n该类题型解法： 直接使用 reverse()自带回文函数、双指针、栈等\n\n此题，首先需要先去除非字母和数字的字符，后将字母全部转化为小写后进行判断\n\n/**\n * @param {string} s\n * @return {boolean}\n */\nvar ispalindrome = function(s) {\n  let len = s.length\n  let left = 0 , right = len-1\n  s = s.tolowercase()\n  while(left<right){\n    if(!isvail(s[left])){\n       left++\n       continue\n    }else if(!isvail(s[right])){\n       right--\n       continue\n    }\n    if(s[left]==s[right]){\n       left++\n       right--\n       continue\n    }\n   \treturn false\n  } \n  return true\n};\n\nlet isvail = function(c){\n  if(c>=\'a\'&&c<=\'z\'){\n     return true\n  }\n  if(c>=\'0\'&&c<=\'9\'){\n     return true\n  }\n  return false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n自己题解\n\n力扣上更简洁的写法\n\nvar ispalindrome = function(s) {\n   s=s.replace(/[^a-za-z0-9]/g,"").replace(/\\s/g,"").tolowercase();\n    let i=0,j=s.length-1;\n    while(i<j){\n        if(s[i]!=s[j]){\n           return false;\n        }\n        i++;\n        j--;\n    }\nreturn true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意：\n\n如果使用 reverse() 函数，会改变原有数组，使用 tostring() 进行比较\n\n\n# 题目三：\n\n给你一个字符串 s，找到 s 中最长的回文子串。\n\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n自己的题解，暴力\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestpalindrome = function(s) {\n    let len = 0;\n    let rs = \'\';\n    for(let i=0;i<=s.length;i++){\n        for(let j=i+1;j<=s.length;j++){\n            //暴力解法\n            let nrs = s.slice(i,j)\n            if(ishw(nrs)){//如果截取的是回文串\n                if(nrs.length>len){\n                    len = nrs.length\n                    rs = nrs\n                }\n            }\n        }\n    }\n    return rs\n};\n\n//判断回文字符串\nlet ishw = function(s){\n    for(let i=0,j=s.length-1;i<j;i++,j--){\n        if(s[i]!==s[j]){\n            return false\n        }\n    }\n    return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n运行效率极差，不学算法碰到类似题目，想破脑袋都想不出啊😭\n\n\n# 题目四：\n\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n滑动窗口\n\n如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的。k+1到rk的字符串显然是不重复的，并且少了原本的第k个字符\n\n解法：当字符串不重复时 right ++ ，当字符串重复是 left++ 进入下一个循环\n\nlet getmax = function(s){\n  if(s.length<=1) return s.length\n  let left = 0, right = 1\n  let max = 0 , rs=[]\n  while(right<s.length){\n  \trs = s.slice(left,right)\n    if(rs.indexof(s.charat(right))>-1){\n       left++//开新循环\n       continue\n    }else {\n      right++\n    }\n    max = max > right-left ? max:right-left\n  }\n  return max \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 选择题\n\n 1.  下列哪些是 html5 的新特性 abcd\n     \n     a . 语义标签\n     \n     b . canvas 绘图\n     \n     c. <audio> 元素\n     \n     d. 增强型表单\n\n 2.  下面可以继承的属性有哪些 acd\n     \n     a. font-size\n     \n     b. background\n     \n     c. color\n     \n     d. cursor\n\n 3.  对于一条100m的宽带，理论下载速度上限是多少 a\n     \n     a. 12.5mb/s\n     \n     b. 100mb/s\n     \n     c. 10mb/s\n     \n     d. 10mb.s\n\n 4.  关于 for of 和 for in 的描述，正确的是 a d\n     \n     a. for in 可以循环普通对象\n     \n     b. for of 可以循环普通对象\n     \n     c. 都不可以循环数组\n     \n     d. 都可以循环数组\n\n 5.  关于事件冒泡描述正确的是 a\n     \n     a. 从元素目标向 document 冒泡\n     \n     b. 从 document 向目标元素冒泡\n     \n     c. 从 document 向目标元素冒泡，在从目标元素向 documnet 冒泡\n     \n     d. 以上都不是\n\n 6.  以下哪些 script 标签属性会使脚本有可能在 domcontentloaded 事件之后加载 ad\n     \n     a. <script async>\n     \n     b. <script defer>\n     \n     c. <script type="module">\n     \n     d. <script type="module" async>\n\n 7.  以下哪些是 css 块级元素的特性 b d\n     \n     a . 宽度默认由其中的内容决定\n     \n     b . 高度默认由其中的内容决定\n     \n     c . 可以被拆分到多行\n     \n     d . 可以通过height 属性指定高度\n\n 8.  以下关于跨域说法错误的是 a\n     \n     a. http://example.com/a.html 和 https://example.com/b.html 是相同的域名，属于同源\n     \n     b. 跨域资源共享规范中规定了除了get之外的 http 请求，或者搭配某些 mini 类型的 post 请求，浏览器需要先发送一个 options 请求\n     \n     c. css中通过 @font-face 使用字体也会有跨域问题\n     \n     d. cookie、localstorage 和 indexeddb 都会受到同源策略的限制\n\n 9.  下列哪些可以实现浏览器存储数据 abd\n     \n     a. cookie\n     \n     b. localstorage\n     \n     c. session\n     \n     d. sessionstorage\n\n 10. 对以下代码说法正确的是 a\n     \n     let arr = [1,2,3,4,5]\n     let arr2 = [1,,3]\n     \n     \n     1\n     2\n     \n     \n     a. 执行 arr.length = 3 ，此时数组为 [1,2,3]\n     \n     b. 执行 arr[10] = 11 , 此时 arr.length 为 6\n     \n     c. 执行 delete arr[2] ，此时 arr.length 为 4，数组为 [1,2,4,5]\n     \n     d. arr2.length 的长度为 2\n\n 11. 在 css 选择器当中， 优先级排序正确的是 d\n     \n     a. id选择器 > 标签选择器 > 类选择器\n     \n     b. 标签选择器 > 类选择器 > id 选择器\n     \n     c. 类选择器>标签选择器>id选择器\n     \n     d. id选择器>类选择器>标签选择器\n\n 12. 如以下代码所示，给 body 绑定两个事件后，调用 document.body.click() 输出的结果是 a\n     \n     document.body.addeventlistener(\'click\',()=>{\n       promise.resolve().then(()=>{\n         console.log(1)\n       })\n       console.log(2)\n     },false)\n     document.body.addeventlistener(\'click\',()=>{\n       promise.resolve().then(()=>{\n         console.log(3)\n       })\n       console.log(4)\n     },false)\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     \n     \n     a. 2, 4, 1, 3 b. 2, 1, 4, 3 c. 1, 2, 3, 4 d. 1, 3, 2, 4\n\n 13. 浮动会导致页面的非正常显示，以下几种清除浮动的方法，哪个是不推荐使用的 d\n     \n     a. 在浮动元素末尾添加一个空的标签例如 <div style="clear:both">\n     \n     b. 通过设置父元素 overflow 值为 hidden\n     \n     c. 给父元素添加clearfix类\n     \n     d. 父元素也设置浮动\n\n 14. 以下代码运行结果是 d\n     \n     var f = function (){\n       console.log("1")\n     }\n     function f(){\n       console.log("2")\n     }\n     f();\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     \n     \n     a. undefined b. 报错 c. 2 d. 1\n\n 15. 下列说法正确的有哪些 a c\n     \n     a. visibility：hidden 表示所占据的空间位置仍然存在，仅为视觉上的完全透明\n     \n     b.display：none 不为被隐藏的对象保留其物理空间\n     \n     c. visibility：hidden 与 display：none 两者没有本质上的区别\n     \n     d. visibility：hidden 回流与重绘\n\n 16. 若主机甲与主机已建立一条 tcp 链接，最大段长 mss 为 1kb，往反时间rtt为 2ms，则在不出现拥塞的前提下，拥塞窗口用 8kb 增长到 32kb 所需要的最长时长是 d\n     \n     a. 4ms b. 8ms c. 24ms d. 48ms\n\n 17. 以下对html标签的使用，哪些是符合语义的 a c\n     \n     a. 使用 table 展示表格数据\n     \n     b. 使用 span 表示按钮\n     \n     c. 使用 article 展示文章内容\n     \n     d. 使用 p 标签展示文章标题\n\n 18. 包过滤防火墙对数据包的过滤依据不包括哪些 c\n     \n     a. 源ip地址\n     \n     b. 源端口号\n     \n     c. mac地址\n     \n     d. 目标ip地址',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"01day01-html与css",frontmatter:{title:"01day01-html与css",date:"2023-02-07T15:17:40.000Z",permalink:"/pages/332858/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/07.%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88/01.%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E9%9D%92%E8%AE%AD%E8%90%A5/01day01-html%E4%B8%8Ecss.html",relativePath:"07.面试综合/01.字节前端青训营/01day01-html与css.md",key:"v-690a5e5f",path:"/pages/332858/",headers:[{level:2,title:"HTML",slug:"html",normalizedTitle:"html",charIndex:14},{level:3,title:"标题 h1-h6",slug:"标题-h1-h6",normalizedTitle:"标题 h1-h6",charIndex:655},{level:3,title:"链接标签 a",slug:"链接标签-a",normalizedTitle:"链接标签 a",charIndex:683},{level:3,title:"输入 input",slug:"输入-input",normalizedTitle:"输入 input",charIndex:717},{level:3,title:"图片 img",slug:"图片-img",normalizedTitle:"图片 img",charIndex:998},{level:3,title:"音频 audio",slug:"音频-audio",normalizedTitle:"音频 audio",charIndex:1033},{level:3,title:"视频 video",slug:"视频-video",normalizedTitle:"视频 video",charIndex:1046},{level:3,title:"列表标签",slug:"列表标签",normalizedTitle:"列表标签",charIndex:1059},{level:3,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:1213},{level:3,title:"语义化",slug:"语义化",normalizedTitle:"语义化",charIndex:1384},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:19}],headersStr:"HTML 标题 h1-h6 链接标签 a 输入 input 图片 img 音频 audio 视频 video 列表标签 引用 语义化 CSS",content:'# 【青训营day01】- HTML与CSS\n\n什么是前端\n\n * 使用web技术栈解决多端GUI人机交互的问题\n\nHTML (内容)、CSS （样式）、JavaScript （行为）、通过 网络协议 ，与服务器端进行交互\n\n需要关注的问题\n\n * 美观\n * 功能\n * 无障碍\n * 安全\n * 性能\n * 兼容\n * 体验\n * ......\n\n前端的边界不止于网页\n\nnode、electron、React Native、Web RTC 、WebGL、WebASSEMBLY\n\n\n# HTML\n\nHyperText Markup Language\n\n标签可以设置属性：<img src="photo.jpg"/>\n\n一个例子\n\n<!doctype html> \n<html>\n  <head>\n    <mate charset="UTF-8"></mate>\n    <title>页面标签</title>\n  </head>\n  <body>\n    <h1>一级标题</h1>\n    <p> 段落内容</p>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * <!doctype html> html的版本\n * <mate> 元信息\n\n注意：\n\n * 标签和属性不区分大小写，推荐小写\n * 空标签可以不闭合，比如 input、mate\n * 属性值推荐使用双引号包裹\n * 某些属性值可以省略，比如 required、readonly\n\n\n# 标题 h1-h6\n\n不同标题标签对应不同的等级\n\n\n# 链接标签 a\n\n<a href="xxURL">官网</>\n\n\n# 输入 input\n\n * <input /> - 普通输入框\n\n * <input type = "range"/> - 滑轮选择\n\n * <input type = "number"/> - 数字输入框\n\n * <input type = "data"/> - 时间选择框\n\n * <textarea/> - 长文本输入框\n\n * <input type = "checkbox"/> - 复选框\n\n * <input type = "radio"/> - 单选框\n\n * <select> - 下拉框\n\n * <datalist> - 数据列表元素\n\n\n# 图片 img\n\n<img src="xxURL" alt/>\n\n\n# 音频 audio\n\n\n# 视频 video\n\n\n# 列表标签\n\n * <ol></ol> - 有序列表\n * <ul></ul> - 无序列表\n * <li></li> - 列表项\n\n<dl>\n  <dt>导演</dt>\n  <dd>陈凯歌</dd>\n  <dt>主演</dt>\n  <dd>xxx</dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 引用\n\n * <blockquote> - 整段引用\n\n * <p> - 段落\n\n * <pre> - 预定义格式文本，该元素中的文本通常按照原文件中的编排\n\n * <cite> - 句子中引用\n\n * <q> - 引用短的文本\n\n * code - 代码引用\n\n * <strong> - 强调\n\n * <em> - 句子中的强调\n\n\n# 语义化\n\n开发者应该遵循语义来编写 HTML\n\n * 了解每个标签和属性的含义\n * 思考什么标签最适合描述这个内容\n * 不适用可视化工具生成代码\n\nHTML传达的是内容结构框架，而不是样式。\n\n代码的可读性、可维护性、搜索引擎优化、提升无障碍性就是有语义化的HTML作用好处\n\n\n\nhtml5 语义化页面标准结构\n\n教学往往都是引路人，MDN\n\n\n# CSS',normalizedContent:'# 【青训营day01】- html与css\n\n什么是前端\n\n * 使用web技术栈解决多端gui人机交互的问题\n\nhtml (内容)、css （样式）、javascript （行为）、通过 网络协议 ，与服务器端进行交互\n\n需要关注的问题\n\n * 美观\n * 功能\n * 无障碍\n * 安全\n * 性能\n * 兼容\n * 体验\n * ......\n\n前端的边界不止于网页\n\nnode、electron、react native、web rtc 、webgl、webassembly\n\n\n# html\n\nhypertext markup language\n\n标签可以设置属性：<img src="photo.jpg"/>\n\n一个例子\n\n<!doctype html> \n<html>\n  <head>\n    <mate charset="utf-8"></mate>\n    <title>页面标签</title>\n  </head>\n  <body>\n    <h1>一级标题</h1>\n    <p> 段落内容</p>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * <!doctype html> html的版本\n * <mate> 元信息\n\n注意：\n\n * 标签和属性不区分大小写，推荐小写\n * 空标签可以不闭合，比如 input、mate\n * 属性值推荐使用双引号包裹\n * 某些属性值可以省略，比如 required、readonly\n\n\n# 标题 h1-h6\n\n不同标题标签对应不同的等级\n\n\n# 链接标签 a\n\n<a href="xxurl">官网</>\n\n\n# 输入 input\n\n * <input /> - 普通输入框\n\n * <input type = "range"/> - 滑轮选择\n\n * <input type = "number"/> - 数字输入框\n\n * <input type = "data"/> - 时间选择框\n\n * <textarea/> - 长文本输入框\n\n * <input type = "checkbox"/> - 复选框\n\n * <input type = "radio"/> - 单选框\n\n * <select> - 下拉框\n\n * <datalist> - 数据列表元素\n\n\n# 图片 img\n\n<img src="xxurl" alt/>\n\n\n# 音频 audio\n\n\n# 视频 video\n\n\n# 列表标签\n\n * <ol></ol> - 有序列表\n * <ul></ul> - 无序列表\n * <li></li> - 列表项\n\n<dl>\n  <dt>导演</dt>\n  <dd>陈凯歌</dd>\n  <dt>主演</dt>\n  <dd>xxx</dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 引用\n\n * <blockquote> - 整段引用\n\n * <p> - 段落\n\n * <pre> - 预定义格式文本，该元素中的文本通常按照原文件中的编排\n\n * <cite> - 句子中引用\n\n * <q> - 引用短的文本\n\n * code - 代码引用\n\n * <strong> - 强调\n\n * <em> - 句子中的强调\n\n\n# 语义化\n\n开发者应该遵循语义来编写 html\n\n * 了解每个标签和属性的含义\n * 思考什么标签最适合描述这个内容\n * 不适用可视化工具生成代码\n\nhtml传达的是内容结构框架，而不是样式。\n\n代码的可读性、可维护性、搜索引擎优化、提升无障碍性就是有语义化的html作用好处\n\n\n\nhtml5 语义化页面标准结构\n\n教学往往都是引路人，mdn\n\n\n# css',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"day02-js",frontmatter:{title:"day02-js",date:"2023-02-07T15:17:40.000Z",permalink:"/pages/0da785/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/07.%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88/01.%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E9%9D%92%E8%AE%AD%E8%90%A5/03.day02-js.html",relativePath:"07.面试综合/01.字节前端青训营/03.day02-js.md",key:"v-3c1c174c",path:"/pages/0da785/",headers:[{level:2,title:"前言：如何写好JS",slug:"前言-如何写好js",normalizedTitle:"前言：如何写好js",charIndex:2},{level:2,title:"职能分离",slug:"职能分离",normalizedTitle:"职能分离",charIndex:36},{level:2,title:"JS组件封装",slug:"js组件封装",normalizedTitle:"js组件封装",charIndex:979},{level:3,title:"结构设计",slug:"结构设计",normalizedTitle:"结构设计",charIndex:1073},{level:3,title:"加上JS行为",slug:"加上js行为",normalizedTitle:"加上js行为",charIndex:3229},{level:3,title:"重构-插件化",slug:"重构-插件化",normalizedTitle:"重构-插件化",charIndex:7444},{level:3,title:"重构-模板化",slug:"重构-模板化",normalizedTitle:"重构-模板化",charIndex:9526},{level:3,title:"重构-抽象化",slug:"重构-抽象化",normalizedTitle:"重构-抽象化",charIndex:14575}],headersStr:"前言：如何写好JS 职能分离 JS组件封装 结构设计 加上JS行为 重构-插件化 重构-模板化 重构-抽象化",content:"# 前言：如何写好JS\n\n * HTML、CSS、JavaScript 职能分离\n * 组件封装\n * 应用函数式编程思想\n\n\n# 职能分离\n\n在使用 js 编写代码时，要注意 js 最好只负责网页的行为。以下例子说明\n\nconst btn = document.getElementById('modeBtn')\nbtn.addEventListener('click',(e)=>{\n  if(e.target.innerHTML === '🌝'){\n    body.style.backgroundColor = 'black';\n    body.style.color = 'white';\n    body.style.innerHTML = '🌛';\n  }else{\n    body.style.backgroundColor = 'white';\n    body.style.color = 'black';\n    body.style.innerHTML = '🌝';\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这种写法在JS中直接操作了CSS样式，不够规范或者说没有体现出职能分离的作用（用JS完成了CSS的工作），对此进行改进的写法\n\nconst btn = document.getElementById('modeBtn')\nbtn.addEventListener('click',(e)=>{\n  const body = document.body\n  if(body.clasName !== 'night'){\n    body.className = 'night';\n  }else{\n    body.className = '';\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这种写法虽然没有直接操作css样式，但是还不够完美的各司其职。对于这种纯展示的交互，可以使用纯 CSS提供的功能来完成\n\n参考：青训营-深夜食堂-3 - 码上掘金 (juejin.cn)\n\n结论：\n\n 1. HTML/CSS/JS 各司其职\n 2. 应当避免不必要的由JS直接操作样式\n 3. 可以用 class 来表示状态\n 4. 纯展示类交互寻求零 js 方案\n\n\n# JS组件封装\n\n组件是指web页面上抽取出来一个个包含模板（HTML）、功能（JS）和样式的（CSS）的单元。好的模板具有：正确性、扩展性、复用性\n\n需求：使用JS封装一个轮播图\n\n\n# 结构设计\n\nhtml\n\n<div id=\"my-slider\" class=\"slider-list\">\n  <ul>\n    <li class=\"slider-list__item--selected\">\n      <img src=\"https://p5.ssl.qhimg.com/t0119c74624763dd070.png\"/>\n    </li>\n    <li class=\"slider-list__item\">\n      <img src=\"https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\"/>\n    </li>\n    <li class=\"slider-list__item\">\n      <img src=\"https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\"/>\n    </li>\n    <li class=\"slider-list__item\">\n      <img src=\"https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\"/>\n    </li>\n  </ul>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ncss\n\n#my-slider{\n  position: relative;\n  width:790px;\n}\n.slider-list ul{\n  list-style-type:none;\n  postion: relative;\n  padding: 0;\n  margin: 0;\n}\n.slider-list_item,\n.slider-list_item--selected{\n  postion: absolute;\n  transition: opacity 1s;\n  opacity: 0;\n  text-aligen: center;\n}\n.slider-list_item--selected{\n  transition: opacity 1s;\n  opacity: 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n经典教学轮播图的结构设计\n\nclass Slider{\n  constructor(id){//构造函数\n    this.container =doucment.getElementById(id);\n    this.items = this.container.querySelectorAll('.slider-list_item, .slider-list_item--selected');\n  }\n  getSelectedItem(){//获取选中list\n    const selected = this.container.querySelector('.slider-list_item--selected');\n    return selected;\n  }\n  getSelectedItemIndex(){//获取选中list的index\n    return Array.from(this.items).indexOf(this.getGetSelectedItem());\n  }\n  slideTo(idx){\n    const selected = this.getSelectedItem();\n    if(selected){\n      selected.className = 'slider-list_item';\n    }\n    const item = this.item[idx];\n    if(item){\n      item.className = 'slider-list_item--selected';\n    }\n  }\n  slideNext(){\n    const currentIdx = this.getSelectedItemIndex();\n    const nextIdx = (currentIdx+1) % this.items.length;\n    this.slideTo(nextIdx);\n  }\n  slidePrevious(){\n   \tconst currentIdx = this.getSelectedItemIndex();\n    const previousIdx = (this.items.length+currentIdx-1) % this.items.length;\n    this.slideTo(nextIdx); \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n青训营-轮播图-1 - 码上掘金 (juejin.cn)\n\n\n# 加上JS行为\n\n加上控件\n\nhtml\n\n<a class=\"slide-list__next\"></a>\n<a class=\"slide-list__previous\"></a>\n<div class=\"slide-list__control\">\n  <span class=\"slide-list__control-buttons--selected\"></span>\n  <span class=\"slide-list__control-buttons\"></span>\n  <span class=\"slide-list__control-buttons\"></span>\n  <span class=\"slide-list__control-buttons\"></span>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ncss\n\n.slider-list_control {\n  position: realative;\n  display: table;\n  background-color: rgba(255,255,255,0.5);\n  padding: 5px;\n  border-radius: 12px;\n  bottom: 30px;\n  margin: auto;\n}\n.slide-list__next,\n.slide-list__previous{\n  display: inline-block;\n  position: absolute;\n  top: 50%;\n  margin-top: -25px;\n  width: 30px;\n  height: 50px;\n  font-size: 24px;\n  text-align: center;\n  line-height: 50px;\n  overflow: hidden;\n  border: none;\n  background: transparent;\n  color: white;\n  background: rgba(0,0,0,0.2);\n  cursor: pointer;\n  opacity: 0;\n  transition: opacity 0.5s;\n}\n.slide-list__previous {\n  left: 0;\n}\n.slide-list__next{\n  right: 0;\n}\n#my-slider:hover .slide-list__previous,\n#my-slider:hover .slide-list__next {\n  opacity: 1;\n}\n\n.slide-list__previous:after {\n  content: '<';\n}\n\n.slide-list__next:after {\n  content: '>';\n}\n.slide-list__control-buttons,\n.slide-list__control-buttons--selected{\n  display: inline-block;\n  width: 15px;\n  height: 15px;\n  border-radius: 50%;\n  margin: 0 5px;\n  background-color: white;\n  cursor: pointer;\n}\n.slide-list__control-buttons--selected {\n  background-color: red;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n修改原有js\n\nconstructor(id,cycle=3000){\n  this.container = document.getElementById(id);\n  this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected');\n  this.cycle = cycle;\n  const controller = this.container.querySelector('.slide-list__control');\n  if(controller){\n     const buttons = controller.querySelectorAll('.slide-list__control-buttons,.slide-list__control-buttons--selected');\n     controller.addEventListener = ('mouseover',e=>{\n       const idx = Array.from(buttons).indexOf(e.target);\n       if(idx>=0){\n          this.slideTo(idx);\n         \tthis.stop();//暂停定时器，防止效果冲突\n       }\n     });\n    controller.addEventListener('mouseout',e=>{\n      this.start();\n    })\n    //这个方法会更新 buttons 的选中\n    this.container.addEventListener('slide', evt => {\n        const idx = evt.detail.index\n        const selected = controller.querySelector('.slide-list__control-buttons--selected');\n        if(selected) selected.className = 'slide-list__control-buttons';\n        buttons[idx].className = 'slide-list__control-buttons--selected';\n      })\n  }\n  const previous = this.container.querySelector('.slide-list-previous');\n  if(previous){\n     previous.addEventListener('click',e=>{\n       this.stop();\n       this.sliderPrevious();\n       this.start();\n       e.preventDefault();\n     })\n  }\n  const next = this.container.querySelector('.slide-list-next');\n  if(next){\n     next.addEventListener('click',e=>{\n       this.stop();\n       this.slideNext();\n       this.start();\n       e.preventDefault();\n     })\n  }\n  slideTo(idx){\n    let selected = this.getSelectedItem();\n    if(selected){\n       selected.className = 'slider-list__item';\n    }\n    let item = this.items[idx];\n    if(item){\n      item.className = 'slider-list__item--selected';\n    }\n    const detail = {index:idx}\n    //接口表示由程序出于某个目的而创建的事件\n    const event = new CustomEvent('slide',\t\t\t\t{bubbles:true,detail})\n    //会向一个指定的事件目标派发一个 Event 事件\n    this.container.dispatchEvent(event)\n  }\n  start(){\n    this.stop();\n    this._timer = setInterval(()=>this.slideNext(), this.cycle);\n  }\n  stop(){\n    clearInterval(this._timer);\n  }\n}\nconst slider = new Slider('my-slider');\nslider.start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n至此一个功能完整的轮播图就做出来了\n\n青训营-轮播图-2 - 码上掘金 (juejin.cn)\n\n此时的轮播图虽然功能完整、但是有许多可以改进的地方。。比如当我们想要删除部分模块时，如删除 buttons-list 这个轮播小控件、或者 next、previous 按钮时。。就需要重新修改、删除代码\n\n解决优化方法：把模块做成插件\n\n如下所示\n\n\n# 重构-插件化\n\n * 将控制元素做抽取成插件\n * 插件与组件之间通过 依赖注入 方式建立联系\n\n对 js 代码进行改进\n\nclass Slider {\n  constructor(id,cycle=3000){\n    this.container = document.getElementById(id);\n    this.items = this.container.querySelectorAll('slider-list__item, .slider-list__item--selected')\n    this.cycle = cycle;\n  }\n  // 添加插件注册器\n  registerPlugins(...plugins){\n    plugins.forEach(plugin = >plugin(this))\n  }\n}\n // 编写插件功能\nfunction pluginController(slider){\n  const controller = slider.container.querySelector('.slide-list__control')\n  if(controller){\n     controller.addEventListener('mouseover', evt=>{\n      const idx = Array.from(buttons).indexOf(evt.target);\n      if(idx >= 0){\n        slider.slideTo(idx);\n        slider.stop();\n      }\n    });\n\n    controller.addEventListener('mouseout', evt=>{\n      slider.start();\n    });\n\n    slider.addEventListener('slide', evt => {\n      const idx = evt.detail.index\n      const selected = controller.querySelector('.slide-list__control-buttons--selected');\n      if(selected) selected.className = 'slide-list__control-buttons';\n      buttons[idx].className = 'slide-list__control-buttons--selected';\n    });\n     }\n  function pluginPrevious(slider){\n  const previous = slider.container.querySelector('.slide-list__previous');\n  if(previous){\n    previous.addEventListener('click', evt => {\n      slider.stop();\n      slider.slidePrevious();\n      slider.start();\n      evt.preventDefault();\n    });\n  }  \n}\n\nfunction pluginNext(slider){\n  const next = slider.container.querySelector('.slide-list__next');\n  if(next){\n    next.addEventListener('click', evt => {\n      slider.stop();\n      slider.slideNext();\n      slider.start();\n      evt.preventDefault();\n    });\n  }  \n}\n}\nconst slider = new Slider('my-slider');\nslider.registerPlugins(pluginController, pluginPrevious, pluginNext);\nslider.start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n这样就可以增删不需要的功能了，青训营-轮播图-3 - 码上掘金 (juejin.cn)\n\n但是还有个问题——样式仍然存在，于是有了更加优化的版本——模板化，如下\n\n\n# 重构-模板化\n\n将HTML模板化，更易于扩展\n\n改造 HTML 和 JS\n\n留一个div，作为轮播图的人柱力\n\n<div id=\"my-slider\" class=\"slider-list\"></div>\n\n\n1\n\n\njs\n\nclass Slider{\n  contructor(id,opts = {images:[],cycle:3000}){\n    this.container = document.getElementById(id);\n    this.options = opts;\n    this.container.innerHTML = this.render();\n    this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected');\n    this.cycle = opts.cycle || 3000;\n    this.slideTo(0);\n  }\n  render(){\n    const images  = this.options.images;\n    const content = images.map(image=>`\n\t\t\t<li class=\"slider-list__item\">\n\t\t\t\t<img src=\"${image}\"/>\n\t\t\t</li>\n\t\t`.trim())\n    return `<ul>${content.join('')}</ul>`\n  }\n  registerPlugins(...plugins){\n    plugins.forEach(plugin=>{\n      const pluginContainer = document.createElement('div');\n      pluginContainer.className = '.slider-list__plugin';\n      pluginContainer.innerHTML = plugin.render(this.options.images);\n      this.container.appendChild(pluginContainer)\n      plugin.action(this)\n    })\n  }\n   getSelectedItem(){\n    const selected = this.container.querySelector('.slider-list__item--selected');\n    return selected\n  }\n  getSelectedItemIndex(){\n    return Array.from(this.items).indexOf(this.getSelectedItem());\n  }\n  slideTo(idx){\n    const selected = this.getSelectedItem();\n    if(selected){ \n      selected.className = 'slider-list__item';\n    }\n    let item = this.items[idx];\n    if(item){\n      item.className = 'slider-list__item--selected';\n    }\n    \n    const detail = {index: idx}\n    const event = new CustomEvent('slide', {bubbles:true, detail})\n    this.container.dispatchEvent(event)\n  }\n  slideNext(){\n    const currentIdx = this.getSelectedItemIndex();\n    const nextIdx = (currentIdx + 1) % this.items.length;\n    this.slideTo(nextIdx);\n  }\n  slidePrevious(){\n    const currentIdx = this.getSelectedItemIndex();\n    const previousIdx = (this.items.length + currentIdx - 1) % this.items.length;\n    this.slideTo(previousIdx);  \n  }\n  addEventListener(type, handler){\n    this.container.addEventListener(type, handler);\n  }\n  start(){\n    this.stop();\n    this._timer = setInterval(()=>this.slideNext(), this.cycle);\n  }\n  stop(){\n    clearInterval(this._timer);\n  }\n}\nconst pluginController = {\n  render(images){\n    return `\n\t\t\t<div class=\"slide-list__control\">\n\t\t\t\t${images.map(image,i)=>`\n\t\t\t\t\t<span class=\"slide-list__control-buttons${i===0?'--selected':''}\"></span>).join('')}\n\t\t\t</div>\n\t\t`.trim();\n  }\n  action(){\n    const controller = slider.container.querySelector('.slide-list__control');\n    \n    if(controller){\n      const buttons = controller.querySelectorAll('.slide-list__control-buttons, .slide-list__control-buttons--selected');\n      controller.addEventListener('mouseover', evt => {\n        const idx = Array.from(buttons).indexOf(evt.target);\n        if(idx >= 0){\n          slider.slideTo(idx);\n          slider.stop();\n        }\n      });\n\n      controller.addEventListener('mouseout', evt => {\n        slider.start();\n      });\n\n      slider.addEventListener('slide', evt => {\n        const idx = evt.detail.index\n        const selected = controller.querySelector('.slide-list__control-buttons--selected');\n        if(selected) selected.className = 'slide-list__control-buttons';\n        buttons[idx].className = 'slide-list__control-buttons--selected';\n      });\n    }    \n  }\n}\nconst pluginPrevious = {\n  render(){\n    return `<a class=\"slide-list__previous\"></a>`;\n  },\n  action(slider){\n    const previous = slider.container.querySelector('.slide-list__previous');\n    if(previous){\n      previous.addEventListener('click', evt => {\n        slider.stop();\n        slider.slidePrevious();\n        slider.start();\n        evt.preventDefault();\n      });\n    }  \n  }\n};\n\nconst pluginNext = {\n  render(){\n    return `<a class=\"slide-list__next\"></a>`;\n  },\n  action(slider){\n    const previous = slider.container.querySelector('.slide-list__next');\n    if(previous){\n      previous.addEventListener('click', evt => {\n        slider.stop();\n        slider.slideNext();\n        slider.start();\n        evt.preventDefault();\n      });\n    }  \n  }\n};\nconst slider = new Slider('my-slider', {images: ['https://p5.ssl.qhimg.com/t0119c74624763dd070.png',\n     'https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg',\n     'https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg',\n     'https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg'], cycle:3000});\n\nslider.registerPlugins(pluginController, pluginPrevious, pluginNext);\nslider.start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n\n\n这样HTML也抽象成了模板，功能删除后。插件的模板也一同删除了\n\n青训营-轮播图-4 - 码上掘金 (juejin.cn)\n\n大佬解决仍然不够完美，于是又有了抽象化\n\n\n# 重构-抽象化\n\n将组件的通用模型抽取出来\n\nclass Component {\n  constructor(id,opts={name,data:[]){\n    this.container = document.getEelmentById(id);\n  \tregisterPlugins(...plugins){\n      plugins.forEach(plugin=>{\n        const pluginContainer = document.createElement('div')\n        pluginContainer.className = `.${name}__plugin`;\n      pluginContainer.innerHTML = plugin.render(this.options.data);\n      this.container.appendChild(pluginContainer);\n      plugin.action(this)\n      })\n    }\n  }\n\trender(data) {\n    /* abstract */\n    return ''\n  }\n}\nclass Slider extends Component{\n  constructor(id,opts = {name:'slider-list',data:[],cycle:3000})\n  super(id,opts)\n  this.items = this.container.querySelectorAll('.slider-list__item, .slider-list__item--selected');\n    this.cycle = opts.cycle || 3000;\n    this.slideTo(0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n青训营-轮播图-final - 码上掘金 (juejin.cn)\n\n结算如此，大佬解决代码依旧不够完美，比如父子节点的调用处理问题、js中依靠大量的css类名属性等问题是否有优化空间。",normalizedContent:"# 前言：如何写好js\n\n * html、css、javascript 职能分离\n * 组件封装\n * 应用函数式编程思想\n\n\n# 职能分离\n\n在使用 js 编写代码时，要注意 js 最好只负责网页的行为。以下例子说明\n\nconst btn = document.getelementbyid('modebtn')\nbtn.addeventlistener('click',(e)=>{\n  if(e.target.innerhtml === '🌝'){\n    body.style.backgroundcolor = 'black';\n    body.style.color = 'white';\n    body.style.innerhtml = '🌛';\n  }else{\n    body.style.backgroundcolor = 'white';\n    body.style.color = 'black';\n    body.style.innerhtml = '🌝';\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这种写法在js中直接操作了css样式，不够规范或者说没有体现出职能分离的作用（用js完成了css的工作），对此进行改进的写法\n\nconst btn = document.getelementbyid('modebtn')\nbtn.addeventlistener('click',(e)=>{\n  const body = document.body\n  if(body.clasname !== 'night'){\n    body.classname = 'night';\n  }else{\n    body.classname = '';\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这种写法虽然没有直接操作css样式，但是还不够完美的各司其职。对于这种纯展示的交互，可以使用纯 css提供的功能来完成\n\n参考：青训营-深夜食堂-3 - 码上掘金 (juejin.cn)\n\n结论：\n\n 1. html/css/js 各司其职\n 2. 应当避免不必要的由js直接操作样式\n 3. 可以用 class 来表示状态\n 4. 纯展示类交互寻求零 js 方案\n\n\n# js组件封装\n\n组件是指web页面上抽取出来一个个包含模板（html）、功能（js）和样式的（css）的单元。好的模板具有：正确性、扩展性、复用性\n\n需求：使用js封装一个轮播图\n\n\n# 结构设计\n\nhtml\n\n<div id=\"my-slider\" class=\"slider-list\">\n  <ul>\n    <li class=\"slider-list__item--selected\">\n      <img src=\"https://p5.ssl.qhimg.com/t0119c74624763dd070.png\"/>\n    </li>\n    <li class=\"slider-list__item\">\n      <img src=\"https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\"/>\n    </li>\n    <li class=\"slider-list__item\">\n      <img src=\"https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\"/>\n    </li>\n    <li class=\"slider-list__item\">\n      <img src=\"https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\"/>\n    </li>\n  </ul>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ncss\n\n#my-slider{\n  position: relative;\n  width:790px;\n}\n.slider-list ul{\n  list-style-type:none;\n  postion: relative;\n  padding: 0;\n  margin: 0;\n}\n.slider-list_item,\n.slider-list_item--selected{\n  postion: absolute;\n  transition: opacity 1s;\n  opacity: 0;\n  text-aligen: center;\n}\n.slider-list_item--selected{\n  transition: opacity 1s;\n  opacity: 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n经典教学轮播图的结构设计\n\nclass slider{\n  constructor(id){//构造函数\n    this.container =doucment.getelementbyid(id);\n    this.items = this.container.queryselectorall('.slider-list_item, .slider-list_item--selected');\n  }\n  getselecteditem(){//获取选中list\n    const selected = this.container.queryselector('.slider-list_item--selected');\n    return selected;\n  }\n  getselecteditemindex(){//获取选中list的index\n    return array.from(this.items).indexof(this.getgetselecteditem());\n  }\n  slideto(idx){\n    const selected = this.getselecteditem();\n    if(selected){\n      selected.classname = 'slider-list_item';\n    }\n    const item = this.item[idx];\n    if(item){\n      item.classname = 'slider-list_item--selected';\n    }\n  }\n  slidenext(){\n    const currentidx = this.getselecteditemindex();\n    const nextidx = (currentidx+1) % this.items.length;\n    this.slideto(nextidx);\n  }\n  slideprevious(){\n   \tconst currentidx = this.getselecteditemindex();\n    const previousidx = (this.items.length+currentidx-1) % this.items.length;\n    this.slideto(nextidx); \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n青训营-轮播图-1 - 码上掘金 (juejin.cn)\n\n\n# 加上js行为\n\n加上控件\n\nhtml\n\n<a class=\"slide-list__next\"></a>\n<a class=\"slide-list__previous\"></a>\n<div class=\"slide-list__control\">\n  <span class=\"slide-list__control-buttons--selected\"></span>\n  <span class=\"slide-list__control-buttons\"></span>\n  <span class=\"slide-list__control-buttons\"></span>\n  <span class=\"slide-list__control-buttons\"></span>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ncss\n\n.slider-list_control {\n  position: realative;\n  display: table;\n  background-color: rgba(255,255,255,0.5);\n  padding: 5px;\n  border-radius: 12px;\n  bottom: 30px;\n  margin: auto;\n}\n.slide-list__next,\n.slide-list__previous{\n  display: inline-block;\n  position: absolute;\n  top: 50%;\n  margin-top: -25px;\n  width: 30px;\n  height: 50px;\n  font-size: 24px;\n  text-align: center;\n  line-height: 50px;\n  overflow: hidden;\n  border: none;\n  background: transparent;\n  color: white;\n  background: rgba(0,0,0,0.2);\n  cursor: pointer;\n  opacity: 0;\n  transition: opacity 0.5s;\n}\n.slide-list__previous {\n  left: 0;\n}\n.slide-list__next{\n  right: 0;\n}\n#my-slider:hover .slide-list__previous,\n#my-slider:hover .slide-list__next {\n  opacity: 1;\n}\n\n.slide-list__previous:after {\n  content: '<';\n}\n\n.slide-list__next:after {\n  content: '>';\n}\n.slide-list__control-buttons,\n.slide-list__control-buttons--selected{\n  display: inline-block;\n  width: 15px;\n  height: 15px;\n  border-radius: 50%;\n  margin: 0 5px;\n  background-color: white;\n  cursor: pointer;\n}\n.slide-list__control-buttons--selected {\n  background-color: red;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n修改原有js\n\nconstructor(id,cycle=3000){\n  this.container = document.getelementbyid(id);\n  this.items = this.container.queryselectorall('.slider-list__item, .slider-list__item--selected');\n  this.cycle = cycle;\n  const controller = this.container.queryselector('.slide-list__control');\n  if(controller){\n     const buttons = controller.queryselectorall('.slide-list__control-buttons,.slide-list__control-buttons--selected');\n     controller.addeventlistener = ('mouseover',e=>{\n       const idx = array.from(buttons).indexof(e.target);\n       if(idx>=0){\n          this.slideto(idx);\n         \tthis.stop();//暂停定时器，防止效果冲突\n       }\n     });\n    controller.addeventlistener('mouseout',e=>{\n      this.start();\n    })\n    //这个方法会更新 buttons 的选中\n    this.container.addeventlistener('slide', evt => {\n        const idx = evt.detail.index\n        const selected = controller.queryselector('.slide-list__control-buttons--selected');\n        if(selected) selected.classname = 'slide-list__control-buttons';\n        buttons[idx].classname = 'slide-list__control-buttons--selected';\n      })\n  }\n  const previous = this.container.queryselector('.slide-list-previous');\n  if(previous){\n     previous.addeventlistener('click',e=>{\n       this.stop();\n       this.sliderprevious();\n       this.start();\n       e.preventdefault();\n     })\n  }\n  const next = this.container.queryselector('.slide-list-next');\n  if(next){\n     next.addeventlistener('click',e=>{\n       this.stop();\n       this.slidenext();\n       this.start();\n       e.preventdefault();\n     })\n  }\n  slideto(idx){\n    let selected = this.getselecteditem();\n    if(selected){\n       selected.classname = 'slider-list__item';\n    }\n    let item = this.items[idx];\n    if(item){\n      item.classname = 'slider-list__item--selected';\n    }\n    const detail = {index:idx}\n    //接口表示由程序出于某个目的而创建的事件\n    const event = new customevent('slide',\t\t\t\t{bubbles:true,detail})\n    //会向一个指定的事件目标派发一个 event 事件\n    this.container.dispatchevent(event)\n  }\n  start(){\n    this.stop();\n    this._timer = setinterval(()=>this.slidenext(), this.cycle);\n  }\n  stop(){\n    clearinterval(this._timer);\n  }\n}\nconst slider = new slider('my-slider');\nslider.start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n至此一个功能完整的轮播图就做出来了\n\n青训营-轮播图-2 - 码上掘金 (juejin.cn)\n\n此时的轮播图虽然功能完整、但是有许多可以改进的地方。。比如当我们想要删除部分模块时，如删除 buttons-list 这个轮播小控件、或者 next、previous 按钮时。。就需要重新修改、删除代码\n\n解决优化方法：把模块做成插件\n\n如下所示\n\n\n# 重构-插件化\n\n * 将控制元素做抽取成插件\n * 插件与组件之间通过 依赖注入 方式建立联系\n\n对 js 代码进行改进\n\nclass slider {\n  constructor(id,cycle=3000){\n    this.container = document.getelementbyid(id);\n    this.items = this.container.queryselectorall('slider-list__item, .slider-list__item--selected')\n    this.cycle = cycle;\n  }\n  // 添加插件注册器\n  registerplugins(...plugins){\n    plugins.foreach(plugin = >plugin(this))\n  }\n}\n // 编写插件功能\nfunction plugincontroller(slider){\n  const controller = slider.container.queryselector('.slide-list__control')\n  if(controller){\n     controller.addeventlistener('mouseover', evt=>{\n      const idx = array.from(buttons).indexof(evt.target);\n      if(idx >= 0){\n        slider.slideto(idx);\n        slider.stop();\n      }\n    });\n\n    controller.addeventlistener('mouseout', evt=>{\n      slider.start();\n    });\n\n    slider.addeventlistener('slide', evt => {\n      const idx = evt.detail.index\n      const selected = controller.queryselector('.slide-list__control-buttons--selected');\n      if(selected) selected.classname = 'slide-list__control-buttons';\n      buttons[idx].classname = 'slide-list__control-buttons--selected';\n    });\n     }\n  function pluginprevious(slider){\n  const previous = slider.container.queryselector('.slide-list__previous');\n  if(previous){\n    previous.addeventlistener('click', evt => {\n      slider.stop();\n      slider.slideprevious();\n      slider.start();\n      evt.preventdefault();\n    });\n  }  \n}\n\nfunction pluginnext(slider){\n  const next = slider.container.queryselector('.slide-list__next');\n  if(next){\n    next.addeventlistener('click', evt => {\n      slider.stop();\n      slider.slidenext();\n      slider.start();\n      evt.preventdefault();\n    });\n  }  \n}\n}\nconst slider = new slider('my-slider');\nslider.registerplugins(plugincontroller, pluginprevious, pluginnext);\nslider.start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n这样就可以增删不需要的功能了，青训营-轮播图-3 - 码上掘金 (juejin.cn)\n\n但是还有个问题——样式仍然存在，于是有了更加优化的版本——模板化，如下\n\n\n# 重构-模板化\n\n将html模板化，更易于扩展\n\n改造 html 和 js\n\n留一个div，作为轮播图的人柱力\n\n<div id=\"my-slider\" class=\"slider-list\"></div>\n\n\n1\n\n\njs\n\nclass slider{\n  contructor(id,opts = {images:[],cycle:3000}){\n    this.container = document.getelementbyid(id);\n    this.options = opts;\n    this.container.innerhtml = this.render();\n    this.items = this.container.queryselectorall('.slider-list__item, .slider-list__item--selected');\n    this.cycle = opts.cycle || 3000;\n    this.slideto(0);\n  }\n  render(){\n    const images  = this.options.images;\n    const content = images.map(image=>`\n\t\t\t<li class=\"slider-list__item\">\n\t\t\t\t<img src=\"${image}\"/>\n\t\t\t</li>\n\t\t`.trim())\n    return `<ul>${content.join('')}</ul>`\n  }\n  registerplugins(...plugins){\n    plugins.foreach(plugin=>{\n      const plugincontainer = document.createelement('div');\n      plugincontainer.classname = '.slider-list__plugin';\n      plugincontainer.innerhtml = plugin.render(this.options.images);\n      this.container.appendchild(plugincontainer)\n      plugin.action(this)\n    })\n  }\n   getselecteditem(){\n    const selected = this.container.queryselector('.slider-list__item--selected');\n    return selected\n  }\n  getselecteditemindex(){\n    return array.from(this.items).indexof(this.getselecteditem());\n  }\n  slideto(idx){\n    const selected = this.getselecteditem();\n    if(selected){ \n      selected.classname = 'slider-list__item';\n    }\n    let item = this.items[idx];\n    if(item){\n      item.classname = 'slider-list__item--selected';\n    }\n    \n    const detail = {index: idx}\n    const event = new customevent('slide', {bubbles:true, detail})\n    this.container.dispatchevent(event)\n  }\n  slidenext(){\n    const currentidx = this.getselecteditemindex();\n    const nextidx = (currentidx + 1) % this.items.length;\n    this.slideto(nextidx);\n  }\n  slideprevious(){\n    const currentidx = this.getselecteditemindex();\n    const previousidx = (this.items.length + currentidx - 1) % this.items.length;\n    this.slideto(previousidx);  \n  }\n  addeventlistener(type, handler){\n    this.container.addeventlistener(type, handler);\n  }\n  start(){\n    this.stop();\n    this._timer = setinterval(()=>this.slidenext(), this.cycle);\n  }\n  stop(){\n    clearinterval(this._timer);\n  }\n}\nconst plugincontroller = {\n  render(images){\n    return `\n\t\t\t<div class=\"slide-list__control\">\n\t\t\t\t${images.map(image,i)=>`\n\t\t\t\t\t<span class=\"slide-list__control-buttons${i===0?'--selected':''}\"></span>).join('')}\n\t\t\t</div>\n\t\t`.trim();\n  }\n  action(){\n    const controller = slider.container.queryselector('.slide-list__control');\n    \n    if(controller){\n      const buttons = controller.queryselectorall('.slide-list__control-buttons, .slide-list__control-buttons--selected');\n      controller.addeventlistener('mouseover', evt => {\n        const idx = array.from(buttons).indexof(evt.target);\n        if(idx >= 0){\n          slider.slideto(idx);\n          slider.stop();\n        }\n      });\n\n      controller.addeventlistener('mouseout', evt => {\n        slider.start();\n      });\n\n      slider.addeventlistener('slide', evt => {\n        const idx = evt.detail.index\n        const selected = controller.queryselector('.slide-list__control-buttons--selected');\n        if(selected) selected.classname = 'slide-list__control-buttons';\n        buttons[idx].classname = 'slide-list__control-buttons--selected';\n      });\n    }    \n  }\n}\nconst pluginprevious = {\n  render(){\n    return `<a class=\"slide-list__previous\"></a>`;\n  },\n  action(slider){\n    const previous = slider.container.queryselector('.slide-list__previous');\n    if(previous){\n      previous.addeventlistener('click', evt => {\n        slider.stop();\n        slider.slideprevious();\n        slider.start();\n        evt.preventdefault();\n      });\n    }  \n  }\n};\n\nconst pluginnext = {\n  render(){\n    return `<a class=\"slide-list__next\"></a>`;\n  },\n  action(slider){\n    const previous = slider.container.queryselector('.slide-list__next');\n    if(previous){\n      previous.addeventlistener('click', evt => {\n        slider.stop();\n        slider.slidenext();\n        slider.start();\n        evt.preventdefault();\n      });\n    }  \n  }\n};\nconst slider = new slider('my-slider', {images: ['https://p5.ssl.qhimg.com/t0119c74624763dd070.png',\n     'https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg',\n     'https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg',\n     'https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg'], cycle:3000});\n\nslider.registerplugins(plugincontroller, pluginprevious, pluginnext);\nslider.start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n\n\n这样html也抽象成了模板，功能删除后。插件的模板也一同删除了\n\n青训营-轮播图-4 - 码上掘金 (juejin.cn)\n\n大佬解决仍然不够完美，于是又有了抽象化\n\n\n# 重构-抽象化\n\n将组件的通用模型抽取出来\n\nclass component {\n  constructor(id,opts={name,data:[]){\n    this.container = document.geteelmentbyid(id);\n  \tregisterplugins(...plugins){\n      plugins.foreach(plugin=>{\n        const plugincontainer = document.createelement('div')\n        plugincontainer.classname = `.${name}__plugin`;\n      plugincontainer.innerhtml = plugin.render(this.options.data);\n      this.container.appendchild(plugincontainer);\n      plugin.action(this)\n      })\n    }\n  }\n\trender(data) {\n    /* abstract */\n    return ''\n  }\n}\nclass slider extends component{\n  constructor(id,opts = {name:'slider-list',data:[],cycle:3000})\n  super(id,opts)\n  this.items = this.container.queryselectorall('.slider-list__item, .slider-list__item--selected');\n    this.cycle = opts.cycle || 3000;\n    this.slideto(0);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n青训营-轮播图-final - 码上掘金 (juejin.cn)\n\n结算如此，大佬解决代码依旧不够完美，比如父子节点的调用处理问题、js中依靠大量的css类名属性等问题是否有优化空间。",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"day03-ts",frontmatter:{title:"day03-ts",date:"2023-02-07T15:17:40.000Z",permalink:"/pages/e7f910/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/07.%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88/01.%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E9%9D%92%E8%AE%AD%E8%90%A5/03.day03-ts.html",relativePath:"07.面试综合/01.字节前端青训营/03.day03-ts.md",key:"v-5c6d07b0",path:"/pages/e7f910/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"day04-HTTP",frontmatter:{title:"day04-HTTP",date:"2023-02-07T15:17:40.000Z",permalink:"/pages/4dacdd/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/07.%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88/01.%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E9%9D%92%E8%AE%AD%E8%90%A5/04.day04-HTTP.html",relativePath:"07.面试综合/01.字节前端青训营/04.day04-HTTP.md",key:"v-1fb423a2",path:"/pages/4dacdd/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"常用登录功能的逻辑",frontmatter:{title:"常用登录功能的逻辑",date:"2023-02-07T15:17:40.000Z",permalink:"/pages/b52f92/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/07.%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88/02.blog/01.%E5%B8%B8%E7%94%A8%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%9A%84%E9%80%BB%E8%BE%91.html",relativePath:"07.面试综合/02.blog/01.常用登录功能的逻辑.md",key:"v-d885a53e",path:"/pages/b52f92/",headers:[{level:2,title:"登录功能",slug:"登录功能",normalizedTitle:"登录功能",charIndex:2},{level:2,title:"cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:145}],headersStr:"登录功能 cookie",content:'# 登录功能\n\nHTTP 是无状态的协议，每一次 HTTP 请求和响应都是一次性的，服务器本身没有记录访问和响应的状态，无法分辨每一次发送者是否为同一浏览器。随着互联网的发展，有了此类的需求，为了进行会话跟踪就需要维护一个有记录的状态。这个状态就是用来记录请求是否来自同一会话的东西，采用 cookie 和 session 技术实现\n\n会话： 用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含 多次 请求和响应\n\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便同一次会话的多次请求 共享数据\n\n体现：网站登录后多个页面有用户名等信息、网站勾选 记住我 后会自动填充账户密码\n\n * 客户端会话跟踪技术 ： cookie\n * 服务端会话跟踪技术：session\n\n\n# cookie\n\n客户端会话技术，将数据保存到客户端，每次请求都携带 cookie 数据\n\n\n\n服务端提供了两个 Servlet，分别为 A 和 B\n\n 1. 浏览器发送HTTP请求1给服务端，服务端ServletA接收请求并进行业务处理\n 2. 服务端ServletA在处理的过程中可以创建一个Cookie对象并将name=zs的数据存入Cookie\n 3. 服务端ServletA在响应数据的时候，会把Cookie对象响应给浏览器\n 4. 浏览器接收到响应数据，会把Cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就 建立了一次会话\n 5. 在同一次会话 中浏览器再次发送HTTP请求2给服务端ServletB，浏览器会携带Cookie对象中的所有数据\n 6. ServletB接收到请求和数据后，就可以获取到存储在Cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享\n\n基本使用\n\n创建 Cookie 对象\n\nCookie cookie = new Cookie("key","value");\n\n\n1\n\n\n发送 Cookie 对象\n\nresponse.addCookie(cookie);\n\n\n1\n\n\n获取 Cookie 对象\n\nCookie[] cookies = request.getCookies();\n\n\n1\n\n\n使用 Cookie 对象\n\ncookie.getName();\ncookie.getValue();\n\n\n1\n2\n',normalizedContent:'# 登录功能\n\nhttp 是无状态的协议，每一次 http 请求和响应都是一次性的，服务器本身没有记录访问和响应的状态，无法分辨每一次发送者是否为同一浏览器。随着互联网的发展，有了此类的需求，为了进行会话跟踪就需要维护一个有记录的状态。这个状态就是用来记录请求是否来自同一会话的东西，采用 cookie 和 session 技术实现\n\n会话： 用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含 多次 请求和响应\n\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便同一次会话的多次请求 共享数据\n\n体现：网站登录后多个页面有用户名等信息、网站勾选 记住我 后会自动填充账户密码\n\n * 客户端会话跟踪技术 ： cookie\n * 服务端会话跟踪技术：session\n\n\n# cookie\n\n客户端会话技术，将数据保存到客户端，每次请求都携带 cookie 数据\n\n\n\n服务端提供了两个 servlet，分别为 a 和 b\n\n 1. 浏览器发送http请求1给服务端，服务端servleta接收请求并进行业务处理\n 2. 服务端servleta在处理的过程中可以创建一个cookie对象并将name=zs的数据存入cookie\n 3. 服务端servleta在响应数据的时候，会把cookie对象响应给浏览器\n 4. 浏览器接收到响应数据，会把cookie对象中的数据存储在浏览器内存中，此时浏览器和服务端就 建立了一次会话\n 5. 在同一次会话 中浏览器再次发送http请求2给服务端servletb，浏览器会携带cookie对象中的所有数据\n 6. servletb接收到请求和数据后，就可以获取到存储在cookie对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享\n\n基本使用\n\n创建 cookie 对象\n\ncookie cookie = new cookie("key","value");\n\n\n1\n\n\n发送 cookie 对象\n\nresponse.addcookie(cookie);\n\n\n1\n\n\n获取 cookie 对象\n\ncookie[] cookies = request.getcookies();\n\n\n1\n\n\n使用 cookie 对象\n\ncookie.getname();\ncookie.getvalue();\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"代码多环境开发",frontmatter:{title:"代码多环境开发",date:"2023-02-07T15:17:40.000Z",permalink:"/pages/0489e2/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/07.%E9%9D%A2%E8%AF%95%E7%BB%BC%E5%90%88/02.blog/02.%E4%BB%A3%E7%A0%81%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%BC%80%E5%8F%91.html",relativePath:"07.面试综合/02.blog/02.代码多环境开发.md",key:"v-bd509ace",path:"/pages/0489e2/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Browser",frontmatter:{title:"Browser",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/b48262/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/01.Browser.html",relativePath:"08.专栏/01.Browser.md",key:"v-661ac802",path:"/pages/b48262/",headers:[{level:2,title:"主要进程",slug:"主要进程",normalizedTitle:"主要进程",charIndex:422},{level:2,title:"渲染进程多线程",slug:"渲染进程多线程",normalizedTitle:"渲染进程多线程",charIndex:707},{level:2,title:"内核",slug:"内核",normalizedTitle:"内核",charIndex:395},{level:3,title:"常见浏览器内核？",slug:"常见浏览器内核",normalizedTitle:"常见浏览器内核？",charIndex:1421},{level:2,title:"检测版本",slug:"检测版本",normalizedTitle:"检测版本",charIndex:1522},{level:2,title:"判断访问设备",slug:"判断访问设备",normalizedTitle:"判断访问设备",charIndex:1670},{level:2,title:"JS单线程问题",slug:"js单线程问题",normalizedTitle:"js单线程问题",charIndex:2289},{level:2,title:"Event Loop",slug:"event-loop",normalizedTitle:"event loop",charIndex:1736},{level:2,title:"运行过程",slug:"运行过程",normalizedTitle:"运行过程",charIndex:2926},{level:2,title:"JS处理异步事件",slug:"js处理异步事件",normalizedTitle:"js处理异步事件",charIndex:4302},{level:2,title:"事件队列有优先级吗",slug:"事件队列有优先级吗",normalizedTitle:"事件队列有优先级吗",charIndex:4879},{level:2,title:"事件循环顺序",slug:"事件循环顺序",normalizedTitle:"事件循环顺序",charIndex:5143},{level:2,title:"process.nextTick",slug:"process-nexttick",normalizedTitle:"process.nexttick",charIndex:2812},{level:2,title:"setTimeout、setImmediate",slug:"settimeout、setimmediate",normalizedTitle:"settimeout、setimmediate",charIndex:6167},{level:3,title:"setTimeout",slug:"settimeout",normalizedTitle:"settimeout",charIndex:1027},{level:2,title:"栗子",slug:"栗子",normalizedTitle:"栗子",charIndex:6654},{level:2,title:"🅰️ 导航阶段",slug:"导航阶段",normalizedTitle:"🅰️ 导航阶段",charIndex:7399},{level:3,title:"①浏览器主进程",slug:"_1浏览器主进程",normalizedTitle:"①浏览器主进程",charIndex:7412},{level:4,title:"1.输入URL",slug:"_1-输入url",normalizedTitle:"1.输入url",charIndex:7423},{level:3,title:"②网络进程",slug:"_2网络进程",normalizedTitle:"②网络进程",charIndex:7723},{level:4,title:"2.URL请求",slug:"_2-url请求",normalizedTitle:"2.url请求",charIndex:7732},{level:4,title:"3. 准备渲染进程",slug:"_3-准备渲染进程",normalizedTitle:"3. 准备渲染进程",charIndex:10179},{level:4,title:"4. 提交文档",slug:"_4-提交文档",normalizedTitle:"4. 提交文档",charIndex:10270},{level:2,title:"🅱️ 渲染阶段",slug:"渲染阶段",normalizedTitle:"🅱️ 渲染阶段",charIndex:10441},{level:4,title:"5. 构建DOM树",slug:"_5-构建dom树",normalizedTitle:"5. 构建dom树",charIndex:10855},{level:4,title:"6. 构建CSSOM",slug:"_6-构建cssom",normalizedTitle:"6. 构建cssom",charIndex:11487},{level:4,title:"7. 样式计算",slug:"_7-样式计算",normalizedTitle:"7. 样式计算",charIndex:11937},{level:4,title:"8. 布局阶段",slug:"_8-布局阶段",normalizedTitle:"8. 布局阶段",charIndex:12033},{level:4,title:"9. 分层",slug:"_9-分层",normalizedTitle:"9. 分层",charIndex:12219},{level:3,title:"图层",slug:"图层",normalizedTitle:"图层",charIndex:12299},{level:4,title:"10. 图层绘制",slug:"_10-图层绘制",normalizedTitle:"10. 图层绘制",charIndex:12562},{level:4,title:"11. 切分图块",slug:"_11-切分图块",normalizedTitle:"11. 切分图块",charIndex:12667},{level:3,title:"④GPU进程",slug:"_4gpu进程",normalizedTitle:"④gpu进程",charIndex:12747},{level:4,title:"12. 栅格化",slug:"_12-栅格化",normalizedTitle:"12. 栅格化",charIndex:12757},{level:3,title:"⑤浏览器主进程",slug:"_5浏览器主进程",normalizedTitle:"⑤浏览器主进程",charIndex:12850},{level:4,title:"13. 合成与显示",slug:"_13-合成与显示",normalizedTitle:"13. 合成与显示",charIndex:12861},{level:2,title:"强缓存",slug:"强缓存",normalizedTitle:"强缓存",charIndex:7823},{level:3,title:"Expires(HTTP/1.0)",slug:"expires-http-1-0",normalizedTitle:"expires(http/1.0)",charIndex:14900},{level:3,title:"Cache-Control(HTTP/1.1)",slug:"cache-control-http-1-1",normalizedTitle:"cache-control(http/1.1)",charIndex:15119},{level:2,title:"协商缓存",slug:"协商缓存",normalizedTitle:"协商缓存",charIndex:7950},{level:3,title:"Last-Modified(HTTP/1.0)",slug:"last-modified-http-1-0",normalizedTitle:"last-modified(http/1.0)",charIndex:15880},{level:3,title:"ETag(HTTP/1.1)",slug:"etag-http-1-1",normalizedTitle:"etag(http/1.1)",charIndex:16202},{level:4,title:"强ETag",slug:"强etag",normalizedTitle:"强etag",charIndex:16662},{level:4,title:"弱ETag",slug:"弱etag",normalizedTitle:"弱etag",charIndex:16722},{level:3,title:"两者对比",slug:"两者对比",normalizedTitle:"两者对比",charIndex:16774},{level:2,title:"缓存存储",slug:"缓存存储",normalizedTitle:"缓存存储",charIndex:17071},{level:3,title:"Service Worker",slug:"service-worker",normalizedTitle:"service worker",charIndex:17153},{level:3,title:"Memory Cache",slug:"memory-cache",normalizedTitle:"memory cache",charIndex:17171},{level:3,title:"Disk Cache",slug:"disk-cache",normalizedTitle:"disk cache",charIndex:17187},{level:3,title:"Push Cache",slug:"push-cache",normalizedTitle:"push cache",charIndex:17201},{level:2,title:"XSS",slug:"xss",normalizedTitle:"xss",charIndex:11284},{level:3,title:"存储型",slug:"存储型",normalizedTitle:"存储型",charIndex:18664},{level:3,title:"反射型",slug:"反射型",normalizedTitle:"反射型",charIndex:18925},{level:3,title:"文档型",slug:"文档型",normalizedTitle:"文档型",charIndex:19150},{level:3,title:"突变型",slug:"突变型",normalizedTitle:"突变型",charIndex:19368},{level:3,title:"防范：一个信念，两个利用",slug:"防范-一个信念-两个利用",normalizedTitle:"防范：一个信念，两个利用",charIndex:19433},{level:4,title:"1.对输入转码过滤",slug:"_1-对输入转码过滤",normalizedTitle:"1.对输入转码过滤",charIndex:19449},{level:4,title:"2.利用CSP",slug:"_2-利用csp",normalizedTitle:"2.利用csp",charIndex:19617},{level:4,title:"3.HttpOnly",slug:"_3-httponly",normalizedTitle:"3.httponly",charIndex:19709},{level:2,title:"CSRF",slug:"csrf",normalizedTitle:"csrf",charIndex:19787},{level:3,title:"防范",slug:"防范",normalizedTitle:"防范",charIndex:19433},{level:4,title:"1.SameSite",slug:"_1-samesite",normalizedTitle:"1.samesite",charIndex:20465},{level:4,title:"2.验证来源站点",slug:"_2-验证来源站点",normalizedTitle:"2.验证来源站点",charIndex:21454},{level:4,title:"3.Token",slug:"_3-token",normalizedTitle:"3.token",charIndex:21596},{level:4,title:"4.安全框架",slug:"_4-安全框架",normalizedTitle:"4.安全框架",charIndex:21893},{level:2,title:"SQL注入",slug:"sql注入",normalizedTitle:"sql注入",charIndex:21922},{level:2,title:"iframe 攻击",slug:"iframe-攻击",normalizedTitle:"iframe 攻击",charIndex:22164},{level:2,title:"GET!==GET+POST",slug:"get-get-post",normalizedTitle:"get!==get+post",charIndex:22191},{level:2,title:"DDos",slug:"ddos",normalizedTitle:"ddos",charIndex:22238},{level:2,title:"DNS劫持",slug:"dns劫持",normalizedTitle:"dns劫持",charIndex:22699},{level:2,title:"其他攻击",slug:"其他攻击",normalizedTitle:"其他攻击",charIndex:23084},{level:2,title:"含义",slug:"含义",normalizedTitle:"含义",charIndex:11080},{level:2,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:4633},{level:2,title:"为啥用它？",slug:"为啥用它",normalizedTitle:"为啥用它？",charIndex:24740},{level:2,title:"WebSocket、HTTP",slug:"websocket、http",normalizedTitle:"websocket、http",charIndex:24869},{level:2,title:"cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:18612},{level:3,title:"多域名拆分",slug:"多域名拆分",normalizedTitle:"多域名拆分",charIndex:25725},{level:2,title:"session",slug:"session",normalizedTitle:"session",charIndex:25112},{level:3,title:"工作流程",slug:"工作流程",normalizedTitle:"工作流程",charIndex:26250},{level:2,title:"关系",slug:"关系",normalizedTitle:"关系",charIndex:11171},{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:5822},{level:2,title:"服务器咋知道session过期？",slug:"服务器咋知道session过期",normalizedTitle:"服务器咋知道session过期？",charIndex:27229},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:12191},{level:3,title:"cookie",slug:"cookie-2",normalizedTitle:"cookie",charIndex:18612},{level:3,title:"session",slug:"session-2",normalizedTitle:"session",charIndex:25112},{level:2,title:"分类",slug:"分类",normalizedTitle:"分类",charIndex:27782},{level:3,title:"localStorage",slug:"localstorage",normalizedTitle:"localstorage",charIndex:27789},{level:3,title:"sessionStorage",slug:"sessionstorage",normalizedTitle:"sessionstorage",charIndex:28130},{level:3,title:"相同点",slug:"相同点",normalizedTitle:"相同点",charIndex:28229},{level:2,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:14209},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:4491},{level:2,title:"IndexedDB",slug:"indexeddb",normalizedTitle:"indexeddb",charIndex:28624},{level:2,title:"set-cookie",slug:"set-cookie",normalizedTitle:"set-cookie",charIndex:29012},{level:2,title:"SameSite",slug:"samesite",normalizedTitle:"samesite",charIndex:20467},{level:2,title:"禁止JS访问cookie",slug:"禁止js访问cookie",normalizedTitle:"禁止js访问cookie",charIndex:29457},{level:2,title:"JS设置cookie",slug:"js设置cookie",normalizedTitle:"js设置cookie",charIndex:29520},{level:2,title:"cookie作用域",slug:"cookie作用域",normalizedTitle:"cookie作用域",charIndex:29917},{level:2,title:"跨域访问cookie",slug:"跨域访问cookie",normalizedTitle:"跨域访问cookie",charIndex:29958},{level:2,title:"没cookie有啥问题",slug:"没cookie有啥问题",normalizedTitle:"没cookie有啥问题",charIndex:30092},{level:2,title:"跨域在服务端真正执行？",slug:"跨域在服务端真正执行",normalizedTitle:"跨域在服务端真正执行？",charIndex:30799},{level:2,title:"目的",slug:"目的",normalizedTitle:"目的",charIndex:31254},{level:2,title:"解决跨域",slug:"解决跨域",normalizedTitle:"解决跨域",charIndex:31299},{level:3,title:"JSONP",slug:"jsonp",normalizedTitle:"jsonp",charIndex:31308},{level:3,title:"postMessage",slug:"postmessage",normalizedTitle:"postmessage",charIndex:32689},{level:3,title:"CORS",slug:"cors",normalizedTitle:"cors",charIndex:32773},{level:4,title:"简单请求",slug:"简单请求",normalizedTitle:"简单请求",charIndex:31101},{level:4,title:"withCredentials",slug:"withcredentials",normalizedTitle:"withcredentials",charIndex:35295},{level:4,title:"预检请求",slug:"预检请求",normalizedTitle:"预检请求",charIndex:30959},{level:4,title:"附身份凭证请求",slug:"附身份凭证请求",normalizedTitle:"附身份凭证请求",charIndex:37939},{level:3,title:"代理",slug:"代理",normalizedTitle:"代理",charIndex:13524},{level:3,title:"nginx 代理",slug:"nginx-代理",normalizedTitle:"nginx 代理",charIndex:38964},{level:4,title:"反向代理、负载均衡",slug:"反向代理、负载均衡",normalizedTitle:"反向代理、负载均衡",charIndex:39005},{level:3,title:"WebSocket",slug:"websocket-2",normalizedTitle:"websocket",charIndex:24497},{level:3,title:"document.domain + iframe",slug:"document-domain-iframe",normalizedTitle:"document.domain + iframe",charIndex:39372},{level:3,title:"location.hash + iframe",slug:"location-hash-iframe",normalizedTitle:"location.hash + iframe",charIndex:39532},{level:3,title:"window.name(共享变量) + iframe",slug:"window-name-共享变量-iframe",normalizedTitle:"window.name(共享变量) + iframe",charIndex:39573},{level:3,title:"Apache转发",slug:"apache转发",normalizedTitle:"apache转发",charIndex:39604},{level:2,title:"proxy",slug:"proxy",normalizedTitle:"proxy",charIndex:38792},{level:2,title:"跨域标准",slug:"跨域标准",normalizedTitle:"跨域标准",charIndex:39944},{level:2,title:"Cookie",slug:"cookie-4",normalizedTitle:"cookie",charIndex:19988},{level:2,title:"Cookie-session",slug:"cookie-session",normalizedTitle:"cookie-session",charIndex:40501},{level:2,title:"SSO",slug:"sso",normalizedTitle:"sso",charIndex:11493},{level:2,title:"Json Web Token",slug:"json-web-token",normalizedTitle:"json web token",charIndex:41079},{level:2,title:"Ajax轮询",slug:"ajax轮询",normalizedTitle:"ajax轮询",charIndex:41990},{level:2,title:"Websocket",slug:"websocket-3",normalizedTitle:"websocket",charIndex:42075},{level:2,title:"Service Worker",slug:"service-worker-2",normalizedTitle:"service worker",charIndex:17153},{level:2,title:"cookie",slug:"cookie-5",normalizedTitle:"cookie",charIndex:18612},{level:2,title:"localStorage",slug:"localstorage-2",normalizedTitle:"localstorage",charIndex:27789},{level:2,title:"web worker",slug:"web-worker",normalizedTitle:"web worker",charIndex:17290},{level:2,title:"Websocket",slug:"websocket-4",normalizedTitle:"websocket",charIndex:42075}],headersStr:"主要进程 渲染进程多线程 内核 常见浏览器内核？ 检测版本 判断访问设备 JS单线程问题 Event Loop 运行过程 JS处理异步事件 事件队列有优先级吗 事件循环顺序 process.nextTick setTimeout、setImmediate setTimeout 栗子 🅰️ 导航阶段 ①浏览器主进程 1.输入URL ②网络进程 2.URL请求 3. 准备渲染进程 4. 提交文档 🅱️ 渲染阶段 5. 构建DOM树 6. 构建CSSOM 7. 样式计算 8. 布局阶段 9. 分层 图层 10. 图层绘制 11. 切分图块 ④GPU进程 12. 栅格化 ⑤浏览器主进程 13. 合成与显示 强缓存 Expires(HTTP/1.0) Cache-Control(HTTP/1.1) 协商缓存 Last-Modified(HTTP/1.0) ETag(HTTP/1.1) 强ETag 弱ETag 两者对比 缓存存储 Service Worker Memory Cache Disk Cache Push Cache XSS 存储型 反射型 文档型 突变型 防范：一个信念，两个利用 1.对输入转码过滤 2.利用CSP 3.HttpOnly CSRF 防范 1.SameSite 2.验证来源站点 3.Token 4.安全框架 SQL注入 iframe 攻击 GET!==GET+POST DDos DNS劫持 其他攻击 含义 特点 为啥用它？ WebSocket、HTTP cookie 多域名拆分 session 工作流程 关系 区别 服务器咋知道session过期？ 应用 cookie session 分类 localStorage sessionStorage 相同点 优点 方法 IndexedDB set-cookie SameSite 禁止JS访问cookie JS设置cookie cookie作用域 跨域访问cookie 没cookie有啥问题 跨域在服务端真正执行？ 目的 解决跨域 JSONP postMessage CORS 简单请求 withCredentials 预检请求 附身份凭证请求 代理 nginx 代理 反向代理、负载均衡 WebSocket document.domain + iframe location.hash + iframe window.name(共享变量) + iframe Apache转发 proxy 跨域标准 Cookie Cookie-session SSO Json Web Token Ajax轮询 Websocket Service Worker cookie localStorage web worker Websocket",content:"# 浏览器\n\n\n\n浏览器是一个多进程架构，我们关心渲染进程(核心进程)\n\n为何使用多进程架构?\n\n多个线程共享 相同地址空间和资源，存在 线程之间可能恶意修改/获取 非授权数据 等 安全问题\n\n单进程浏览器： 1、不稳定。单进程中 插件、渲染线程崩溃导致 浏览器崩溃 2、不流畅。脚本（死循环）/插件会使浏览器卡顿 3、不安全。插件和脚本可获取OS 任意资源\n\n多进程浏览器： 1、解决不稳定。进程 相互隔离，一个页面/插件崩溃时，仅影响当前插件/页面 2、解决不流畅。脚本阻塞当前页面渲染进程，不影响其他页面 3、解决不安全。多进程架构使用沙箱。沙箱看成是OS给进程上一把锁，沙箱的程序可以运行，不能在硬盘上写入数据，不能在敏感位置读取数据\n\n> 沙箱 将渲染进程和OS隔离\n> \n> 利用OS提供的安全技术，渲染进程在执行过程中无法访问OS的数据，渲染进程需要访问系统资源时，通过浏览器内核实现，将访问结果通过IPC转发给渲染进程\n\n\n# 主要进程\n\n1、浏览器主进程\n\n控制页面创建、销毁、网络资源管理、下载等， 提供存储等功能\n\n浏览器进程中线程：\n\n 1. UI进程\n 2. 存储线程：控制文件的访问\n\n2、插件进程\n\n负责插件运行，插件易崩溃，需通过插件进程隔离，保证插件进程崩溃不会对浏览器/页面造成影响\n\n3、GPU进程\n\n最多一个，用于3D绘制等，从浏览器进程中独立出来\n\n4、浏览器渲染进程(浏览器内核)\n\n**每个Tab页对应一个进程，互不影响 ， 将HTML、CSS 和 JS转换为可以与用户交互的网页 **\n\n5、网络进程\n\n从浏览器进程中独立出来， 负责页面的网络资源加载\n\n\n\n\n# 渲染进程多线程\n\n1、GUI 线程\n\n渲染页面。在JS引擎运行脚本期间**，GUI渲染线程都是处于挂起状态的，被”冻结”了**\n\n2、JS 引擎线程\n\n**解析和执行 JS ，v8 引擎 跑在 JS 引擎线程上，没有单/多线程之说，因为解释这个语言的是 的线程 是单线程；**JS 引擎线程与 GUI 线程互斥，浏览器执行 JS 程序的时候，GUI 渲染线程 保存在一个队列当中；直到 JS 程序执行完成，才接着执行；如果 JS 执行时间过长，会影响页面的渲染，所有要尽量控制 JS 的大小\n\n3、定时触发线程\n\nJS引擎是单线程**， 处于阻塞线程状态会影响记计时的准确， 因此通过单独线程来计时并触发定时是更为合理的方案**\n\n为什么 setTimeout 不阻塞后面程序的运行，因为 setTimeout 不是由 JS 引擎线程完成，是由定时器触发线程完的，所以它们可以同时进行，定时器触发线程 在定时任务完成后 通知事件触发线程 往任务队列里添加事件\n\n4、事件触发线程\n\n当一个事件被触发时该线程把事件添加到待处理队列的队尾，等待JS引擎处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等\n\n5、异步 HTTP 请求线程\n\nXMLHttpRequest 连接 通过浏览器新开线程请求， 检测到状态变更，如果设置有回调，异步线程就产生状态变更事件放到 JS引擎的处理队列中等待处理\n\n\n# 内核\n\n浏览器内核 通过取得页面内容、整理信息、计算和组合最终输出可视化图像结果（渲染引擎）\n\n每一个tab页面可以看作是浏览器内核进程，浏览器内核是多线程的\n\n\n * # 常见浏览器内核？\n\nTrident内核：IE，360，搜狗等浏览器\n\nGecko内核：Firefox\n\nBlink内核：Opera7及以上\n\nWebkit内核：Safari，Chrome\n\n\n * # 检测版本\n\n 1. window.navigator.userAgent 不可靠，因为 userAgent可被改写，早期浏览器如 ie，会伪装自己的 userAgent值为 Mozilla躲过检测\n 2. 功能检测，根据每个浏览器独有特性判断，如 ie 独有 ActiveXObject\n\n\n# 判断访问设备\n\nnavigator.userAgent\n\n设备屏幕的宽度大小\n\n客户端操作系统类型(platform)\n\n\n# ⚠️Event Loop\n\n面试率超高的JS事件循环，看这篇就够了\n\n面试必问之 JS 事件循环（Event Loop），看这一篇足够\n\n事件循环，是指浏览器或Node解决JS单线程运行时不会阻塞的一种机制——我们经常使用异步的原理\n\n设置 2 个线程，一个负责程序本身的运行——“主线程”\n\n另一个负责主线程和其他进程（主要是各种 I/O 操作）的通信 ——“Event Loop 线程”\n\nJS 采用这种机制，解决单线程带来的问题\n\n> JS 引擎执行代码时会产生执行栈，调用异步 API，例如 setTimeout，setInterval，Promise 等回调触发时，会进入异步任务队列，当同步代码执行完成后，会去异步队列取出回调函数执行，形成事件循环\n\n事件循环任务：将队列和调用堆栈连接起来\n\n执行栈类似于函数调用栈的运行容器，当其为空，JS检查事件队列，将第一个任务压入栈中执行。若调用栈和微任务队列为空，事件循环检查宏任务队列是否还有任务，弹出进入调用栈执行再弹出\n\n * setTimeout回调 不是马上执行，而是最快可以多久后执行，因为它会等待调用 栈为空\n\n * 浏览器的渲染必须要调用栈为空时才会执行\n\n * 一个回调出栈，另一个回调进栈的间隙(此时栈空)，渲染得以顺利进行\n\n\n# JS单线程问题\n\nsetTimeout如果在主线程上运行会阻塞其他活动\n\n所以，需要做的就是，离开这个线程，同时运行这个任务\n\n作为浏览器脚本语言，JS主要用于 用户互动、操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题\n\n比如，假定JS同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂\n\n> JS异步实现？\n\n浏览器的内核多线程实现\n\n\n# Event Loop\n\n任务被分为 宏任务 和 微任务\n\n 1. 宏观：浏览器多线程（从宏观来看是多线程实现了异步）\n 2. 微观：Event Loop\n\n**常见的macrotask有：(一般由浏览器发起)**DOM渲染后触发\n\n 1. script整体代码\n 2. setImmediate(node )\n 3. setTimeout 和 setInterval\n 4. requestAnimationFrame？？不是宏任务！(CSS详述)\n 5. I/O\n 6. UI rendering\n\n> POSTMessage\n\n常见的microtask有：(一般由JS自身创建)DOM渲染前触发\n\n 1. process.nextTick (Node)\n 2. Promise callback(例如 promise.then)\n 3. Object.observe (基本已废弃)\n 4. MutationObserver\n\n\n# 运行过程\n\nJS 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都放到调用栈等待主线程执行\n\n单线程任务分为同步/异步任务，同步任务在调用栈中按照顺序等待主线程执行，异步任务在有了结果后，将注册的回调放入任务队列中等待主线程空闲时（调用栈被清空），被读取到栈内等待主线程执行\n\n线程都有自己的运行数据存储空间，堆的空间比较大，所以存储对象\n\n函数调用就入栈，执行完函数体的代码自动从栈中弹出——调用栈\n\n当栈中的函数出栈时，栈为空的话，我们会调用一些异步函数，这个异步函数会找它们的异步处理模块，异步处理模块包括定时器、promise、Ajax等，异步处理模块会找它们各自对应的线程，线程向任务队列中添加事件，再从任务队列中取出事件，执行对应的回调\n\n3个注意点：\n\n 1. 当宏任务执行完，会去执行所有微任务\n 2. 微任务执行完再去执行下一个宏任务，等调用栈为空时执行一个微任务；调用栈不为空时，任务队列的微任务一直等；微任务执行完又去取任务队列的宏任务**，依次执行宏任务，执行宏任务时检查当前是否存在微任务，若有微任务就去 执行完所有微任务，然后 再去执行宏任务 **\n\n注意点：\n\n 1. 一个 Event Loop 有一/多个 task queue（任务队列）\n 2. 每个 Event Loop 有一个 microtask queue（微任务队列）\n 3. requestAnimationFrame 不在任务队列也不在微任务队列，在渲染阶段执行\n 4. 任务需要多次事件循环才能执行完，微任务是一次性执行完\n 5. 第一个宏任务（主程序）执行完，执行全部的微任务（一个 promise），再执行下一个宏任务（settimeout）\n\n（1）所有同步任务都在主线程上执行，形成 执行栈\n\n（2）主线程之外， 存在 \"任务队列\"（task queue）。只要异步任务有 结果，就在\"任务队列\"之中放置一个事件\n\n（3）同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册\n\n（4）当指定 事情完成 ，Event Table 将这个函数移入Event Queue\n\n（3）一旦\"执行栈\"中的所有同步任务执行完毕，系统 读取\"任务队列（event Queue）\"的异步任务,如果有就推入主线程\n\n（4）主线程不断重复以上步骤\n\n要把本次宏任务下所产生的微任务全部执行完才会执行下一个宏任务，记住是产生的，没有产生的不会执行！\nasync函数是对一些异步操作的处理方式，一旦调用会立即执行，其中可包含微任务和宏任务\nawait语句后面的代码回放进微任务队列执行\n\n\n1\n2\n3\n\n\n**一轮事件循环就是第一轮宏任务和微任务结束。**当微任务队列清空后，一个事件循环结束\n\n正确的一次 Event loop 顺序是：\n\n 1. 执行同步代码，这属于宏任务\n 2. 执行栈为空，查询是否有微任务需要执行\n 3. 执行所有微任务\n 4. 必要的话渲染 UI\n 5. 然后开始下一轮 Event loop，执行宏任务中的异步代码\n\n如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中\n\n\n# JS处理异步事件\n\n * 同步任务：主线程排队执行的任务，只有前一个执行完毕，才能执行后一个\n * 异步任务：不进入主线程、进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行，该任务才进入主线程执行\n\n既然JS是单线程的,只能在一条线程上执行, 如何实现异步 ?——事件循环(event loop)\n\n> 执行栈\n\njs 生成 与 方法对应的执行环境（context）——执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this。当方法被依次调用，同一时间只能执行一个，于是这些方法被排队在单独的地方——执行栈\n\n> 任务队列\n\njs的另一大特点——非阻塞， 关键在于任务队列\n\njs引擎遇到 异步任务后 不会一直等待其返回结果，而是 将这个任务 压入到任务队列 ，继续执行执行栈中的 任务。当 异步任务返回结果后，js 将这个任务加入与当前执行栈不同的另一个队列——任务队列\n\n被放入任务队列不会立刻执行，而是等待当前执行栈中的所有任务 执行完毕， 主线程处于闲置状态时，去查找任务队列是否有任务。如果有， 主线程会从中取出排在第一位的事件， 把这个任务对应的回调放入执行栈中， 执行其 同步代码， 反复 形成 无限的循环\n\n\n# 事件队列有优先级吗\n\n\n# Node事件循环\n\n官网描述：\n\nNode.js启动时，初始化事件循环，处理输入脚本，这个脚本可能异步API调用、调度计时器/调用process.nextTick()，然后开始处理事件循环\n\nJS和Node.js 基于V8 引擎 ，浏览器 包含 异步方式在 Node 是一样的。除此之外，Node 还有一些其他的异步形式\n\nmicrotask 在事件循环的各个阶段之间执行（一个阶段执行完毕，就去执行microtask队列）。和浏览器不同，nodejs是来都来了，一次执行完该阶段的任务好了\n\n\n# 事件循环顺序\n\n\n\n 1. timers 阶段 ：执行setTimeout和setInterval的callback\n\n 2. pending IO callbacks：系统操作的回调，如定时器和setImmediate回调，上一轮循环中少数callback的执行\n\n 3. idle，prepare：仅在内部使用\n\n 4. poll：等待新的 I/O 事件进来，其他所有宏任务都属于poll阶段，最重要的阶段，执行pending callback，适当的情况会阻塞在这个阶段\n    \n    1. 当 poll 中没有定时器，发生两件事\n    \n    * poll 队列不为空，遍历回调队列并同步执行，直到队列为空或者系统限制\n    \n    * poll 队列为空，两件事\n      \n      * 有 setImmediate 需要执行，poll 阶段停止并进入到 check 阶段执行 setImmediate\n      * 没有 setImmediate 需要执行，等待回调被加入到队列中并立即执行回调\n      \n      如果有别的定时器需被执行，回到 timer 阶段执行回调\n\n 5. check：setImmediate回调执行\n\n 6. close callbacks：内部使用，关闭回调执行\n\n\n\n每个阶段都去执行完当前阶段的任务队列，继续执行当前阶段的微任务队列，只有当前阶段所有微任务都执行完，才进入下阶段。这里也是与浏览器中逻辑差异较大的地方，不过浏览器不区分这些阶段，也少了很多异步操作类型，不用刻意区分两者区别\n\n另一个与浏览器的差异体现在同一个阶段不同任务执行\n\n * 浏览器，宏任务完成优先处理微任务\n * Node，处于 timers 阶段，先将所有 timer 回调执行完之后再执行微任务\n\n差异可以用浏览器和 NodeJS 10 对比验证。感觉有点反程序员？因此 NodeJS 在 11 后，修改了此处逻辑使其与浏览器尽量一致，每个 timer 执行后都检查微任务队列， NodeJS 11 后的输出已经和浏览器一致了\n\n\n# process.nextTick\n\n将一个函数推迟到代码中所书写的下一个同步方法执行完毕或异步方法的事件回调开始执行时调用，该方法 参数是被推迟的函数\n\nprocess.nextTic和微任务啥时候执行?process.nextTick优先于微任务\n\n\n# setTimeout、setImmediate\n\n二者相似，区别在调用时机不同\n\n * setImmediate —— check 阶段\n\n * setTimeout poll 阶段为空闲时，且设定时间到达后执行， timer 阶段执行\n\n\n * # setTimeout\n\n每一个setTimeout在执行时，会返回唯一ID\n\nfor ( var i=1; i<=5; i++) {\n\tsetTimeout( function timer(j) {\n\t\tconsole.log( j );\n\t}, i*1000, i);\n}\n\n\n1\n2\n3\n4\n5\n\n\n利用setTimeout第三个参数解决循环输出问题\n\nprocess.nextTick() 比 promise.then()执行早，同步任务后，其他所有异步任务前，优先执行 nextTick。可以想象是把 nextTick 的任务放到了当前循环的后面，与 promise.then() 类似，但比 promise.then() 更前面。\n\n当前同步代码执行完成后，不管其他异步任务，尽快执行 nextTick\n\n\n# 栗子\n\nfunction cb(msg) {\n    return function () {\n        console.log(msg)\n    }\n}\n\nsetTimeout(cb('setTimeout'), 100)\nsetTimeout(cb('setImmediate'))\nprocess.nextTick(cb('process.nextTick'))\ncb('Main process')()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# node和浏览器事件循环区别\n\n流程对比：\n\n 1. 执行 Script 代码\n 2. 把微任务队列清空：Node 清空微任务队列的手法比较特别。在浏览器中，我们只有一个微任务队列需要接受处理；但在 Node 中，有两类微任务队列：next-tick 队列和其它队列。next-tick 队列专门收敛 process.nextTick 派发的异步任务。清空队列时，优先清空 next-tick 队列中的任务，随后才会清空其它微任务\n 3. 开始执行 macro-task（宏任务）。Node 执行宏任务的方式与浏览器不同：在浏览器中，每次出队执行一个宏任务； Node 中，我们每次会尝试清空当前阶段对应宏任务队列里的所有任务\n 4. 步骤3开始，进入 3 -> 2 -> 3 -> 2…的循环\n\n\n# ✅ 输入URL回车后……\n\n>  1. URL解析\n>  2. 查找缓存\n>  3. 域名解析：浏览器>系统>本地hosts>根域名>顶级域名>二级域名>三级域名\n>  4. TCP三次握手\n>  5. 发送HTTP请求\n>  6. 处理请求并返回\n>  7. 解析渲染页面\n>  8. TCP四次挥手\n\n\n# 🅰️ 导航阶段\n\n\n# ①浏览器主进程\n\n# 1.输入URL\n\n**1、**浏览器进程检查url，组装协议，构成完整url，两种情况：\n\n * 输入 搜索内容：地址栏使用浏览器默认搜索引擎，合成新的带搜索关键字的URL\n * 输入 URL：地址栏根据规则，给这段内容加上协议，合成为完整URL\n\n**2、**浏览器进程通过进程间通信（IPC）把url请求发送给网络进程\n\nURL一般包括几大部分：\n\n * protocol，协议头，如http，ftp\n * host，主机域名/IP地址\n * port，端口号\n * path，目录路径\n * query，查询参数\n * fragment， #后的hash值，一般用来定位到某个位置\n\n\n\n\n# ②网络进程\n\n# 2.URL请求\n\n**3、**网络进程接收到url请求后检查本地是否缓存\n\n * 浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，不会发送请求。如果没有命中，进入下一步\n\n * 没有命中强缓存规则，浏览器发送请求，根据请求头的If-Modified-Since(last_modified)和If-None-Match(ETag)判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，进入下一步\n\n * 如果前两步都没有命中，直接从服务端获取资源\n\n**4、**准备IP地址和端口：DNS解析时先查找缓存，没有再使用DNS服务器解析，查找顺序：\n\n * 浏览器缓存\n\n * 本机缓存\n\n * hosts文件\n\n * 路由器缓存\n\n * ISP DNS缓存\n\n * DNS递归查询（本地DNS服务器 -> 权限DNS服务器 -> 顶级DNS服务器 -> 13台根DNS服务器）\n\n\n\n> 域名查询时可能经过了CDN调度器（如果有cdn存储功能的话）\n> \n> dns解析很耗时，解析域名过多会让首屏加载变得过慢，可以考虑 dns-prefetch优化\n> \n> https://developer.mozilla.org/zh-CN/docs/Web/Performance/dns-prefetch\n\n**5、**等待TCP队列：浏览器为每个域名最多维护6个TCP连接，如果发起一个HTTP请求时，这 6个 TCP连接都处于忙碌状态，请求会处于排队状态，解决：\n\n * 采用域名分片技术：将一个站点的资源放在多个（CDN）域名下面\n   \n   * 升级为HTTP2，就没有6个TCP连接的限制了\n\n**6、**三次握手建立TCP连接：\n\n\n\n * 第一次：**客户端向服务器端发送一个同步数据包，报文的TCP首部中：**同步SYN为1，表示这是一个请求建立连接的数据包；序号Seq=x，x为所传送数据的第一个字节的序号，随后进入SYN-SENT状态\n\n> 标志位值为1表示该标志位有效\n\n * **第二次：**服务器根据收到数据包的SYN标志位判断为建立连接的请求，返回一个确认数据包，标志位SYN=1，ACK=1，序号seq=y，确认号ack=x + 1表示收到了客户端传输过来的x字节数据，希望下次从x+1个字节开始传，并进入SYN-RCVD状态\n\n> 要区分标志位ACK和确认号ack\n\n * **第三次：**客户端收到后，再给服务器发送一个确认数据包，标志位ACK=1，序号seq=x+1，确认号ack=y+1，随后进入ESTABLISHED状态；\n\n服务器端收到后，也进入ESTABLISHED状态，由此成功建立TCP连接，开始数据传送\n\n * 为什么要三次握手？避免服务器等待造成资源浪费，具体原因：\n\n> 如果没有最后一个数据包确认（第三次握手），A先发出建立连接的请求数据包，由于网络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包\n> \n> 于是发出第二个建立连接的请求数据包，这次网路通畅，B的确认数据包也很快就到达A。于是A与B开始传输数据\n> \n> 过了一会A第一次发出的建立连接的请求数据包到达了B，B以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以忽略B发来的第二个确认数据包，但是B发出确认数据包之后就要一直等待A的回复，而A永远也不会回复\n> \n> 由此造成服务器资源浪费，这种情况多了B计算机可能就停止响应了\n\n**7、**构建并发送HTTP请求\n\n * 建立TCP连接后，浏览器发送http请求到服务器，请求的内容包括 请求行 请求头和请求体\n * 当服务器接收到请求之后，处理完之后返回HTTP响应消息，包括，响应行，响应头和响应体\n * 服务器响应之后，HTTP默认开启长连接，页面关闭后，TCP连接经过四次挥手断开\n\n**8、**服务器端处理请求\n\n**9、**客户端处理响应，检查服务器响应报文状态码\n\n * 301/302表示服务器已更换域名需要重定向，网络进程会从响应头的Location字段里面读取重定向的地址，发起新的HTTP/HTTPS请求，跳回第4步\n   \n   200，检查Content-Type，值为text/html说明是HTML文档，是application/octet-stream说明是文件下载\n\n\n\n**10、**请求结束，当通用首部字段Conection不是Keep-Alive时，即不为TCP长连接时，四次挥手断开TCP连接\n\n四次挥手步骤（抽象派）\n\n * 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\n * 被动方：收到通道关闭的信息\n * 被动方：那我也告诉你，我这边向你的主动通道也关闭了\n * 主动方：最后收到数据，之后双方无法通信\n\n\n\n * **第一次：**客户端（主动断开连接）发送数据包给服务器，标志位FIN=1，序号位seq=u，停止发送数据\n * **第二次：**服务器收到数据包后，由于还需传输数据，无法立即关闭连接，先返回标志位ACK=1，序号seq=v，确认号ack=u+1的数据包\n * **第三次：**服务器准备好断开连接后，返回数据包，标志位FIN=1，ACK=1，序号seq=w，确认号ack=u+1\n * **第四次：**客户端收到数据包后，返回标志位ACK=1，序号seq=u+1，确认号ack=w+1的数据包\n\n由此通过四次挥手断开TCP连接\n\n> 详细过程参见：https://www.cnblogs.com/AhuntSun-blog/p/12028636.html\n\n为什么要四次挥手？\n\n服务器不能马上断开连接，导致FIN释放连接报文与ACK确认接收报文需要分两次传输，即第二次和第三次\"挥手\"\n\n# 3. 准备渲染进程\n\n**11、**准备渲染进程：浏览器进程检查当前url是否与之前打开了渲染进程的页面的根域名相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程\n\n# 4. 提交文档\n\n**12、**提交文档：\n\n * 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息后与网络进程建立传输数据的“管道”\n * 渲染进程接收完数据后，向浏览器发送“确认提交”\n * 浏览器进程接收到确认消息后更新浏览器界面状态：安全状态、地址栏url、前进后退的历史状态、更新web页面\n\n\n\n\n# 🅱️ 渲染阶段\n\n渲染步骤：\n\n 1. 渲染进程解析HTML文本，解析 HTML 同时，如果遇到内联样式，下载并构建样式规则（stytle rules）。遇到 JS 脚本下载并执行，构建dom树\n 2. 构建DOM过程若遇到外联样式/脚本声明，暂停文档解析，开始下载样式脚本和文件\n 3. 样式文件下载完成后构建CSSDOM；脚本文件下载完成后，解析并执行，继续解析文档构建DOM\n 4. 文档解析完成后，合成布局树（Layout/reflow），负责各元素尺寸、位置的计算\n 5. 绘制render树（paint），绘制页面像素信息\n 6. 渲染进程对布局树分层，分别栅格化每一层得到合成帧\n 7. 渲染进程将合成帧发送给GPU将各层合成（composite）显示\n\n渲染阶段通过渲染流水线在渲染进程的主线程和合成线程配合下，完成页面渲染；\n\n> tiles 瓷砖，小瓦片\n> \n> raster 光栅\n\n③渲染进程\n\n# 5. 构建DOM树\n\n13、将请求回来的数据解压，HTML解析器HTML字节流通过分词器拆分为一个个Token，生成节点Node，最后解析成浏览器识别的DOM树结构[解析HTML，生成DOM树]\n\n 1. \n 2. 重点过程\n    1. Conversion：浏览器将获得的HTML内容（Bytes）转换为单个字符\n    2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集\n    3. Lexing词法分析：分词的结果是得到一堆token，把他们转换为对象，分别定义属性和规则\n    4. DOM构建：HTML标记定义的是不同标签之间的关系，这个关系像树形结构。例如：body对象的父节点是HTML对象，p对象的父节点就是body对象\n 3. 最后DOM树\n\n\n\nConsole选项打开控制台输入document查看DOM树\n\n> 渲染引擎有一个安全检查模块叫 XSSAuditor，检测词法安全。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截\n\n首次解析HTML时渲染进程开启一个预解析线程，遇到HTML文档中内嵌的JS和CSS外部引用会同步提前下载这些文件，下载时间以最后下载完的文件为准\n\n\n\n# 6. 构建CSSOM\n\n14、CSS解析器将CSS转换为浏览器能识别的styleSheets——CSSOM：通过控制台输入document.styleSheets查看\n\n考虑一下阻塞的问题，JS有修改CSS和HTML的能力，所以需要先等到 CSS 文件下载完成并生成 CSSOM，再执行 JS 脚本，最后继续构建 DOM。由于这种阻塞，导致了解析白屏[解析CSS， 生成CSSOM]\n\n> 优化：\n> \n>  1. 移除JS/css的文件下载：通过内联 JS/ CSS\n>  2. 尽量减少文件大小：如通过 webpack 等工具移除不必要注释，压缩 JS 文件\n>  3. 将不进行DOM操作/CSS样式修改的 JS 标记上 sync/ defer异步引入\n>  4. 使用媒体查询属性：将大CSS文件拆分成多个用途的 CSS 文件，在特定的场景下会加载特定的 CSS 文件\n\n通过浏览器调试工具的Network面板中的DOMContentLoaded查看最后生成DOM树所需的时间\n\n\n\n\n\n# 7. 样式计算\n\n**15、**转换样式表中的属性值，标准化。如将em转换为px，color转换为rgb\n\n**16、**计算DOM树中每个节点具体样式，遵循CSS的继承和层叠规则\n\n\n\n# 8. 布局阶段\n\n[结合DOM和CSSOM树，生成渲染树]\n\n**17、**创建布局树，遍历DOM树中所有节点，去掉所有隐藏的节点（比如head，添加了display:none的节点），保留可见的节点\n\n**18、**计算布局树中节点的坐标位置（较复杂，这里不展开），对于每个可见的节点，找到CSSOM树中对应规则并应用，根据每个可见节点及其对应的样式，生成渲染树\n\n# 9. 分层\n\n**19、**对布局树分层，生成分层树（Layer Tree），通过Chrome调试工具的Layer查看。分层树中每一个节点都直接/间接的属于一个图层\n\n\n * # 图层\n\n可把普通文档流看成一个图层。特定属性可以生成一个新的图层。不同的图层渲染互不影响，对于某些频繁需要渲染的建议单独生成一个新图层，提高性能\n\n以下几个常用属性可以生成新图层\n\n * 3D 变换：translate3d、translateZ\n * will-change\n * video、iframe\n * 动画实现的 opacity 转换\n * position: fixed\n\n> 页面分层后，会加大重绘开销？？不会\n> \n> 使用GPU硬件加速的操作都由GPU进程负责？？我觉得 是的！\n\n# 10. 图层绘制\n\n**20、**为每个图层生成绘制列表（即绘制指令），将其提交到合成线程。以上操作都是在渲染进程中主线程中进行，提交到合成线程后就不阻塞主线程了\n\n\n\n> 渲染进程中的合成线程部分\n\n\n\n# 11. 切分图块\n\n**21、**合成线程将图层切分成大小固定的图块（256x256或者512x512）优先绘制靠近视口的图块，可加速页面显示速度\n\n\n\n\n# ④GPU进程\n\n# 12. 栅格化\n\n22、在光栅化线程池中将图块转换成位图，通常这个过程会使用GPU加速生成，使用GPU生成位图的过程叫快速栅格化/GPU栅格化，生成的位图保存在GPU内存中\n\n\n\n\n# ⑤浏览器主进程\n\n# 13. 合成与显示\n\n**23、**合成：一旦所有图块都被光栅化，合成线程将它们合成为一张图片，生成绘制图块的命令——“DrawQuad”，将该命令提交给浏览器进程\n\n> 注意：合成过程在渲染进程的合成线程中完成，不影响渲染进程的主线程\n\n**24、**显示：浏览器进程里面有一个叫viz的组件，接收合成线程发过来的DrawQuad命令，根据DrawQuad命令，将其页面内容绘制到内存中，最后将内存显示在屏幕上。将像素发送给GPU，展示在页面上(GPU将多个合成层合并成一个层，展示)\n\n到这里，经过这一系列的阶段，编写好的HTML、CSS、JS等文件，经过浏览器就会显示出漂亮的页面了\n\n> Layout回流 [重排]：通过 JS 或者 CSS 修改元素几何位置属性，会触发重新布局，解析后面一系列子阶段\n> \n> 重绘：跳过布局阶段，直接进入绘制，然后分块、生成位图及以后子阶段；Painting 根据渲染树及回流得到的几何信息，得到节点的绝对像素\n> \n> 合成：渲染引擎跳过布局和绘制阶段，执行的后续操作，发生在合成线程，非主线程\n\n\n# 🔥合成线程处理事件\n\n合成线程合成不同光栅层优化性能，若页面不监听事件，合成线程可完全独立于 主线程生成新的合成帧。但若监听了事件呢？\n\n> 标记\"慢滚动区域\"\n\n当页面被合成线程合成过，合成线程会标记哪些区域有事件，当事件发生在响应区域时，合成线程将事件发送给主线程处理，若在 非事件监听区域，则 渲染进程直接创建新的帧 不关心主线程\n\n\n\n> 事件监听时标记\n\n利用事件代理冒泡，在目标元素的上层元素中监听事件\n\ndocument.body.addEventListener('touchstart',event=>{\n    if(event.target===area){\n        event.preventDefault()\n    }\n});\n\n\n1\n2\n3\n4\n5\n\n\n确实 可以更高效监听事件\n\nbut，从浏览器角度看，此时 整个页面都会标记为 \"慢滚动区域\"，意味着 虽然页面部分元素不需要事件监听，但 合成线程 依然在每次交互发生后等待主线程处理事件，弱化了合成线程的优化效果\n\n> 解决\n\n事件代理时传入 passive:true，告诉 渲染进程，依然需要将事件发送给主线程，但无需等待\n\ndocument.body.addEventListener('touchstart',event=>{\n    if(event.target===area){\n        event.preventDefault()\n    }\n},{passive:true});\n\n\n1\n2\n3\n4\n5\n\n\npassive 改善滚屏性能\n\n\n# 前端缓存\n\n前端缓存 主要分为http缓存和浏览器缓存\n\nHTTP缓存：强缓存、协商缓存\n\n浏览器缓存：storage 前端数据库和应用缓存\n\n应用缓存主要通过manifest文件注册被缓存的静态资源，已被废弃，因为设计有些不合理，缓存静态文件的同时，默认缓存html文件。导致页面更新只能通过manifest文件中的版本号决定。所以，应用缓存只适合那种常年不变化的静态网站\n\n> 优点\n\n * 减少不必要网络传输，节约带宽(省钱)\n * 降低客户端获取资源的延迟，读取缓存速度快，地理位置可能比源服务器更近\n * 更快加载页面(加速)\n * 减少 服务器 负载(减载)\n\n> 缺点\n\n * 占内存\n\n\n# HTTP缓存\n\n能用cache-control就不用expires\netag不是last-modified的完全替代方案，而是last-modified的补充方案，项目中使用etag还是last-modified取决于业务场景\n\n\n1\n2\n\n\n\n\nHTTP控制缓存的字段主要包括Cache-Control/Expires，Last-Modified/Etag\n\n本地强缓存过期了，就需要协商缓存，去看服务器上的资源改没有\n\n\n# 强缓存\n\n客户端请求后，先访问缓存数据库看缓存是否存在。存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库\n\n服务器与浏览器约定文件过期时间，向browser缓存查找请求结果，根据该结果的缓存规则决定是否使用该结果\n\n * 强制缓存失效，发送请求（和第一次请求一样）200\n * 存在缓存结果和标识但结果已失效，使用协商缓存\n * 存在缓存结果和标识且未失效，直接返回结果，在 size 项中标识的是 200 from disk cache\n\n发送请求，服务器把缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器， 控制强制缓存的字段是Expires（HTTP1.0时期使用）\n\nCache-Control（HTTP/1.1 使用）\n\nCache-Control优先级比Expires高\n\n\n# Expires(HTTP/1.0)\n\n响应头，时间戳，控制网页缓存，**服务器返回请求结果缓存的到期时间，**再次发起该请求时，如果客户端的时间小于Expires的值， 直接使用HTTP本地缓存并返回200\n\n缺点： Expires控制缓存的原理是使用客户端的时间与服务端返回时间做对比，如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，强制缓存直接失效，这样的话强制缓存 毫无意义\n\n\n# Cache-Control(HTTP/1.1)\n\n响应头和请求头\n\n没有采用具体的过期时间节点的方式，而是采用过期时长控制缓存，对应缓存为max-age\n\n在HTTP/1.1中，Cache-Control是最重要的规则，服务端参数为：\n\n> public：都可以被缓存\n> \n> private：只有客户端可以缓存，默认\n> \n> no-cache：协商缓存验证\n> \n> no-store：更狠，不使用任何缓存\n> \n> max-age=x ：缓存内容将在xxx秒后失效，单位是 s！！！\n> \n> must-revalidate：一旦资源过期，在成功向原始服务器验证之前，不能使用\n\nno-cache和no-store存在时 忽略max-age！\n\npublic和private ——决定资源是否可以在 代理服务器 缓存\n\nCache-Control实现流程:\n\n 1. 浏览器第一次访问服务器资源时，服务器在response头部加上 Cache-Control， Cache-Control 设置 过期时间大小\n 2. 浏览器再次访问服务器资源时，先通过请求资源的时间与cache-control中设置的过期时间对比，计算该资源是否过期，若没有则使用该缓存，否则重新请求\n 3. 服务器再次收到请求后，更新Response头部的Cache-Control\n\n优先级：Cache-Control>Expires\n\n\n# 协商缓存\n\n与服务端协商之后，通过 协商结果 判断是否使用本地缓存，通过服务端告知客户端是否可以使用缓存——协商缓存\n\n强制缓存失效后，browser携带缓存标识tag 发请求，由服务器根据缓存tag决定是否使用缓存\n\ntag分为2组字段（不是两个）：Last-Modified和ETag\n\n\n# Last-Modified(HTTP/1.0)\n\nLast-Modified(响应头)，If-Modified-Since(请求头)\n\n文件在服务端的最后修改时间\n\n判断请求资源是否最新，浏览器第一次发送请求后，服务器会在响应头中加入这个字段\n\nbrowser接收后，若再次请求，在请求头中携带If-Modified-Since字段，询问该时间之后，资源是否有被修改过，其实就是第一次访问服务器返回的Last-Modified的值\n\n服务器拿到请求头中If-Modified-Since和该资源最后修改时间对比：\n\n> 若请求头中这个值小于修改时间，说明应该更新了。返回新的资源，状态码为200\n> \n> 否则返回304，直接使用缓存\n\n\n# ETag(HTTP/1.1)\n\n服务器根据当前文件的内容，给文件页面生成唯一标识。通过响应头传送给浏览器，下次请求时，将这个值作为If-None-Match字段的内容\n\n * 当第一次请求资源时，服务器返回资源的同时， Response 头部加上 ETag 唯一标识，这个唯一标识根据当前请求资源生成\n\n * 当 再次请求访问服务器中的该资源，先检查强制缓存是否过期，如果没过期，直接使用本地缓存；如果过期，在 Request 头部加上 If-None-Match 字段，该字段是 ETag 唯一标识\n\n * 服务器再次收到请求后，根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识比较：\n   \n   * 值相等，返回 304 Not Modified，不会返回资源\n   * 不相等，则返回 200 状态码和资源，并在 Response 头部加上新的 ETag\n\n * 如果浏览器收到 304 的响应状态码，从本地缓存中加载资源，否则更新资源？？协商缓存 资源缓存在本地还是服务器？？\n\n# 强ETag\n\n不论实体发生多么细微的变化都会改变其值，生成的哈希码深入每个字节，保证文件内容绝对不变\n\n耗计算量\n\n# 弱ETag\n\n只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变\n\n准确率不高\n\n\n# 两者对比\n\n如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， Etag 的优先级更高，先判断 Etag 是否变化，如果 Etag 没有变化，再看  Last-Modified\n\n\n1\n\n 1. 精确度**：ETag>Last_Modified**\n    * 编辑了资源文件，但内容没改变，造成缓存失效\n    * Last_Modified可感知的时间单位是s，若在1s内修改了文件，不能体现出来\n 2. 性能上：Last_Modified优于Etag\n\n有哈希值的文件设置 强缓存\n没有哈希值(index.html)设置协商缓存\n\n\n1\n2\n\n\n\n# 缓存存储\n\n * 内存缓存：快速读取和实效性\n * 硬盘缓存：写入硬盘文件，需要I/O操作，读取复杂，速度慢\n\n浏览器中的缓存位置，按优先级从高到低排列：\n\n * Service Worker\n * Memory Cache\n * Disk Cache\n * Push Cache\n\n都没命中的话，就发请求\n\n大的JS 、CSS文件直接丢进磁盘，反之丢进内存\n\n内存使用率高时，文件优先进入磁盘\n\n\n# Service Worker\n\n是web worker的一个类型\n\n\n# Memory Cache\n\n内存中的缓存，主要包含 当前中页面中已经抓取到的资源，例如已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存读取高效，可是缓存持续性很短 一旦关闭Tab页面，内存中的缓存也就被释放了\n\n计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存不多\n\n\n# Disk Cache\n\nDisk Cache 存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上\n\n在所有缓存中，它的覆盖面基本最大。它会根据HTTP Header中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需重新请求，而且即使在跨站点时，相同地址的资源一旦被硬盘缓存，就不会再请求\n\n\n# Push Cache\n\nPush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令\n\n 1. 所有的资源都能被推送，并且能够被缓存\n 2. 可以推送 no-cache 和 no-store 的资源\n 3. 一旦连接被关闭，Push Cache 就被释放\n 4. 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。主要依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接\n 5. Push Cache 中的缓存只能被使用一次\n 6. 浏览器可以拒绝接受已经存在的资源推送\n 7. 可以给其他域名推送资源\n\n\n# 啥资源强/协商缓存？\n\n * HTML：协商缓存\n * CSS、JS、图片：强缓存，文件命名带上hash值\n\n考虑缓存的内容：\n\n * css文件\n * js文件\n * logo、图标\n * html\n * 可下载的内容\n\n不应该缓存的内容：\n\n * 业务敏感的 GET 请求\n\n网站的缓存设置最佳实践——入口 html 文件 Cache-Control 设置 no-cache，其他文件 max-age，这样入口文件会用本地缓存但每次都协商，能及时更新，而其他资源不会发请求，减少服务端压力\n\n如果要更新的话，html 文件协商后发现有更新会下载新 html，关联了其他 hash 的文件，浏览器会下载新的，不会走到之前文件的缓存\n\n强制刷新的实现——设置了 Cache-Control 为 no-cache\n\n清空缓存并强制刷新的功能，是清掉本地的强缓存再去协商，能保证一定是拿到最新的资源\n\n\n# ⚠️前端安全\n\n\n# XSS\n\n跨站脚本攻击\n\nCross Site Scripting ，和 CSS 区别，CSS 是层叠样式表 (Cascading Style Sheets)\n\n用户输入/向代码中注入JS，暗地执行脚本\n\n 1. 写死循环\n 2. 监听用户行为，窃取用户信息(cookie、token)\n 3. 诱骗用户 点击/填写 表单\n 4. 绘制UI(例如 弹窗)\n\n\n# 存储型\n\nstored xss\n\n危害最大，对所有用户可见\n\nXSS代码发送到数据库，前端请求数据时，将XSS代码发送到前端\n\n场景：留言区提交一段脚本执行，若前后端未做好转义的工作，评论内容存在数据库，页面渲染过程中直接执行，相当于执行一段未知逻辑的JS代码\n\n如论坛发帖、商品评论、用户私信等\n\n * 1、攻击者网页回帖，帖子中包含JS脚本\n * 2、回帖提交服务器后，存储至数据库\n * 3、其他网友查看帖子，后台查询该帖子的回帖内容，构建完整网页，返回浏览器\n * 4、该网友浏览器渲染返回的网页，中招！\n\n\n# 反射型\n\nreflected xss\n\n不涉及 数据库，将JS代码作为请求参数放置URL中，诱导用户点击\n\n恶意脚本通过作为网络请求的参数，经过服务器，反射到HTML文档中执行解析，服务器不会存储这些恶意脚本\n\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等\n\n 1. 用户点击后， JS作为 参数传给 后端\n 2. 后端 没有检查过滤，简单处理后放入网页正文中返回给浏览器\n 3. 浏览器解析返回的网页，中招！\n\n\n# 文档型\n\nDOM-based - xss\n\n * 不需要 服务器 参与\n * 恶意攻击的 发起+执行，全在浏览器 完成\n\nXSS攻击作为中间人，劫持到网络数据包，修改里面的HTML\n\n劫持包括：\n\n 1. WIFI路由劫持\n 2. 本地恶意软件\n\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JS 自身安全漏洞，而其他两种 XSS 都属于服务端安全漏洞\n\n\n# 突变型\n\nmutation-based xss\n\n * 利用 浏览器渲染 DOM 的特性\n * 不同 浏览器 有区别\n\n\n\n\n# 防范：一个信念，两个利用\n\n# 1.对输入转码过滤\n\n * 如果允许 用户上传 DOM，需要对 string 转义\n * 上传 svg，需要扫描，因为 svg 标签中可能插入 脚本\n * 尽量不做用户自定义跳转的行为，如果要的话，需要做好过滤，否则可能 会传递 JS代码\n * 如果允许用户自定义样式的话(url 或 背景图片)，可能导致xss攻击(非常巧妙)\n\n# 2.利用CSP\n\nContent Security Policy\n\n浏览器内容安全策略\n\n\n\n 1. 限制其他域下的资源加载\n 2. 禁止向其它域提交数据\n 3. 提供上报机制\n\n# 3.HttpOnly\n\n阻止JS对cookie的访问(标记或授权对话)\n\n阻止 XSS 攻击：服务器对脚本进行过滤或转码，利用 CSP 策略\n\n！！不能阻挡CSRF！！\n\n\n# CSRF\n\n也叫 XSRF\n\n跨站伪造请求（钓鱼）\n\nCross-Site Request Forgery\n\n打开A网站的情况 ，另开Tab 打开恶意网站B，此时在B页面的“唆使”下，浏览器发起 对网站A的 请求\n\n * 1、这个 请求不是用户主动 ，而是B“唆使的”，如 危害较大的请求操作（发邮件？删数据？等等）那就麻烦了\n\n * 2、因为 A网站已经打开了，浏览器存有A 的Cookie ， 被“唆使”的请求 自动带上这些信息，A网站后端分不清楚这是否是用户真实的意愿\n\n * 在用户不知情 的情况下\n\n * 利用用户 权限\n\n * 构造指定 HTTP 请求，窃取或修改 用户敏感信息\n\n * CSRF 蠕虫\n\n> CSRF 蠕虫指的是产生蠕虫效果，会将CSRF攻击一传十 十传百，当一个用户访问恶意页面后通过 CSRF 获取其好友列表信息，再利用私信好友的CSRF 漏洞给每个好友发送一条指向恶意页面的信息，只要有人查看信息链接，CSRF 蠕虫会不断传播！\n\n\n\n攻击者诱导受害者进入第三方网站，向被攻击网站发送跨站请求。利用受害者已经获取的注册凭证（如cookie） ，绕过后台验证，冒充用户对被攻击的网站执行某项操作\n\n利用所在网站的目前登录信息，悄悄提交各种信息，比XSS更恶劣\n\n\n\n> 本质：利用cookie会在同源请求中携带发送给服务器的特点，冒充用户\n\n点击链接后，可能发生\n\n 1. 自动发送GET请求。利用src发送请求\n 2. 自动发送POST请求\n 3. 诱导点击发送GET请求\n\n\n# 防范\n\n\n\n# 1.SameSite\n\n\n\n根源上解决 CSRF 攻击\n\nSameSite 限制domain属性和 当前域名 是否匹配\n\n\n\nSameSite属性取值\n\n * Strict，仅允许同站请求携带 Cookie\n\n * Lax，宽松一点，允许部分第三方请求携带 Cookie\n\n * None，最宽松，默认模式，无论是否跨站都会发送 Cookie\n\nSet-Cookie: name=lizheming; SameSite=None; Secure\n\n\n1\n\n\n> 浏览器针对HTTPS域名才支持SameSite=None，所以我们还需要携带 Secure 属性\n\n\n\nSameSite和SameOrigin不同，同域判断 更严格，Cookie中的同站判断比较宽松，主要根据Mozilla维护的公共后缀表（Pulic Suffix List）使用 有效顶级域名 effective top-level domains (eTLD) +1 的规则查找得到的一级域名是否相同 来判断是否 是同站请求\n\n例如 .org 是在 PSL 中是有效顶级域名，imnerd.org 则是一级域名。所以 https://blog.imnerd.org 和 https://www.imnerd.org 是同站域名。\n\n而 .github.io 也是有效顶级域名，所以 https://lizheming.github.io 和 https://blog.github.io 得到的一级域名不一样，他们两个是跨域请求\n\n在类似 GitHub/GitLab Pages，Vercel 这种提供子域名给用户建站的第三方服务中，eTLD的同站判断非常有用，通过将原本是一级域 的域名 添加到 eTLD 列表中，让浏览器认为配有用户名 的完整域名才是一级域名，有效解决了 不同用户站点的 cookie 共享问题\n\neTLD 是有效顶级域名，和 Top-Level Domain顶级域名有区别。eTLD记录在 PST中，TLD记录在RZD(Root Zone Database——根区域数据库)，RZD记录了所有的 跟域 列表\n\neTLD 主要为了解决 .com.cn，，com.hk，这种看起来像是 一级域名 但其实是 作为顶级域名 存在的场景\n\n> Schemeful Same Site 同站计划\n\n# 2.验证来源站点\n\n请求头中的origin和referer\n\nreferer表明请求来源于哪个地址\n\norigin只包含域名信息，referer包含具体的URL路径\n\n我们可以拒绝一切非本站发出的请求\n\n简单，但是当网站域名有多个，或经常 变换域名时 会非常麻烦，具有 局限性\n\n# 3.Token\n\n\n\n利用token（后端生成的一个唯一登陆态，传给前端保存）每次前端请求都会带token，检验通过才同意请求\n\n\n\ntoken 必须和具体用户绑定，才能确保不会被其他注册用户利用\n\ntoken必须设置有效时间，保不齐哪天token被窃取，已请求的数据会被攻击者利用\n\n为什么 token可以防止 csrf?\n\nToken被用户端放在Cookie中（不设置HttpOnly），同源页面每次发请求都在请求头或者参数中加入Cookie中读取的Token来完成验证。 CSRF只能通过浏览器自己带上Cookie，不能操作Cookie来获取到Token并加到http请求的参数中\n\n# 4.安全框架\n\n如Spring Security\n\n\n# SQL注入\n\n将恶意的 Sql查询/添加语句插入到应用 输入参数 ，让服务器执行攻击者期望的SQL语句，得到数据库数据/对数据库 读取、修改、删除、插入\n\n\n\n如何让Web服务器执行攻击者的SQL语句？\n\n将有毒的SQL语句放置于Form表单/请求参数中，提交到 服务器，如果 服务器没有做输入安全检查，直接将变量取出执行SQL语句， 中招\n\n预防方式 ：\n\n * 严格检查输入变量 类型和格式\n * 过滤/转义特殊字符\n * 对访问数据库的应用程序采用Web应用防火墙\n\n\n\n\n# iframe 攻击\n\niframe是同源请求\n\n\n# GET!==GET+POST\n\n请求一定要区分开\n\n还有其他种类的攻击，这里不再细说\n\n\n# DDos\n\nDistributed Denial of Service：分布式拒绝服务攻击。是拒绝服务攻击的升级版。 让服务不可用。常用 攻击对外提供服务的服务器\n\n * Web服务\n * 邮件服务\n * DNS服务\n * 即时通讯服务\n\n攻击者不断 请求，让合法用户 请求无法及时处理——DoS 攻击\n\n攻击者使用多台计算机/计算机集群进行 DoS 攻击—— DDoS 攻击\n\n早期 ， DoS攻击是 很容易的事情：一台性能强劲的计算机，写个程序多线程不断 请求，服务器应接不暇，最终无法处理正常 请求，对别的正常用户来说， 网站貌似无法访问，拒绝服务就是这 个意思\n\n现在 服务器早已不是一台服务器 ， www.baidu.com的域名，背后是数不清的CDN节点，数不清的Web服务器\n\n这种情况 想靠单台计算机 试图让 网络服务满载，无异于鸡蛋碰石头\n\n分布式技术 可 提供高可用的服务，也能 被攻击方用来进行大规模杀伤性攻击。攻击者不再局限于单台计算机的攻击能力，转而通过成规模的网络集群发起拒绝服务攻击\n\n\n# DNS劫持\n\nWeb服务发展 如火如荼， 离不开 默默无闻的域名解析系统\n\nDNS 将域名转换成IP ， 早期协议 设计 没有太多考虑其安全性，对于查询方来说：\n\n * 我去请求的真的是一个DNS服务器吗？是不是别人冒充的？\n * 查询的结果有没有被人篡改过？这个IP真是这个网站的吗？\n\nDNS 没有机制 保证能回答这些问题，因此DNS劫持 泛滥，用户在地址栏输入域名的那一刻起，一路上的凶险防不胜防：\n\n * 本地计算机中的木马修改hosts文件\n * 本地计算机中的木马修改DNS数据包中的应答\n * 网络中的节点（如路由器）修改DNS数据包中的应答\n * 网络中的节点（如运营商）修改DNS数据包中的应答\n\n后来，以阿里、腾讯等头部互联网厂推出httpDNS服务，釜底抽薪，原来DNS天差地别，通过这项技术让DNS变成 在http协议之上的一个应用服务\n\n\n# 其他攻击\n\n * JSON 劫持\n\n轻量级的数据交换格式，而劫持就是对数据 窃取（或者应该称为打劫、拦截比较合适。恶意攻击者通过 特定的手段，将本应该返回的 JSON数据 拦截，转而 发送 给恶意攻击者 。一般 劫持的JSON数据都是包含敏感信息或者有价值的数据\n\n * 暴力破解\n\n一般针对密码，弱密码（Weak Password）很容易被猜到或被破解\n\n解决方案 密码复杂度要足够大，也要足够隐蔽 限制尝试次数\n\n * HTTP 报头追踪漏洞\n\nHTTP/1.1 规范定义了 HTTP TRACE 方法，主要是用于客户端通过向 Web 服务器提交 TRACE 请求来进行测试或获得诊断信息。\n\n当 Web 服务器启用 TRACE 时，提交的请求头会在服务器响应的内容（Body）中完整的返回，其中 HTTP 头很可能包括 Session Token、Cookies 或其它认证信息。攻击者可以利用此漏洞来欺骗合法用户并得到他们的私人信息\n\n解决：禁用 HTTP TRACE\n\n * 信息泄露\n\nWeb 服务器或应用程序没有正确处理一些特殊请求，泄露 Web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等\n\n所以需注意：\n\n应用程序报错时，不对外产生调试信息 过滤用户提交的数据与特殊字符 保证源代码、服务器配置的安全\n\n * 目录遍历漏洞\n\n攻击者向 服务器发请求，在 URL 中或在有特殊意义的目录中附加 ../、或者附加 ../ 的一些变形（如 .. 或 ..// 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令\n\n * 命令执行漏洞\n\n通过 URL 发起请求，在 Web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪\n\n * 文件上传漏洞\n\n如果对文件上传路径变量过滤不严， 且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器\n\n所以 需注意：\n\n需严格限制和校验上传的文件，禁止上传恶意代码的文件 限制相关目录的执行权限，防范 webshell 攻击\n\n * 其他漏洞\n\nSSLStrip 攻击\n\nOpenSSL Heartbleed 安全漏洞\n\nCCS 注入漏洞\n\n证书有效性验证漏洞\n\n * 业务漏洞\n\n跟具体的应用程序相关，比如参数篡改（连续编号 ID / 订单、1 元支付）、重放攻击（伪装支付）、权限控制（越权操作）\n\n * 框架或应用漏洞\n\nWordPress 4.7 / 4.7.1：REST API 内容注入漏洞\n\nDrupal Module RESTWS 7.x：Remote PHP Code Execution\n\nSugarCRM 6.5.23：REST PHP Object Injection Exploit\n\nApache Struts：REST Plugin With Dynamic Method Invocation Remote Code Execution\n\nOracle GlassFish Server：REST CSRF\n\nQQ Browser 9.6：API 权限控制问题导致泄露隐私模式\n\nHacking Docker：Registry API 未授权访问\n\n\n# WebSocket\n\n\n * # 含义\n\n在单个TCP连接上进行全双工通信的协议\n\n使客户端和服务器间数据交换更简单，允许server主动向client推送data\n\n\n * # 特点\n\n 1. 建立在TCP协议之上\n 2. 良好兼容性。默认端口80和443，握手阶段采用http协议，所以握手时不容易屏蔽，能通过各种HTTP代理服务器\n 3. 数据格式轻量，性能开销小，通信高效\n 4. 二进制和文本均可发送\n 5. 无同源限制\n 6. 协议标识符是ws，网址是url\n\n\n * # 为啥用它？\n\nWebSocket出现前，创建一个和server双通道通信的web应用，需要依赖HTTP协议，不停轮询，导致\n\n * server维持来自每个客户端大量的不同连接\n\n * 大量轮询造成高开销，带上多余header，无用的数据传输\n\n\n * # WebSocket、HTTP\n\n\n\n * 都基于HTTP，可靠，应用层协议\n * WebSocket建立握手时，data通过HTTP传输。建立之后，真正传输不需要HTTP协议\n\n> 不同\n\n 1. WebSocket双向通信，HTTP单向\n 2. HTTP/2具备server推送功能，但HTTP/2只能推送静态资源，无法推送指定信息\n\n> 优点\n\n * WebSocket一旦被创建，互相沟通所消耗的请求头很小\n * server可向client推送消息\n\n\n# 🌈 cookie、session\n\n实现了HTTP的状态管理，跟踪browser用户身份的会话方式，Cookie在客户端，Session在服务端\n\n\n# cookie\n\nHTTP是无状态协议，服务器管理全部客户端状态会成为负担\n\n> Cookie——一小段文本信息。客户端请求服务器，如果服务器需要记录该用户状态，向客户端浏览器颁发一个Cookie\n> \n> 客户端把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交。服务器检查该Cookie，辨认用户状态\n> \n> Cookie 根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息， 通知客户端保存Cookie。当下次客户端再往该服务器发送请求时， 客户端会自动在请求报文中加入 Cookie 值后发送出去\n> \n> 服务器端发现客户端发送过来的Cookie后， 检查是从哪一个客户端发来的连接请求， 对比服务器上的记录，得到之前的状态信息\n\n 1. 用户能操作cookie，性能缺陷，不管域名下地址是否需要cookie，请求都会携带上完整的cookie\n 2. 每次访问都要送cookie给server，浪费宽带\n 3. path 可限制路径\n 4. 存在浏览器端\n 5. cookie很多都是4K大小，受浏览器限制\n 6. cookie当浏览器关闭就消亡，累计计时，从创建时就开始计时\n 7. 容易被截取篡改\n\n\n# 多域名拆分\n\n * 在移动端，如果请求的域名数过多，会降低请求速度\n * 一种优化方案： dns-prefetch（让浏览器空闲时提前解析dns域名，勿滥用）\n\n\n\n\n# session\n\n> Session另一种记录客户状态的机制，存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上\n> \n> 浏览器再次访问只需从该Session中查找该客户的状态就可以\n\n 1. session存在服务器端，可存储任何类型数据\n 2. session理论上受内存限制\n 3. 占用server内存，服务器内存压力大\n 4. 依赖cookie，若禁用cookie，需要使用URL重写，不安全\n 5. 导致代码不好维护（过度使用session）\n 6. session声明周期是间隔的，没有访问session就被销毁\n\n> sessionId的携带方式\n> \n>  * cookie\n>  * URL重写:因为cookie可以人为禁用，常采取的技术就是URL重写，将sessionID附加在URL的后面. 附加的方式有两种，一种是作为URL路径的附加，另一种是作为 query 字符串附加在URL后面\n>  * 隐藏表单\n\n\n# 工作流程\n\n 1. 登录时，用户提交的表单，放入HTTP请求报文\n 2. 服务器验证信息，正确则存在数据库中，key为sessionID\n 3. 服务器返回的响应报文的Set-Cookie首部字段包含这个SessionId，客户端收到后将Cookie存进浏览器\n 4. 客户端之后对同一个服务器请求时会包含该Cookie，服务器收到后提取出SessionId，读取用户信息\n\n\n# 关系\n\nCookie和Session非常相似，Cookie相当于客户端持有的通行证，Session相当于服务器上的通行名册\n\n服务器第一次接收到请求时，开辟一块 Session 空间，同时生成一个 session id ，通过响应头的Set-Cookie：JSESSIONID=XXXXXXX ，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个JSESSIONID=XXXXXXX的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束\n\n接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后服务器通过读取请求头中的 Cookie 信息，获取名称为 SESSIONID 的值\n\n\n# 区别\n\n 1. 存放位置：Cookie在客户端，Session在服务器端\n 2. 安全性（隐私策略）：Cookie对客户端可见；Session存储在服务器端。使用Cookie需要对其加密\n 3. 有效期：设置Cookie很大的过期时间，Cookie保存很长时间；服务器会定期清理超时Session ID避免出现过大压力；但Session依赖于类似Session ID这样的Cookie，而Cookie对Session ID过期时间默许为-1。只要关闭浏览器，Session就失效\n 4. 对服务器造成的压力：Session保存在服务器端，每个用户都产生Session，并发访问多会产生十分多的Sssion，耗费内存；Cookie保存在客户端，不占用服务器资源\n 5. 存取值的类型：Cookie只支持字符串数据，session可以存任意数据类型\n 6. 存储大小：**cookie保存的数据不超过4K，**session可存储高于cookie，但访问量过多会导致占用过多资源\n\n\n# 服务器咋知道session过期？\n\nrequest.getSession(boolean)，若为true，如果当前会话不可用，创建新的会话，若存在就返回当前会话。若参数是false，在request当前会话不存在时返回null\n\n\n# 应用\n\n\n# cookie\n\n关闭浏览器消失\n\n 1. 会话状态管理（判断是否登录过网站，购物车，游戏分数等）\n 2. 保存上次登录信息\n 3. 保存上次查看页面\n 4. 个性化设置\n 5. 浏览器行为跟踪\n\n为什么cookie内存容量小？4KB\n\n * 可能造成页面卡顿\n * 传送给服务器压力大\n\n\n# session\n\n 1. 保存用户专用信息在server，sessionId唯一标志符\n 2. 购物车\n 3. 登录信息\n 4. 数据放在session，同一用户不同页面使用\n 5. 防止用户非法登录\n\n\n# 🍉 Webstorage\n\n克服cookie带来的限制，不需要持续将数据返回server\n\n 1. 提供cookie之外的存储会话数据的路径\n 2. 跨网站/应用 检测用户的行为而不需要服务端脚本和数据库\n 3. 拥有在用户即使突然断网的情况下可以保存部分web应用的能力，不会因为网络连接问题受影响\n 4. 和cookie一样存在跨域策略\n\n\n# 分类\n\n\n# localStorage\n\n(针对同一个域名)\n\n特点：\n\n 1. 生命周期：持久化本地存储，除非手动删除数据，否则数据永远不过期\n 2. 存储的信息在同一域中共享\n 3. 大小***：5M***，和浏览器厂商有关\n 4. 本质上是对字符串的读取，若存储内容过多会消耗内存空间，导致页面卡顿\n 5. 受同源策略限制\n\n缺点就是\n\n1.无法像cookie设置过期时间\n\n2.只能存字符串\n\n设置过期时间：\n\n自定义方法实现，存数据时把当前时间记录，获取数据时判断当前时间和之前时间差是否在指定过期时间范围内，若过期则清楚数据\n\n> localStorage存储达到上限，如何继续存数据？\n\n 1. 滚动存储\n 2. 跨域存储\n\n> localStorage的key占内存！！\n\n\n# sessionStorage\n\n和localStorage相似，唯一不同是生命周期，一旦页面关闭，sessionStorage将会删除数据\n\n> sessionstorage会被覆盖吗？？\n\n\n# 相同点\n\n 1. 存储大小：一般是5MB\n 2. 存储位置：都存在客户端\n 3. 存储内容类型：只能存储字符串类型\n 4. 获取方式：window.localStorage\n 5. 应用：localStorage用于长期登录，适合长期保存在本地的数据。sessionStorage用于敏感账号一次性登录\n 6. 接口封装\n\n\n# 优点\n\n 1. 存储空间大\n 2. 节省网络流量\n 3. 快速显示\n 4. 安全性\n 5. 对于那种只需要短暂存储关闭页面就可以丢弃的数据，sessionStorage很好用\n\n\n# 方法\n\nsetItem(key,value) //保存\ngetItem(key) //获取\nkey() //获取键名\nremoveItem(key) //清除\nclear() //清除所有数据\nkey(index) //获取索引的key\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# IndexedDB\n\nIndexed Database API（IndexedDB）\n\n前端数据库有WebSql和IndexDB，其中WebSql被规范废弃，他们都有大约50MB的最大容量，可以理解为localStorage的加强版。\n\n扩展的前端存储方式，是运行在浏览器中的非关系型数据库，理论上容量无上限\n\n> 特性\n\n 1. 储存量理论上没有上限\n 2. 所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时\n 3. 原生支持储存JS的对象\n 4. 是个正经的数据库，意味着数据库能干的事它都能干\n 5. 同源策略限制\n 6. 操作繁琐\n\n\n# cookie？\n\n属性：Name、Value、Domain、Path、Expires/Max-age、Size、HttpOnly、Secure、SameSite和Priority\n\n\n# set-cookie\n\n\n\nDomain 决定cookie在哪个域有效，设置对子域生效。以\".\"开始。domain指定的域名可做到与结尾匹配一致\n\nPath：Cookie的有效路径。以“/”结尾\n\nExpires/Max-age 均为Cookie的有效期，前者若不设置则默认页面关闭时删除该cookie。后者单位为秒，若设置为0则立即失效，为负数，在页面关闭时失效。默认为-1\n\nSecure：安全属性，true（browser只会在HTTPS和SSL等安全协议中传输cookie）\n\n\n# SameSite\n\n限制第三方cookie。可阻止跨站请求攻击\n\n * Strict：最严格，完全禁止第三方cookie\n * Lax：大多不发送第三方cookie，导航到目标网站的GET请求除外\n * None：可显式关闭SameSite属性，设置为none，前提是同时设置Secure属性，否则无效。默认\n\nPriority：优先级，当cookie过多时优先级低的cookie会被清除\n\n\n# 禁止JS访问cookie\n\n设置HttpOnly\n\nJS Document.cookieAPI 无法访问cookie\n\n\n# JS设置cookie\n\ndocument.cookie 属性来创建 、读取、及删除 cookie\n\n创建 cookie ：\n\n> document.cookie=\"username=John Doe\";\n\n添加一个过期时间（默认cookie 在浏览器关闭时删除：\n\n> document.cookie=\"username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT\";\n\n使用 path 参数告诉浏览器 cookie 的路径。默认，cookie 属于当前页面\n\n> document.cookie=\"username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/\";\n\n读取\n\n> var x= document.cookie; //以字符串方式返回所有cookie\n\n\n# cookie作用域\n\n> domain本身以及domain下的所有子域名\n\n\n# 跨域访问cookie\n\n 1. cookie不能跨根域，但JS可以，JS可以将cookie传给另外的域再保存一次域名cookie，这样可能存在不同的cookie域包含同一个cookie值\n 2. browser不允许跨根域读写\n 3. 采用SSO单点登录方式\n\n\n# 没cookie有啥问题\n\ncookie：解决 如何记录客户端用户信息 的问题。保存在本地的一部分数据，在再次发送请求时被携带并传送到服务器，通知server是否请求来自统一状态浏览器，如保持用户登录\n\n使基于无HTTP协议记录的信息状态稳定成为可能\n\n作用：\n\n 1. 会话状态\n 2. 个性化设置\n 3. 浏览器行为跟踪\n\n\n# 单点登录？\n\n单点登录（Single Sign On）\n\nSSO的——在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用\n\n> 淘宝跳转到天猫为啥不重新登录？\n\n淘宝和天猫设置了单点登录SSO，在多个系统的集群，只需一次登录，其他系统感知到用户登录，不需重新登录\n\n淘宝和天猫 间部署 专门用作登录的服务器，相当于实现一个 中转站，这个中转站存放需要共享登录状态服务应用的session，相当钥匙，用户跳转应用时 都会来中转站看看，若session存在就直接使用钥匙打开门，否则 得先确认用户身份 制造session钥匙存在中转站再开门，用户身份存储和有效时间均由中转站说了算，统一管理\n\n\n# session原理\n\n客户端登录完成之后，服务器创建对应的 session，session 创建完之后，把 session - id 发送给客户端，客户端存储到浏览器中。这样客户端每次访问服务器时，都会带着sessionid，服务器拿到 sessionid 后，在内存找到与之对应session 这样就可正常工作了\n\n\n# 🔥 浏览器同源策略\n\n一个域的JS脚本在未经允许的情况下，不能访问另一个域的内容，同源指的 协议 域名 和 端口均相等的情况，为同一个域\n\n\n# 跨域在服务端真正执行？\n\n同源策略限制，请求发送到后端，后端返回数据时被浏览器的跨域拦截\n\n服务端就算想拦截，也没法判断是否跨域，所有 Header 都可被篡改，它用什么判断请求是否跨域？很明显服务端心有余而力不足！\n\n请求一定是先发出去，返回的时候被浏览器拦截了，如果请求有返回值，会被浏览器隐藏掉\n\noptions 预检请求 询问 是否允许这次请求，如果是跨域请求，可以理解为：询问 服务端是否允许请求在当前域下跨域发送\n\n当然，还有其他作用，如 询问 服务端支持哪些 HTTP 方法\n\n预检请求不会真正在服务端执行，但也是一个请求，考虑到服务端开销，不是所有请求都会发送预检\n\n浏览器把请求判定为 简单请求，浏览器就不会发送预检了\n\n所以，如果发送的是简单请求，这个请求不管是否会受到跨域限制，只要发出去了，一定会在服务端执行，浏览器只是隐藏了返回值而已\n\n对于前端开发大部分跨域问题，都是通过代理解决\n\n代理使用场景：\n\n生产环境不跨域，但开发环境跨域，只需在开发环境代理解决即可——开发代理\n\n\n# 目的\n\n浏览器的保护机制，保证用户安全，防止恶意网站窃取数据\n\n防范CSRF攻击\n\n\n# 解决跨域\n\n\n# JSONP\n\n客户端准备回调——>script标签 发请求——>服务端收到请求，返回函数调用——>客户端执行回调\n\n优势在于 支持 老式浏览器，向不支持cors的网站请求\n\n前后端配合，只支持GET。利用src发送请求，传递回调\n\n不受跨域限制：script，link，img，href，src，因为这些操作不出现安全问题\n\n> 为啥只能用get？\n\njsonp就是创建一个script标签插入到body中，后端执行回调，前端接收数据\n\n因为根本没有设置请求格式的余地\n\nhttp就是这样规定的\n\n1、\n\n// 动态的加载JS文件\nfunction addScript(src) {\n  const script = document.createElement('script');\n  script.src = src;\n  script.type = \"text/javascript\";\n  document.body.appendChild(script);\n}\naddScript(\"http://xxx.xxx.com/xxx.js?callback=handleRes\");\n// 设置一个全局的callback函数来接收回调结果\nfunction handleRes(res) {\n  console.log(res);\n}\n// 接口返回的数据格式\nhandleRes({a: 1, b: 2});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n2、\n\nconst jsonp = ({ url, params, callbackName }) => {\n    const generateUrl = () => {\n        let dataSrc = ''\n        for (let key in params) {\n            if (params.hasOwnProperty(key)) {\n                dataSrc += `${key}=${params[key]}&`\n            }\n        }\n        dataSrc += `callback=${callbackName}`\n        return `${url}?${dataSrc}`\n    }\n    return new Promise((resolve, reject) => {\n        const scriptEle = document.createElement('script')\n        scriptEle.src = generateUrl()\n        document.body.appendChild(scriptEle)\n        window[callbackName] = data => {\n            resolve(data)\n            document.removeChild(scriptEle)\n        }\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# postMessage\n\nHTML5引入的API，实现安全跨源通信\n\n让主页面和任意iframe/window,open打开的页面 双向通信\n\n兼容性也好\n\n\n\n\n# CORS\n\n跨域时部分浏览器默认不携带cookie，为了携带cookie需设置xmlhttprequest的withCrendetails属性\n\n如果不需要cookie，最好置成false，避免浏览器默认允许cookie携带\n\n后端需要包装ACA系列header\n\n'Access-Control-Allow-Origin' '*';\n'Access-Control-Allow-Credentials' \"true\"; \n'Access-Control-Allow-Headers' 'X-Requested-With';\n\n\n1\n2\n3\n\n\n除此以外无需额外配置\n\n跨域资源共享 Cross Origin Resourse-Sharing\n\n**一般后端开启。**基于HTTP1.1的跨域解决方案\n\n服务端设置 Access-Control-Allow-Origin 开启 CORS。 表示哪些域名可以访问资源，通配符表示所有网站都可以访问！！！！\n\n请求可附带很多信息，对服务器造成不同程度影响，有的请求只是获取，有的请求会改动数据\n\n针对不同请求，CORS规定3种交互模式\n\n * 简单请求\n * 需要预检的请求\n * 附带身份凭证的请求\n\n# 简单请求\n\n同时满足以下条件，是简单请求：\n\n 1. 请求方法属于：\n    * get\n    * post\n    * head\n 2. 请求头仅包含安全字段，常见的安全字段：\n    * Accept\n    * Accept-Language\n    * Content-Language\n    * Content-Type\n    * DPR\n    * Downlink\n    * Save-Data\n    * Viewport-Width\n    * Width\n 3. 请求头如果包含Content-Type，仅限：\n\ncontent-type：application/json 会触发options方法！\n\n * text/plain\n * multipart/form-data\n * application/x-www-form-urlencoded\n\n> 为兼容表单，历史上表单一直可发出跨域请求，Ajax跨域设计是，只要表单可以发，Ajax就可以直接发\n\n 4. 请求中任意 XMLHttpRequest 均没有注册事件监听器；XMLHttpRequest 可使用 XMLHttpRequest.upload 访问\n\n 5. 请求没有使用 ReadableStream\n\n以上条件同时满足，为简单请求\n\n当浏览器判定某个ajax 请求是简单请求时，发生以下的事情\n\n 1. 请求头添加Origin\n\nGET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n\n\n1\n2\n3\n4\n5\n6\n\n\nOrigin告诉服务器，本次请求来自源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意请求\n\n如果Origin指定源不在许可范围，服务器正常回应。浏览器发现，回应的头信息没有包含Access-Control-Allow-Origin，知道出错了，抛出一个错误，被XMLHttpRequest的onerror回调捕获。这种错误无法通过状态码识别，状态码可能是200\n\n如果指定域名在许可范围，响应多出几个字段\n\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text/html; charset=utf-8\n\n\n1\n2\n3\n4\n\n 2. 响应头包含Access-Control-Allow-Origin**\n\n必须\n\n * *：我很开放，什么人我都允许访问\n * 具体源：如http://my.com，我就允许你访问\n\n> 实际这两个值对客户端http://my.com而言，都一样，客户端不会管其他源服务器允不允许，就关心自己是否被允许\n> \n> 服务器也可以维护可被允许的源列表，如果Origin命中该列表，才响应具体源\n> \n> 为了避免后续麻烦，强烈推荐响应具体源\n\n假设服务器做出以下响应：\n\nHTTP/1.1 200 OK\nDate: Tue, 21 Apr 2020 08:03:35 GMT\n...\nAccess-Control-Allow-Origin: http://my.com\n...\n\n消息体中的数据\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子\n\n\n\n> Access-Control-Allow-Credentials\n\n可选。\n\n是布尔值，表是否允许发送Cookie。默认Cookie不包括在CORS请求。true表示服务器明确许可，Cookie可包含在请求。\n\n也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段\n\n> Access-Control-Expose-Headers\n\n可选。\n\nCORS请求时，XMLHttpRequest的getResponseHeader()只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma\n\n想拿到其他字段须在Access-Control-Expose-Headers指定\n\nAccess-Control-Expose-Headers: FooBar\n\n\n1\n\n\ngetResponseHeader('FooBar')可返回FooBar的值\n\n> # withCredentials\n\nCORS请求默认不发送Cookie\n\n如要把Cookie发到服务器，要服务器同意，指定Access-Control-Allow-Credentials\n\nAccess-Control-Allow-Credentials: true\n\n\n1\n\n\n另一方面，开发者须在AJAX请求中打开withCredentials\n\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\n\n1\n2\n\n\n否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理\n\n如果省略withCredentials，有的浏览器还是会一起发送Cookie。这时，可显式关闭withCredentials\n\nxhr.withCredentials = false;\n\n\n1\n\n\n注意，如果要发送Cookie，Access-Control-Allow-Origin不能设为星号，必须指定明确/与请求网页一致的域名\n\n同时，Cookie依然遵循同源政策\n\n# 预检请求\n\n非简单请求是对服务器有特殊要求的请求，比如请求方法是put/delete，或content-type值为 application/json\n\n先询问服务器当前网页所在域名是否在服务器许可名单，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，才会发出正式的请求，否则报错\n\n如果浏览器不认为是简单请求：\n\n 1. 浏览器发送预检请求，询问服务器是否允许\n 2. 服务器允许\n 3. 浏览器发送真实请求\n 4. 服务器完成真实的响应\n\n比如，在页面http://my.com/index.html中有以下代码造成了跨域\n\n// 需要预检的请求\nfetch('http://crossdomain.com/api/user', {\n  method: 'POST', // post 请求\n  headers: {\n    // 设置请求头\n    a: 1,\n    b: 2,\n    'content-type': 'application/json',\n  },\n  body: JSON.stringify({ name: '袁小进', age: 18 }), // 设置请求体\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n浏览器发现它不是简单请求，按照下面的流程与服务器交互\n\n 1. 浏览器发送预检请求，询问服务器是否允许\n\nOPTIONS /cors HTTP/1.1\nOrigin: http://api.bob.com\nAccess-Control-Request-Method: PUT\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这并非真实请求，请求中不包含请求头，也没有消息体，这是预检请求，询问服务器，是否允许后续真实请求\n\n预检请求没有请求体，它包含后续真实请求要做的事情\n\n预检请求特征：\n\n * 请求方法为OPTIONS\n * 没有请求体\n * 请求头包含\n * * Origin：请求的源，和简单请求的含义一致\n   * Access-Control-Request-Method：必须，后续的真实请求使用的请求方法\n   * Access-Control-Request-Headers：逗号分隔的字符串，浏览器CORS请求额外发送的头字段，上例是X-Custom-Header\n\n 2. 服务器允许\n\n收到预检请求后，检查预检请求中信息，如果允许，则响应\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Methods: GET, POST, PUT\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n预检请求，只需要在响应头添加：\n\n * Access-Control-Allow-Origin：和简单请求一样，允许的源\n * Access-Control-Allow-Methods：允许后续真实的请求方法\n * Access-Control-Allow-Headers：允许改动的请求头\n * Access-Control-Max-Age：多少秒内对于同样请求源/方法/头，都不再发预检请求\n\n 3. 浏览器发送真实请求\n\n预检被服务器允许后，浏览器发送真实请求，请求数据\n\nPOST /api/user HTTP/1.1\nHost: crossdomain.com\nConnection: keep-alive\n...\nReferer: http://my.com/index.html\nOrigin: http://my.com\n\n{\"name\": \"xiaoming\", \"age\": 18 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 服务器响应真实请求\n\nHTTP/1.1 200 OK\nDate: Tue, 21 Apr 2020 08:03:35 GMT\n...\nAccess-Control-Allow-Origin: http://my.com\n...\n\n添加用户成功\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n完成预检之后，后续的处理与简单请求相同\n\n\n\n# 附身份凭证请求\n\n默认，ajax 跨域请求不附带 cookie，这样某些需要权限的操作就无法进行\n\n通过简单的配置可以实现附带 cookie\n\n// xhr\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\n// fetch api\nfetch(url, {\n  credentials: 'include',\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加cookie字段\n\n而服务器响应时，需要明确告知客户端：服务器允许这样的凭据\n\n告知的方式非常简单，在响应头中添加：Access-Control-Allow-Credentials: true\n\n对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝\n\n另外：对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为*。这就是不推荐使用*的原因\n\n额外补充\n\n在跨域访问时，JS 只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，需要服务器设置本响应头\n\n> pragma 是旧产物，已被抛弃\n\nAccess-Control-Expose-Headers头让服务器把允许浏览器访问的头放入白名单，例如：\n\nAccess-Control-Expose-Headers: authorization, a, b\n\n\n1\n\n\n这样 JS 就能够访问指定的响应头了\n\n\n# 代理\n\n适用场景：生产环境不发生跨域，但开发环境发生跨域\n\n开发代理：只需要在开发环境使用代理解决跨域\n\n\n\nmodule.exports = {\n  devServer: { // 配置开发服务器\n    proxy: { // 配置代理\n      \"/api\": { // 若请求路径以 /api 开头\n        target: \"http://dev.taobao.com\", // 将其转发到 http://dev.taobao.com\n      },\n    },\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# nginx 代理\n\n反向代理功能是nginx的三大主要功能之一（静态web服务器、反向代理、负载均衡）\n\n反向代理：帮服务器拿到数据，选择合适的服务器\n\n和CORS原理同，配置请求响应头Access-Control-Allow-Origin等\n\n\n\n# 反向代理、负载均衡\n\nNginx作为反向代理服务器，把http请求转发到另一个或者一些服务器上。把本地一个url前缀映射到要跨域访问的web服务器上，实现跨域访问\n\nNginx检测url前缀，把http请求转发到真实的物理服务器\n\nrewrite命令把前缀去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求来自代理服务器\n\n> 正向代理就是冒充客户端，反向代理就是冒充服务端\n\n\n# WebSocket\n\n(与HTTP同级)\n\nWebSocket请求头信息中有origin字段，表示请求源自哪个域，服务器可以根据这个字段判断是否允许本次通信\n\n\n# document.domain + iframe\n\n原理：相同主域名不同子域名下的页面\n\n**只能用于二级域名相同的情况下，**比如 a.test.com 和 b.test.com 适用于该方式\n\n只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域\n\n\n\n\n# location.hash + iframe\n\n通过C页面实现A和B通信\n\n\n# window.name(共享变量) + iframe\n\n\n# Apache转发\n\n逆向代理，让跨域变成同域\n\n> CSS文件的加载受跨域限制吗？？\n\n\n# proxy\n\nproxy原理——\"同源策略是浏览器需要遵循的标准，但如果是服务器向 服务器请求 就无须遵循同源策略\"\n\n实现——本地向proxy代理服务器发送请求，proxy接收本地请求，转化为目标地址相同IP和端口 向 目标地址发请求\n\nproxy: {\n     '/api': {\n       'target': 'http://178.192.13.284:9060',//目标URL\n       'changeOrigin': true,\n       'pathRewrite': { '^/api' : '' }\n     },\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 跨域标准\n\n跨域往标准靠近，cors，nginx和jsonp属于较老的技术了\n\n\n# 反向/正向代理\n\n代理服务器 代理了 目标服务器，和 客户端 交互\n\n将不同域名转换为相同域名\n\n正向代理是客户端的代理，反向代理是服务器的代理\n\n正向代理一般客户端架设；反向代理一般服务器架设\n\n正向代理服务器不知道真正的客户端是谁，反向代理 客户端不知道真正的服务器是谁\n\n正向代理为了解决访问限制问题；反向代理提供复杂均衡、安全防护等；二者 均能挺高访问速度\n\n所以 梯子 这个行为其实是 正向代理，突破访问权限的，由客户端来架设的，方向代理是为了所有人都能访问服务端\n\n正向代理作用\n\n突破访问限制(中介 角色)\n提高访问速度\n隐藏客户端真实IP \n\n\n1\n2\n3\n\n\n\n# ✔️ 鉴权\n\n\n# Cookie\n\n服务端响应客户端请求时，返回一个cookie，后续客户端的请求携带这个cookie\n\n特点\n\n 1. 存储在客户端，可随意纂改\n 2. 影响性能，最大为4kb\n 3. 一个浏览器对于一个网站只能存不超过20个Cookie，而浏览器一般只允许存放300个Cookie\n 4. 移动端对Cookie支持不友好\n 5. 一般情况下存储的是纯文本\n\n设置正确的domain和path，减少数据传输，节省带宽\n\n\n# Cookie-session\n\ncookie需要的存的东西越来越多，但是cookie大小有限制\n\n所以后端返回sessionId，客户端将sessionid存在cookie中\n\n缓存数据库：所有机器根据sessionId去缓存系统获取用户信息和认证\n\n局限性\n\n 1. 依赖Cookie，但Cookie可被禁用\n 2. 系统不停请求缓存服务器查找信息，内存开销增加\n 3. 存在单点登录失败的可能性\n\n> 若负责session的机器挂了，整个登录就挂了，但项目中，负责session的机器也是有多台机器的集群进行负载均衡增加可靠性\n\n\n# SSO\n\n（单点登录）三种类型\n\nSingle Sign On 在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统\n\n\n\n单点登录\n\n 1. 同一站点下\n 2. 相同的顶级域名\n 3. 不同的顶级域名\n\n相同域名和相同顶级域名下可共享cookie\n\n但是不同域呢？\n\n * CAS（中央认证服务）原理\n   \n   流程和Cookie-session模式相同\n\n\n\n“跳到SSO系统准备登录时发现SSO已经登录了”咋做到的？\n\n> Oauth2授权机制，系统b向SSO系统跳转时，让它从系统a跳转，携带系统a的会话信息跳到SSO，再重定向回到系统b\n\n阮一峰-OAuth 2.0 的四种方式\n\n\n# Json Web Token\n\n> 最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+哈希算法压缩成一定长的十六进制字符串，防止恶意三方拼接token请求)\n\nJWT由header（头部）、payload（负载）、signature（签名）这三个部分组成，中间用.来分隔开：Header.Payload.Signature\n\njwt: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJhIiwiaWF0IjoxNTUxOTUxOTk4fQ.2jf3kl_uKWRkwjOP6uQRJFqMlwSABcgqqcJofFH5XCo\"\n\n\n1\n\n\n\n\n * JWT工作原理\n\n\n\n * 弊端\n   \n   1. JWT的退出是假的登录失效，只要之前的token没过期依然可以用\n   2. 安全性依赖密钥\n   3. 加密生成的数据长\n\n * 优点\n   \n   1. 无状态，可扩展\n   2. 支持移动设备\n   3. 跨程序调用\n   4. 安全\n\nsession 和 token 的对比就是「用不用cookie」和「后端存不存」的对比\n\n> 说出以上方法时，顺便说自己项目中用的哪些鉴权方法\n> \n> 用了cookie token jwt\n\n\n# OAuth 2.0\n\nauthorization\n\n目前最流行的授权机制，授权第三方应用，获取用户数据\n\n> 场景再现 有没有一种方法，能够让快递员自由进入校区，但是不知道小区居民的密码，同时他们唯一权限就是送货\n\n数据的所有者告诉系统，同意授权第三方应用进入系统，获取数据，系统产生一个token代替密码，供第三方使用\n\nOAuth2.0有四种颁发令牌的方式\n\n * 授权码（authorization-code）\n * 隐藏式（implicit）\n * 密码式（password）：\n * 客户端凭证（client credentials）\n\n第三方需要先备案，拿到2个身份识别码：客户端ID和客户端密钥\n\n\n# 前后端实时通信\n\n\n# Ajax轮询\n\n设置周期T，每T s向服务端请求一次数据，达到实时显示，本质是HTTP的request/response模式\n\n每次都是客户端主动请求，浪费贷款\n\n\n# Websocket\n\n只需一次握手 即可通信\n\n\n# Service Worker\n\n\n# 浏览器不同tab页通信\n\n应用场景 网页即时通讯\n\n\n# cookie\n\n\n# localStorage\n\n\n# web worker\n\nservice worker是web worker的一种类型\n\n\n# Websocket\n\n\n# 加了代理服务器，缓存如何计算？\n\nHTTP 的代理服务以及缓存代理",normalizedContent:"# 浏览器\n\n\n\n浏览器是一个多进程架构，我们关心渲染进程(核心进程)\n\n为何使用多进程架构?\n\n多个线程共享 相同地址空间和资源，存在 线程之间可能恶意修改/获取 非授权数据 等 安全问题\n\n单进程浏览器： 1、不稳定。单进程中 插件、渲染线程崩溃导致 浏览器崩溃 2、不流畅。脚本（死循环）/插件会使浏览器卡顿 3、不安全。插件和脚本可获取os 任意资源\n\n多进程浏览器： 1、解决不稳定。进程 相互隔离，一个页面/插件崩溃时，仅影响当前插件/页面 2、解决不流畅。脚本阻塞当前页面渲染进程，不影响其他页面 3、解决不安全。多进程架构使用沙箱。沙箱看成是os给进程上一把锁，沙箱的程序可以运行，不能在硬盘上写入数据，不能在敏感位置读取数据\n\n> 沙箱 将渲染进程和os隔离\n> \n> 利用os提供的安全技术，渲染进程在执行过程中无法访问os的数据，渲染进程需要访问系统资源时，通过浏览器内核实现，将访问结果通过ipc转发给渲染进程\n\n\n# 主要进程\n\n1、浏览器主进程\n\n控制页面创建、销毁、网络资源管理、下载等， 提供存储等功能\n\n浏览器进程中线程：\n\n 1. ui进程\n 2. 存储线程：控制文件的访问\n\n2、插件进程\n\n负责插件运行，插件易崩溃，需通过插件进程隔离，保证插件进程崩溃不会对浏览器/页面造成影响\n\n3、gpu进程\n\n最多一个，用于3d绘制等，从浏览器进程中独立出来\n\n4、浏览器渲染进程(浏览器内核)\n\n**每个tab页对应一个进程，互不影响 ， 将html、css 和 js转换为可以与用户交互的网页 **\n\n5、网络进程\n\n从浏览器进程中独立出来， 负责页面的网络资源加载\n\n\n\n\n# 渲染进程多线程\n\n1、gui 线程\n\n渲染页面。在js引擎运行脚本期间**，gui渲染线程都是处于挂起状态的，被”冻结”了**\n\n2、js 引擎线程\n\n**解析和执行 js ，v8 引擎 跑在 js 引擎线程上，没有单/多线程之说，因为解释这个语言的是 的线程 是单线程；**js 引擎线程与 gui 线程互斥，浏览器执行 js 程序的时候，gui 渲染线程 保存在一个队列当中；直到 js 程序执行完成，才接着执行；如果 js 执行时间过长，会影响页面的渲染，所有要尽量控制 js 的大小\n\n3、定时触发线程\n\njs引擎是单线程**， 处于阻塞线程状态会影响记计时的准确， 因此通过单独线程来计时并触发定时是更为合理的方案**\n\n为什么 settimeout 不阻塞后面程序的运行，因为 settimeout 不是由 js 引擎线程完成，是由定时器触发线程完的，所以它们可以同时进行，定时器触发线程 在定时任务完成后 通知事件触发线程 往任务队列里添加事件\n\n4、事件触发线程\n\n当一个事件被触发时该线程把事件添加到待处理队列的队尾，等待js引擎处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、ajax异步请求等\n\n5、异步 http 请求线程\n\nxmlhttprequest 连接 通过浏览器新开线程请求， 检测到状态变更，如果设置有回调，异步线程就产生状态变更事件放到 js引擎的处理队列中等待处理\n\n\n# 内核\n\n浏览器内核 通过取得页面内容、整理信息、计算和组合最终输出可视化图像结果（渲染引擎）\n\n每一个tab页面可以看作是浏览器内核进程，浏览器内核是多线程的\n\n\n * # 常见浏览器内核？\n\ntrident内核：ie，360，搜狗等浏览器\n\ngecko内核：firefox\n\nblink内核：opera7及以上\n\nwebkit内核：safari，chrome\n\n\n * # 检测版本\n\n 1. window.navigator.useragent 不可靠，因为 useragent可被改写，早期浏览器如 ie，会伪装自己的 useragent值为 mozilla躲过检测\n 2. 功能检测，根据每个浏览器独有特性判断，如 ie 独有 activexobject\n\n\n# 判断访问设备\n\nnavigator.useragent\n\n设备屏幕的宽度大小\n\n客户端操作系统类型(platform)\n\n\n# ⚠️event loop\n\n面试率超高的js事件循环，看这篇就够了\n\n面试必问之 js 事件循环（event loop），看这一篇足够\n\n事件循环，是指浏览器或node解决js单线程运行时不会阻塞的一种机制——我们经常使用异步的原理\n\n设置 2 个线程，一个负责程序本身的运行——“主线程”\n\n另一个负责主线程和其他进程（主要是各种 i/o 操作）的通信 ——“event loop 线程”\n\njs 采用这种机制，解决单线程带来的问题\n\n> js 引擎执行代码时会产生执行栈，调用异步 api，例如 settimeout，setinterval，promise 等回调触发时，会进入异步任务队列，当同步代码执行完成后，会去异步队列取出回调函数执行，形成事件循环\n\n事件循环任务：将队列和调用堆栈连接起来\n\n执行栈类似于函数调用栈的运行容器，当其为空，js检查事件队列，将第一个任务压入栈中执行。若调用栈和微任务队列为空，事件循环检查宏任务队列是否还有任务，弹出进入调用栈执行再弹出\n\n * settimeout回调 不是马上执行，而是最快可以多久后执行，因为它会等待调用 栈为空\n\n * 浏览器的渲染必须要调用栈为空时才会执行\n\n * 一个回调出栈，另一个回调进栈的间隙(此时栈空)，渲染得以顺利进行\n\n\n# js单线程问题\n\nsettimeout如果在主线程上运行会阻塞其他活动\n\n所以，需要做的就是，离开这个线程，同时运行这个任务\n\n作为浏览器脚本语言，js主要用于 用户互动、操作dom。这决定了它只能是单线程，否则会带来很复杂的同步问题\n\n比如，假定js同时有两个线程，一个线程在某个dom节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂\n\n> js异步实现？\n\n浏览器的内核多线程实现\n\n\n# event loop\n\n任务被分为 宏任务 和 微任务\n\n 1. 宏观：浏览器多线程（从宏观来看是多线程实现了异步）\n 2. 微观：event loop\n\n**常见的macrotask有：(一般由浏览器发起)**dom渲染后触发\n\n 1. script整体代码\n 2. setimmediate(node )\n 3. settimeout 和 setinterval\n 4. requestanimationframe？？不是宏任务！(css详述)\n 5. i/o\n 6. ui rendering\n\n> postmessage\n\n常见的microtask有：(一般由js自身创建)dom渲染前触发\n\n 1. process.nexttick (node)\n 2. promise callback(例如 promise.then)\n 3. object.observe (基本已废弃)\n 4. mutationobserver\n\n\n# 运行过程\n\njs 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都放到调用栈等待主线程执行\n\n单线程任务分为同步/异步任务，同步任务在调用栈中按照顺序等待主线程执行，异步任务在有了结果后，将注册的回调放入任务队列中等待主线程空闲时（调用栈被清空），被读取到栈内等待主线程执行\n\n线程都有自己的运行数据存储空间，堆的空间比较大，所以存储对象\n\n函数调用就入栈，执行完函数体的代码自动从栈中弹出——调用栈\n\n当栈中的函数出栈时，栈为空的话，我们会调用一些异步函数，这个异步函数会找它们的异步处理模块，异步处理模块包括定时器、promise、ajax等，异步处理模块会找它们各自对应的线程，线程向任务队列中添加事件，再从任务队列中取出事件，执行对应的回调\n\n3个注意点：\n\n 1. 当宏任务执行完，会去执行所有微任务\n 2. 微任务执行完再去执行下一个宏任务，等调用栈为空时执行一个微任务；调用栈不为空时，任务队列的微任务一直等；微任务执行完又去取任务队列的宏任务**，依次执行宏任务，执行宏任务时检查当前是否存在微任务，若有微任务就去 执行完所有微任务，然后 再去执行宏任务 **\n\n注意点：\n\n 1. 一个 event loop 有一/多个 task queue（任务队列）\n 2. 每个 event loop 有一个 microtask queue（微任务队列）\n 3. requestanimationframe 不在任务队列也不在微任务队列，在渲染阶段执行\n 4. 任务需要多次事件循环才能执行完，微任务是一次性执行完\n 5. 第一个宏任务（主程序）执行完，执行全部的微任务（一个 promise），再执行下一个宏任务（settimeout）\n\n（1）所有同步任务都在主线程上执行，形成 执行栈\n\n（2）主线程之外， 存在 \"任务队列\"（task queue）。只要异步任务有 结果，就在\"任务队列\"之中放置一个事件\n\n（3）同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入event table并注册\n\n（4）当指定 事情完成 ，event table 将这个函数移入event queue\n\n（3）一旦\"执行栈\"中的所有同步任务执行完毕，系统 读取\"任务队列（event queue）\"的异步任务,如果有就推入主线程\n\n（4）主线程不断重复以上步骤\n\n要把本次宏任务下所产生的微任务全部执行完才会执行下一个宏任务，记住是产生的，没有产生的不会执行！\nasync函数是对一些异步操作的处理方式，一旦调用会立即执行，其中可包含微任务和宏任务\nawait语句后面的代码回放进微任务队列执行\n\n\n1\n2\n3\n\n\n**一轮事件循环就是第一轮宏任务和微任务结束。**当微任务队列清空后，一个事件循环结束\n\n正确的一次 event loop 顺序是：\n\n 1. 执行同步代码，这属于宏任务\n 2. 执行栈为空，查询是否有微任务需要执行\n 3. 执行所有微任务\n 4. 必要的话渲染 ui\n 5. 然后开始下一轮 event loop，执行宏任务中的异步代码\n\n如果宏任务中的异步代码有大量的计算并且需要操作 dom 的话，为了更快的 界面响应，我们可以把操作 dom 放入微任务中\n\n\n# js处理异步事件\n\n * 同步任务：主线程排队执行的任务，只有前一个执行完毕，才能执行后一个\n * 异步任务：不进入主线程、进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行，该任务才进入主线程执行\n\n既然js是单线程的,只能在一条线程上执行, 如何实现异步 ?——事件循环(event loop)\n\n> 执行栈\n\njs 生成 与 方法对应的执行环境（context）——执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this。当方法被依次调用，同一时间只能执行一个，于是这些方法被排队在单独的地方——执行栈\n\n> 任务队列\n\njs的另一大特点——非阻塞， 关键在于任务队列\n\njs引擎遇到 异步任务后 不会一直等待其返回结果，而是 将这个任务 压入到任务队列 ，继续执行执行栈中的 任务。当 异步任务返回结果后，js 将这个任务加入与当前执行栈不同的另一个队列——任务队列\n\n被放入任务队列不会立刻执行，而是等待当前执行栈中的所有任务 执行完毕， 主线程处于闲置状态时，去查找任务队列是否有任务。如果有， 主线程会从中取出排在第一位的事件， 把这个任务对应的回调放入执行栈中， 执行其 同步代码， 反复 形成 无限的循环\n\n\n# 事件队列有优先级吗\n\n\n# node事件循环\n\n官网描述：\n\nnode.js启动时，初始化事件循环，处理输入脚本，这个脚本可能异步api调用、调度计时器/调用process.nexttick()，然后开始处理事件循环\n\njs和node.js 基于v8 引擎 ，浏览器 包含 异步方式在 node 是一样的。除此之外，node 还有一些其他的异步形式\n\nmicrotask 在事件循环的各个阶段之间执行（一个阶段执行完毕，就去执行microtask队列）。和浏览器不同，nodejs是来都来了，一次执行完该阶段的任务好了\n\n\n# 事件循环顺序\n\n\n\n 1. timers 阶段 ：执行settimeout和setinterval的callback\n\n 2. pending io callbacks：系统操作的回调，如定时器和setimmediate回调，上一轮循环中少数callback的执行\n\n 3. idle，prepare：仅在内部使用\n\n 4. poll：等待新的 i/o 事件进来，其他所有宏任务都属于poll阶段，最重要的阶段，执行pending callback，适当的情况会阻塞在这个阶段\n    \n    1. 当 poll 中没有定时器，发生两件事\n    \n    * poll 队列不为空，遍历回调队列并同步执行，直到队列为空或者系统限制\n    \n    * poll 队列为空，两件事\n      \n      * 有 setimmediate 需要执行，poll 阶段停止并进入到 check 阶段执行 setimmediate\n      * 没有 setimmediate 需要执行，等待回调被加入到队列中并立即执行回调\n      \n      如果有别的定时器需被执行，回到 timer 阶段执行回调\n\n 5. check：setimmediate回调执行\n\n 6. close callbacks：内部使用，关闭回调执行\n\n\n\n每个阶段都去执行完当前阶段的任务队列，继续执行当前阶段的微任务队列，只有当前阶段所有微任务都执行完，才进入下阶段。这里也是与浏览器中逻辑差异较大的地方，不过浏览器不区分这些阶段，也少了很多异步操作类型，不用刻意区分两者区别\n\n另一个与浏览器的差异体现在同一个阶段不同任务执行\n\n * 浏览器，宏任务完成优先处理微任务\n * node，处于 timers 阶段，先将所有 timer 回调执行完之后再执行微任务\n\n差异可以用浏览器和 nodejs 10 对比验证。感觉有点反程序员？因此 nodejs 在 11 后，修改了此处逻辑使其与浏览器尽量一致，每个 timer 执行后都检查微任务队列， nodejs 11 后的输出已经和浏览器一致了\n\n\n# process.nexttick\n\n将一个函数推迟到代码中所书写的下一个同步方法执行完毕或异步方法的事件回调开始执行时调用，该方法 参数是被推迟的函数\n\nprocess.nexttic和微任务啥时候执行?process.nexttick优先于微任务\n\n\n# settimeout、setimmediate\n\n二者相似，区别在调用时机不同\n\n * setimmediate —— check 阶段\n\n * settimeout poll 阶段为空闲时，且设定时间到达后执行， timer 阶段执行\n\n\n * # settimeout\n\n每一个settimeout在执行时，会返回唯一id\n\nfor ( var i=1; i<=5; i++) {\n\tsettimeout( function timer(j) {\n\t\tconsole.log( j );\n\t}, i*1000, i);\n}\n\n\n1\n2\n3\n4\n5\n\n\n利用settimeout第三个参数解决循环输出问题\n\nprocess.nexttick() 比 promise.then()执行早，同步任务后，其他所有异步任务前，优先执行 nexttick。可以想象是把 nexttick 的任务放到了当前循环的后面，与 promise.then() 类似，但比 promise.then() 更前面。\n\n当前同步代码执行完成后，不管其他异步任务，尽快执行 nexttick\n\n\n# 栗子\n\nfunction cb(msg) {\n    return function () {\n        console.log(msg)\n    }\n}\n\nsettimeout(cb('settimeout'), 100)\nsettimeout(cb('setimmediate'))\nprocess.nexttick(cb('process.nexttick'))\ncb('main process')()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# node和浏览器事件循环区别\n\n流程对比：\n\n 1. 执行 script 代码\n 2. 把微任务队列清空：node 清空微任务队列的手法比较特别。在浏览器中，我们只有一个微任务队列需要接受处理；但在 node 中，有两类微任务队列：next-tick 队列和其它队列。next-tick 队列专门收敛 process.nexttick 派发的异步任务。清空队列时，优先清空 next-tick 队列中的任务，随后才会清空其它微任务\n 3. 开始执行 macro-task（宏任务）。node 执行宏任务的方式与浏览器不同：在浏览器中，每次出队执行一个宏任务； node 中，我们每次会尝试清空当前阶段对应宏任务队列里的所有任务\n 4. 步骤3开始，进入 3 -> 2 -> 3 -> 2…的循环\n\n\n# ✅ 输入url回车后……\n\n>  1. url解析\n>  2. 查找缓存\n>  3. 域名解析：浏览器>系统>本地hosts>根域名>顶级域名>二级域名>三级域名\n>  4. tcp三次握手\n>  5. 发送http请求\n>  6. 处理请求并返回\n>  7. 解析渲染页面\n>  8. tcp四次挥手\n\n\n# 🅰️ 导航阶段\n\n\n# ①浏览器主进程\n\n# 1.输入url\n\n**1、**浏览器进程检查url，组装协议，构成完整url，两种情况：\n\n * 输入 搜索内容：地址栏使用浏览器默认搜索引擎，合成新的带搜索关键字的url\n * 输入 url：地址栏根据规则，给这段内容加上协议，合成为完整url\n\n**2、**浏览器进程通过进程间通信（ipc）把url请求发送给网络进程\n\nurl一般包括几大部分：\n\n * protocol，协议头，如http，ftp\n * host，主机域名/ip地址\n * port，端口号\n * path，目录路径\n * query，查询参数\n * fragment， #后的hash值，一般用来定位到某个位置\n\n\n\n\n# ②网络进程\n\n# 2.url请求\n\n**3、**网络进程接收到url请求后检查本地是否缓存\n\n * 浏览器发送请求前，根据请求头的expires和cache-control判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，不会发送请求。如果没有命中，进入下一步\n\n * 没有命中强缓存规则，浏览器发送请求，根据请求头的if-modified-since(last_modified)和if-none-match(etag)判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，进入下一步\n\n * 如果前两步都没有命中，直接从服务端获取资源\n\n**4、**准备ip地址和端口：dns解析时先查找缓存，没有再使用dns服务器解析，查找顺序：\n\n * 浏览器缓存\n\n * 本机缓存\n\n * hosts文件\n\n * 路由器缓存\n\n * isp dns缓存\n\n * dns递归查询（本地dns服务器 -> 权限dns服务器 -> 顶级dns服务器 -> 13台根dns服务器）\n\n\n\n> 域名查询时可能经过了cdn调度器（如果有cdn存储功能的话）\n> \n> dns解析很耗时，解析域名过多会让首屏加载变得过慢，可以考虑 dns-prefetch优化\n> \n> https://developer.mozilla.org/zh-cn/docs/web/performance/dns-prefetch\n\n**5、**等待tcp队列：浏览器为每个域名最多维护6个tcp连接，如果发起一个http请求时，这 6个 tcp连接都处于忙碌状态，请求会处于排队状态，解决：\n\n * 采用域名分片技术：将一个站点的资源放在多个（cdn）域名下面\n   \n   * 升级为http2，就没有6个tcp连接的限制了\n\n**6、**三次握手建立tcp连接：\n\n\n\n * 第一次：**客户端向服务器端发送一个同步数据包，报文的tcp首部中：**同步syn为1，表示这是一个请求建立连接的数据包；序号seq=x，x为所传送数据的第一个字节的序号，随后进入syn-sent状态\n\n> 标志位值为1表示该标志位有效\n\n * **第二次：**服务器根据收到数据包的syn标志位判断为建立连接的请求，返回一个确认数据包，标志位syn=1，ack=1，序号seq=y，确认号ack=x + 1表示收到了客户端传输过来的x字节数据，希望下次从x+1个字节开始传，并进入syn-rcvd状态\n\n> 要区分标志位ack和确认号ack\n\n * **第三次：**客户端收到后，再给服务器发送一个确认数据包，标志位ack=1，序号seq=x+1，确认号ack=y+1，随后进入established状态；\n\n服务器端收到后，也进入established状态，由此成功建立tcp连接，开始数据传送\n\n * 为什么要三次握手？避免服务器等待造成资源浪费，具体原因：\n\n> 如果没有最后一个数据包确认（第三次握手），a先发出建立连接的请求数据包，由于网络原因绕远路了。a经过设定的超时时间后还未收到b的确认数据包\n> \n> 于是发出第二个建立连接的请求数据包，这次网路通畅，b的确认数据包也很快就到达a。于是a与b开始传输数据\n> \n> 过了一会a第一次发出的建立连接的请求数据包到达了b，b以为是再次建立连接，所以又发出一个确认数据包。由于a已经收到了一个确认数据包，所以忽略b发来的第二个确认数据包，但是b发出确认数据包之后就要一直等待a的回复，而a永远也不会回复\n> \n> 由此造成服务器资源浪费，这种情况多了b计算机可能就停止响应了\n\n**7、**构建并发送http请求\n\n * 建立tcp连接后，浏览器发送http请求到服务器，请求的内容包括 请求行 请求头和请求体\n * 当服务器接收到请求之后，处理完之后返回http响应消息，包括，响应行，响应头和响应体\n * 服务器响应之后，http默认开启长连接，页面关闭后，tcp连接经过四次挥手断开\n\n**8、**服务器端处理请求\n\n**9、**客户端处理响应，检查服务器响应报文状态码\n\n * 301/302表示服务器已更换域名需要重定向，网络进程会从响应头的location字段里面读取重定向的地址，发起新的http/https请求，跳回第4步\n   \n   200，检查content-type，值为text/html说明是html文档，是application/octet-stream说明是文件下载\n\n\n\n**10、**请求结束，当通用首部字段conection不是keep-alive时，即不为tcp长连接时，四次挥手断开tcp连接\n\n四次挥手步骤（抽象派）\n\n * 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\n * 被动方：收到通道关闭的信息\n * 被动方：那我也告诉你，我这边向你的主动通道也关闭了\n * 主动方：最后收到数据，之后双方无法通信\n\n\n\n * **第一次：**客户端（主动断开连接）发送数据包给服务器，标志位fin=1，序号位seq=u，停止发送数据\n * **第二次：**服务器收到数据包后，由于还需传输数据，无法立即关闭连接，先返回标志位ack=1，序号seq=v，确认号ack=u+1的数据包\n * **第三次：**服务器准备好断开连接后，返回数据包，标志位fin=1，ack=1，序号seq=w，确认号ack=u+1\n * **第四次：**客户端收到数据包后，返回标志位ack=1，序号seq=u+1，确认号ack=w+1的数据包\n\n由此通过四次挥手断开tcp连接\n\n> 详细过程参见：https://www.cnblogs.com/ahuntsun-blog/p/12028636.html\n\n为什么要四次挥手？\n\n服务器不能马上断开连接，导致fin释放连接报文与ack确认接收报文需要分两次传输，即第二次和第三次\"挥手\"\n\n# 3. 准备渲染进程\n\n**11、**准备渲染进程：浏览器进程检查当前url是否与之前打开了渲染进程的页面的根域名相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程\n\n# 4. 提交文档\n\n**12、**提交文档：\n\n * 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息后与网络进程建立传输数据的“管道”\n * 渲染进程接收完数据后，向浏览器发送“确认提交”\n * 浏览器进程接收到确认消息后更新浏览器界面状态：安全状态、地址栏url、前进后退的历史状态、更新web页面\n\n\n\n\n# 🅱️ 渲染阶段\n\n渲染步骤：\n\n 1. 渲染进程解析html文本，解析 html 同时，如果遇到内联样式，下载并构建样式规则（stytle rules）。遇到 js 脚本下载并执行，构建dom树\n 2. 构建dom过程若遇到外联样式/脚本声明，暂停文档解析，开始下载样式脚本和文件\n 3. 样式文件下载完成后构建cssdom；脚本文件下载完成后，解析并执行，继续解析文档构建dom\n 4. 文档解析完成后，合成布局树（layout/reflow），负责各元素尺寸、位置的计算\n 5. 绘制render树（paint），绘制页面像素信息\n 6. 渲染进程对布局树分层，分别栅格化每一层得到合成帧\n 7. 渲染进程将合成帧发送给gpu将各层合成（composite）显示\n\n渲染阶段通过渲染流水线在渲染进程的主线程和合成线程配合下，完成页面渲染；\n\n> tiles 瓷砖，小瓦片\n> \n> raster 光栅\n\n③渲染进程\n\n# 5. 构建dom树\n\n13、将请求回来的数据解压，html解析器html字节流通过分词器拆分为一个个token，生成节点node，最后解析成浏览器识别的dom树结构[解析html，生成dom树]\n\n 1. \n 2. 重点过程\n    1. conversion：浏览器将获得的html内容（bytes）转换为单个字符\n    2. tokenizing分词：浏览器按照html规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集\n    3. lexing词法分析：分词的结果是得到一堆token，把他们转换为对象，分别定义属性和规则\n    4. dom构建：html标记定义的是不同标签之间的关系，这个关系像树形结构。例如：body对象的父节点是html对象，p对象的父节点就是body对象\n 3. 最后dom树\n\n\n\nconsole选项打开控制台输入document查看dom树\n\n> 渲染引擎有一个安全检查模块叫 xssauditor，检测词法安全。在分词器解析出来 token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 csp 规范，是否存在跨站点请求等。如果出现不符合规范的内容，xssauditor 会对该脚本或者下载任务进行拦截\n\n首次解析html时渲染进程开启一个预解析线程，遇到html文档中内嵌的js和css外部引用会同步提前下载这些文件，下载时间以最后下载完的文件为准\n\n\n\n# 6. 构建cssom\n\n14、css解析器将css转换为浏览器能识别的stylesheets——cssom：通过控制台输入document.stylesheets查看\n\n考虑一下阻塞的问题，js有修改css和html的能力，所以需要先等到 css 文件下载完成并生成 cssom，再执行 js 脚本，最后继续构建 dom。由于这种阻塞，导致了解析白屏[解析css， 生成cssom]\n\n> 优化：\n> \n>  1. 移除js/css的文件下载：通过内联 js/ css\n>  2. 尽量减少文件大小：如通过 webpack 等工具移除不必要注释，压缩 js 文件\n>  3. 将不进行dom操作/css样式修改的 js 标记上 sync/ defer异步引入\n>  4. 使用媒体查询属性：将大css文件拆分成多个用途的 css 文件，在特定的场景下会加载特定的 css 文件\n\n通过浏览器调试工具的network面板中的domcontentloaded查看最后生成dom树所需的时间\n\n\n\n\n\n# 7. 样式计算\n\n**15、**转换样式表中的属性值，标准化。如将em转换为px，color转换为rgb\n\n**16、**计算dom树中每个节点具体样式，遵循css的继承和层叠规则\n\n\n\n# 8. 布局阶段\n\n[结合dom和cssom树，生成渲染树]\n\n**17、**创建布局树，遍历dom树中所有节点，去掉所有隐藏的节点（比如head，添加了display:none的节点），保留可见的节点\n\n**18、**计算布局树中节点的坐标位置（较复杂，这里不展开），对于每个可见的节点，找到cssom树中对应规则并应用，根据每个可见节点及其对应的样式，生成渲染树\n\n# 9. 分层\n\n**19、**对布局树分层，生成分层树（layer tree），通过chrome调试工具的layer查看。分层树中每一个节点都直接/间接的属于一个图层\n\n\n * # 图层\n\n可把普通文档流看成一个图层。特定属性可以生成一个新的图层。不同的图层渲染互不影响，对于某些频繁需要渲染的建议单独生成一个新图层，提高性能\n\n以下几个常用属性可以生成新图层\n\n * 3d 变换：translate3d、translatez\n * will-change\n * video、iframe\n * 动画实现的 opacity 转换\n * position: fixed\n\n> 页面分层后，会加大重绘开销？？不会\n> \n> 使用gpu硬件加速的操作都由gpu进程负责？？我觉得 是的！\n\n# 10. 图层绘制\n\n**20、**为每个图层生成绘制列表（即绘制指令），将其提交到合成线程。以上操作都是在渲染进程中主线程中进行，提交到合成线程后就不阻塞主线程了\n\n\n\n> 渲染进程中的合成线程部分\n\n\n\n# 11. 切分图块\n\n**21、**合成线程将图层切分成大小固定的图块（256x256或者512x512）优先绘制靠近视口的图块，可加速页面显示速度\n\n\n\n\n# ④gpu进程\n\n# 12. 栅格化\n\n22、在光栅化线程池中将图块转换成位图，通常这个过程会使用gpu加速生成，使用gpu生成位图的过程叫快速栅格化/gpu栅格化，生成的位图保存在gpu内存中\n\n\n\n\n# ⑤浏览器主进程\n\n# 13. 合成与显示\n\n**23、**合成：一旦所有图块都被光栅化，合成线程将它们合成为一张图片，生成绘制图块的命令——“drawquad”，将该命令提交给浏览器进程\n\n> 注意：合成过程在渲染进程的合成线程中完成，不影响渲染进程的主线程\n\n**24、**显示：浏览器进程里面有一个叫viz的组件，接收合成线程发过来的drawquad命令，根据drawquad命令，将其页面内容绘制到内存中，最后将内存显示在屏幕上。将像素发送给gpu，展示在页面上(gpu将多个合成层合并成一个层，展示)\n\n到这里，经过这一系列的阶段，编写好的html、css、js等文件，经过浏览器就会显示出漂亮的页面了\n\n> layout回流 [重排]：通过 js 或者 css 修改元素几何位置属性，会触发重新布局，解析后面一系列子阶段\n> \n> 重绘：跳过布局阶段，直接进入绘制，然后分块、生成位图及以后子阶段；painting 根据渲染树及回流得到的几何信息，得到节点的绝对像素\n> \n> 合成：渲染引擎跳过布局和绘制阶段，执行的后续操作，发生在合成线程，非主线程\n\n\n# 🔥合成线程处理事件\n\n合成线程合成不同光栅层优化性能，若页面不监听事件，合成线程可完全独立于 主线程生成新的合成帧。但若监听了事件呢？\n\n> 标记\"慢滚动区域\"\n\n当页面被合成线程合成过，合成线程会标记哪些区域有事件，当事件发生在响应区域时，合成线程将事件发送给主线程处理，若在 非事件监听区域，则 渲染进程直接创建新的帧 不关心主线程\n\n\n\n> 事件监听时标记\n\n利用事件代理冒泡，在目标元素的上层元素中监听事件\n\ndocument.body.addeventlistener('touchstart',event=>{\n    if(event.target===area){\n        event.preventdefault()\n    }\n});\n\n\n1\n2\n3\n4\n5\n\n\n确实 可以更高效监听事件\n\nbut，从浏览器角度看，此时 整个页面都会标记为 \"慢滚动区域\"，意味着 虽然页面部分元素不需要事件监听，但 合成线程 依然在每次交互发生后等待主线程处理事件，弱化了合成线程的优化效果\n\n> 解决\n\n事件代理时传入 passive:true，告诉 渲染进程，依然需要将事件发送给主线程，但无需等待\n\ndocument.body.addeventlistener('touchstart',event=>{\n    if(event.target===area){\n        event.preventdefault()\n    }\n},{passive:true});\n\n\n1\n2\n3\n4\n5\n\n\npassive 改善滚屏性能\n\n\n# 前端缓存\n\n前端缓存 主要分为http缓存和浏览器缓存\n\nhttp缓存：强缓存、协商缓存\n\n浏览器缓存：storage 前端数据库和应用缓存\n\n应用缓存主要通过manifest文件注册被缓存的静态资源，已被废弃，因为设计有些不合理，缓存静态文件的同时，默认缓存html文件。导致页面更新只能通过manifest文件中的版本号决定。所以，应用缓存只适合那种常年不变化的静态网站\n\n> 优点\n\n * 减少不必要网络传输，节约带宽(省钱)\n * 降低客户端获取资源的延迟，读取缓存速度快，地理位置可能比源服务器更近\n * 更快加载页面(加速)\n * 减少 服务器 负载(减载)\n\n> 缺点\n\n * 占内存\n\n\n# http缓存\n\n能用cache-control就不用expires\netag不是last-modified的完全替代方案，而是last-modified的补充方案，项目中使用etag还是last-modified取决于业务场景\n\n\n1\n2\n\n\n\n\nhttp控制缓存的字段主要包括cache-control/expires，last-modified/etag\n\n本地强缓存过期了，就需要协商缓存，去看服务器上的资源改没有\n\n\n# 强缓存\n\n客户端请求后，先访问缓存数据库看缓存是否存在。存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库\n\n服务器与浏览器约定文件过期时间，向browser缓存查找请求结果，根据该结果的缓存规则决定是否使用该结果\n\n * 强制缓存失效，发送请求（和第一次请求一样）200\n * 存在缓存结果和标识但结果已失效，使用协商缓存\n * 存在缓存结果和标识且未失效，直接返回结果，在 size 项中标识的是 200 from disk cache\n\n发送请求，服务器把缓存规则放入http响应报文的http头中和请求结果一起返回给浏览器， 控制强制缓存的字段是expires（http1.0时期使用）\n\ncache-control（http/1.1 使用）\n\ncache-control优先级比expires高\n\n\n# expires(http/1.0)\n\n响应头，时间戳，控制网页缓存，**服务器返回请求结果缓存的到期时间，**再次发起该请求时，如果客户端的时间小于expires的值， 直接使用http本地缓存并返回200\n\n缺点： expires控制缓存的原理是使用客户端的时间与服务端返回时间做对比，如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，强制缓存直接失效，这样的话强制缓存 毫无意义\n\n\n# cache-control(http/1.1)\n\n响应头和请求头\n\n没有采用具体的过期时间节点的方式，而是采用过期时长控制缓存，对应缓存为max-age\n\n在http/1.1中，cache-control是最重要的规则，服务端参数为：\n\n> public：都可以被缓存\n> \n> private：只有客户端可以缓存，默认\n> \n> no-cache：协商缓存验证\n> \n> no-store：更狠，不使用任何缓存\n> \n> max-age=x ：缓存内容将在xxx秒后失效，单位是 s！！！\n> \n> must-revalidate：一旦资源过期，在成功向原始服务器验证之前，不能使用\n\nno-cache和no-store存在时 忽略max-age！\n\npublic和private ——决定资源是否可以在 代理服务器 缓存\n\ncache-control实现流程:\n\n 1. 浏览器第一次访问服务器资源时，服务器在response头部加上 cache-control， cache-control 设置 过期时间大小\n 2. 浏览器再次访问服务器资源时，先通过请求资源的时间与cache-control中设置的过期时间对比，计算该资源是否过期，若没有则使用该缓存，否则重新请求\n 3. 服务器再次收到请求后，更新response头部的cache-control\n\n优先级：cache-control>expires\n\n\n# 协商缓存\n\n与服务端协商之后，通过 协商结果 判断是否使用本地缓存，通过服务端告知客户端是否可以使用缓存——协商缓存\n\n强制缓存失效后，browser携带缓存标识tag 发请求，由服务器根据缓存tag决定是否使用缓存\n\ntag分为2组字段（不是两个）：last-modified和etag\n\n\n# last-modified(http/1.0)\n\nlast-modified(响应头)，if-modified-since(请求头)\n\n文件在服务端的最后修改时间\n\n判断请求资源是否最新，浏览器第一次发送请求后，服务器会在响应头中加入这个字段\n\nbrowser接收后，若再次请求，在请求头中携带if-modified-since字段，询问该时间之后，资源是否有被修改过，其实就是第一次访问服务器返回的last-modified的值\n\n服务器拿到请求头中if-modified-since和该资源最后修改时间对比：\n\n> 若请求头中这个值小于修改时间，说明应该更新了。返回新的资源，状态码为200\n> \n> 否则返回304，直接使用缓存\n\n\n# etag(http/1.1)\n\n服务器根据当前文件的内容，给文件页面生成唯一标识。通过响应头传送给浏览器，下次请求时，将这个值作为if-none-match字段的内容\n\n * 当第一次请求资源时，服务器返回资源的同时， response 头部加上 etag 唯一标识，这个唯一标识根据当前请求资源生成\n\n * 当 再次请求访问服务器中的该资源，先检查强制缓存是否过期，如果没过期，直接使用本地缓存；如果过期，在 request 头部加上 if-none-match 字段，该字段是 etag 唯一标识\n\n * 服务器再次收到请求后，根据请求中的 if-none-match 值与当前请求的资源生成的唯一标识比较：\n   \n   * 值相等，返回 304 not modified，不会返回资源\n   * 不相等，则返回 200 状态码和资源，并在 response 头部加上新的 etag\n\n * 如果浏览器收到 304 的响应状态码，从本地缓存中加载资源，否则更新资源？？协商缓存 资源缓存在本地还是服务器？？\n\n# 强etag\n\n不论实体发生多么细微的变化都会改变其值，生成的哈希码深入每个字节，保证文件内容绝对不变\n\n耗计算量\n\n# 弱etag\n\n只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变\n\n准确率不高\n\n\n# 两者对比\n\n如果 http 响应头部同时有 etag 和 last-modified 字段的时候， etag 的优先级更高，先判断 etag 是否变化，如果 etag 没有变化，再看  last-modified\n\n\n1\n\n 1. 精确度**：etag>last_modified**\n    * 编辑了资源文件，但内容没改变，造成缓存失效\n    * last_modified可感知的时间单位是s，若在1s内修改了文件，不能体现出来\n 2. 性能上：last_modified优于etag\n\n有哈希值的文件设置 强缓存\n没有哈希值(index.html)设置协商缓存\n\n\n1\n2\n\n\n\n# 缓存存储\n\n * 内存缓存：快速读取和实效性\n * 硬盘缓存：写入硬盘文件，需要i/o操作，读取复杂，速度慢\n\n浏览器中的缓存位置，按优先级从高到低排列：\n\n * service worker\n * memory cache\n * disk cache\n * push cache\n\n都没命中的话，就发请求\n\n大的js 、css文件直接丢进磁盘，反之丢进内存\n\n内存使用率高时，文件优先进入磁盘\n\n\n# service worker\n\n是web worker的一个类型\n\n\n# memory cache\n\n内存中的缓存，主要包含 当前中页面中已经抓取到的资源，例如已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存读取高效，可是缓存持续性很短 一旦关闭tab页面，内存中的缓存也就被释放了\n\n计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存不多\n\n\n# disk cache\n\ndisk cache 存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 memory cache 胜在容量和存储时效性上\n\n在所有缓存中，它的覆盖面基本最大。它会根据http header中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需重新请求，而且即使在跨站点时，相同地址的资源一旦被硬盘缓存，就不会再请求\n\n\n# push cache\n\npush cache（推送缓存）是 http/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在chrome浏览器中只有5分钟左右，同时它也并非严格执行http头中的缓存指令\n\n 1. 所有的资源都能被推送，并且能够被缓存\n 2. 可以推送 no-cache 和 no-store 的资源\n 3. 一旦连接被关闭，push cache 就被释放\n 4. 多个页面可以使用同一个http/2的连接，也就可以使用同一个push cache。主要依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个http连接\n 5. push cache 中的缓存只能被使用一次\n 6. 浏览器可以拒绝接受已经存在的资源推送\n 7. 可以给其他域名推送资源\n\n\n# 啥资源强/协商缓存？\n\n * html：协商缓存\n * css、js、图片：强缓存，文件命名带上hash值\n\n考虑缓存的内容：\n\n * css文件\n * js文件\n * logo、图标\n * html\n * 可下载的内容\n\n不应该缓存的内容：\n\n * 业务敏感的 get 请求\n\n网站的缓存设置最佳实践——入口 html 文件 cache-control 设置 no-cache，其他文件 max-age，这样入口文件会用本地缓存但每次都协商，能及时更新，而其他资源不会发请求，减少服务端压力\n\n如果要更新的话，html 文件协商后发现有更新会下载新 html，关联了其他 hash 的文件，浏览器会下载新的，不会走到之前文件的缓存\n\n强制刷新的实现——设置了 cache-control 为 no-cache\n\n清空缓存并强制刷新的功能，是清掉本地的强缓存再去协商，能保证一定是拿到最新的资源\n\n\n# ⚠️前端安全\n\n\n# xss\n\n跨站脚本攻击\n\ncross site scripting ，和 css 区别，css 是层叠样式表 (cascading style sheets)\n\n用户输入/向代码中注入js，暗地执行脚本\n\n 1. 写死循环\n 2. 监听用户行为，窃取用户信息(cookie、token)\n 3. 诱骗用户 点击/填写 表单\n 4. 绘制ui(例如 弹窗)\n\n\n# 存储型\n\nstored xss\n\n危害最大，对所有用户可见\n\nxss代码发送到数据库，前端请求数据时，将xss代码发送到前端\n\n场景：留言区提交一段脚本执行，若前后端未做好转义的工作，评论内容存在数据库，页面渲染过程中直接执行，相当于执行一段未知逻辑的js代码\n\n如论坛发帖、商品评论、用户私信等\n\n * 1、攻击者网页回帖，帖子中包含js脚本\n * 2、回帖提交服务器后，存储至数据库\n * 3、其他网友查看帖子，后台查询该帖子的回帖内容，构建完整网页，返回浏览器\n * 4、该网友浏览器渲染返回的网页，中招！\n\n\n# 反射型\n\nreflected xss\n\n不涉及 数据库，将js代码作为请求参数放置url中，诱导用户点击\n\n恶意脚本通过作为网络请求的参数，经过服务器，反射到html文档中执行解析，服务器不会存储这些恶意脚本\n\n反射型 xss 漏洞常见于通过 url 传递参数的功能，如网站搜索、跳转等\n\n 1. 用户点击后， js作为 参数传给 后端\n 2. 后端 没有检查过滤，简单处理后放入网页正文中返回给浏览器\n 3. 浏览器解析返回的网页，中招！\n\n\n# 文档型\n\ndom-based - xss\n\n * 不需要 服务器 参与\n * 恶意攻击的 发起+执行，全在浏览器 完成\n\nxss攻击作为中间人，劫持到网络数据包，修改里面的html\n\n劫持包括：\n\n 1. wifi路由劫持\n 2. 本地恶意软件\n\ndom 型 xss 跟前两种 xss 的区别：dom 型 xss 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 js 自身安全漏洞，而其他两种 xss 都属于服务端安全漏洞\n\n\n# 突变型\n\nmutation-based xss\n\n * 利用 浏览器渲染 dom 的特性\n * 不同 浏览器 有区别\n\n\n\n\n# 防范：一个信念，两个利用\n\n# 1.对输入转码过滤\n\n * 如果允许 用户上传 dom，需要对 string 转义\n * 上传 svg，需要扫描，因为 svg 标签中可能插入 脚本\n * 尽量不做用户自定义跳转的行为，如果要的话，需要做好过滤，否则可能 会传递 js代码\n * 如果允许用户自定义样式的话(url 或 背景图片)，可能导致xss攻击(非常巧妙)\n\n# 2.利用csp\n\ncontent security policy\n\n浏览器内容安全策略\n\n\n\n 1. 限制其他域下的资源加载\n 2. 禁止向其它域提交数据\n 3. 提供上报机制\n\n# 3.httponly\n\n阻止js对cookie的访问(标记或授权对话)\n\n阻止 xss 攻击：服务器对脚本进行过滤或转码，利用 csp 策略\n\n！！不能阻挡csrf！！\n\n\n# csrf\n\n也叫 xsrf\n\n跨站伪造请求（钓鱼）\n\ncross-site request forgery\n\n打开a网站的情况 ，另开tab 打开恶意网站b，此时在b页面的“唆使”下，浏览器发起 对网站a的 请求\n\n * 1、这个 请求不是用户主动 ，而是b“唆使的”，如 危害较大的请求操作（发邮件？删数据？等等）那就麻烦了\n\n * 2、因为 a网站已经打开了，浏览器存有a 的cookie ， 被“唆使”的请求 自动带上这些信息，a网站后端分不清楚这是否是用户真实的意愿\n\n * 在用户不知情 的情况下\n\n * 利用用户 权限\n\n * 构造指定 http 请求，窃取或修改 用户敏感信息\n\n * csrf 蠕虫\n\n> csrf 蠕虫指的是产生蠕虫效果，会将csrf攻击一传十 十传百，当一个用户访问恶意页面后通过 csrf 获取其好友列表信息，再利用私信好友的csrf 漏洞给每个好友发送一条指向恶意页面的信息，只要有人查看信息链接，csrf 蠕虫会不断传播！\n\n\n\n攻击者诱导受害者进入第三方网站，向被攻击网站发送跨站请求。利用受害者已经获取的注册凭证（如cookie） ，绕过后台验证，冒充用户对被攻击的网站执行某项操作\n\n利用所在网站的目前登录信息，悄悄提交各种信息，比xss更恶劣\n\n\n\n> 本质：利用cookie会在同源请求中携带发送给服务器的特点，冒充用户\n\n点击链接后，可能发生\n\n 1. 自动发送get请求。利用src发送请求\n 2. 自动发送post请求\n 3. 诱导点击发送get请求\n\n\n# 防范\n\n\n\n# 1.samesite\n\n\n\n根源上解决 csrf 攻击\n\nsamesite 限制domain属性和 当前域名 是否匹配\n\n\n\nsamesite属性取值\n\n * strict，仅允许同站请求携带 cookie\n\n * lax，宽松一点，允许部分第三方请求携带 cookie\n\n * none，最宽松，默认模式，无论是否跨站都会发送 cookie\n\nset-cookie: name=lizheming; samesite=none; secure\n\n\n1\n\n\n> 浏览器针对https域名才支持samesite=none，所以我们还需要携带 secure 属性\n\n\n\nsamesite和sameorigin不同，同域判断 更严格，cookie中的同站判断比较宽松，主要根据mozilla维护的公共后缀表（pulic suffix list）使用 有效顶级域名 effective top-level domains (etld) +1 的规则查找得到的一级域名是否相同 来判断是否 是同站请求\n\n例如 .org 是在 psl 中是有效顶级域名，imnerd.org 则是一级域名。所以 https://blog.imnerd.org 和 https://www.imnerd.org 是同站域名。\n\n而 .github.io 也是有效顶级域名，所以 https://lizheming.github.io 和 https://blog.github.io 得到的一级域名不一样，他们两个是跨域请求\n\n在类似 github/gitlab pages，vercel 这种提供子域名给用户建站的第三方服务中，etld的同站判断非常有用，通过将原本是一级域 的域名 添加到 etld 列表中，让浏览器认为配有用户名 的完整域名才是一级域名，有效解决了 不同用户站点的 cookie 共享问题\n\netld 是有效顶级域名，和 top-level domain顶级域名有区别。etld记录在 pst中，tld记录在rzd(root zone database——根区域数据库)，rzd记录了所有的 跟域 列表\n\netld 主要为了解决 .com.cn，，com.hk，这种看起来像是 一级域名 但其实是 作为顶级域名 存在的场景\n\n> schemeful same site 同站计划\n\n# 2.验证来源站点\n\n请求头中的origin和referer\n\nreferer表明请求来源于哪个地址\n\norigin只包含域名信息，referer包含具体的url路径\n\n我们可以拒绝一切非本站发出的请求\n\n简单，但是当网站域名有多个，或经常 变换域名时 会非常麻烦，具有 局限性\n\n# 3.token\n\n\n\n利用token（后端生成的一个唯一登陆态，传给前端保存）每次前端请求都会带token，检验通过才同意请求\n\n\n\ntoken 必须和具体用户绑定，才能确保不会被其他注册用户利用\n\ntoken必须设置有效时间，保不齐哪天token被窃取，已请求的数据会被攻击者利用\n\n为什么 token可以防止 csrf?\n\ntoken被用户端放在cookie中（不设置httponly），同源页面每次发请求都在请求头或者参数中加入cookie中读取的token来完成验证。 csrf只能通过浏览器自己带上cookie，不能操作cookie来获取到token并加到http请求的参数中\n\n# 4.安全框架\n\n如spring security\n\n\n# sql注入\n\n将恶意的 sql查询/添加语句插入到应用 输入参数 ，让服务器执行攻击者期望的sql语句，得到数据库数据/对数据库 读取、修改、删除、插入\n\n\n\n如何让web服务器执行攻击者的sql语句？\n\n将有毒的sql语句放置于form表单/请求参数中，提交到 服务器，如果 服务器没有做输入安全检查，直接将变量取出执行sql语句， 中招\n\n预防方式 ：\n\n * 严格检查输入变量 类型和格式\n * 过滤/转义特殊字符\n * 对访问数据库的应用程序采用web应用防火墙\n\n\n\n\n# iframe 攻击\n\niframe是同源请求\n\n\n# get!==get+post\n\n请求一定要区分开\n\n还有其他种类的攻击，这里不再细说\n\n\n# ddos\n\ndistributed denial of service：分布式拒绝服务攻击。是拒绝服务攻击的升级版。 让服务不可用。常用 攻击对外提供服务的服务器\n\n * web服务\n * 邮件服务\n * dns服务\n * 即时通讯服务\n\n攻击者不断 请求，让合法用户 请求无法及时处理——dos 攻击\n\n攻击者使用多台计算机/计算机集群进行 dos 攻击—— ddos 攻击\n\n早期 ， dos攻击是 很容易的事情：一台性能强劲的计算机，写个程序多线程不断 请求，服务器应接不暇，最终无法处理正常 请求，对别的正常用户来说， 网站貌似无法访问，拒绝服务就是这 个意思\n\n现在 服务器早已不是一台服务器 ， www.baidu.com的域名，背后是数不清的cdn节点，数不清的web服务器\n\n这种情况 想靠单台计算机 试图让 网络服务满载，无异于鸡蛋碰石头\n\n分布式技术 可 提供高可用的服务，也能 被攻击方用来进行大规模杀伤性攻击。攻击者不再局限于单台计算机的攻击能力，转而通过成规模的网络集群发起拒绝服务攻击\n\n\n# dns劫持\n\nweb服务发展 如火如荼， 离不开 默默无闻的域名解析系统\n\ndns 将域名转换成ip ， 早期协议 设计 没有太多考虑其安全性，对于查询方来说：\n\n * 我去请求的真的是一个dns服务器吗？是不是别人冒充的？\n * 查询的结果有没有被人篡改过？这个ip真是这个网站的吗？\n\ndns 没有机制 保证能回答这些问题，因此dns劫持 泛滥，用户在地址栏输入域名的那一刻起，一路上的凶险防不胜防：\n\n * 本地计算机中的木马修改hosts文件\n * 本地计算机中的木马修改dns数据包中的应答\n * 网络中的节点（如路由器）修改dns数据包中的应答\n * 网络中的节点（如运营商）修改dns数据包中的应答\n\n后来，以阿里、腾讯等头部互联网厂推出httpdns服务，釜底抽薪，原来dns天差地别，通过这项技术让dns变成 在http协议之上的一个应用服务\n\n\n# 其他攻击\n\n * json 劫持\n\n轻量级的数据交换格式，而劫持就是对数据 窃取（或者应该称为打劫、拦截比较合适。恶意攻击者通过 特定的手段，将本应该返回的 json数据 拦截，转而 发送 给恶意攻击者 。一般 劫持的json数据都是包含敏感信息或者有价值的数据\n\n * 暴力破解\n\n一般针对密码，弱密码（weak password）很容易被猜到或被破解\n\n解决方案 密码复杂度要足够大，也要足够隐蔽 限制尝试次数\n\n * http 报头追踪漏洞\n\nhttp/1.1 规范定义了 http trace 方法，主要是用于客户端通过向 web 服务器提交 trace 请求来进行测试或获得诊断信息。\n\n当 web 服务器启用 trace 时，提交的请求头会在服务器响应的内容（body）中完整的返回，其中 http 头很可能包括 session token、cookies 或其它认证信息。攻击者可以利用此漏洞来欺骗合法用户并得到他们的私人信息\n\n解决：禁用 http trace\n\n * 信息泄露\n\nweb 服务器或应用程序没有正确处理一些特殊请求，泄露 web 服务器的一些敏感信息，如用户名、密码、源代码、服务器信息、配置信息等\n\n所以需注意：\n\n应用程序报错时，不对外产生调试信息 过滤用户提交的数据与特殊字符 保证源代码、服务器配置的安全\n\n * 目录遍历漏洞\n\n攻击者向 服务器发请求，在 url 中或在有特殊意义的目录中附加 ../、或者附加 ../ 的一些变形（如 .. 或 ..// 甚至其编码），导致攻击者能够访问未授权的目录，以及在 web 服务器的根目录以外执行命令\n\n * 命令执行漏洞\n\n通过 url 发起请求，在 web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪\n\n * 文件上传漏洞\n\n如果对文件上传路径变量过滤不严， 且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器\n\n所以 需注意：\n\n需严格限制和校验上传的文件，禁止上传恶意代码的文件 限制相关目录的执行权限，防范 webshell 攻击\n\n * 其他漏洞\n\nsslstrip 攻击\n\nopenssl heartbleed 安全漏洞\n\nccs 注入漏洞\n\n证书有效性验证漏洞\n\n * 业务漏洞\n\n跟具体的应用程序相关，比如参数篡改（连续编号 id / 订单、1 元支付）、重放攻击（伪装支付）、权限控制（越权操作）\n\n * 框架或应用漏洞\n\nwordpress 4.7 / 4.7.1：rest api 内容注入漏洞\n\ndrupal module restws 7.x：remote php code execution\n\nsugarcrm 6.5.23：rest php object injection exploit\n\napache struts：rest plugin with dynamic method invocation remote code execution\n\noracle glassfish server：rest csrf\n\nqq browser 9.6：api 权限控制问题导致泄露隐私模式\n\nhacking docker：registry api 未授权访问\n\n\n# websocket\n\n\n * # 含义\n\n在单个tcp连接上进行全双工通信的协议\n\n使客户端和服务器间数据交换更简单，允许server主动向client推送data\n\n\n * # 特点\n\n 1. 建立在tcp协议之上\n 2. 良好兼容性。默认端口80和443，握手阶段采用http协议，所以握手时不容易屏蔽，能通过各种http代理服务器\n 3. 数据格式轻量，性能开销小，通信高效\n 4. 二进制和文本均可发送\n 5. 无同源限制\n 6. 协议标识符是ws，网址是url\n\n\n * # 为啥用它？\n\nwebsocket出现前，创建一个和server双通道通信的web应用，需要依赖http协议，不停轮询，导致\n\n * server维持来自每个客户端大量的不同连接\n\n * 大量轮询造成高开销，带上多余header，无用的数据传输\n\n\n * # websocket、http\n\n\n\n * 都基于http，可靠，应用层协议\n * websocket建立握手时，data通过http传输。建立之后，真正传输不需要http协议\n\n> 不同\n\n 1. websocket双向通信，http单向\n 2. http/2具备server推送功能，但http/2只能推送静态资源，无法推送指定信息\n\n> 优点\n\n * websocket一旦被创建，互相沟通所消耗的请求头很小\n * server可向client推送消息\n\n\n# 🌈 cookie、session\n\n实现了http的状态管理，跟踪browser用户身份的会话方式，cookie在客户端，session在服务端\n\n\n# cookie\n\nhttp是无状态协议，服务器管理全部客户端状态会成为负担\n\n> cookie——一小段文本信息。客户端请求服务器，如果服务器需要记录该用户状态，向客户端浏览器颁发一个cookie\n> \n> 客户端把cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该cookie一同提交。服务器检查该cookie，辨认用户状态\n> \n> cookie 根据从服务器端发送的响应报文内的一个叫做 set-cookie 的首部字段信息， 通知客户端保存cookie。当下次客户端再往该服务器发送请求时， 客户端会自动在请求报文中加入 cookie 值后发送出去\n> \n> 服务器端发现客户端发送过来的cookie后， 检查是从哪一个客户端发来的连接请求， 对比服务器上的记录，得到之前的状态信息\n\n 1. 用户能操作cookie，性能缺陷，不管域名下地址是否需要cookie，请求都会携带上完整的cookie\n 2. 每次访问都要送cookie给server，浪费宽带\n 3. path 可限制路径\n 4. 存在浏览器端\n 5. cookie很多都是4k大小，受浏览器限制\n 6. cookie当浏览器关闭就消亡，累计计时，从创建时就开始计时\n 7. 容易被截取篡改\n\n\n# 多域名拆分\n\n * 在移动端，如果请求的域名数过多，会降低请求速度\n * 一种优化方案： dns-prefetch（让浏览器空闲时提前解析dns域名，勿滥用）\n\n\n\n\n# session\n\n> session另一种记录客户状态的机制，存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上\n> \n> 浏览器再次访问只需从该session中查找该客户的状态就可以\n\n 1. session存在服务器端，可存储任何类型数据\n 2. session理论上受内存限制\n 3. 占用server内存，服务器内存压力大\n 4. 依赖cookie，若禁用cookie，需要使用url重写，不安全\n 5. 导致代码不好维护（过度使用session）\n 6. session声明周期是间隔的，没有访问session就被销毁\n\n> sessionid的携带方式\n> \n>  * cookie\n>  * url重写:因为cookie可以人为禁用，常采取的技术就是url重写，将sessionid附加在url的后面. 附加的方式有两种，一种是作为url路径的附加，另一种是作为 query 字符串附加在url后面\n>  * 隐藏表单\n\n\n# 工作流程\n\n 1. 登录时，用户提交的表单，放入http请求报文\n 2. 服务器验证信息，正确则存在数据库中，key为sessionid\n 3. 服务器返回的响应报文的set-cookie首部字段包含这个sessionid，客户端收到后将cookie存进浏览器\n 4. 客户端之后对同一个服务器请求时会包含该cookie，服务器收到后提取出sessionid，读取用户信息\n\n\n# 关系\n\ncookie和session非常相似，cookie相当于客户端持有的通行证，session相当于服务器上的通行名册\n\n服务器第一次接收到请求时，开辟一块 session 空间，同时生成一个 session id ，通过响应头的set-cookie：jsessionid=xxxxxxx ，向客户端发送要求设置 cookie 的响应；客户端收到响应后，在本机客户端设置了一个jsessionid=xxxxxxx的 cookie 信息，该 cookie 的过期时间为浏览器会话结束\n\n接下来客户端每次向同一个网站发送请求时，请求头都会带上该 cookie信息（包含 sessionid ）， 然后服务器通过读取请求头中的 cookie 信息，获取名称为 sessionid 的值\n\n\n# 区别\n\n 1. 存放位置：cookie在客户端，session在服务器端\n 2. 安全性（隐私策略）：cookie对客户端可见；session存储在服务器端。使用cookie需要对其加密\n 3. 有效期：设置cookie很大的过期时间，cookie保存很长时间；服务器会定期清理超时session id避免出现过大压力；但session依赖于类似session id这样的cookie，而cookie对session id过期时间默许为-1。只要关闭浏览器，session就失效\n 4. 对服务器造成的压力：session保存在服务器端，每个用户都产生session，并发访问多会产生十分多的sssion，耗费内存；cookie保存在客户端，不占用服务器资源\n 5. 存取值的类型：cookie只支持字符串数据，session可以存任意数据类型\n 6. 存储大小：**cookie保存的数据不超过4k，**session可存储高于cookie，但访问量过多会导致占用过多资源\n\n\n# 服务器咋知道session过期？\n\nrequest.getsession(boolean)，若为true，如果当前会话不可用，创建新的会话，若存在就返回当前会话。若参数是false，在request当前会话不存在时返回null\n\n\n# 应用\n\n\n# cookie\n\n关闭浏览器消失\n\n 1. 会话状态管理（判断是否登录过网站，购物车，游戏分数等）\n 2. 保存上次登录信息\n 3. 保存上次查看页面\n 4. 个性化设置\n 5. 浏览器行为跟踪\n\n为什么cookie内存容量小？4kb\n\n * 可能造成页面卡顿\n * 传送给服务器压力大\n\n\n# session\n\n 1. 保存用户专用信息在server，sessionid唯一标志符\n 2. 购物车\n 3. 登录信息\n 4. 数据放在session，同一用户不同页面使用\n 5. 防止用户非法登录\n\n\n# 🍉 webstorage\n\n克服cookie带来的限制，不需要持续将数据返回server\n\n 1. 提供cookie之外的存储会话数据的路径\n 2. 跨网站/应用 检测用户的行为而不需要服务端脚本和数据库\n 3. 拥有在用户即使突然断网的情况下可以保存部分web应用的能力，不会因为网络连接问题受影响\n 4. 和cookie一样存在跨域策略\n\n\n# 分类\n\n\n# localstorage\n\n(针对同一个域名)\n\n特点：\n\n 1. 生命周期：持久化本地存储，除非手动删除数据，否则数据永远不过期\n 2. 存储的信息在同一域中共享\n 3. 大小***：5m***，和浏览器厂商有关\n 4. 本质上是对字符串的读取，若存储内容过多会消耗内存空间，导致页面卡顿\n 5. 受同源策略限制\n\n缺点就是\n\n1.无法像cookie设置过期时间\n\n2.只能存字符串\n\n设置过期时间：\n\n自定义方法实现，存数据时把当前时间记录，获取数据时判断当前时间和之前时间差是否在指定过期时间范围内，若过期则清楚数据\n\n> localstorage存储达到上限，如何继续存数据？\n\n 1. 滚动存储\n 2. 跨域存储\n\n> localstorage的key占内存！！\n\n\n# sessionstorage\n\n和localstorage相似，唯一不同是生命周期，一旦页面关闭，sessionstorage将会删除数据\n\n> sessionstorage会被覆盖吗？？\n\n\n# 相同点\n\n 1. 存储大小：一般是5mb\n 2. 存储位置：都存在客户端\n 3. 存储内容类型：只能存储字符串类型\n 4. 获取方式：window.localstorage\n 5. 应用：localstorage用于长期登录，适合长期保存在本地的数据。sessionstorage用于敏感账号一次性登录\n 6. 接口封装\n\n\n# 优点\n\n 1. 存储空间大\n 2. 节省网络流量\n 3. 快速显示\n 4. 安全性\n 5. 对于那种只需要短暂存储关闭页面就可以丢弃的数据，sessionstorage很好用\n\n\n# 方法\n\nsetitem(key,value) //保存\ngetitem(key) //获取\nkey() //获取键名\nremoveitem(key) //清除\nclear() //清除所有数据\nkey(index) //获取索引的key\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# indexeddb\n\nindexed database api（indexeddb）\n\n前端数据库有websql和indexdb，其中websql被规范废弃，他们都有大约50mb的最大容量，可以理解为localstorage的加强版。\n\n扩展的前端存储方式，是运行在浏览器中的非关系型数据库，理论上容量无上限\n\n> 特性\n\n 1. 储存量理论上没有上限\n 2. 所有操作都是异步的，相比 localstorage 同步操作性能更高，尤其是数据量较大时\n 3. 原生支持储存js的对象\n 4. 是个正经的数据库，意味着数据库能干的事它都能干\n 5. 同源策略限制\n 6. 操作繁琐\n\n\n# cookie？\n\n属性：name、value、domain、path、expires/max-age、size、httponly、secure、samesite和priority\n\n\n# set-cookie\n\n\n\ndomain 决定cookie在哪个域有效，设置对子域生效。以\".\"开始。domain指定的域名可做到与结尾匹配一致\n\npath：cookie的有效路径。以“/”结尾\n\nexpires/max-age 均为cookie的有效期，前者若不设置则默认页面关闭时删除该cookie。后者单位为秒，若设置为0则立即失效，为负数，在页面关闭时失效。默认为-1\n\nsecure：安全属性，true（browser只会在https和ssl等安全协议中传输cookie）\n\n\n# samesite\n\n限制第三方cookie。可阻止跨站请求攻击\n\n * strict：最严格，完全禁止第三方cookie\n * lax：大多不发送第三方cookie，导航到目标网站的get请求除外\n * none：可显式关闭samesite属性，设置为none，前提是同时设置secure属性，否则无效。默认\n\npriority：优先级，当cookie过多时优先级低的cookie会被清除\n\n\n# 禁止js访问cookie\n\n设置httponly\n\njs document.cookieapi 无法访问cookie\n\n\n# js设置cookie\n\ndocument.cookie 属性来创建 、读取、及删除 cookie\n\n创建 cookie ：\n\n> document.cookie=\"username=john doe\";\n\n添加一个过期时间（默认cookie 在浏览器关闭时删除：\n\n> document.cookie=\"username=john doe; expires=thu, 18 dec 2043 12:00:00 gmt\";\n\n使用 path 参数告诉浏览器 cookie 的路径。默认，cookie 属于当前页面\n\n> document.cookie=\"username=john doe; expires=thu, 18 dec 2043 12:00:00 gmt; path=/\";\n\n读取\n\n> var x= document.cookie; //以字符串方式返回所有cookie\n\n\n# cookie作用域\n\n> domain本身以及domain下的所有子域名\n\n\n# 跨域访问cookie\n\n 1. cookie不能跨根域，但js可以，js可以将cookie传给另外的域再保存一次域名cookie，这样可能存在不同的cookie域包含同一个cookie值\n 2. browser不允许跨根域读写\n 3. 采用sso单点登录方式\n\n\n# 没cookie有啥问题\n\ncookie：解决 如何记录客户端用户信息 的问题。保存在本地的一部分数据，在再次发送请求时被携带并传送到服务器，通知server是否请求来自统一状态浏览器，如保持用户登录\n\n使基于无http协议记录的信息状态稳定成为可能\n\n作用：\n\n 1. 会话状态\n 2. 个性化设置\n 3. 浏览器行为跟踪\n\n\n# 单点登录？\n\n单点登录（single sign on）\n\nsso的——在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用\n\n> 淘宝跳转到天猫为啥不重新登录？\n\n淘宝和天猫设置了单点登录sso，在多个系统的集群，只需一次登录，其他系统感知到用户登录，不需重新登录\n\n淘宝和天猫 间部署 专门用作登录的服务器，相当于实现一个 中转站，这个中转站存放需要共享登录状态服务应用的session，相当钥匙，用户跳转应用时 都会来中转站看看，若session存在就直接使用钥匙打开门，否则 得先确认用户身份 制造session钥匙存在中转站再开门，用户身份存储和有效时间均由中转站说了算，统一管理\n\n\n# session原理\n\n客户端登录完成之后，服务器创建对应的 session，session 创建完之后，把 session - id 发送给客户端，客户端存储到浏览器中。这样客户端每次访问服务器时，都会带着sessionid，服务器拿到 sessionid 后，在内存找到与之对应session 这样就可正常工作了\n\n\n# 🔥 浏览器同源策略\n\n一个域的js脚本在未经允许的情况下，不能访问另一个域的内容，同源指的 协议 域名 和 端口均相等的情况，为同一个域\n\n\n# 跨域在服务端真正执行？\n\n同源策略限制，请求发送到后端，后端返回数据时被浏览器的跨域拦截\n\n服务端就算想拦截，也没法判断是否跨域，所有 header 都可被篡改，它用什么判断请求是否跨域？很明显服务端心有余而力不足！\n\n请求一定是先发出去，返回的时候被浏览器拦截了，如果请求有返回值，会被浏览器隐藏掉\n\noptions 预检请求 询问 是否允许这次请求，如果是跨域请求，可以理解为：询问 服务端是否允许请求在当前域下跨域发送\n\n当然，还有其他作用，如 询问 服务端支持哪些 http 方法\n\n预检请求不会真正在服务端执行，但也是一个请求，考虑到服务端开销，不是所有请求都会发送预检\n\n浏览器把请求判定为 简单请求，浏览器就不会发送预检了\n\n所以，如果发送的是简单请求，这个请求不管是否会受到跨域限制，只要发出去了，一定会在服务端执行，浏览器只是隐藏了返回值而已\n\n对于前端开发大部分跨域问题，都是通过代理解决\n\n代理使用场景：\n\n生产环境不跨域，但开发环境跨域，只需在开发环境代理解决即可——开发代理\n\n\n# 目的\n\n浏览器的保护机制，保证用户安全，防止恶意网站窃取数据\n\n防范csrf攻击\n\n\n# 解决跨域\n\n\n# jsonp\n\n客户端准备回调——>script标签 发请求——>服务端收到请求，返回函数调用——>客户端执行回调\n\n优势在于 支持 老式浏览器，向不支持cors的网站请求\n\n前后端配合，只支持get。利用src发送请求，传递回调\n\n不受跨域限制：script，link，img，href，src，因为这些操作不出现安全问题\n\n> 为啥只能用get？\n\njsonp就是创建一个script标签插入到body中，后端执行回调，前端接收数据\n\n因为根本没有设置请求格式的余地\n\nhttp就是这样规定的\n\n1、\n\n// 动态的加载js文件\nfunction addscript(src) {\n  const script = document.createelement('script');\n  script.src = src;\n  script.type = \"text/javascript\";\n  document.body.appendchild(script);\n}\naddscript(\"http://xxx.xxx.com/xxx.js?callback=handleres\");\n// 设置一个全局的callback函数来接收回调结果\nfunction handleres(res) {\n  console.log(res);\n}\n// 接口返回的数据格式\nhandleres({a: 1, b: 2});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n2、\n\nconst jsonp = ({ url, params, callbackname }) => {\n    const generateurl = () => {\n        let datasrc = ''\n        for (let key in params) {\n            if (params.hasownproperty(key)) {\n                datasrc += `${key}=${params[key]}&`\n            }\n        }\n        datasrc += `callback=${callbackname}`\n        return `${url}?${datasrc}`\n    }\n    return new promise((resolve, reject) => {\n        const scriptele = document.createelement('script')\n        scriptele.src = generateurl()\n        document.body.appendchild(scriptele)\n        window[callbackname] = data => {\n            resolve(data)\n            document.removechild(scriptele)\n        }\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# postmessage\n\nhtml5引入的api，实现安全跨源通信\n\n让主页面和任意iframe/window,open打开的页面 双向通信\n\n兼容性也好\n\n\n\n\n# cors\n\n跨域时部分浏览器默认不携带cookie，为了携带cookie需设置xmlhttprequest的withcrendetails属性\n\n如果不需要cookie，最好置成false，避免浏览器默认允许cookie携带\n\n后端需要包装aca系列header\n\n'access-control-allow-origin' '*';\n'access-control-allow-credentials' \"true\"; \n'access-control-allow-headers' 'x-requested-with';\n\n\n1\n2\n3\n\n\n除此以外无需额外配置\n\n跨域资源共享 cross origin resourse-sharing\n\n**一般后端开启。**基于http1.1的跨域解决方案\n\n服务端设置 access-control-allow-origin 开启 cors。 表示哪些域名可以访问资源，通配符表示所有网站都可以访问！！！！\n\n请求可附带很多信息，对服务器造成不同程度影响，有的请求只是获取，有的请求会改动数据\n\n针对不同请求，cors规定3种交互模式\n\n * 简单请求\n * 需要预检的请求\n * 附带身份凭证的请求\n\n# 简单请求\n\n同时满足以下条件，是简单请求：\n\n 1. 请求方法属于：\n    * get\n    * post\n    * head\n 2. 请求头仅包含安全字段，常见的安全字段：\n    * accept\n    * accept-language\n    * content-language\n    * content-type\n    * dpr\n    * downlink\n    * save-data\n    * viewport-width\n    * width\n 3. 请求头如果包含content-type，仅限：\n\ncontent-type：application/json 会触发options方法！\n\n * text/plain\n * multipart/form-data\n * application/x-www-form-urlencoded\n\n> 为兼容表单，历史上表单一直可发出跨域请求，ajax跨域设计是，只要表单可以发，ajax就可以直接发\n\n 4. 请求中任意 xmlhttprequest 均没有注册事件监听器；xmlhttprequest 可使用 xmlhttprequest.upload 访问\n\n 5. 请求没有使用 readablestream\n\n以上条件同时满足，为简单请求\n\n当浏览器判定某个ajax 请求是简单请求时，发生以下的事情\n\n 1. 请求头添加origin\n\nget /cors http/1.1\norigin: http://api.bob.com\nhost: api.alice.com\naccept-language: en-us\nconnection: keep-alive\nuser-agent: mozilla/5.0...\n\n\n1\n2\n3\n4\n5\n6\n\n\norigin告诉服务器，本次请求来自源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意请求\n\n如果origin指定源不在许可范围，服务器正常回应。浏览器发现，回应的头信息没有包含access-control-allow-origin，知道出错了，抛出一个错误，被xmlhttprequest的onerror回调捕获。这种错误无法通过状态码识别，状态码可能是200\n\n如果指定域名在许可范围，响应多出几个字段\n\naccess-control-allow-origin: http://api.bob.com\naccess-control-allow-credentials: true\naccess-control-expose-headers: foobar\ncontent-type: text/html; charset=utf-8\n\n\n1\n2\n3\n4\n\n 2. 响应头包含access-control-allow-origin**\n\n必须\n\n * *：我很开放，什么人我都允许访问\n * 具体源：如http://my.com，我就允许你访问\n\n> 实际这两个值对客户端http://my.com而言，都一样，客户端不会管其他源服务器允不允许，就关心自己是否被允许\n> \n> 服务器也可以维护可被允许的源列表，如果origin命中该列表，才响应具体源\n> \n> 为了避免后续麻烦，强烈推荐响应具体源\n\n假设服务器做出以下响应：\n\nhttp/1.1 200 ok\ndate: tue, 21 apr 2020 08:03:35 gmt\n...\naccess-control-allow-origin: http://my.com\n...\n\n消息体中的数据\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子\n\n\n\n> access-control-allow-credentials\n\n可选。\n\n是布尔值，表是否允许发送cookie。默认cookie不包括在cors请求。true表示服务器明确许可，cookie可包含在请求。\n\n也只能设为true，如果服务器不要浏览器发送cookie，删除该字段\n\n> access-control-expose-headers\n\n可选。\n\ncors请求时，xmlhttprequest的getresponseheader()只能拿到6个基本字段：cache-control、content-language、content-type、expires、last-modified、pragma\n\n想拿到其他字段须在access-control-expose-headers指定\n\naccess-control-expose-headers: foobar\n\n\n1\n\n\ngetresponseheader('foobar')可返回foobar的值\n\n> # withcredentials\n\ncors请求默认不发送cookie\n\n如要把cookie发到服务器，要服务器同意，指定access-control-allow-credentials\n\naccess-control-allow-credentials: true\n\n\n1\n\n\n另一方面，开发者须在ajax请求中打开withcredentials\n\nvar xhr = new xmlhttprequest();\nxhr.withcredentials = true;\n\n\n1\n2\n\n\n否则，即使服务器同意发送cookie，浏览器也不会发送。或者，服务器要求设置cookie，浏览器也不会处理\n\n如果省略withcredentials，有的浏览器还是会一起发送cookie。这时，可显式关闭withcredentials\n\nxhr.withcredentials = false;\n\n\n1\n\n\n注意，如果要发送cookie，access-control-allow-origin不能设为星号，必须指定明确/与请求网页一致的域名\n\n同时，cookie依然遵循同源政策\n\n# 预检请求\n\n非简单请求是对服务器有特殊要求的请求，比如请求方法是put/delete，或content-type值为 application/json\n\n先询问服务器当前网页所在域名是否在服务器许可名单，以及可以使用哪些http动词和头信息字段。只有得到肯定答复，才会发出正式的请求，否则报错\n\n如果浏览器不认为是简单请求：\n\n 1. 浏览器发送预检请求，询问服务器是否允许\n 2. 服务器允许\n 3. 浏览器发送真实请求\n 4. 服务器完成真实的响应\n\n比如，在页面http://my.com/index.html中有以下代码造成了跨域\n\n// 需要预检的请求\nfetch('http://crossdomain.com/api/user', {\n  method: 'post', // post 请求\n  headers: {\n    // 设置请求头\n    a: 1,\n    b: 2,\n    'content-type': 'application/json',\n  },\n  body: json.stringify({ name: '袁小进', age: 18 }), // 设置请求体\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n浏览器发现它不是简单请求，按照下面的流程与服务器交互\n\n 1. 浏览器发送预检请求，询问服务器是否允许\n\noptions /cors http/1.1\norigin: http://api.bob.com\naccess-control-request-method: put\naccess-control-request-headers: x-custom-header\nhost: api.alice.com\naccept-language: en-us\nconnection: keep-alive\nuser-agent: mozilla/5.0...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这并非真实请求，请求中不包含请求头，也没有消息体，这是预检请求，询问服务器，是否允许后续真实请求\n\n预检请求没有请求体，它包含后续真实请求要做的事情\n\n预检请求特征：\n\n * 请求方法为options\n * 没有请求体\n * 请求头包含\n * * origin：请求的源，和简单请求的含义一致\n   * access-control-request-method：必须，后续的真实请求使用的请求方法\n   * access-control-request-headers：逗号分隔的字符串，浏览器cors请求额外发送的头字段，上例是x-custom-header\n\n 2. 服务器允许\n\n收到预检请求后，检查预检请求中信息，如果允许，则响应\n\nhttp/1.1 200 ok\ndate: mon, 01 dec 2008 01:15:39 gmt\nserver: apache/2.0.61 (unix)\naccess-control-allow-origin: http://api.bob.com\naccess-control-allow-methods: get, post, put\naccess-control-allow-headers: x-custom-header\ncontent-type: text/html; charset=utf-8\ncontent-encoding: gzip\ncontent-length: 0\nkeep-alive: timeout=2, max=100\nconnection: keep-alive\ncontent-type: text/plain\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n预检请求，只需要在响应头添加：\n\n * access-control-allow-origin：和简单请求一样，允许的源\n * access-control-allow-methods：允许后续真实的请求方法\n * access-control-allow-headers：允许改动的请求头\n * access-control-max-age：多少秒内对于同样请求源/方法/头，都不再发预检请求\n\n 3. 浏览器发送真实请求\n\n预检被服务器允许后，浏览器发送真实请求，请求数据\n\npost /api/user http/1.1\nhost: crossdomain.com\nconnection: keep-alive\n...\nreferer: http://my.com/index.html\norigin: http://my.com\n\n{\"name\": \"xiaoming\", \"age\": 18 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 4. 服务器响应真实请求\n\nhttp/1.1 200 ok\ndate: tue, 21 apr 2020 08:03:35 gmt\n...\naccess-control-allow-origin: http://my.com\n...\n\n添加用户成功\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n完成预检之后，后续的处理与简单请求相同\n\n\n\n# 附身份凭证请求\n\n默认，ajax 跨域请求不附带 cookie，这样某些需要权限的操作就无法进行\n\n通过简单的配置可以实现附带 cookie\n\n// xhr\nvar xhr = new xmlhttprequest();\nxhr.withcredentials = true;\n\n// fetch api\nfetch(url, {\n  credentials: 'include',\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加cookie字段\n\n而服务器响应时，需要明确告知客户端：服务器允许这样的凭据\n\n告知的方式非常简单，在响应头中添加：access-control-allow-credentials: true\n\n对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝\n\n另外：对于附带身份凭证的请求，服务器不得设置 access-control-allow-origin 的值为*。这就是不推荐使用*的原因\n\n额外补充\n\n在跨域访问时，js 只能拿到一些最基本的响应头，如：cache-control、content-language、content-type、expires、last-modified、pragma，如果要访问其他头，需要服务器设置本响应头\n\n> pragma 是旧产物，已被抛弃\n\naccess-control-expose-headers头让服务器把允许浏览器访问的头放入白名单，例如：\n\naccess-control-expose-headers: authorization, a, b\n\n\n1\n\n\n这样 js 就能够访问指定的响应头了\n\n\n# 代理\n\n适用场景：生产环境不发生跨域，但开发环境发生跨域\n\n开发代理：只需要在开发环境使用代理解决跨域\n\n\n\nmodule.exports = {\n  devserver: { // 配置开发服务器\n    proxy: { // 配置代理\n      \"/api\": { // 若请求路径以 /api 开头\n        target: \"http://dev.taobao.com\", // 将其转发到 http://dev.taobao.com\n      },\n    },\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# nginx 代理\n\n反向代理功能是nginx的三大主要功能之一（静态web服务器、反向代理、负载均衡）\n\n反向代理：帮服务器拿到数据，选择合适的服务器\n\n和cors原理同，配置请求响应头access-control-allow-origin等\n\n\n\n# 反向代理、负载均衡\n\nnginx作为反向代理服务器，把http请求转发到另一个或者一些服务器上。把本地一个url前缀映射到要跨域访问的web服务器上，实现跨域访问\n\nnginx检测url前缀，把http请求转发到真实的物理服务器\n\nrewrite命令把前缀去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求来自代理服务器\n\n> 正向代理就是冒充客户端，反向代理就是冒充服务端\n\n\n# websocket\n\n(与http同级)\n\nwebsocket请求头信息中有origin字段，表示请求源自哪个域，服务器可以根据这个字段判断是否允许本次通信\n\n\n# document.domain + iframe\n\n原理：相同主域名不同子域名下的页面\n\n**只能用于二级域名相同的情况下，**比如 a.test.com 和 b.test.com 适用于该方式\n\n只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域\n\n\n\n\n# location.hash + iframe\n\n通过c页面实现a和b通信\n\n\n# window.name(共享变量) + iframe\n\n\n# apache转发\n\n逆向代理，让跨域变成同域\n\n> css文件的加载受跨域限制吗？？\n\n\n# proxy\n\nproxy原理——\"同源策略是浏览器需要遵循的标准，但如果是服务器向 服务器请求 就无须遵循同源策略\"\n\n实现——本地向proxy代理服务器发送请求，proxy接收本地请求，转化为目标地址相同ip和端口 向 目标地址发请求\n\nproxy: {\n     '/api': {\n       'target': 'http://178.192.13.284:9060',//目标url\n       'changeorigin': true,\n       'pathrewrite': { '^/api' : '' }\n     },\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 跨域标准\n\n跨域往标准靠近，cors，nginx和jsonp属于较老的技术了\n\n\n# 反向/正向代理\n\n代理服务器 代理了 目标服务器，和 客户端 交互\n\n将不同域名转换为相同域名\n\n正向代理是客户端的代理，反向代理是服务器的代理\n\n正向代理一般客户端架设；反向代理一般服务器架设\n\n正向代理服务器不知道真正的客户端是谁，反向代理 客户端不知道真正的服务器是谁\n\n正向代理为了解决访问限制问题；反向代理提供复杂均衡、安全防护等；二者 均能挺高访问速度\n\n所以 梯子 这个行为其实是 正向代理，突破访问权限的，由客户端来架设的，方向代理是为了所有人都能访问服务端\n\n正向代理作用\n\n突破访问限制(中介 角色)\n提高访问速度\n隐藏客户端真实ip \n\n\n1\n2\n3\n\n\n\n# ✔️ 鉴权\n\n\n# cookie\n\n服务端响应客户端请求时，返回一个cookie，后续客户端的请求携带这个cookie\n\n特点\n\n 1. 存储在客户端，可随意纂改\n 2. 影响性能，最大为4kb\n 3. 一个浏览器对于一个网站只能存不超过20个cookie，而浏览器一般只允许存放300个cookie\n 4. 移动端对cookie支持不友好\n 5. 一般情况下存储的是纯文本\n\n设置正确的domain和path，减少数据传输，节省带宽\n\n\n# cookie-session\n\ncookie需要的存的东西越来越多，但是cookie大小有限制\n\n所以后端返回sessionid，客户端将sessionid存在cookie中\n\n缓存数据库：所有机器根据sessionid去缓存系统获取用户信息和认证\n\n局限性\n\n 1. 依赖cookie，但cookie可被禁用\n 2. 系统不停请求缓存服务器查找信息，内存开销增加\n 3. 存在单点登录失败的可能性\n\n> 若负责session的机器挂了，整个登录就挂了，但项目中，负责session的机器也是有多台机器的集群进行负载均衡增加可靠性\n\n\n# sso\n\n（单点登录）三种类型\n\nsingle sign on 在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统\n\n\n\n单点登录\n\n 1. 同一站点下\n 2. 相同的顶级域名\n 3. 不同的顶级域名\n\n相同域名和相同顶级域名下可共享cookie\n\n但是不同域呢？\n\n * cas（中央认证服务）原理\n   \n   流程和cookie-session模式相同\n\n\n\n“跳到sso系统准备登录时发现sso已经登录了”咋做到的？\n\n> oauth2授权机制，系统b向sso系统跳转时，让它从系统a跳转，携带系统a的会话信息跳到sso，再重定向回到系统b\n\n阮一峰-oauth 2.0 的四种方式\n\n\n# json web token\n\n> 最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+哈希算法压缩成一定长的十六进制字符串，防止恶意三方拼接token请求)\n\njwt由header（头部）、payload（负载）、signature（签名）这三个部分组成，中间用.来分隔开：header.payload.signature\n\njwt: \"eyjhbgcioijiuzi1niisinr5cci6ikpxvcj9.eyj1c2vyawqioijhiiwiawf0ijoxntuxotuxotk4fq.2jf3kl_ukwrkwjop6uqrjfqmlwsabcgqqcjoffh5xco\"\n\n\n1\n\n\n\n\n * jwt工作原理\n\n\n\n * 弊端\n   \n   1. jwt的退出是假的登录失效，只要之前的token没过期依然可以用\n   2. 安全性依赖密钥\n   3. 加密生成的数据长\n\n * 优点\n   \n   1. 无状态，可扩展\n   2. 支持移动设备\n   3. 跨程序调用\n   4. 安全\n\nsession 和 token 的对比就是「用不用cookie」和「后端存不存」的对比\n\n> 说出以上方法时，顺便说自己项目中用的哪些鉴权方法\n> \n> 用了cookie token jwt\n\n\n# oauth 2.0\n\nauthorization\n\n目前最流行的授权机制，授权第三方应用，获取用户数据\n\n> 场景再现 有没有一种方法，能够让快递员自由进入校区，但是不知道小区居民的密码，同时他们唯一权限就是送货\n\n数据的所有者告诉系统，同意授权第三方应用进入系统，获取数据，系统产生一个token代替密码，供第三方使用\n\noauth2.0有四种颁发令牌的方式\n\n * 授权码（authorization-code）\n * 隐藏式（implicit）\n * 密码式（password）：\n * 客户端凭证（client credentials）\n\n第三方需要先备案，拿到2个身份识别码：客户端id和客户端密钥\n\n\n# 前后端实时通信\n\n\n# ajax轮询\n\n设置周期t，每t s向服务端请求一次数据，达到实时显示，本质是http的request/response模式\n\n每次都是客户端主动请求，浪费贷款\n\n\n# websocket\n\n只需一次握手 即可通信\n\n\n# service worker\n\n\n# 浏览器不同tab页通信\n\n应用场景 网页即时通讯\n\n\n# cookie\n\n\n# localstorage\n\n\n# web worker\n\nservice worker是web worker的一种类型\n\n\n# websocket\n\n\n# 加了代理服务器，缓存如何计算？\n\nhttp 的代理服务以及缓存代理",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"CN",frontmatter:{title:"CN",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/eab60b/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/02.CN.html",relativePath:"08.专栏/02.CN.md",key:"v-b5259178",path:"/pages/eab60b/",headers:[{level:2,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:508},{level:2,title:"URI、URL",slug:"uri、url",normalizedTitle:"uri、url",charIndex:1112},{level:2,title:"HTTP首部字段?",slug:"http首部字段",normalizedTitle:"http首部字段?",charIndex:1274},{level:2,title:"请求头",slug:"请求头",normalizedTitle:"请求头",charIndex:2604},{level:2,title:"请求首部字段",slug:"请求首部字段",normalizedTitle:"请求首部字段",charIndex:3492},{level:3,title:"Accept",slug:"accept",normalizedTitle:"accept",charIndex:1285},{level:3,title:"Accept-Charset",slug:"accept-charset",normalizedTitle:"accept-charset",charIndex:3622},{level:3,title:"Accept-Encoding",slug:"accept-encoding",normalizedTitle:"accept-encoding",charIndex:3819},{level:3,title:"Accept-Language",slug:"accept-language",normalizedTitle:"accept-language",charIndex:3918},{level:3,title:"Authorization",slug:"authorization",normalizedTitle:"authorization",charIndex:3963},{level:3,title:"Host",slug:"host",normalizedTitle:"host",charIndex:1327},{level:3,title:"If-Match",slug:"if-match",normalizedTitle:"if-match",charIndex:1454},{level:3,title:"If-None-Match",slug:"if-none-match",normalizedTitle:"if-none-match",charIndex:1351},{level:3,title:"If-Modified-Since",slug:"if-modified-since",normalizedTitle:"if-modified-since",charIndex:1414},{level:3,title:"If-Unmodified-Since",slug:"if-unmodified-since",normalizedTitle:"if-unmodified-since",charIndex:1481},{level:3,title:"If-Range",slug:"if-range",normalizedTitle:"if-range",charIndex:4332},{level:3,title:"Referer——正确Referrer",slug:"referer-正确referrer",normalizedTitle:"referer——正确referrer",charIndex:4682},{level:3,title:"origin",slug:"origin",normalizedTitle:"origin",charIndex:4817},{level:3,title:"User-Agent",slug:"user-agent",normalizedTitle:"user-agent",charIndex:4861},{level:2,title:"响应首部字段",slug:"响应首部字段",normalizedTitle:"响应首部字段",charIndex:3499},{level:3,title:"Accept-Ranges",slug:"accept-ranges",normalizedTitle:"accept-ranges",charIndex:5063},{level:3,title:"Age",slug:"age",normalizedTitle:"age",charIndex:4866},{level:3,title:"ETag",slug:"etag",normalizedTitle:"etag",charIndex:2632},{level:3,title:"Location",slug:"location",normalizedTitle:"location",charIndex:2491},{level:3,title:"Proxy-Authenticate",slug:"proxy-authenticate",normalizedTitle:"proxy-authenticate",charIndex:5375},{level:3,title:"Retry-After",slug:"retry-after",normalizedTitle:"retry-after",charIndex:5414},{level:3,title:"Server",slug:"server",normalizedTitle:"server",charIndex:1823},{level:3,title:"Vary",slug:"vary",normalizedTitle:"vary",charIndex:5469},{level:3,title:"WWW-Authenticate",slug:"www-authenticate",normalizedTitle:"www-authenticate",charIndex:5655},{level:2,title:"通用首部字段",slug:"通用首部字段",normalizedTitle:"通用首部字段",charIndex:3506},{level:3,title:"Cache-Control(HTTP1.1）",slug:"cache-control-http1-1",normalizedTitle:"cache-control(http1.1）",charIndex:5693},{level:3,title:"Connection",slug:"connection",normalizedTitle:"connection",charIndex:1301},{level:3,title:"Date",slug:"date",normalizedTitle:"date",charIndex:6302},{level:3,title:"Transfer-Encoding",slug:"transfer-encoding",normalizedTitle:"transfer-encoding",charIndex:6311},{level:3,title:"Upgrade",slug:"upgrade",normalizedTitle:"upgrade",charIndex:6333},{level:3,title:"Via",slug:"via",normalizedTitle:"via",charIndex:6345},{level:3,title:"Range（用于断点续传",slug:"range-用于断点续传",normalizedTitle:"range（用于断点续传",charIndex:6406},{level:2,title:"实体首部字段",slug:"实体首部字段",normalizedTitle:"实体首部字段",charIndex:3513},{level:3,title:"Allow",slug:"allow",normalizedTitle:"allow",charIndex:5587},{level:3,title:"Content-Encoding",slug:"content-encoding",normalizedTitle:"content-encoding",charIndex:1601},{level:3,title:"Content-Language",slug:"content-language",normalizedTitle:"content-language",charIndex:6600},{level:3,title:"Content-Length",slug:"content-length",normalizedTitle:"content-length",charIndex:6621},{level:3,title:"Content-Location",slug:"content-location",normalizedTitle:"content-location",charIndex:6651},{level:3,title:"Content-MD5",slug:"content-md5",normalizedTitle:"content-md5",charIndex:6672},{level:3,title:"Content-Rage",slug:"content-rage",normalizedTitle:"content-rage",charIndex:6688},{level:3,title:"Content-Type",slug:"content-type",normalizedTitle:"content-type",charIndex:6705},{level:3,title:"Expires",slug:"expires",normalizedTitle:"expires",charIndex:1696},{level:3,title:"Last-Modified",slug:"last-modified",normalizedTitle:"last-modified",charIndex:1734},{level:2,title:"Cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:7173},{level:3,title:"Set-Cookie",slug:"set-cookie",normalizedTitle:"set-cookie",charIndex:7260},{level:3,title:"Cookie 请求首部字段",slug:"cookie-请求首部字段",normalizedTitle:"cookie 请求首部字段",charIndex:8268},{level:2,title:"请求报文",slug:"请求报文",normalizedTitle:"请求报文",charIndex:3365},{level:2,title:"响应报文",slug:"响应报文",normalizedTitle:"响应报文",charIndex:3388},{level:2,title:"为啥3次握手？",slug:"为啥3次握手",normalizedTitle:"为啥3次握手？",charIndex:9120},{level:2,title:"2MSL 等待状态？",slug:"_2msl-等待状态",normalizedTitle:"2msl 等待状态？",charIndex:11338},{level:2,title:"为啥4次挥手？",slug:"为啥4次挥手",normalizedTitle:"为啥4次挥手？",charIndex:11844},{level:2,title:"SYN攻击？",slug:"syn攻击",normalizedTitle:"syn攻击？",charIndex:12025},{level:2,title:"TCP",slug:"tcp",normalizedTitle:"tcp",charIndex:162},{level:3,title:"TCP头部很大，具体有哪些报文信息？",slug:"tcp头部很大-具体有哪些报文信息",normalizedTitle:"tcp头部很大，具体有哪些报文信息？",charIndex:12619},{level:2,title:"UDP",slug:"udp",normalizedTitle:"udp",charIndex:166},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:232},{level:2,title:"数据分片和排序",slug:"数据分片和排序",normalizedTitle:"数据分片和排序",charIndex:13235},{level:2,title:"首部校验",slug:"首部校验",normalizedTitle:"首部校验",charIndex:13416},{level:2,title:"确认和重传（重传机制）",slug:"确认和重传-重传机制",normalizedTitle:"确认和重传（重传机制）",charIndex:13904},{level:3,title:"超时重传",slug:"超时重传",normalizedTitle:"超时重传",charIndex:14139},{level:3,title:"快速重传",slug:"快速重传",normalizedTitle:"快速重传",charIndex:14147},{level:3,title:"SACK-Selective",slug:"sack-selective",normalizedTitle:"sack-selective",charIndex:14974},{level:3,title:"D-SACK-Duplicate",slug:"d-sack-duplicate",normalizedTitle:"d-sack-duplicate",charIndex:15227},{level:4,title:"丢包",slug:"丢包",normalizedTitle:"丢包",charIndex:8782},{level:4,title:"网络延时",slug:"网络延时",normalizedTitle:"网络延时",charIndex:15543},{level:4,title:"好处",slug:"好处",normalizedTitle:"好处",charIndex:15805},{level:2,title:"流量控制",slug:"流量控制",normalizedTitle:"流量控制",charIndex:12767},{level:3,title:"保证次序？",slug:"保证次序",normalizedTitle:"保证次序？",charIndex:16051},{level:3,title:"提高吞吐量？",slug:"提高吞吐量",normalizedTitle:"提高吞吐量？",charIndex:16192},{level:3,title:"实现最优解？",slug:"实现最优解",normalizedTitle:"实现最优解？",charIndex:16251},{level:2,title:"滑动窗口",slug:"滑动窗口",normalizedTitle:"滑动窗口",charIndex:16349},{level:4,title:"正常情况",slug:"正常情况",normalizedTitle:"正常情况",charIndex:10680},{level:4,title:"丢包情况",slug:"丢包情况",normalizedTitle:"丢包情况",charIndex:17554},{level:4,title:"超时重传",slug:"超时重传-2",normalizedTitle:"超时重传",charIndex:14139},{level:2,title:"拥塞控制",slug:"拥塞控制",normalizedTitle:"拥塞控制",charIndex:12732},{level:3,title:"慢开始",slug:"慢开始",normalizedTitle:"慢开始",charIndex:19104},{level:3,title:"拥塞避免",slug:"拥塞避免",normalizedTitle:"拥塞避免",charIndex:18998},{level:3,title:"拥塞发生",slug:"拥塞发生",normalizedTitle:"拥塞发生",charIndex:19006},{level:3,title:"快速恢复",slug:"快速恢复",normalizedTitle:"快速恢复",charIndex:19014},{level:2,title:"流量控制和拥塞控制？",slug:"流量控制和拥塞控制",normalizedTitle:"流量控制和拥塞控制？",charIndex:21136},{level:2,title:"升级 TCP 工作困难",slug:"升级-tcp-工作困难",normalizedTitle:"升级 tcp 工作困难",charIndex:21339},{level:2,title:"TCP 建立连接延迟",slug:"tcp-建立连接延迟",normalizedTitle:"tcp 建立连接延迟",charIndex:21524},{level:2,title:"TCP 存在队头阻塞问题",slug:"tcp-存在队头阻塞问题",normalizedTitle:"tcp 存在队头阻塞问题",charIndex:21369},{level:2,title:"网络迁移需重新建立 TCP 连接",slug:"网络迁移需重新建立-tcp-连接",normalizedTitle:"网络迁移需重新建立 tcp 连接",charIndex:21865},{level:2,title:"代理",slug:"代理",normalizedTitle:"代理",charIndex:1324},{level:3,title:"代理方法",slug:"代理方法",normalizedTitle:"代理方法",charIndex:22304},{level:4,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:1411},{level:4,title:"透明代理",slug:"透明代理",normalizedTitle:"透明代理",charIndex:22418},{level:2,title:"网关",slug:"网关",normalizedTitle:"网关",charIndex:3074},{level:2,title:"隧道",slug:"隧道",normalizedTitle:"隧道",charIndex:22595},{level:2,title:"options方法？",slug:"options方法",normalizedTitle:"options方法？",charIndex:23018},{level:2,title:"GET",slug:"get",normalizedTitle:"get",charIndex:2554},{level:2,title:"POST",slug:"post",normalizedTitle:"post",charIndex:22759},{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:3224},{level:2,title:"GET参数写法固定？",slug:"get参数写法固定",normalizedTitle:"get参数写法固定？",charIndex:24003},{level:2,title:"POST比GET安全？",slug:"post比get安全",normalizedTitle:"post比get安全？",charIndex:24214},{level:2,title:"GET长度限制？",slug:"get长度限制",normalizedTitle:"get长度限制？",charIndex:24425},{level:2,title:"POST产生两个TCP数据包？",slug:"post产生两个tcp数据包",normalizedTitle:"post产生两个tcp数据包？",charIndex:24513},{level:2,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:24710},{level:2,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:16370},{level:2,title:"一个TCP连接中HTTP请求可一起发送么",slug:"一个tcp连接中http请求可一起发送么",normalizedTitle:"一个tcp连接中http请求可一起发送么",charIndex:26335},{level:2,title:"HTTP1.0",slug:"http1-0",normalizedTitle:"http1.0",charIndex:26748},{level:2,title:"HTTP 1.1性能?",slug:"http-1-1性能",normalizedTitle:"http 1.1性能?",charIndex:26893},{level:2,title:"HTTP1.1相比HTTP1.0",slug:"http1-1相比http1-0",normalizedTitle:"http1.1相比http1.0",charIndex:27686},{level:2,title:"二者存在问题：",slug:"二者存在问题",normalizedTitle:"二者存在问题：",charIndex:28169},{level:2,title:"HTTP1.1性能瓶颈",slug:"http1-1性能瓶颈",normalizedTitle:"http1.1性能瓶颈",charIndex:28330},{level:2,title:"特点",slug:"特点-2",normalizedTitle:"特点",charIndex:508},{level:2,title:"特点",slug:"特点-3",normalizedTitle:"特点",charIndex:508},{level:2,title:"应用",slug:"应用-2",normalizedTitle:"应用",charIndex:232},{level:2,title:"HTTP不断轮询",slug:"http不断轮询",normalizedTitle:"http不断轮询",charIndex:29565},{level:2,title:"长轮询",slug:"长轮询",normalizedTitle:"长轮询",charIndex:29689},{level:2,title:"Websocket",slug:"websocket-2",normalizedTitle:"websocket",charIndex:29112},{level:2,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:1147},{level:3,title:"二进制分帧",slug:"二进制分帧",normalizedTitle:"二进制分帧",charIndex:30203},{level:3,title:"首部压缩",slug:"首部压缩",normalizedTitle:"首部压缩",charIndex:30591},{level:3,title:"多路复用",slug:"多路复用",normalizedTitle:"多路复用",charIndex:26555},{level:3,title:"请求优先级",slug:"请求优先级",normalizedTitle:"请求优先级",charIndex:28461},{level:3,title:"流量控制",slug:"流量控制-2",normalizedTitle:"流量控制",charIndex:12767},{level:3,title:"服务端推送",slug:"服务端推送",normalizedTitle:"服务端推送",charIndex:28860},{level:3,title:"数据流",slug:"数据流",normalizedTitle:"数据流",charIndex:20398},{level:2,title:"缺陷",slug:"缺陷",normalizedTitle:"缺陷",charIndex:21331},{level:2,title:"特性",slug:"特性-2",normalizedTitle:"特性",charIndex:1147},{level:3,title:"连接迁移",slug:"连接迁移",normalizedTitle:"连接迁移",charIndex:33281},{level:3,title:"无队头阻塞",slug:"无队头阻塞",normalizedTitle:"无队头阻塞",charIndex:33290},{level:3,title:"自定义拥塞控制",slug:"自定义拥塞控制",normalizedTitle:"自定义拥塞控制",charIndex:33300},{level:3,title:"前向安全和前向纠错",slug:"前向安全和前向纠错",normalizedTitle:"前向安全和前向纠错",charIndex:33312},{level:2,title:"为什么HTTP3.0使用UDP？",slug:"为什么http3-0使用udp",normalizedTitle:"为什么http3.0使用udp？",charIndex:33326},{level:2,title:"SSL/TLS",slug:"ssl-tls",normalizedTitle:"ssl/tls",charIndex:24955},{level:3,title:"作用",slug:"作用",normalizedTitle:"作用",charIndex:4267},{level:3,title:"SSL/TLS的四次握手",slug:"ssl-tls的四次握手",normalizedTitle:"ssl/tls的四次握手",charIndex:33881},{level:2,title:"🍪HTTPS保证传输安全？",slug:"🍪https保证传输安全",normalizedTitle:"🍪https保证传输安全？",charIndex:35152},{level:3,title:"TLS1.0",slug:"tls1-0",normalizedTitle:"tls1.0",charIndex:35171},{level:3,title:"TLS.12",slug:"tls-12",normalizedTitle:"tls.12",charIndex:35195},{level:2,title:"🔥 HTTPS、HTTP",slug:"https、http",normalizedTitle:"🔥 https、http",charIndex:35217},{level:2,title:"HTTP存在风险",slug:"http存在风险",normalizedTitle:"http存在风险",charIndex:35622},{level:3,title:"HTTPS 在 HTTP 与 TCP 层间加入SSL/TLS 协议，解决上述风险",slug:"https-在-http-与-tcp-层间加入ssl-tls-协议-解决上述风险",normalizedTitle:"https 在 http 与 tcp 层间加入ssl/tls 协议，解决上述风险",charIndex:35722},{level:2,title:"HTTPS 如何解决上面三个风险？",slug:"https-如何解决上面三个风险",normalizedTitle:"https 如何解决上面三个风险？",charIndex:35890},{level:2,title:"混合加密",slug:"混合加密",normalizedTitle:"混合加密",charIndex:35913},{level:2,title:"摘要算法",slug:"摘要算法",normalizedTitle:"摘要算法",charIndex:35939},{level:2,title:"数字签名",slug:"数字签名",normalizedTitle:"数字签名",charIndex:36025},{level:2,title:"数字证书",slug:"数字证书",normalizedTitle:"数字证书",charIndex:34522},{level:2,title:"域名",slug:"域名",normalizedTitle:"域名",charIndex:261},{level:2,title:"分布式",slug:"分布式",normalizedTitle:"分布式",charIndex:38409},{level:2,title:"本地DNS服务器",slug:"本地dns服务器",normalizedTitle:"本地dns服务器",charIndex:38615},{level:2,title:"递归、迭代查询",slug:"递归、迭代查询",normalizedTitle:"递归、迭代查询",charIndex:38666},{level:2,title:"所有 DNS 查询都必须遵循递归 + 迭代 ？",slug:"所有-dns-查询都必须遵循递归-迭代",normalizedTitle:"所有 dns 查询都必须遵循递归 + 迭代 ？",charIndex:39491},{level:2,title:"DNS 优化和应用",slug:"dns-优化和应用",normalizedTitle:"dns 优化和应用",charIndex:39667},{level:3,title:"DNS缓存",slug:"dns缓存",normalizedTitle:"dns缓存",charIndex:39681},{level:3,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:39964},{level:4,title:"CDN(Content Delivery Network)",slug:"cdn-content-delivery-network",normalizedTitle:"cdn(content delivery network)",charIndex:40127},{level:3,title:"dns-prefetch",slug:"dns-prefetch",normalizedTitle:"dns-prefetch",charIndex:40230},{level:2,title:"为啥使用UDP？",slug:"为啥使用udp",normalizedTitle:"为啥使用udp？",charIndex:40351},{level:2,title:"解析不存在的域名？",slug:"解析不存在的域名",normalizedTitle:"解析不存在的域名？",charIndex:40394},{level:2,title:"TCP/IP协议族？",slug:"tcp-ip协议族",normalizedTitle:"tcp/ip协议族？",charIndex:40539},{level:2,title:"TCP 协议保证页面文件完整送达浏览器?",slug:"tcp-协议保证页面文件完整送达浏览器",normalizedTitle:"tcp 协议保证页面文件完整送达浏览器?",charIndex:40876},{level:2,title:"✔️ QUIC协议",slug:"quic协议",normalizedTitle:"✔️ quic协议",charIndex:41147},{level:2,title:"特点",slug:"特点-4",normalizedTitle:"特点",charIndex:508},{level:3,title:"无队头阻塞",slug:"无队头阻塞-2",normalizedTitle:"无队头阻塞",charIndex:33290},{level:3,title:"流量控制",slug:"流量控制-3",normalizedTitle:"流量控制",charIndex:12767},{level:3,title:"更快的连接建立",slug:"更快的连接建立",normalizedTitle:"更快的连接建立",charIndex:42460},{level:3,title:"连接迁移",slug:"连接迁移-2",normalizedTitle:"连接迁移",charIndex:33281},{level:2,title:"优点",slug:"优点-2",normalizedTitle:"优点",charIndex:24710}],headersStr:"特点 URI、URL HTTP首部字段? 请求头 请求首部字段 Accept Accept-Charset Accept-Encoding Accept-Language Authorization Host If-Match If-None-Match If-Modified-Since If-Unmodified-Since If-Range Referer——正确Referrer origin User-Agent 响应首部字段 Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server Vary WWW-Authenticate 通用首部字段 Cache-Control(HTTP1.1） Connection Date Transfer-Encoding Upgrade Via Range（用于断点续传 实体首部字段 Allow Content-Encoding Content-Language Content-Length Content-Location Content-MD5 Content-Rage Content-Type Expires Last-Modified Cookie Set-Cookie Cookie 请求首部字段 请求报文 响应报文 为啥3次握手？ 2MSL 等待状态？ 为啥4次挥手？ SYN攻击？ TCP TCP头部很大，具体有哪些报文信息？ UDP 应用 数据分片和排序 首部校验 确认和重传（重传机制） 超时重传 快速重传 SACK-Selective D-SACK-Duplicate 丢包 网络延时 好处 流量控制 保证次序？ 提高吞吐量？ 实现最优解？ 滑动窗口 正常情况 丢包情况 超时重传 拥塞控制 慢开始 拥塞避免 拥塞发生 快速恢复 流量控制和拥塞控制？ 升级 TCP 工作困难 TCP 建立连接延迟 TCP 存在队头阻塞问题 网络迁移需重新建立 TCP 连接 代理 代理方法 缓存 透明代理 网关 隧道 options方法？ GET POST 区别 GET参数写法固定？ POST比GET安全？ GET长度限制？ POST产生两个TCP数据包？ 优点 缺点 一个TCP连接中HTTP请求可一起发送么 HTTP1.0 HTTP 1.1性能? HTTP1.1相比HTTP1.0 二者存在问题： HTTP1.1性能瓶颈 特点 特点 应用 HTTP不断轮询 长轮询 Websocket 特性 二进制分帧 首部压缩 多路复用 请求优先级 流量控制 服务端推送 数据流 缺陷 特性 连接迁移 无队头阻塞 自定义拥塞控制 前向安全和前向纠错 为什么HTTP3.0使用UDP？ SSL/TLS 作用 SSL/TLS的四次握手 🍪HTTPS保证传输安全？ TLS1.0 TLS.12 🔥 HTTPS、HTTP HTTP存在风险 HTTPS 在 HTTP 与 TCP 层间加入SSL/TLS 协议，解决上述风险 HTTPS 如何解决上面三个风险？ 混合加密 摘要算法 数字签名 数字证书 域名 分布式 本地DNS服务器 递归、迭代查询 所有 DNS 查询都必须遵循递归 + 迭代 ？ DNS 优化和应用 DNS缓存 负载均衡 CDN(Content Delivery Network) dns-prefetch 为啥使用UDP？ 解析不存在的域名？ TCP/IP协议族？ TCP 协议保证页面文件完整送达浏览器? ✔️ QUIC协议 特点 无队头阻塞 流量控制 更快的连接建立 连接迁移 优点",content:'# OSI七层模型\n\nOSI将计算机网络体系结构分为7层\n\n 1. 物理层，通信信道上的原始比特流传输（比特流）\n\n 2. 数据链路层（定义数据的基本格式）（帧）\n\n 3. 网络层。主要协议是IP和ARP（定义ip编址，定义路由功能，如不同设备间的数据转发）（包）\n\n 4. 传输层，为两台主机进程间通信提供服务，主要协议为TCP，UDP（数据段）\n\n 5. 会话层，管理不同用户和进程之间的对话\n\n 6. 表示层，处理两个通信系统中交换信息的表示方式\n\n 7. 应用层，定义应用进程间交互规则，为不同的网络应用提供服务。域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP协议（报文）\n\n简单网络管理协议（SNMP） 是一种应用层协议\n\nDHCP（动态主机配置协议）是一个局域网的网络协议\n\n\n\n应用层发送http请求，到传输层通过三次握手建立tcp/ip连接，到网络层的ip寻址，再到数据链路层封装成帧，最后到物理层利用物理介质传输\n\n\n# 💚 HTTP协议?\n\n超文本传输协议，HyperText Transfer Protocol\n\n * 超文本\n * 传输\n * 协议\n\n协议特点:\n\n * 「协」，代表必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东\n * 「议」，代表对参与者的行为约定和规范。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等\n\nHTTP是一个计算机世界的协议，确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式\n\nHTTP是一个双向协议！\n\n> 超文本：HTTP传输的内容\n\n在HTTP眼中，简单字符文字，图片，视频，压缩包等都算作 文本。超文本——超越了普通文本的文本，有超链接。HTML就是最常见的超文本\n\n> HTTP是一个在计算机世界里专门在 两点 之间 传输 文字、图片、音频、视频 等 超文本 数据的 约定和规范\n\n那HTTP是用于从互联网传输超文本到本地浏览器的协议，对吗?\n\n不对，因为也可以是服务器<--\x3e服务器，所以采用两点间的描述更准确\n\n\n# 特点\n\n支持客户/服务器模式\n\n简单快速：客户端请求服务时，只需要传送请求方法和路径。HTTP协议简单，HTTP服务器的程序规模小，通信速度快\n\n灵活：允许传输任意类型数据对象。正在传输的类型由Content-type标记\n\n无状态：HTTP协议无法根据之前的状态处理本次请求\n\n无连接：每次连接只能处理一个请求。服务器处理完请求，收到应答后即断开连接，节省时间\n\n\n# URI、URL\n\n * URN或同时具备locators 和names特性\n * URN像一个人的名字，URL像这个人的地址\n * 换句话说：URN确定东西的身份，URL提供找到它的方式\n\nURL是URI的一种，不是所有的URI都是URL；URI唯一标识身份，URL给出访问机制（http/ftp/telnet等）\n\n\n# HTTP首部字段?\n\nAccept: 允许的媒体类型\nConnection: 连接选项，例如是否允许代理\nHost: 客户端发送请求时，指定服务器的域名\nIf-None-Match: 判断请求实体的Etag是否包含在If-None-Match中，如果包含，则返回304，使用缓存\nIf-Modified-Since: 判断修改时间是否一致，如果一致，使用缓存\nIf-Match: 与If-None-Match相反\nIf-Unmodified-Since: 与If-Modified-Since相反\nReferer: 这个请求发起的源头\nCache-Control: 缓存策略，如max-age:100\nConnection: 连接选项，例如是否允许代理\nContent-Encoding: 返回内容的编码，如gzip\nEtag: entity tag，实体标签，给每个实体生成一个单独的值，用于客户端缓存，与If-None-Match配合使用\nExpires: 设置缓存过期时间，Cache-Control也会相应变化\nLast-Modified: 最近修改时间，用于客户端缓存，与If-Modified-Since配合使用\nPragma: 似乎和Cache-Control差不多，用于旧的浏览器\nServer: 服务器信息\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 🌈 状态码\n\n\n\n1xx Informational 提示信息，请求正在处理 2xx Success（成功）请求正常处理完毕\n\n * 200 请求成功\n * 201 请求成功且服务器创建了新的资源\n * 202 已接受，但未处理完成\n * 203 (非授权信息) 已成功处理，但返回信息可能来自另一个源\n * 204 成功处理，但没有返回内容\n * 205 重置内容 服务器成功执行请求，没有返回内容，与204不同，他需要请求者重置文档视图（比如，清除表单内容，重新输入）\n * **206 部分内容 服务器成功执行部分请求 ，**应用于 HTTP 分块下载或断点续传，响应返回的 body 数据并不是资源的全部，也是处理成功的状态\n\n3xx Redirection（重定向）资源位置变动\n\n * 300（多种选择）\n * 301 (Permanently Moved) 永久性重定向，请求的资源已不存在，需用新的 URL 访问\n\n> 永久：域名、服务器、网站架构大幅度改变，如启用新域名、服务器切换到新机房、网站目录层次重构\n\n * 302 (**Temporarily Moved **) 临时重定向，请求的资源还在，暂时需要用另一个 URL 来访问\n\n> 场景：系统维护，告诉用户一会儿再来。服务降级，双十一，将不重要的功能入口先关闭，保证核心服务正常运行\n\n> 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器自动重定向新的 URL\n\n * 303 请求对应的资源存在另一个URL，使用GET获取资源\n\n * 304 ——缓存重定向， 不具有跳转含义，可继续使用缓存资源。 服务器只根据请求头中的 If-None-Match 和 响应头中的 ETag 比较判断是否返回 304，一致返回 304\n\n * 305 （使用代理）\n\n * 307 （临时重定向）类似于302， 但重定向后请求里的方法和实体不允许变动，含义比302明确\n\n4xx Client error（客户端错误）\n\n * 400 不理解请求的语法（一般为参数错误）\n * 401 未授权\n * 403 禁止访问资源，可能是客户端权限不对\n * 404 资源不存在（错误 URL）或找不到请求的网页，拒绝请求且不想说明理由\n * 405（方法禁用）\n * 406（不接受）\n * 407（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n * 408（请求超时）\n\n5xx Server Error 服务器处理请求出错\n\n * 500 Internal Serve Error， 与 400 类型，笼统通用\n * 501 客户端请求的功能还不支持，类似“即将开业，敬请期待”\n * 502 Bad Gateway 通常是服务器作为网关或代理时返回，服务器自身工作正常，访问后端服务器发生错误\n * 503 Service Unavailable，类似“网络服务正忙，请稍后重试”\n * 504 gateway time-out，服务器在尝试加载网页或填写浏览器的另一个请求时未从其访问的另一台服务器收到响应\n\n> 502和504 区别？\n\n都和网关有关\n\n502 一般表现为我们自己写的 应用层服务 挂了，或者网关指定的上游 服务直接指错了地址，网关层无法接收响应\n\n504 一般是 应用层服务 超时，超过了 网关配置的时间，如查库操作耗时十分钟，超过了nginx配置的超时时间\n\n\n# HTTP报文\n\n分为\n\n请求报文(请求行 请求头部 空行 请求体)\n\n响应报文(状态码 消息报头 响应正文)\n\n服务端收到请求后只返回响应头，不会发送相应内容\n\n请求和响应报文唯一区别：第一行用状态信息代替了请求信息\n\n\n# 请求头\n\nHTTP报文一共有四种首部字段（请求头）：请求首部字段、响应首部字段、通用首部字段、实体首部字段\n\n\n# 请求首部字段\n\n\n# Accept\n\nAccept: text/html 浏览器可以接受服务器回发的类型\n\nAccept: / 浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)\n\n\n# Accept-Charset\n\n通知服务器用户代理（浏览器）支持的字符集及字符集的相对优先顺序\n\nAccept-Charset： iso-8859-5, unicode-1-1;q=0.8\n\n\n1\n\n\n中的unicode-1-1;q=0.8是一个整体，表示unicode编码优先级为0.8，小于默认的iso编码优先级（默认q=1）；不要以为分号（；）为分割符，其实逗号（，）才是分割符\n\n\n# Accept-Encoding\n\n用户代理支持的内容编码及内容编码的优先级顺序。 可一次性指定多种内容编码\n\n常见的编码方式有：gzip、compress、deflate、identity\n\n\n# Accept-Language\n\n告知服务器浏览器能够接收的语言 ，及相对优先级\n\n\n# Authorization\n\nWeb认证信息\n\n\n# Host\n\n客户端发送请求时，指定服务器的域名\n\nHost:www.1024nav.com 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。虚拟主机位于同一个IP上，使用首部字段 Host 区分\n\n若服务器未设定主机名，Host为空值\n\n有了 Host ，可以将请求发往「同一台」服务器上的不同网站\n\n\n\n\n# If-Match\n\n当If-Match的字段值跟Etag值匹配时，服务器才会接收请求\n\n\n# If-None-Match\n\nIf-None-Match 的字段值与 ETag值不一致时， 可处理该请求。 与 If-Match 首部字段的作用相反\n\n\n# If-Modified-Since\n\n比较资源更新时间\n\n\n# If-Unmodified-Since\n\n\n# If-Range\n\n附带条件之一。 告知服务器若指定的 If-Range 字段值（ETag 值或者时间） 和请求资源的 ETag 值或时间一致时， 则作为范围请求处理。 反之， 则返回全体资源\n\n我们思考一下不使用首部字段If-Range 发送请求的情况。 服务器端的资源如果更新， 那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412:Precondition Failed作为响应返回， 其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range比起来，就需要花费两倍的功夫\n\n\n1\n\n\n> 形如If--xxx这种样式的请求首部字段，可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求\n\n\n# Referer——正确Referrer\n\nReferer: https://www.1024nav.com 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的\n\n告知服务器 该页面的来源URL，精确到详细页面地址\n\n\n# origin\n\n最初的请求从哪里发起(精确到端口)，比referer更注重隐私\n\n\n# User-Agent\n\nUser-Agent: user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36，告诉HTTP服务器，客户端使用操作系统和浏览器的名称和版本\n\n\n# 响应首部字段\n\n\n# Accept-Ranges\n\n是否接受字节范围请求\n\n\n# Age\n\n告知客户端，源服务器在多久前创建了响应，单位为秒\n\n\n# ETag\n\n告知客户端实体标识。一种将资源以字符串形式做唯一标识的方式。服务器为每份资源分配对应的 ETag值 资源更新时，ETag 更新。生成 ETag 时，没有统一的算法规则，仅由服务器分配\n\n\n# Location\n\n将响应接收方引导至某个与请求 URI 位置不同的资源\n\n该字段配合 3xx ： Redirection 的响应， 提供重定向的URI\n\n浏览器收到301/302报文，检查响应头中是否有location。若有，则提取出URI并发出新的请求，相当于 自动点击这个链接\n\n\n# Proxy-Authenticate\n\n代理服务器对客户端的认证信息\n\n\n# Retry-After\n\n对再次发起请求的时机要求\n\n\n# Server\n\nHTTP服务器的安装信息\n\n\n# Vary\n\n代理服务器缓存的管理信息\n\nCORS 和缓存 如果服务器未使用“*”，而是指定了一个域，为了向客户端表明服务器的返回会根据Origin请求头而有所不同，必须在Vary响应头中包含Origin\n\nAccess-Control-Allow-Origin: https://developer.mozilla.org\nVary: Origin\n\n\n1\n2\n\n\n\n# WWW-Authenticate\n\n认证信息\n\n\n# 通用首部字段\n\n\n# Cache-Control(HTTP1.1）\n\nprivate ：默认， 只能作为私有缓存，不能用户间共享\n\npublic 响应会被缓存，向任意方提供响应的缓存\n\nmust-revalidate 可缓存但必须再向源服务器进行确认\n\n:no-cache 缓存前必须确认其有效性， 该指令还是会使用缓存，只不过使用前要确认其新鲜程度（协商缓存）\n\n: max-age=31536000 设置缓存最大的有效时间，单位是秒\n\n:no-store 真正的所有内容都不缓存\n\n\n# Connection\n\n客户端要求服务器使用 TCP 持久连接，以便其他请求复用\n\nHTTP 对 TCP 连接的使用，分为两种方式：“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”，一个 TCP 连接从头用到尾）\n\n两个作用：\n\n * 控制不再转发给代理的首部字段\n * 管理持久连接\n\nConnection: keep-alive 一个网页打开后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，继续使用这一条已经建立的连接\n\nConnection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立连接\n\n\n# Date\n\n\n# Transfer-Encoding\n\n\n# Upgrade\n\n\n# Via\n\n追踪客户端与服务器之间的请求和响应报文的传输路径。(各个代理服务器会往Via首部添加自身服务器的信息)\n\n\n# Range（用于断点续传\n\nRange:bytes=0-5 指定第一个字节的位置和最后一个字节的位置。告诉服务器自己想取对象的哪部分\n\n\n# 实体首部字段\n\n是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息\n\n\n# Allow\n\n\n# Content-Encoding\n\n说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式\n\n\n\n\n# Content-Language\n\n\n# Content-Length\n\n本次回应的数据长度\n\n\n# Content-Location\n\n\n# Content-MD5\n\n\n# Content-Rage\n\n\n# Content-Type\n\n告诉客户端，本次媒体资源格式，请求头则代表请求体资源类型；响应头则代表响应体资源类型\n\nContent-Type: text/html; charset=UTF-8;\nContent-Type: multipart/form-data;\n\n\n1\n2\n\n\n\n\n\n# Expires\n\n将资源失效的日期告知客户端。缓存服务器（代理服务器）在接收到含有首部字段 Expires的响应后，以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源\n\n源服务器不希望缓存服务器对资源缓存时， 最好在 Expires 字段内写入与首部字段 Date 相同的时间值\n\n但是，当首部字段Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age指令\n\n\n# Last-Modified\n\n指明资源最终修改的时间。 与请求头If-Modified-Since是一对\n\n\n# Cookie\n\n可校验 Cookie 的有效期，及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web 站点和攻击者的攻击而泄露\n\n\n# Set-Cookie\n\n当服务器准备开始管理客户端的状态时，会事先告知各种信息。\n\nSet-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path\n\n\n1\n\n\ncookie字段\n\n属性              作用\nname=value      赋值cookie的名称和值\nexpires=date    cookie有效期\npath=path       限制指定的Cookie的发送范围的文件目录，默认为当前\ndomain=domain   限制cookie生效的域名，默认为创建cookie的服务域名\nHttpOnly        不能通过 JS 访问 Cookie，减少 XSS 攻击\nsecure          只能在协议为 HTTPS 的请求中携带\nSameSite        浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击\n\n * expires\n\n指定 Cookie 有效期。省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内\n\n * domain\n\ncookie作用域\n\n比如，指定 .example.com 后，除 .example.com 以外， www.example.com或 www2.example.com等子域名都可以访问Cookie\n\n * secure\n\n限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie\n\nSet-Cookie: name=value; secure\n\n\n1\n\n\n以上例子仅当在https://www.example.com/（HTTPS）安全连接的情况下才会进行Cookie 的回收\n\n当省略 secure 属性时，不论 HTTP还是 HTTPS，都会对 Cookie 进行回收\n\n * HttpOnly\n\n禁止JS脚本访问 Cookie\n\nSet-Cookie: name=value; HttpOnly\n\n\n1\n\n * SameSite\n\n是否允许跨域时携带Cookie\n\nstrict：任何情况都不允许作为第三方cookie\n\nLax：宽松模式，只能在请求方法为Get且请求改变了当前页面或打开新的页面时，允许cookie跨域访问\n\nNone：默认模式，请求自动携带cookie\n\n\n# Cookie 请求首部字段\n\n告知服务器，当客户端想获得 HTTP状态管理支持时， 会在请求中包含从服务器接收到的 Cookie。 接收到多个Cookie 时，同样可以以多个 Cookie形式发送。\n\nCookie: status=enable\n\n\n1\n\n\n\n# 请求报文\n\n请求头header细分为\n\n * 请求行\n\n * 请求头\n\nheader包括\n\n 1. 请求方法\n 2. 协议\n 3. 目标url\n\n请求体body，包括请求的内容\n\n\n\n\n# 响应报文\n\n响应行\n\n响应头\n\n响应体\n\n\n\n\n# ✔️ 三次握手\n\n>  1. 建立连接。服务端 初始化创建连接，确认接收后的状态为SYN_receive。客户端等待状态为SYN_send\n>  2. 收到了客户端的SYN，此时服务器处于SYN_RECD状态\n>  3. 客户端收到服务端的SYN/ACK数据包后，发送标有ACK的数据包。ack=y+1，seq=x+1，作为应答。客户端和服务器端状态变化为established\n\nack(Acknowledge Number 确认序列号)——32位，确认接收对方的数据，ACK 为 1 时该确认序列号字段才有效——解决不丢包的问题\n\nseq(Sequence Number 序列号)——32位，标识发送数据，连接请求报文段，客户端进入SYN_SENT，等待服务器确认，发送自己的数据，确保数据通信有序性\n\nSYN(synchronous)——同步序列号，发起一个新连接**(带有SYN的过程包不带数据)，第三次握手可携带数据)，消耗一个序号**。SYN 标志位和 ACK 标志位搭配使用，当连接请求时，SYN=1，ACK=0连接被响应时，SYN=1，ACK=1\n\nACK(acknowledgement)——标志位，应答确认序号有效，我接收到的信息确实是你所发送的信息。发送方到接收方通道没问题\n\nSYN+ACK（验证接收方到发送方通道）——双方通信无误必须是两者互相发送消息都无误\n\n\n\n\n# 为啥3次握手？\n\n> 本质是，信道不可靠，但是通信双方需要就某个问题达成一致。三次通信是理论上最小值，3次握手不是TCP本身的要求，而是为了满足“在不可靠信道上可靠传输信息”这一需求导致的。为了判断双方的接收和发送能力是否正常\n\n> 红蓝军 问题，由于信息可能丢失，为了保证信息传达准确性，我们需多次传递，通信次数越多，信息到达概率越大。TCP 采用三次握手，尽可能可靠\n\n防止已失效的连接请求报文段突然又传送到了服务端，产生错误\n\n在谢希仁著《计算机网络》书中同时举了一个例子，如下：\n\n> “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。\n> \n> 本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。\n> \n> 假设不采用“三次握手”，只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。\n> \n> 但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”\n\n握手次数不过是提高“它是可用的”这个结论的可信度\n\n四次握手没必要\n\n\n# ✅ 四次挥手\n\n【四次挥手是2+2】留下扫尾工作的时间\n\n客户端和服务端均能主动关闭连接\n\nFIN=1 ACK=1 表示TCP连接释放报文段\n\n\n1\n\n 1. TCP是全双工模式，当主机1发出FIN连接释放报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；并停止再发送数据，主动关闭TCP连接。进入FIN_WAIT1(终止等待状态1)，等待服务器确认\n\n但这个时候主机1还是可接受来自主机2的数据\n\n 2. 当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1；**服务器：我请求报文接收完了，准备关闭，你也准备吧。**此时服务端处于CLSE_WAIT状态，即服务端收到连接释放报文段后即发出确认报文段。此时的TCP处于半关闭状态\n\n 3. 当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，**我也没有数据要发送了，**之后彼此就会愉快的中断这次TCP连接。服务端发送连接释放报文段，进入LAST_ACK状态，等待客户端确认\n\n 4. 客户端向服务器发送报文段，ACK+seq+ack，进入等待TIME_WAIT状态。需要过一阵子以确保服务端收到自己的ACK报文段后才进入CLSED状态，服务器收到报文段后关闭连接，发起方等待一段时间后没有回复，正常关闭。浏览器：我响应报文接收完，准备关闭了，你也准备关闭吧\n\n如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化\n\n * FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态表示等待对方的FIN报文\n\n区别是：FIN_WAIT_1状态是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态（等待对方的ACK报文）\n\n而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，在实际正常情况下，无论对方何种情况，都应马上回应ACK报文，所以FIN_WAIT_1状态一般比较难见到，而FIN_WAIT_2状态常常可以用netstat看到（主动方——A）\n\n * FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接（主动方）\n * CLOSE_WAIT：表示在等待关闭\n\n怎么理解呢？\n\n当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有，那么你也可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接（被动方）\n\n * LAST_ACK: 是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态（被动方）\n * TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态**，而无须经过FIN_WAIT_2状态（主动方）**\n * CLOSED: 连接中断\n\n\n# 2MSL 等待状态？\n\nTIME_WAIT状态也为2MSL等待状态。报文段最大生存时间 MSL（Maximum Segment Lifetime）\n\n 1. 保证客户端发送的最后一个ACK报文段能够到达server\n 2. 防止“已失效的连接请求报文段”出现在本连接中\n\n客户端发送完最后一个ACK报文段后，再经过 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段\n\n> client端接到第三次挥手的时候，client端不会马上CLOSED，而是等待两个msl再关闭\n> \n> 因为如果client端发送的第四次挥手server端没收到，server可能会重传第三次挥手的包，并且依旧在TIME_WAIT状态\n> \n> 这时 如果client直接关闭请求，会导致server端一直重传；有了2MSL之后（也就是等一个来回），就可以接收到server端重传的挥手报文，重新进行第四次挥手\n\n为什么是两个msl，一个不可以吗\n\n> 因为server端检测到丢包就需要一个msl，还没等server端重传，client端就CLOSED了\n\n\n# 为啥4次挥手？\n\n当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。ACK 用来 应答，SYN 用来 同步\n\n关闭连接时，服务器收到对方的FIN报文时，仅表示对方不再发送数据了，但还能接收数据，而自己也未必不发送数据了，所以服务器可立即关闭，也可发送数据，再发送FIN报文表示同意关闭连接，因此，服务器ACK和FIN一般分开发送\n\n\n# SYN攻击？\n\n服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器 容易受到SYN洪泛攻击\n\nSYN攻击：Client在短时间内伪造大量不存在的IP地址，并向Server不断地发 送SYN包，Server回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，引起网络拥塞甚至系统瘫痪\n\n常见的防御 SYN 攻击的方法\n\n 1. 缩短超时（SYN Timeout）时间\n 2. 增加最大半连接数\n 3. 过滤网关防护\n 4. SYN cookies技术\n\n\n# 啥时候用TCP/UDP？\n\n实时性要求比较高，选择udp，比如游戏，媒体通信和实时视频流，即出现传输错误也可以容忍\n\n其他大部分情况，都是用TCP，因为要求传输内容可靠，不出现丢失\n\n\n# ⚠️TCP、UDP？\n\nTCP：Transmission Control Protocol， 传输控制协议\n\nUDP ：User Datagram Protocol 用户数据报协议\n\n\n\n\n# TCP\n\n 1. 面向连接\n 2. 可靠交付\n 3. 无差错，不丢失，无重复，按序到达\n 4. 面向字节流\n 5. 首部20字节，开销大\n 6. 只能点对点全双工可靠信道\n\n\n\n\n# TCP头部很大，具体有哪些报文信息？\n\n\n# UDP\n\n 1. 无连接(利用IP提供面向无连接通信服务)\n 2. 尽最大努力交付，不可靠(传输途中出现丢包，不负责重发；当包的到达顺序乱序，不纠正)\n 3. 面向报文\n 4. 无拥塞控制(按照应用程序发来的数据原样发送，即使出现网络拥堵，也不会进行流量控制等避免拥塞的行为)\n 5. 支持一对一，一对多，多对一和多对多的交互通信\n 6. 首部开销小，8字节\n 7. 实时性好，效率高\n 8. 不可靠信道\n 9. 无论应用层交给UDP多长的报文，统统发送，一次发送一个报文\n\n简言之：\n\n * TCP向上层提供面向连接的可靠服务，建立连接3次握手、断开连接4次挥手；UDP向上层提供无连接不可靠服务，发送端只负责将数据发送到网络，接收端从消息队列读取\n * UDP没有TCP传输来的准确，但是在很多实时性要求高的地方有所作为\n * 对数据准确性要求高，速度可以相对较慢，可选用TCP\n * TCP面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输，在目的站重新装配。UDP面向报文，不会拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文上传上层应用\n\n\n# 应用\n\n\n# 🌰 TCP为什么可靠？\n\n可靠：保证接收方进程从缓存区读出的字节流和发送方发出的字节流完全一样\n\n实现可靠传输的机制有 校验、序号、确认和重传\n\n\n# 数据分片和排序\n\ntcp会按 最大传输单元(MTU)合理分片，接收方缓存未按序到达的数据， 重新排序后交给应用层\n\nUDP：IP数据报大于1500字节，大于MTU。这时发送方的IP层需要分片，把数据报分成若干片，每一片都小于MTU\n\n而接收方IP层则需要重组 数据报\n\n由于UDP的特性，某一片数据丢失时，接收方无法重组数据报，导致丢弃整个UDP数据报\n\n\n# 首部校验\n\n接收端用CRC检验整个报文段有无损坏\n\n增加伪首部，反码求和\n\nTCP协议规定，TCP的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用 累加和校验 方式计算出一个数字，存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，将计算出的校验和 和接收到的首部中的 校验和比较，如果不一致则 说明数据在传输过程中出错。\n\n但这个机制能够保证检查出一切错误吗？显然不能。\n\n因为这种校验方式是累加和，将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是小学生都知道A+B=B+A，假如在传输的过程中有前后两个16比特位的数据前后颠倒了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），导致 校验和的计算结果和颠倒之前一样，接收端肯定无法检查出这是错误的数据\n\n解决方案\n\n传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据进行MD5加密，如果加密结果和摘要一致，则认为没有问题\n\n\n# 确认和重传（重传机制）\n\nTCP面向字节流，一个字节一个序号\n\nACK信号，发送方按照顺序给要发送的数据包的每个字节都标上号\n\nTCP实现可靠传输的方式之一，通过 序列号和确认应答 实现\n\n基于序号机制，接收方接收到某个报文段后，发送给发送方一个确认号，采用累计确认法，表示已收到消息\n\n保证因链路故障未能到达数据能被 多次重发\n\n不一定能如上图那么顺利进行正常的数据传输，万一在传输过程中丢失了呢？\n\nTCP针对数据包丢失的情况——重传机制\n\n常见的重传机制\n\n * 超时重传\n * 快速重传\n * SACK\n * D-SACK\n\n\n# 超时重传\n\n发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，重发该数据\n\n两种情况发生超时重传：\n\n 1. 数据包 丢失\n 2. 确认应答丢失\n\n> 超时时间该设置为多少？\n\nRTT（Round-Trip Time 往返时延）：数据发送时刻到接收到确认的时刻的差值\n\nRTO (Retransmission Timeout超时重传时间)\n\n假设在重传的情况下，超时时间 RTO 「较长或较短」时，发生什么事情？\n\n 1. 超时时间 RTO 较大，重发就慢，丢了老半天才重发，没有效率，性能差\n\n 2. 超时时间 RTO 较小时，导致可能没有丢就重发，于是重发就快，增加网络拥塞，导致更多的超时，更多的超时导致更多的重发\n\n超时重传时间RTO的值应该略大于报文往返RTT的值。且RTO动态变化\n\n超时触发重传存在的问题，超时周期可能相对较长，可以以更快捷的方式操作吗？——快速重传\n\n\n# 快速重传\n\n发送方收到冗余确认，判断报文段丢失\n\n不以时间为驱动，以数据驱动重传\n\n上图，发送方发出了 1，2，3，4，5 份数据：\n\n * Seq1先到了，于是ACk回2\n\n * 结果2没有到，3到了，所以ACK还是回2\n\n * 后面的4和5都到了，但是ACK还是回2，因为2号包没收到\n\n * 发送端收到了3个ACK=2的确认，知道2没有收到，在定时器过期前，重传丢失的2\n\n * 最后，接收到了2，因为此时3 4 5包都收到了，所以ACK回6\n\n快速重传的工作方式就是当收到3个相同的ACK报文时，在定时器过期之前，重传丢失的报文段\n\n面临的问题：重传的时候，是重传之前的一个，还是重传所有？\n\n对以上的例子，重传2？还是重传2 3 4 5 呢？因为发送端并不清楚这三个连续的ACK 2是谁传回来的\n\n所以，有了SACK方法——解决不知道该重传哪些TCP报文\n\n\n# SACK-Selective\n\n（ Selective Acknowledgment 选择性确认）\n\n这种方式需要在 TCP 头部「选项」字段里加一个 SACK ，它可以将缓存的地图发送给发送方，这样发送方就知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据\n\n下图，发送方收到了三次同样的 ACK 确认报文，于是触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，重发时，就只选择这个 TCP 段重复发送\n\n如果要主持SACK，必须双方都要支持\n\n\n# D-SACK-Duplicate\n\nDuplicate SACK 又称 D-SACK，其使用了 SACK 告诉「发送方」有哪些数据被重复接收了\n\n# 丢包\n\n * 「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）\n\n * 「接收方」发现数据重复收到，于是回了一个 SACK = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收，因为 ACK 都到了 4000 了，意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK\n\n * 这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了\n\n# 网络延时\n\n * 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文\n * 后面报文到达的三个相同的 ACK 确认报文，触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」\n * 所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包\n * 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟\n\n# 好处\n\n 1. 让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了\n 2. 知道是不是「发送方」的数据包被网络延迟了\n 3. 知道网络中是不是把「发送方」的数据包给复制了\n\n\n# 流量控制\n\n发送方不能无脑发送数据给接收方，需要考虑接收方处理能力\n\n如果一直发数据给对方，处理不过来会触发重发机制，浪费网络流量\n\n流量控制——为了控制发送方发送速率，保证接收方来得及接收\n\nTCP 提供一种机制可让「发送方」根据「接收方」的实际接收能力控制发送的数据量——流量控制\n\n\n# 保证次序？\n\n“停止等待”\n\n\n\n发送方发送一个包1，这时候接收方确认包1。发送包2，确认包2。\n\n这样一直下去，直到完全发送完所有数据，结束。就解决了丢包，出错，乱序等一些情况！\n\n同时也存在问题。问题：吞吐量非常低。我们发完包1，一定要等确认包1.我们才能发送第二个包\n\n\n# 提高吞吐量？\n\n两个包一起发送，一起确认。可以看出我们改进的方案比之前的好很多，所花的时间只是一个来回的时间\n\n\n# 实现最优解？\n\n> 每次需要发多少个包过去呢？发多少是最合适？\n\n我们可不可以把第一个包和第二个包发过去后，收到第一个确认包就把第三个包发过去呢？ 而不是去等到第二个包的确认包才去发第三个包——"滑动窗口"的实现\n\n为每个数据包确认应答的缺点：包往返时间越长，网络吞吐量越低\n\n\n# 滑动窗口\n\n你一句我一句，效率低。如果你说完一句话，我没有及时回复，你不是要干等着我做完其他事，我回复你，你才能说下一句话，显然不现实\n\n因此，这种传输方式的缺点——数据包的往返时间越长，通信效率越低\n\n为解决这个问题，TCP引入了窗口这个概念，即使往返时间较长，也不会降低网络通信效率\n\n窗口大小：无需等待确认应答，可以继续发送数据的最大值\n\n实际上是OS开辟的一个缓存空间，发送方在等到确认应答返回前，必须在缓冲区保留已发送的数据。若按期收到确认应答，此时数据可以从缓存区中清除\n\n假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。下图：\n\n只要发送方收到了ACK700的确认应答，意味着700之前的所有数据接收方都收到了——累计确认(累计应答)\n\n> 窗口大小谁决定？\n\nTCP 头里有一个字段 Window，就是窗口大小\n\n这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端根据这个接收端的处理能力发送数据，而不会导致接收端处理不过来\n\n因此，通常窗口大小由接收方的窗口大小决定\n\n发送方发送的数据不能超过接收方窗口大小，否则接收方无法正常接收数据\n\n> 发送方的滑动窗口\n\n我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：\n\n\n\n在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小为 0 ，表明可用窗口耗尽，没收到 ACK 确认之前无法继续发送数据\n\n\n\n在下图，当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了\n\n\n\n> 接收方的滑动窗口\n\n接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：\n\n\n\n接收窗口和发送窗口的大小是相等的吗？\n\n并不完全相等，接收窗口大小约等于发送窗口的大小\n\n因为滑动窗口不是一成不变。比如，当接收方的应用进程读取数据的速度非常快的话，这样接收窗口可以很快空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。这个传输过程存在时延，所以接收窗口和发送窗口是约等于的关系\n\n\n\n# 正常情况\n\n\n\n4号包已经被对方接收到，窗口往右移一格。我们把11号包读进缓存。进入“待发送”的状态。接下来的操作就是一样的了，确认包后，窗口继续往后移，将未发送的包读进缓存，把“待发送”的包状态变为“已发送”\n\n# 丢包情况\n\n可能我们包发过去，但是对方的ACK丢了\n\n也有可能是我们的包并没有发过去\n\n站在发送方的角度看就是我们并没有收到ACK\n\n\n\n因此，我们会一直等待ACK，若一直等不到，我们也会把读进缓存的待发送的包也一起发过去。但是，这时我们的窗口已经满了，就不能把12号包读进来，而是始终在等待5号包的ACK\n\n> 若我们这ACK始终不来，咋办？\n\n# 超时重传\n\nACK需要按顺序来，必须等到5的ACK收到了，才会把6-11的ACK发送过去。酱紫也保证了滑动窗口的顺序\n\n\n\n此时，5号包已经接收到了ACK，后面的6-8号包也已经发送过去已ACK。窗口继续向后移动\n\n\n\nrwnd表示receiver window\n\n> 该协议允许发送方在停止并等待确认前发送多个数据分组。发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量\n\n滑动窗口大小——接收方还有多大的缓冲区可以用于接收数据，用以 解决发送速率过快导致接收方不能接收 的问题。发送方 通过滑动窗口大小确定应该发送多少字节数据。当滑动窗口为 0 时，发送方一般不再发送数据报，两种情况除外，一种情况是可以发送紧急数据\n\n发送方A的发送窗口表示：在没有收到B确认的情况下，A可以连续把窗口内的数据都发送出去，凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用\n\n发送窗口的位置由窗口前沿和后沿位置共同确定：\n\n * 后沿不动——没有收到新的确认\n * 后沿前移——收到了新的确认\n * 前沿前移——收到新的确认，或者接收方的窗口变大\n * 前沿不动——没有收到新的确认，接收方的窗口大小不变，或者收到了新的确认，但接收方的窗口变小\n\n 1. 发送端只能发送接收端指定的报文大小，超过了则暂停发送信息\n\n 2. 滑动窗口由窗口值控制传输流量的大小；利用重发机制解决发送端消息丢失；利用 持续计数器和探测报文解决接收端发送的窗口值丢失导致的无限等待情况\n\n\n# 拥塞控制\n\n流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络中发生了什么\n\n一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵\n\n网络拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 会重传数据，但是一重传就会导致网络的负担更重，导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....\n\n拥塞控制，避免「发送方」的数据填满整个网络\n\n为了在「发送方」调节所要发送数据的量，定义一个叫做「拥塞窗口」的概念\n\nRTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定\n\n对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:\n\n * 拥塞窗口（Congestion Window，cwnd**） 把一次性能够发送的数据包多少的窗口**称之为拥塞窗口\n\n拥塞窗口 cwnd 变化规则：\n\n>  * 只要网络中没有出现拥塞，cwnd 增大\n>  * 网络中出现了拥塞，cwnd 减小\n\n * 慢启动阈值（Slow Start Threshold，ssthresh）\n\n> 怎么知道当前网络是否出现了拥塞？\n\n只要「发送方」没有在规定时间内接收到 ACK 应答报文，就是发生了超时重传，认为网络出现了拥塞\n\n> 拥塞控制的控制算法？\n\n拥塞控制主要是四个算法：\n\n * 慢启动\n * 拥塞避免\n * 拥塞发生\n * 快速恢复\n\n> MTU 最大传输单元\n\n> MSS(最大消息长度)：为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知在每个分节能发送的最大TCP数据\n\n\n# 慢开始\n\nTCP 刚建立连接完成后，首先有个慢启动的过程，意思就是一点一点提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？\n\n慢启动的算法记住一个规则就行：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1\n\n发包的个数是指数性的增长\n\n有一个叫慢启动门限 ssthresh （slow start threshold）变量\n\n * cwnd < ssthresh 时，使用慢启动算法\n * cwnd >= ssthresh 时，使用「拥塞避免算法」\n\n 1. 连接建好的开始，初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据\n\n 2. 每收到一个ACK，cwnd大小加一，线性上升\n\n 3. 每过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小翻倍，乘以2，指数让升\n\n 4. 还有一个ssthresh（slow start threshold），是一个上限，cwnd >= ssthresh时，进入“拥塞避免算法”\n\n\n# 拥塞避免\n\n拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 进入拥塞避免\n\n过了慢启动阈值后，拥塞避免算法可避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值\n\n进入拥塞避免算法后，规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd\n\n一般来说，TCP拥塞控制默认 认为网络丢包是 由于网络拥塞导致，所以一般 TCP拥塞控制算法以丢包 作为网络进入拥塞状态的信号。对丢包有两种判定方式，\n\n一种是超时重传RTO[Retransmission Timeout]超时\n\n另一个是收到三个重复确认ACK\n\n超时重传是TCP协议保证数据可靠性的一个重要机制，原理是在发送一个数据以后开启一个计时 器，一定时间内如果没有得到发送数据报的ACK报文，就重新发送数据，直到发送成功\n\n但如果发送端接收到3个以上的重复ACK，TCP意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫超时 重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：\n\n发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2\n\ncwnd重置为1 进入慢启动过程是早期的处理办法，但是一丢包就一切重来，cwnd又重置为1，不利于网络数据的稳定传递\n\n就这么一直增长后，网络慢慢进入了拥塞的状况，就会出现丢包现象，这时就需要 重传 丢失的数据包\n\n当触发了重传机制，也就进入了「拥塞发生算法」\n\n\n# 拥塞发生\n\n当网络出现拥塞，会发生数据包重传，重传机制主要有两种：\n\n * 超时重传\n * 快速重传\n\n> 发生超时重传的拥塞发生算法\n\n发生了「超时重传」，就会使用拥塞发生算法\n\n这时，ssthresh 和 cwnd 的值会变化：\n\n * ssthresh 设为 cwnd/2\n * cwnd 重置为 1\n\n\n\n接着，重新开始慢启动，慢启动会突然减少数据流。这真是一旦「超时重传」，马上回到解放前。这种方式太激进了，反应很强烈，会造成网络卡顿\n\n就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。\n\n> 发生快速重传的拥塞发生算法\n\n还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传\n\nTCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：\n\n * cwnd = cwnd/2 ，也就是设置为原来的一半\n * ssthresh = cwnd\n * 进入快速恢复算法\n\n\n# 快速恢复\n\n快速重传和快速恢复算法一般同时使用，快速恢复算法认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈\n\n正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：\n\n * cwnd = cwnd/2 ，设置为原来的一半\n * ssthresh = cwnd\n\n然后，进入快速恢复算法：\n\n * 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）\n * 重传丢失的数据包\n * 如果再收到重复的 ACK， cwnd 增加 1\n * 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，即再次进入拥塞避免状态\n\n\n\n没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长\n\n\n# 流量控制和拥塞控制？\n\n流量控制：传输网络畅通但接收设备小容量\n\n拥塞控制：内部拥塞是大容量接收设备\n\n流量控制属于通信双方协商；拥塞控制涉及通信链路全局\n\n流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定\n\n拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整\n\n\n# TCP 缺陷？\n\n * 升级 TCP 工作困难\n * TCP 建立连接的延迟\n * TCP 存在队头阻塞问题\n * 网络迁移需要重新建立 TCP 连接\n\n\n# 升级 TCP 工作困难\n\nTCP协议在内核中实现，应用程序只能使用不能修改，若想要升级TCP只能升级内核\n\n内核升级设计到底层软件和运行库的更新，我们的服务程序需要回归测试是否兼容新的内核版本，服务器的内核升级比较保守且缓慢\n\n\n# TCP 建立连接延迟\n\n基于TCP实现的应用协议，都需要先建立三次握手才能进行数据传输，比如HTTP1.1/1.1、HTTP/2、HTTPS\n\n大多数网站都是使用的HTTPS，TCP三次握手之后，还需要经过TLS四次握手后，才能进行HTTP数据的传输，一定程度增加了数据传输的延迟\n\n\n# TCP 存在队头阻塞问题\n\nTCP是字节流协议，TCP层必须保证收到的字节数据完整且有序，如果序列号较低的TCP段在网络传输中丢失，即使序列号较高的TCP段已经被接收，应用层也无法从内核中读取到这部分数据\n\nHTTP/2多个请求是跑在一个TCP连接中的，当TCP丢包时，整个TCP都要等待重传，会阻塞该TCP连接中的所有请求，所以 HTTP/2 队头阻塞问题就是TCP协议导致的\n\n\n\n\n# 网络迁移需重新建立 TCP 连接\n\n基于 TCP 传输协议的 HTTP 协议，通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接\n\n\n\n当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，就必须要断开连接，重新建立 TCP 连接\n\n建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本很高\n\n\n# UDP 实现可靠传输？\n\nTCP 天然支持可靠传输，为什么还需要基于 UDP 实现可靠传输呢？这不是重复造轮子吗？\n\n\n# 通信数据转发程序\n\n\n# 代理\n\n代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时接收服务器返回的响应并转发给客户端\n\n基本行为——接收客户端发送的请求后转发给其他服务器。代理不改变请求URL，直接发送给前方持有资源的目标服务器\n\n\n\n\n# 代理方法\n\n# 缓存\n\n代理转发响应时，缓存代理（Caching Proxy）预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回\n\n# 透明代理\n\n转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理\n\n\n# 网关\n\n网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关\n\n\n\n\n# 隧道\n\n隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序\n\n\n\n\n# HTTP请求方法\n\n方法        描述\nGET       请求指定的页面信息，返回实体主体\nHEAD      类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头，确认URI的有效性及资源更新的日期时间等\nPOST      向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改\nPUT       从客户端向服务器传送的数据取代指定的文档的内容\nDELETE    请求服务器删除指定的页面\nCONNECT   HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器\nOPTIONS   允许客户端查看服务器的性能；查询针对请求URI 指定的资源支持的方法\nTRACE     回显服务器收到的请求，主要用于测试或诊断\n\n\n# options方法？\n\nbrowser自动发起\n\n获取当前URL所支持的方法\n\n检查服务器性能\n\n\n# 💚 GET、POST\n\n\n# GET\n\n**不能 传中文，会**乱码！！\n\n根据 RFC 规范，GET 是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等\n\nGET 请求的参数位置一般写在 URL 中，URL 规定只能支持 ASCII，浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）\n\n传送的数据量较小，不能大于2KB\n\n\n# POST\n\n根据 RFC 规范，POST 是根据请求负荷（报文body）对指定的资源做出处理\n\nPOST 请求携带数据的位置一般写在报文 body 中，数据可以是任意格式，只要与服务端协商好，且浏览器不会对 body 大小做限制\n\n\n# 区别\n\n幂等：多次执行相同的操作，结果都相同\n\n安全：请求方法不会破坏服务器上的资源\n\n * 大多数浏览器限制url 2KB，大多数服务器处理 64 K url，GET可带 body 但不保证可被接收\n * GET产生一个TCP 数据包，POST 产生2个——有争议！！这个根代码和TCP协议栈有关，和HTTP 无关\n\nGET： 浏览器一并发送 http header 和 data，服务器响应200\nPOST：浏览器先发送 header ，服务器响应100 continue ，browser再发送 data，响应200\n\n\n1\n2\n\n\n * 都是HTTP请求方式，HTTP 基于 TCP/IP ，没实质区别\n\n * 不携带参数时，最大区别是请求行不同\n   \n   1. GET：GET /uri HTTP/1.1\n   2. POST：POST /uri HTTP/1.1\n\n * GET安全且幂等，可对数据缓存，缓存可以做到浏览器上（彻底避免浏览器发请求），也可以做到代理上（如nginx），可以保存为书签\n\n * POST是新增或提交数据，会修改服务器资源，不安全，不幂等。浏览器一般不缓存POST请求，也不能保存为书签\n\n * 从传输的角度来说，他俩都不安全，HTTP是明文传输，只要在网络节点抓包就能完整获取数据报文，只有HTTPS才能加密安全\n\nget和post的区别本质上被浏览器/服务器限制，而不是HTTP协议限制\n\n\n# GET参数写法固定？\n\nRFC 并没规定 GET 请求不能带 body 。理论上，任何请求都可以带 body 。只是因为 RFC 定义的 GET 请求是获取资源，根据这个语义不需要用到 body\n\nURL 中的查询参数也不是 GET 所独有，POST 请求的 URL 中也可以有参数\n\n解析报文过程：获取TCP数据，正则从数据获取Header和Body，提取参数，也可以自己约定参数写法，只要后端能够解析出来就行\n\n\n# POST比GET安全？\n\n如果「安全」放入概念是指信息是否会被泄漏的话，虽然 POST 用 body 传输数据，GET 用 URL 传输，数据会在浏览器地址拦容易看到，但并不能说 GET 不如 POST 安全\n\nHTTP 传输的内容都是明文，在浏览器地址拦看不到 POST 提交的 body 数据，但只要抓个包就都能看到\n\n要避免传输过程中数据被窃取——使用 HTTPS 协议，所有 HTTP 的数据都被加密传输\n\n\n# GET长度限制？\n\nHTPP协议没有对Body和URL长度限制，是浏览器和服务器原因\n\n服务器原因是处理长URL消耗多的资源（防止恶意构造长的URL），为了性能和安全\n\n\n# POST产生两个TCP数据包？\n\nheader和body分开发送是部分浏览器请求方法，不属于post必然行为\n\n100 continue为了在发送body之前查看服务器是否接受这个实体，属于优化\n\n大多数是尽量在TCP包中将请求发出去，但也确实存在先发header，再发body的情况。具体是多少个TCP包，这个不关HTTP的事，是OS TCP协议栈和代码的问题\n\n\n# ⏩ HTTP\n\n\n# 优点\n\n 1. 简单\n    \n    * HTTP 基本报文格式是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用门槛\n\n 2. 灵活 易扩展\n    \n    * HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，允许开发人员自定义和扩充\n    * HTTP 由于工作在应用层（ OSI 第七层），它下层可以随意变化\n    * HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC\n\n 3. 应用广泛和跨平台\n    \n    * HTTP 的应用范围非常广泛，从台式机浏览器到手机上的各种 APP，从看新闻到购物、理财，HTTP 的应用遍地开花，天然具有跨平台优越性\n\n 4. 可靠\n    \n    * HTTP对传输数据进行一层包装，加上一个头，调用API，通过TCP/IP协议发送和接收\n\n 5. 使用 请求-应答 通信模式\n\n 6. 无状态，client和server永远处于“无知”状态，每次请求和答复独立。协议不要求server或client记录请求的相关信息\n    \n    TCP有状态：CLOSED——ESTABLISHED——FIN-WAIT——CLOSED。HTTP 1.1中总是默认启动keep-alive长连接机制\n\n\n# 缺点\n\n 1. 明文传输，内容可能被窃听\n\n明文意味着在传输过程中的信息，方便阅读。正是这样，HTTP 所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有账号密码信息，那号没了\n\n 2. 不安全，无法验证通信双方身份，也不能判断报文是否修改\n\nHTTP 比较严重的缺点是不安全：\n\n * 通信使用明文（不加密），内容可能被窃听。比如，账号信息容易泄漏，那你号没了\n * 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了\n * 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了\n\nHTTP 的安全问题，可以用 HTTPS 解决，通过引入 SSL/TLS 层，在安全上达到极致\n\n 3. 无论是谁发送来的请求都会响应\n\n * 无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器\n * 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端\n * 无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户\n * 无法判定请求是来自何方、出自谁手\n * 即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）\n\n 4. 无状态双刃剑\n\n * 无状态的好处，服务器不会记忆 HTTP 的状态，所以不需要额外资源记录状态信息，能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务\n\n * 无状态的坏处，既然服务器没有记忆能力，在完成有关联性的操作时会非常麻烦\n\n例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息\n\n这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？\n\n对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术\n\nCookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态\n\n相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了\n\n\n\n\n# 一个TCP连接中HTTP请求可一起发送么\n\n（比如一起发三个请求，再三个响应一起接收)?\n\nHTTP1.1存在一个问题，单个TCP连接在同一时刻只能处理一个请求。即两个请求的生命周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接中不能重叠\n\n在 HTTP/1.1 存在 Pipelining 技术可以完成多个请求同时发送，但由于浏览器默认关闭，所以认为这是不可行的\n\n在 HTTP2 中由于 Multiplexing (多路复用)特点的，多个 HTTP 请求可以在同一个 TCP连接中并行进行\n\n在 HTTP/1.1 时代，浏览器如何提高页面加载效率呢？主要有下面两点：\n\n 1. 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求\n 2. 和服务器建立多个 TCP 连接\n\n\n# HTTP 0.9\n\n * 只支持get\n * 不支持请求头\n * 只能传输纯文本\n * 无状态连接\n\n\n# HTTP1.0、HTTP1.1\n\n\n\n\n# HTTP1.0\n\n与服务器只保持短暂的连接，每次请求都要与服务器建立一个TCP连接\n\n * 响应不仅限文本\n * 支持响应/请求头\n * 默认短连接，增加keep-alive关键字由短链接变成长连接\n * 支持get post head\n\n\n# HTTP 1.1性能?\n\n * 新增options、put、delete、trace和connect\n\n * 增加host字段\n\n * 长连接\n\n（Persistent Connection）在一个TCP连接上可传送多个HTTP请求和响应，减少建立、关闭连接的消耗和延迟。默认开启Connection : keep-alive\n\n只要任意端没有明确提出断开连接，则保持 TCP 连接状态\n\n如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端主动断开连接\n\n * 管道网络传输(请求流水线处理)\n\nHTTP/1.1 采用长连接的方式，使得管道（pipeline）网络传输成为可能\n\n在同一个 TCP 连接里面，客户端可发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，减少整体响应时间\n\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求， 但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应\n\n注意，是按照服务端收到的请求顺序响应，不管哪个请求是先发送，假设客户端先发送 A 请求，后发送 B 请求，如果服务端先收到 B 请求，就先响应 B 请求，再响应 A 请求，但是假设处理 B 请求耗时较长，请求 A 的响应就会被阻塞，称为「队头堵塞」\n\n所以，HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞\n\n * 队头阻塞\n\n「请求 - 应答」的模式加剧了 HTTP 的性能问题\n\n当顺序发送的请求序列中的一个请求因为某种原因被阻塞，在后面排队的所有请求也一同被阻塞，会导致客户端一直请求不到数据——「队头阻塞」，好比上班的路上塞车\n\n总之 HTTP/1.1 的性能一般般\n\n\n# HTTP1.1相比HTTP1.0\n\n 1. 缓存处理，引入更多缓存头控制缓存策略。HTTP1.0中主要使用header里的If-Modified-Since，Expires来做为缓存判断的标准，HTTP1.1则引入更多的缓存控制策略例如Entity tag，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头控制缓存策略\n 2. 带宽优化及网络连接的使用，增加断点续传功能\n 3. 错误通知的管理：新增24个错误状态码，如409（conflict）表示请求资源与资源当前状态冲突、410（Gone）表示服务器上某个资源被永久性删除\n 4. Host头处理。随着虚拟主机技术的发展，一台物理服务器上可以存在多个虚拟主机且共享同一个IP。HTTP 1.1请求和响应都支持host头，请求消息中如果缺少host，400（Bad Request）\n 5. 长连接，改善HTTP1.0短连接造成的性能开销\n 6. 支持管道网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，减少整体响应时间\n\n\n# 二者存在问题：\n\n 1. HTTP传输数据，每次都要3次握手建立连接，增加大量延迟\n 2. 明文传输\n 3. header携带内容过大，增加传输成本\n 4. HTTP1.1支持keep-alive，但是keep-alive使用多了同样给服务端带来大量性能压力，因为文件被请求后，服务端需要保持不必要的连接很长时间\n\n\n# HTTP1.1性能瓶颈\n\n 1. 请求/响应头部未经压缩就发送，首部信息越多延迟越大，只能压缩Body部分\n 2. 发送冗长首部.每次发送相同的首部造成浪费\n 3. 服务器按请求的顺序响应，如果服务器响应慢，会导致客户端一直请求不到数据——队头阻塞\n 4. 没有请求优先级控制\n 5. 请求只能从客户端开始，服务器只能被动响应\n\n\n# SPDY-HTTP1.x优化\n\nSPDY位于HTTP之下，TCP和SSL之上，可轻松兼容老版本的HTTP协议，也可使用已有的SSL功能\n\n\n# 特点\n\n * 降低延迟\n\n针对HTTP高延迟的问题，SPDY采取了多路复用（multiplexing）\n\n多路复用通过多个请求stream共享一个tcp连接，解决了HOL blocking(队头阻塞)问题，降低延迟同时提高带宽利用率\n\n * 请求优先级（request prioritization）\n\n多路复用的连接共享机制可能导致关键请求被阻塞\n\nSPDY允许给每个request设置优先级，重要请求优先得到响应\n\n * header压缩\n\n减少包的大小和数量，酱紫通信产生的数据包数量和发送的字节数就更少了\n\n * 基于HTTPS的加密协议传输，提高传输数据的可靠性\n * 服务端推送（Server push）\n\n采用了SPDY的网页，例如我的网页有一个style.css的请求，在客户端收到style.css数据的同时，服务端会将style.js的文件推送给客户端，当客户端再次尝试获取style.js时就可以直接从缓存中得到，不用再次请求\n\n * 多路复用。通过单一的TCP连接，可以无限制处理多个HTTP请求\n * 服务器提示功能。服务器可主动提示客户端请求所需的资源。在客户端发现资源前就获取资源的存在，在资源已缓存的情况下，避免发送请求\n\n\n# WebSocket\n\nWebsocket和socket——雷锋和雷峰塔\n\n网络传输协议，浏览器和服务端 全双工通讯的网络技术，位于应用层\n\n节省服务器资源和带宽达到实时通迅\n\n客户端和服务器只需完成一次握手，两者就可创建持久性连接，并进行双向数据传输\n\n\n# 特点\n\n 1. 二进制帧。语法语义和HTTP完全不兼容，对比HTTP2，WebSocket侧重于 实时通信，HTTP2侧重于提高传输效率，不存在多路复用，优先级等特性；不需要服务器推送\n\n\n# 应用\n\nwebsocket完美继承 TCP 的全双工能力， 还贴心 提供了解决粘包的方案。 适用于需要服务器和客户端（浏览器）频繁交互的大部分场景。 网页/小程序游戏，网页聊天室， 类似飞书 的网页协同办公软件\n\n使用websocket协议的网页游戏里，怪物移动以及攻击玩家的行为是服务器逻辑产生 ，对玩家产生的伤害等数据， 由服务器主动发送给客户端，客户端获得数据后展示效果\n\n * 弹幕\n * 媒体聊天\n * 协同编辑\n * 基于位置的应用\n * 体育实况更新\n\n\n# HTTP不断轮询\n\n伪服务器推的方式——前端不断定时发请求到服务器，服务器收到请求后给客户端响应\n\n场景：扫码登录\n\n问题：\n\n 1. 满屏的HTTP请求，消耗带宽增加服务器负担\n 2. 最坏情况需要等1~2s触发请求，跳转页面，出现卡顿\n\n\n# 长轮询\n\n若http请求将超时设置的很大，在30s内只要服务器收到了扫码请求，就立马返回给客户端，若超时则发下一个请求\n\n场景：百度网盘\n\n长轮询——发起一个请求，在较长时间内等待服务器响应\n\n\n# Websocket\n\n\n# ✅ HTTP 2.0\n\n更快 更稳定 更简单\n\n\n\n\n# 特性\n\nHTTP/2 协议基于 HTTPS\n\nHTTP2.0可以说是SPDY的升级版本，与SPDY的区别如下：\n\n 1. HTTP2.0支持明文HTTP传输，而SPDY强制使用HTTPS\n 2. HTTP2.0消息头压缩算法使用HPACK，而SPDY使用DEFLATE\n\nHTTP2.0主要目标——改进传输性能，实现低延迟和高吞吐量\n\nHTTP2.0升级改造需要考虑：\n\n 1. HTTP2.0支持非HTTPS，但主流浏览器如chrome、Firefox还是只支持基于TLS部署的HTTP2.0协议，所以升级HTTP2.0还是要先升级HTTPS\n 2. 升级HTTPS后，如果使用NGINX，只需要在配置文件中启动相应的协议就可\n 3. HTTP2.0完全兼容HTTP1.x，对于不支持HTTP2.0的浏览器，NGINX自动向下兼容\n\n\n# 二进制分帧\n\nHTTP/2 不像 HTTP/1.1 纯文本形式的报文，而是全面采用二进制格式**，头信息和数据体都是二进制，统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）\n\n帧——HTTP/2 通信最小单位，每个帧都包含帧头，至少会标识出当前帧所属的数据流\n\nHTTP/2 连接是永久的，仅需要每个来源 一个连接\n\n\n\n对人不友好，但是对计算机友好，因为计算机只懂二进制，收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，增加了数据传输的效率\n\n(因为是新增的二进制分帧层，所以叫2.0)\n\n不改变HTTP语义，HTTP方法、状态码、URL及首部字段。改进传输性能，实现低延迟和高吞吐量\n\nHTTP1.x解析基于文本，文本展现形式多样，要做到健壮性考虑的场景必然很多，二进制则只有0和1，更高效健壮\n\n\n# 首部压缩\n\n> HTTP/2 会压缩头（Header）如果同时发出多个请求，他们的头一样或是相似，协议会消除重复的部分\n> \n> HPACK算法：客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，提高速度\n\nHTTP 1.x无首部压缩，Gzip只对请求体压缩\n\nSPDY和HTTP 2.0都支持首部压缩。使头部帧最大程度复用，减少头部大小，减少内存和流量\n\n比如：第一次请求，包含头部各种信息，后来又发送另外请求，发现大部分字段可以复用，一次只发送一个当前请求特有的头部帧即可\n\n避免重复header传输\n\n 1. HTTP2.0会压缩首部元数据，在client和server使用首部表跟踪和存储之前发送的健值对，对于相同数据，不需每次请求响应都发送\n 2. 所有header必须全部小写，而且请求行要独立为健值对（即header+值）\n\n\n# 多路复用\n\nHTTP 1.0：建立连接，请求数据完毕之后立即关闭连接\n\n后采用keep-alive模式使得可以复用连接而不断开，可利用这次连接继续请求\n\n缺点：必须等到server返回上一次的请求数据才进行下一次请求\n\nQ：遇到一个请求很久没有响应，后面的请求只能等待？\n\nHTTP/2 可以在一个连接中并发请求，不用按照顺序一一对应\n\n多路复用（MultiPlexing），即连接共享，每一个request都是用作连接共享机制。每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混杂在一起，接收方根据request的id将request归属到不同服务端请求里。客户端只需要一个连接就可以加载一个页面\n\n移除了 HTTP/1.1 中的串行请求，不需要排队等待，不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接利用率\n\n举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分\n\n优点：\n\n 1. 并行交错发送请求，请求之间互不影响\n 2. TCP连接一旦建立可并行发送请求\n 3. 消除不必要延迟，减少页面加载时间\n 4. 可最大程度利用HTTP 1.x\n\n\n# 请求优先级\n\nserver根据流的优先级控制资源分配，响应数据准备好后，把优先级最高的帧发送给client。browser发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序，这时请求不用排队，节省时间，最大限度利用连接\n\n\n# 流量控制\n\n流：不改变协议，允许采用多种流量控制算法\n\n特点：\n\n 1. 流量基于HTTP连接的每一跳进行，不是端到端控制\n 2. 流量基于窗口更新帧进行，接收方可广播准备接收字节\n 3. 流量控制有方向，接收方根据自身情况控制窗口大小\n 4. 流量控制可由接收方禁用\n 5. 只有data帧服从流量控制，其他不会消耗控制窗口的空间\n\n\n# 服务端推送\n\nHTTP/2 一定程度上改善了传统的「请求 - 应答」工作模式，服务不再被动响应，也可以主动向客户端发送消息\n\nserver push通过推送那些它认为客户端将会需要使用到的内容到客户端缓存中，避免往返的延迟\n\n\n# 数据流\n\nHTTP/2 的数据包不是按顺序发送，同一个连接里面连续的数据包，可能属于不同回应。因此，必须要对数据包做标记，指出它属于哪个回应\n\nHTTP/2 中每个请求或相应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号（Stream ID），不同 Stream 的帧可乱序发送（因此可并发不同Stream ），因为每个帧头部携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息\n\n客户端和服务器双方都可以建立 Stream， Stream ID 也有区别，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号\n\n\n\n客户端可以指定数据流的优先级。优先级高的请求，服务器先响应 该请求\n\n\n# 缺陷\n\nHTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层\n\nHTTP/2 基于 TCP 协议传输数据，TCP 是字节流协议，TCP 层必须保证收到的字节数据完整且连续，这样内核才会将缓冲区里的数据返回给 HTTP 应用，当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据—— HTTP/2 队头阻塞问题\n\n\n\n图中发送方发送了很多个 packet，每个 packet 都有自己的序号，可认为是 TCP 的序列号， packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不连续，接收方的应用层无法从内核中读取，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据\n\n所以，一旦发生丢包现象，会触发 TCP 重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传\n\n\n# HTTP3\n\nHttp3.0 相对于 Http2.0 是脱胎换骨的改变！\n\nHTTP1.1和HTTP1.2都有队头阻塞的问题\n\n * HTTP1.1中的管道(pipeline)解决了请求的对头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，只能等相应完这个请求后， 才能处理下一个请求。——HTTP 层队头阻塞\n * HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但一旦发生丢包，就会阻塞所有 HTTP 请求——TCP 层队头阻塞\n\nHTTP/2 队头阻塞的问题是因为 TCP，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！！\n\n\n\nUDP 不管顺序，也不管丢包，不会像 HTTP/2 出现队头阻塞问题\n\nUDP 不可靠传输，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠传输\n\n\n# 特性\n\n\n# 连接迁移\n\n\n# 无队头阻塞\n\n\n# 自定义拥塞控制\n\n\n# 前向安全和前向纠错\n\n\n# 为什么HTTP3.0使用UDP？\n\n\n# 🌰 HTTPS=HTTP+SSL/TLS\n\nHTTPS=HTTP+加密+认证+完整性保护\n\n（HTTP Secure）\n\n\n\nHTTPS是加强版的HTTP，是在HTTP和TCP间建立了一个中间层(安全层)，进行加密，TCP必须将数据包解密才能传给上面的HTTP\n\nheader+body整个都加密，啥都看不到\n\nURL信息在header中，自然被加密\n\n\n\n> HTTPS加密的内容有？？\n> \n>  * 请求头\n>  * 请求路劲\n>  * 请求参数\n\n不会加密 请求域名！！！\n\n\n# SSL/TLS\n\n“Secure Sockets Layer”，叫做“安全套接层”（依靠整数验证服务器身份）一种用于加密和验证应用程序和web服务器间发送的数据的协议\n\n标准化之后的名称改为 TLS（“Transport Layer Security”），叫做“传输层安全协议”\n\n> 公钥加密，私钥解密\n\n\n# 作用\n\n认证用户和服务，加密数据，维护数据完整性\n\nSSL证书验证服务器身份，并为它们之间的通信进行加密\n\nSSL/TLS 协议基本流程：\n\n * 客户端向服务器索要并验证服务器的公钥\n * 双方协商生产「会话秘钥」\n * 双方采用「会话秘钥」加密通信\n\n\n# SSL/TLS的四次握手\n\n\n\nSSL/TLS 的「握手阶段」涉及四次通信，可见下图：\n\n\n\n> 服务端生成第一随机数和第二随机数以及自己的公钥发送给客户端，客户端用服务端的公钥锁上预主秘钥（第三随机数），发送给服务端，服务端收到后用自己的私钥解密，取出欲主密钥，后面2者完全使用欲主密钥以对称加密的方式通信\n> \n> 欲主密钥——会话秘钥\n\nSSL/TLS 协议建立的流程：\n\n 1. ClientHello\n\n客户端向服务器发起加密通信请求—— ClientHello 请求\n\n客户端主要向服务器发送以下信息：\n\n（1）支持的 SSL/TLS 协议版本，如 TLS 1.2 版本\n\n（2）第一随机数——客户端生产的随机数（Client Random），用于后面生成「会话秘钥」条件之一\n\n（3）**客户端支持的加密方法，**如 RSA 公钥加密，此时是明文传输\n\n（4）支持的压缩算法\n\n 2. SeverHello\n\n服务器收到客户端请求后，向客户端发出响应—— SeverHello。服务器回应：\n\n（1）确认SSL/TLS协议版本，如果浏览器不支持，关闭加密通信\n\n（2）第二随机数——服务器生产的随机数（Server Random），是生产「会话秘钥」的条件之一\n\n（3）确认使用加密算法\n\n（4）服务器证书(证书包含网站地址，非对称加密公钥，证书领发机构等信息)\n\n 3. 客户端回应\n\n客户端收到服务器的回应之后，通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书真实性（颁发机构是否合法，证书中包含网址是否和正在访问的一样），证书过期，会给一个警告，是否选择继续通信\n\n如果证书没有问题，客户端从数字证书中取出服务器的公钥，使用它加密报文，向服务器发送：\n\n（1）第三随机数（pre-master key），用于服务器公钥加密\n\n（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信\n\n（3）客户端握手结束通知，这一项同时把之前所有内容发生改变的数据做个摘要，供服务端校验\n\n服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着用协商的加密算法，各自生成本次通信的「会话秘钥」\n\n> 为啥是3个随机数？\n> \n> 一个伪随机可能不完全随机，可是3个随机数就很接近随机了，每增加一个自由度，随机性增加的可不是一！！\n\n 4. 服务器的最后回应\n\n服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」\n\n然后，向客户端发送最后的信息：\n\n（1）加密通信算法改变通知，随后的信息都将用「会话秘钥」加密通信\n\n（2）服务器握手结束通知，同时把之前所有内容的发生改变的数据做个摘要(内容的hash值)，供客户端校验\n\n至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，完全使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容\n\n\n# 🍪HTTPS保证传输安全？\n\n\n# TLS1.0\n\n使用RSA密钥交换算法\n\n\n# TLS.12\n\n使用ECDHE算法\n\n\n# 🔥 HTTPS、HTTP\n\n> 简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取\n\n 1. HTTPS 需要申请数字证书（去 CA 申请），保证服务器的身份可信\n 2. HTTPS在TCP和HTTP应用层间加入了SSL/TLS安全协议，是HTTP的加密版本；HTTP 是超文本传输协议，明文传输不安全\n 3. HTTP 端口 80； HTTPS 端口 443\n 4. HTTP 无状态连接，建立连接相对简单，三次握手后即可进行报文传输.HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输\n 5. HTTPS 协议 由 SSL+HTTP 构建，更安全\n 6. HTTPS提供\n    * 数据完整性\n    * 隐私性\n    * 身份认证\n    * 不可否认性\n\n\n# HTTPS解决啥问题\n\n\n\n\n# HTTP存在风险\n\n 1. 窃听风险，如通信链路上可以获取通信内容，用户号容易没\n 2. 篡改风险，如强制植入垃圾广告，视觉污染，用户眼容易瞎\n 3. 冒充风险，如冒充淘宝网站，用户钱容易没\n\n\n# HTTPS 在 HTTP 与 TCP 层间加入SSL/TLS 协议，解决上述风险\n\n 1. 信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没\n 2. 校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告\n 3. 身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没\n\n\n# HTTPS 如何解决上面三个风险？\n\n 1. 混合加密实现信息的机密性，解决了窃听的风险\n 2. 摘要算法实现完整性，它能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险\n 3. 将服务器公钥放入到数字证书中，解决了冒充的风险（身份认证）\n 4. 数字签名：不可否定。内容摘要算法得到摘要，私钥加密摘要，对方使用对应公钥解密，得到摘要，再和自己得到的服务器提供的原文摘要对比，一致说明这个内容就是原服务器提供的，由证书说明了服务器的身份\n\n\n\n\n# 混合加密\n\n\n\n对称加密——“加密”和“解密”使用【相同的】密钥\n\n> a发给b的文件需要加密，a用锁锁住文件发给b，然后再把钥匙发给b，b拿到钥匙和文件，解锁\n\n非对称加密——加密 和 解密 使用不同的 密钥 (消耗大)\n\n> a发给b的文件需要加密，b把自己的锁发给a，a锁好后把文件发给b，b的钥匙一直都在自己手上，然后用自己的钥匙（私钥）解自己的锁（公钥），不用担心钥匙在传递过程中被窃取\n\n公钥可以公开给任何人使用，私钥需要保密。公钥加密后只能用私钥解密，相反，私钥加密后只能用公钥解密\n\n\n\n\n\n通过混合加密的方式保证信息的机密性，解决了窃听的风险\n\nHTTPS 采用对称加密和非对称加密结合的「混合加密」方式：\n\n 1. 在通信建立前采用非对称加密的方式交换「欲主秘钥」，后续就不再使用非对称加密\n 2. 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据\n\n采用「混合加密」方式的原因：\n\n * 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换\n * 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢\n\n\n\n> 非对称加密本质是为了防止私钥加密数据外传\n\n\n\n🌰网站保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，无法破解密文\n\n上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客劫持\n\n因此，在上述加密的基础上仍需加上完整性、身份验证的特性，实现真正的安全——摘要算法\n\n\n# 摘要算法\n\n实现完整性，为数据生成独一无二的「指纹」，校验数据的完整性，解决了篡改的风险\n\n可以理解为一种特殊的压缩算法(生成hash值)，把任意长度数据 压缩 成固定长度，独一无二 的摘要 字符串，就像是给这段数据生成了一个数字 指纹\n\n\n\n客户端在发送明文之前通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据完整\n\n\n# 数字签名\n\n数字签名确定消息确实是由发送方签名并发出来，因为别人假冒不了发送方的签名\n\n> 私钥加密，公钥解密！\n\n如果想篡改，必须篡改原文信息后 私钥加密 才能得到原来的效果，可惜私钥不公开\n\n签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的\n\n\n\n和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥\n\n这时候就需要一个第三方——证书验证机构CA\n\n\n# 数字证书\n\n数字证书作用：\n\n 1. 服务器向浏览器证明自己的身份\n 2. 把公钥传给服务器\n\n客户端先向服务器端索要公钥，公钥加密信息，服务器收到密文后，用自己的私钥解密\n\n这就存在问题，如何保证公钥不被篡改？\n\n所以需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的\n\n\n\n 1. 服务器的运营人员向数字证书认证机构提出公开密钥的申请\n 2. 数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名\n 3. 分配这个已签名的公开密钥，将该公开密钥放入公钥证书绑定在一起\n 4. 服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信\n\n接到证书的客户端使用数字证书认证机构的公开密钥，对证书上的数字签名进行验证，一旦验证通过，则证明：\n\n * 认证服务器的公开密钥的是真实有效的数字证书认证机构\n * 服务器的公开密钥值得信赖\n\n\n# HTTPS中间人攻击\n\n客户端和服务器之间的桥梁、双向获取并且篡改信息\n\n\n\n标准回答\n\n攻击者通过与客户端和客户端的目标服务器同时建立连接，作为客户端和服务器的桥梁，处理双方的数据，整个会话期间的内容几乎完全被攻击者控制。攻击者可以拦截双方的会话并且插入新的数据内容\n\n加分回答\n\n中间人攻击的过程：\n\n 1. 本地请求被劫持，所有请求均发送到中间人服务器\n 2. 中间人服务器返回中间人自己的证书\n 3. 客户端创建随机数，通过中间人证书中的公钥加密 传送给中间人，凭随机数构造对称加密对传输内容加密传输\n 4. 中间人拥有客户端返回的随机数，可以对内容解密\n 5. 中间人以客户端的请求内容向真的服务器发送请求\n 6. 服务器通过建立的通道返回加密后的数据\n 7. 中间人对加密算法内容解密\n 8. 中间人对内容加密传输\n 9. 客户端通过和中间人建立的对称加密算法对返回数据解密\n\n缺少证书的验证，客户端完全不知道自己的网络被拦截，数据被中间人窃取\n\n\n# HTTPS一定安全？\n\nHTTPS 协议本身到目前为止没有任何漏洞，即使成功进行中间人攻击，本质是利用客户端漏洞（用户点击继续访问/被恶意导入伪造根证书），并不是 HTTPS 不够安全\n\n双向认证，客户端验证服务端身份，服务端也会验证客户端身份\n\n\n\n\n# 🌰 DNS 解析\n\n将主机名转换为IP地址\n\n>  1. 一个由分层的DNS服务器实现的分布式数据库\n>  2. 一个使得主机能查询分布式数据库的应用层协议\n\n\n# 域名\n\n\n\n例如www.xxx.com，www为三级域名、xxx为二级域名、com为顶级域名(TLD-top level domain)，系统为用户做了兼容，域名末尾的根域名.一般不需要输入\n\n\n\n还有电脑默认的本地域名服务器\n\n\n# 分布式\n\n世界上没有一台DNS服务器拥有因特网上所有主机的映射，每台DNS只负责部分映射\n\n\n# 本地DNS服务器\n\n本地DNS服务器起着代理的作用，负责将该请求转发到DNS服务器层次结构中\n\n\n# 递归、迭代查询\n\n * 递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案\n\n\n\n * 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求\n\n\n\n 1.  浏览器根据地址去缓存查找DNS解析记录，没有的话，浏览器查找OS中是否有该域名的DNS解析记录\n 2.  缓存过期或没有记录，浏览器向域名服务器发请求解析域名\n 3.  主机m向本地DNS服务器发送一个DNS查询报文，其中包含期待被转换的主机名a.b.com\n 4.  本地DNS~无法解析，则将该报文转发到根DNS~\n 5.  该根~注意到com前缀，便向本地DNS服务器返回com对应的顶级域名DNS服务器(TLD)的IP地址列表\n 6.  本地DNS~则向其中一台TLD服务器发送查询报文\n 7.  该TLD服务器注意到b.com前缀，于是向本地DNS服务器返回权威DNS服务器的IP地址\n 8.  本地DNS服务器又向其中一台权威DNS服务器发送查询报文\n 9.  终于，该权威服务器返回了a.b.com的IP地址\n 10. 本地DNS服务器将a.b.com跟IP地址的映射返回给主机m.n.com，m.n.com就可以用该IP向a.b.com发送请求啦\n\n\n\n主机向本地DNS服务器dns.n.com发出的查询是递归查询，这个查询是主机m.n.com以自己的名义向本地DNS服务器请求想要的IP映射，且本地DNS服务器直接返回映射结果到主机\n\n**后继查询为迭代查询，**包括本地DNS 服务器向根 DNS 服务器发送查询请求、本地 DNS 服务器向 TLD 服务器发送查询请求、本地 DNS 服务器向权威 DNS 服务器发送查询请求，所有的请求都是由本地 DNS 服务器发出，所有的响应都是直接返回给本地 DNS 服务器。\n\n解析结束，撒花✿✿ヽ(°▽°)ノ✿\n\n\n# 所有 DNS 查询都必须遵循递归 + 迭代 ？\n\n不是\n\n理论上，任何 DNS 查询既可以是递归的，也可以是迭代的\n\n> TLD 一定知道权威 DNS 服务器的 IP 地址吗？\n\n不一定，有时 TLD 只是知道中间的某个 DNS 服务器，再由这个中间 DNS 服务器去找到权威 DNS 服务器。这种时候，整个查询过程就需要更多的 DNS 报文\n\n\n# DNS 优化和应用\n\n\n# DNS缓存\n\n在一个 DNS 查询的过程中，当某一台 DNS 服务器接收到一个 DNS 应答（例如，包含某主机名到 IP 地址的映射）时，它就能够将映射缓存到本地，下次查询就可以直接用缓存\n\n有了缓存，大多数 DNS 查询都绕过了根 DNS 服务器，需要向根 DNS 服务器发起查询的请求很少\n\nDNS存在多级缓存，从离浏览器的距离**排序的话**，有以下几种:\n\n * 浏览器缓存\n\n * 系统缓存\n\n * 路由器缓存\n\n * ISP(运营商) DNS缓存(本地服务器缓存)\n\n * 根域名服务器缓存\n\n * 顶级域名服务器缓存\n\n * 主域名服务器缓存\n\n\n# 负载均衡\n\n(DNS重定向) DNS负载均衡技术——在DNS服务器中为同一个主机名配置多个IP地址\n\n简单说：用户发起的请求都指向调度服务器（反向代理服务器，如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，调度器等待实际服务器的HTTP响应，并将它反馈给用户\n\n# CDN(Content Delivery Network)\n\n利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容\n\n\n# dns-prefetch\n\nDNS Prefetch 是一种 DNS 预解析技术。当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验\n\n\n# 为啥使用UDP？\n\n因为UDP快！UDP的DNS协议只要一个请求一个应答就好\n\n\n# 解析不存在的域名？\n\n如果域名 不存在，浏览器还是会从DNS那里解析一下，发现自己 操作系统 本地缓存都没有，CDN也没有，根域名 顶级域名 权威域名 非权威域名都没有\n\nDNS解析失败，不会进入HTTP请求流程，不会有状态码错误，只会返回DNS解析错误信息\n\n\n# others\n\n\n# TCP/IP协议族？\n\nTCP/IP协议将**应用层，表示层，会话层合并为应用层，**物理层和数据链层合并为网络接口层\n\nTCP/IP协议指的是由 FTP SMTP TCP UDP IP ARP 等协议构成的协议集合\n\nTCP/IP，传输控制协议/网际协议\n\n * TCP（传输控制协议）\n\n一种面向连接的、可靠的、基于字节流的传输层通信协议\n\n * IP（网际协议）\n\n用于封包交换数据网络的协议\n\nTCP/IP协议指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，\n\n只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols）\n\n\n# TCP 协议保证页面文件完整送达浏览器?\n\n * IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息\n * UDP 头中除了目的端口，还有源端口号等信息\n * IP 负责把数据包送达目的主机\n * UDP 负责把数据包送达具体应用\n * 对于错误的数据包，UDP 不提供重发机制，只是丢弃当前的包，不能保证数据的可靠性，但是传输速度非常块\n * TCP 头除了包含了目标端口和本机端口号外，还提供用于排序的序列号，保证了数据完整传输，连接分为三个阶段：建立连接、传输数据和断开连接\n\n\n# ✔️ QUIC协议\n\nQUIC（Quick UDP Internet Connections）快速UDP互联网连接 ，基于UDP的传输层协议\n\n降低网络通信的延迟，工作在应用层\n\n可靠性：UDP是不可靠协议，但是QUIC在UDP的基础上做了些改造，使得它提供了和TCP类似的可靠性，提供了数据包重传、拥塞控制、调整传输节奏及其他一些TCP中存在的特性\n\n实现了无需、并发字节流：QUIC的单个数据流可以保证有序交付，但多个数据流之间可能乱序，这意味着单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与 发送方的发送顺序不同\n\n快速握手：QUIC提供0-RTT和1-RTT的连接建立\n\n使用TLS 1.3 传输层安全协议：与更早的TLS版本相比，TLS 1.3有很多优点，最主要原因是 其握手所花费的往返次数更低，能降低协议的延迟\n\n\n> # 特点\n\n * 0-RTT 建联(首次 建联除外)\n * 类似 TCP的可靠传输\n * 类似 TLS 的加密传输，支持完美前向安全\n * 用户空间的拥塞控制，最新的BBR算法\n * 支持h2的基于流的多路复用，但没有tcp的HOL问题\n * 前向纠错FEC\n * 类似MOTCP的Connection migration\n\n\n\n\n\n\n> # 无队头阻塞\n\n发送窗口和接收窗口的队头阻塞这两个问题的原因都是TCP 必须按序处理数据， TCP 层为了保证数据有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，否则就停留\n\nHTTP/2 抽象出 Stream 的概念，实现了 HTTP 并发传输，一个 Stream 代表 HTTP/1.1 里的请求和响应\n\n在 HTTP/2 连接上，不同 Stream 的帧可以乱序发送（因此可以并发不同的 Stream ），因为每个帧头部会携带 Stream ID 信息，接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须严格有序\n\n但是 HTTP/2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，当数据丢失，滑动窗口无法往前移动，会阻塞所有的 HTTP 请求，这属于 TCP 层队头阻塞\n\nQUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也可以在同一条连接上并发传输多个 Stream，Stream 可认为就是一条 HTTP 请求\n\nQUIC 有自己一套机制保证传输的可靠性。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，不存在队头阻塞问题。与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流会因此受影响\n\n但是 QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立，各自控制的滑动窗口\n\n\n\n\n> # 流量控制\n\nQUIC 基于 UDP 传输，而 UDP 没有流量控制，因此 QUIC 实现了自己的流量控制机制。不过，QUIC 的滑动窗口滑动的条件跟 TCP 有差别\n\n\n> # 更快的连接建立\n\n对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需分批次来握手，先 TCP 握手，再 TLS 握手\n\nHTTP/3 在传输数据前需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手是为确认双方的「连接 ID」，连接迁移基于连接 ID 实现\n\n但 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是QUIC 内部包含了 TLS，它在自己的帧携带 TLS 里的“记录”，再加上 QUIC 使用 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，下图：\n\n\n\n甚至，在第二次连接时，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果\n\n\n> # 连接迁移\n\n基于 TCP 传输协议的 HTTP 协议，通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，当移动设备的网络从 4G 切换到 WIFI 时， IP 地址变化，就必须断开连接，重新建立连接。建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本很高\n\nQUIC 协议没有用四元组的方式“绑定”连接，而是通过连接 ID标记通信的两个端点，客户端和服务器可以各自选择一组 ID 标记自己，即使移动设备的网络变化，导致 IP 地址变化，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”复用原连接，消除重连成本，没有丝毫卡顿感，达到了连接迁移的功能\n\n所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议\n\n\n\nQUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，会出现新的问题，因为有的网络设备会丢掉 UDP 包，而 QUIC 基于UDP 实现，如果网络设备无法识别 QUIC 包，就会将其当作 UDP包丢弃\n\n所以，HTTP/3 现在普及的进度非常缓慢，不知道未来 UDP 是否能够逆袭 TCP\n\n\n> # 优点\n\n具有SPDY的所有优点；\n\n0-RTT连接\n\n减少丢包\n\n前向纠错，减少重传时延\n\n自适应拥赛控制，减少重新连接\n\n相当于TLS加密\n\nQUIC主要目标是减少连接延迟，客户端第一次连接服务器时，QUIC只需要1RTT的延迟就可以建立可靠安全的连接，相对于TCP+TLS的1～3次RTT要更加快捷\n\n之后客户端可以在本地缓存加密的认证信息，再次与服务端建立连接时可以实现0RTT的连接建立延迟\n\nQUIC同时复用了HTTP2.0的多路复用（Multiplexing）功能，但由于QUIC基于UDP，避免了HTTP/2的Head-of-Line Bolcking问题\n\nQUIC基于UDP，运行在用户域而不是系统内核，使得QUIC协议可以快速部署和更新\n\n重传与恢复\n\n与TCP类似，QUIC每发送一个包后，都会等待回复一个确认包\n\n当丢包率超过协议的纠错阀值，会显示与隐式进行重传\n\n对于某些重要的数据包，在确认丢失前就会进行重传\n\n这样在网络中会有若干个相同包同时传输，任何一个成功抵达就完成了连接，降低丢包率\n\n接收方对于关键数据包的多次发送和普通数据包的超时重传，都采用相同的重复包处理机制\n\nQUIC在拥塞避免算法上还加入了心跳机包，减少丢包率\n\nQUIC使用FEC（前向纠错）恢复数据，FEC采用简单的异或方式\n\n每次发送一组数据，包含若干个数据包后，并对这些数据包依次做异或运算，最后结果作为一个FEC包再发送出去\n\n接收方收到一组数据后，根据数据包和FEC包即可以进行考验和纠错\n\n安全性\n\nQUIC对每个散装的UDP包都进行了加密和认证的保护，并且避免使用前向依赖（如CBC模式）的方法，这样每个UDP包可以独立地根据IV进行加密或者认证处理\n\nQUIC使用了两级密钥机制：初始密钥和会话密钥。初次连接时不加密，并协商初始密钥\n\n初始密钥协商完毕后再马上协商会话密钥，可以保证密钥的前向安全性，之后通信过程还可以实现密钥的更新\n\n接收方收到密钥更新时，需要用新旧两种密钥对数据进行解密，直到成功才会正式使用新密钥\n\n0RTT握手过程\n\nQUIC握手过程需要一次数据交互，0RTT即可以完成握手过程的密钥协商，比TLS相比效率提供了5倍\n\n初始密钥协商成果后，服务端提供一个临时随机数，双方根据这个随机数生成会话密钥',normalizedContent:'# osi七层模型\n\nosi将计算机网络体系结构分为7层\n\n 1. 物理层，通信信道上的原始比特流传输（比特流）\n\n 2. 数据链路层（定义数据的基本格式）（帧）\n\n 3. 网络层。主要协议是ip和arp（定义ip编址，定义路由功能，如不同设备间的数据转发）（包）\n\n 4. 传输层，为两台主机进程间通信提供服务，主要协议为tcp，udp（数据段）\n\n 5. 会话层，管理不同用户和进程之间的对话\n\n 6. 表示层，处理两个通信系统中交换信息的表示方式\n\n 7. 应用层，定义应用进程间交互规则，为不同的网络应用提供服务。域名系统 dns，支持万维网应用的 http 协议，电子邮件系统采用的 smtp协议（报文）\n\n简单网络管理协议（snmp） 是一种应用层协议\n\ndhcp（动态主机配置协议）是一个局域网的网络协议\n\n\n\n应用层发送http请求，到传输层通过三次握手建立tcp/ip连接，到网络层的ip寻址，再到数据链路层封装成帧，最后到物理层利用物理介质传输\n\n\n# 💚 http协议?\n\n超文本传输协议，hypertext transfer protocol\n\n * 超文本\n * 传输\n * 协议\n\n协议特点:\n\n * 「协」，代表必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东\n * 「议」，代表对参与者的行为约定和规范。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等\n\nhttp是一个计算机世界的协议，确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式\n\nhttp是一个双向协议！\n\n> 超文本：http传输的内容\n\n在http眼中，简单字符文字，图片，视频，压缩包等都算作 文本。超文本——超越了普通文本的文本，有超链接。html就是最常见的超文本\n\n> http是一个在计算机世界里专门在 两点 之间 传输 文字、图片、音频、视频 等 超文本 数据的 约定和规范\n\n那http是用于从互联网传输超文本到本地浏览器的协议，对吗?\n\n不对，因为也可以是服务器<--\x3e服务器，所以采用两点间的描述更准确\n\n\n# 特点\n\n支持客户/服务器模式\n\n简单快速：客户端请求服务时，只需要传送请求方法和路径。http协议简单，http服务器的程序规模小，通信速度快\n\n灵活：允许传输任意类型数据对象。正在传输的类型由content-type标记\n\n无状态：http协议无法根据之前的状态处理本次请求\n\n无连接：每次连接只能处理一个请求。服务器处理完请求，收到应答后即断开连接，节省时间\n\n\n# uri、url\n\n * urn或同时具备locators 和names特性\n * urn像一个人的名字，url像这个人的地址\n * 换句话说：urn确定东西的身份，url提供找到它的方式\n\nurl是uri的一种，不是所有的uri都是url；uri唯一标识身份，url给出访问机制（http/ftp/telnet等）\n\n\n# http首部字段?\n\naccept: 允许的媒体类型\nconnection: 连接选项，例如是否允许代理\nhost: 客户端发送请求时，指定服务器的域名\nif-none-match: 判断请求实体的etag是否包含在if-none-match中，如果包含，则返回304，使用缓存\nif-modified-since: 判断修改时间是否一致，如果一致，使用缓存\nif-match: 与if-none-match相反\nif-unmodified-since: 与if-modified-since相反\nreferer: 这个请求发起的源头\ncache-control: 缓存策略，如max-age:100\nconnection: 连接选项，例如是否允许代理\ncontent-encoding: 返回内容的编码，如gzip\netag: entity tag，实体标签，给每个实体生成一个单独的值，用于客户端缓存，与if-none-match配合使用\nexpires: 设置缓存过期时间，cache-control也会相应变化\nlast-modified: 最近修改时间，用于客户端缓存，与if-modified-since配合使用\npragma: 似乎和cache-control差不多，用于旧的浏览器\nserver: 服务器信息\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 🌈 状态码\n\n\n\n1xx informational 提示信息，请求正在处理 2xx success（成功）请求正常处理完毕\n\n * 200 请求成功\n * 201 请求成功且服务器创建了新的资源\n * 202 已接受，但未处理完成\n * 203 (非授权信息) 已成功处理，但返回信息可能来自另一个源\n * 204 成功处理，但没有返回内容\n * 205 重置内容 服务器成功执行请求，没有返回内容，与204不同，他需要请求者重置文档视图（比如，清除表单内容，重新输入）\n * **206 部分内容 服务器成功执行部分请求 ，**应用于 http 分块下载或断点续传，响应返回的 body 数据并不是资源的全部，也是处理成功的状态\n\n3xx redirection（重定向）资源位置变动\n\n * 300（多种选择）\n * 301 (permanently moved) 永久性重定向，请求的资源已不存在，需用新的 url 访问\n\n> 永久：域名、服务器、网站架构大幅度改变，如启用新域名、服务器切换到新机房、网站目录层次重构\n\n * 302 (**temporarily moved **) 临时重定向，请求的资源还在，暂时需要用另一个 url 来访问\n\n> 场景：系统维护，告诉用户一会儿再来。服务降级，双十一，将不重要的功能入口先关闭，保证核心服务正常运行\n\n> 301 和 302 都会在响应头里使用字段 location，指明后续要跳转的 url，浏览器自动重定向新的 url\n\n * 303 请求对应的资源存在另一个url，使用get获取资源\n\n * 304 ——缓存重定向， 不具有跳转含义，可继续使用缓存资源。 服务器只根据请求头中的 if-none-match 和 响应头中的 etag 比较判断是否返回 304，一致返回 304\n\n * 305 （使用代理）\n\n * 307 （临时重定向）类似于302， 但重定向后请求里的方法和实体不允许变动，含义比302明确\n\n4xx client error（客户端错误）\n\n * 400 不理解请求的语法（一般为参数错误）\n * 401 未授权\n * 403 禁止访问资源，可能是客户端权限不对\n * 404 资源不存在（错误 url）或找不到请求的网页，拒绝请求且不想说明理由\n * 405（方法禁用）\n * 406（不接受）\n * 407（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n * 408（请求超时）\n\n5xx server error 服务器处理请求出错\n\n * 500 internal serve error， 与 400 类型，笼统通用\n * 501 客户端请求的功能还不支持，类似“即将开业，敬请期待”\n * 502 bad gateway 通常是服务器作为网关或代理时返回，服务器自身工作正常，访问后端服务器发生错误\n * 503 service unavailable，类似“网络服务正忙，请稍后重试”\n * 504 gateway time-out，服务器在尝试加载网页或填写浏览器的另一个请求时未从其访问的另一台服务器收到响应\n\n> 502和504 区别？\n\n都和网关有关\n\n502 一般表现为我们自己写的 应用层服务 挂了，或者网关指定的上游 服务直接指错了地址，网关层无法接收响应\n\n504 一般是 应用层服务 超时，超过了 网关配置的时间，如查库操作耗时十分钟，超过了nginx配置的超时时间\n\n\n# http报文\n\n分为\n\n请求报文(请求行 请求头部 空行 请求体)\n\n响应报文(状态码 消息报头 响应正文)\n\n服务端收到请求后只返回响应头，不会发送相应内容\n\n请求和响应报文唯一区别：第一行用状态信息代替了请求信息\n\n\n# 请求头\n\nhttp报文一共有四种首部字段（请求头）：请求首部字段、响应首部字段、通用首部字段、实体首部字段\n\n\n# 请求首部字段\n\n\n# accept\n\naccept: text/html 浏览器可以接受服务器回发的类型\n\naccept: / 浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)\n\n\n# accept-charset\n\n通知服务器用户代理（浏览器）支持的字符集及字符集的相对优先顺序\n\naccept-charset： iso-8859-5, unicode-1-1;q=0.8\n\n\n1\n\n\n中的unicode-1-1;q=0.8是一个整体，表示unicode编码优先级为0.8，小于默认的iso编码优先级（默认q=1）；不要以为分号（；）为分割符，其实逗号（，）才是分割符\n\n\n# accept-encoding\n\n用户代理支持的内容编码及内容编码的优先级顺序。 可一次性指定多种内容编码\n\n常见的编码方式有：gzip、compress、deflate、identity\n\n\n# accept-language\n\n告知服务器浏览器能够接收的语言 ，及相对优先级\n\n\n# authorization\n\nweb认证信息\n\n\n# host\n\n客户端发送请求时，指定服务器的域名\n\nhost:www.1024nav.com 请求的主机名，允许多个域名同处一个ip地址，即虚拟主机。虚拟主机位于同一个ip上，使用首部字段 host 区分\n\n若服务器未设定主机名，host为空值\n\n有了 host ，可以将请求发往「同一台」服务器上的不同网站\n\n\n\n\n# if-match\n\n当if-match的字段值跟etag值匹配时，服务器才会接收请求\n\n\n# if-none-match\n\nif-none-match 的字段值与 etag值不一致时， 可处理该请求。 与 if-match 首部字段的作用相反\n\n\n# if-modified-since\n\n比较资源更新时间\n\n\n# if-unmodified-since\n\n\n# if-range\n\n附带条件之一。 告知服务器若指定的 if-range 字段值（etag 值或者时间） 和请求资源的 etag 值或时间一致时， 则作为范围请求处理。 反之， 则返回全体资源\n\n我们思考一下不使用首部字段if-range 发送请求的情况。 服务器端的资源如果更新， 那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412:precondition failed作为响应返回， 其目的是催促客户端再次发送请求。这样一来，与使用首部字段 if-range比起来，就需要花费两倍的功夫\n\n\n1\n\n\n> 形如if--xxx这种样式的请求首部字段，可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求\n\n\n# referer——正确referrer\n\nreferer: https://www.1024nav.com 当浏览器向web服务器发送请求的时候，一般会带上referer，告诉服务器我是从哪个页面链接过来的\n\n告知服务器 该页面的来源url，精确到详细页面地址\n\n\n# origin\n\n最初的请求从哪里发起(精确到端口)，比referer更注重隐私\n\n\n# user-agent\n\nuser-agent: user-agent: mozilla/5.0 (macintosh; intel mac os x 10_15_7) applewebkit/537.36 (khtml, like gecko) chrome/98.0.4758.80 safari/537.36，告诉http服务器，客户端使用操作系统和浏览器的名称和版本\n\n\n# 响应首部字段\n\n\n# accept-ranges\n\n是否接受字节范围请求\n\n\n# age\n\n告知客户端，源服务器在多久前创建了响应，单位为秒\n\n\n# etag\n\n告知客户端实体标识。一种将资源以字符串形式做唯一标识的方式。服务器为每份资源分配对应的 etag值 资源更新时，etag 更新。生成 etag 时，没有统一的算法规则，仅由服务器分配\n\n\n# location\n\n将响应接收方引导至某个与请求 uri 位置不同的资源\n\n该字段配合 3xx ： redirection 的响应， 提供重定向的uri\n\n浏览器收到301/302报文，检查响应头中是否有location。若有，则提取出uri并发出新的请求，相当于 自动点击这个链接\n\n\n# proxy-authenticate\n\n代理服务器对客户端的认证信息\n\n\n# retry-after\n\n对再次发起请求的时机要求\n\n\n# server\n\nhttp服务器的安装信息\n\n\n# vary\n\n代理服务器缓存的管理信息\n\ncors 和缓存 如果服务器未使用“*”，而是指定了一个域，为了向客户端表明服务器的返回会根据origin请求头而有所不同，必须在vary响应头中包含origin\n\naccess-control-allow-origin: https://developer.mozilla.org\nvary: origin\n\n\n1\n2\n\n\n\n# www-authenticate\n\n认证信息\n\n\n# 通用首部字段\n\n\n# cache-control(http1.1）\n\nprivate ：默认， 只能作为私有缓存，不能用户间共享\n\npublic 响应会被缓存，向任意方提供响应的缓存\n\nmust-revalidate 可缓存但必须再向源服务器进行确认\n\n:no-cache 缓存前必须确认其有效性， 该指令还是会使用缓存，只不过使用前要确认其新鲜程度（协商缓存）\n\n: max-age=31536000 设置缓存最大的有效时间，单位是秒\n\n:no-store 真正的所有内容都不缓存\n\n\n# connection\n\n客户端要求服务器使用 tcp 持久连接，以便其他请求复用\n\nhttp 对 tcp 连接的使用，分为两种方式：“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“keep-alive”或“persistent connection”，一个 tcp 连接从头用到尾）\n\n两个作用：\n\n * 控制不再转发给代理的首部字段\n * 管理持久连接\n\nconnection: keep-alive 一个网页打开后，客户端和服务器之间用于传输http数据的tcp连接不会关闭，如果客户端再次访问这个服务器上的网页，继续使用这一条已经建立的连接\n\nconnection: close 代表一个request完成后，客户端和服务器之间用于传输http数据的tcp连接会关闭， 当客户端再次发送request，需要重新建立连接\n\n\n# date\n\n\n# transfer-encoding\n\n\n# upgrade\n\n\n# via\n\n追踪客户端与服务器之间的请求和响应报文的传输路径。(各个代理服务器会往via首部添加自身服务器的信息)\n\n\n# range（用于断点续传\n\nrange:bytes=0-5 指定第一个字节的位置和最后一个字节的位置。告诉服务器自己想取对象的哪部分\n\n\n# 实体首部字段\n\n是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息\n\n\n# allow\n\n\n# content-encoding\n\n说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式\n\n\n\n\n# content-language\n\n\n# content-length\n\n本次回应的数据长度\n\n\n# content-location\n\n\n# content-md5\n\n\n# content-rage\n\n\n# content-type\n\n告诉客户端，本次媒体资源格式，请求头则代表请求体资源类型；响应头则代表响应体资源类型\n\ncontent-type: text/html; charset=utf-8;\ncontent-type: multipart/form-data;\n\n\n1\n2\n\n\n\n\n\n# expires\n\n将资源失效的日期告知客户端。缓存服务器（代理服务器）在接收到含有首部字段 expires的响应后，以缓存来应答请求，在expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源\n\n源服务器不希望缓存服务器对资源缓存时， 最好在 expires 字段内写入与首部字段 date 相同的时间值\n\n但是，当首部字段cache-control 有指定 max-age 指令时，比起首部字段 expires，会优先处理 max-age指令\n\n\n# last-modified\n\n指明资源最终修改的时间。 与请求头if-modified-since是一对\n\n\n# cookie\n\n可校验 cookie 的有效期，及发送方的域、路径、协议等信息，所以正规发布的 cookie 内的数据不会因来自其他web 站点和攻击者的攻击而泄露\n\n\n# set-cookie\n\n当服务器准备开始管理客户端的状态时，会事先告知各种信息。\n\nset-cookie: status=enable; expires=tue, 05 jul 2011 07:26:31 gmt; path\n\n\n1\n\n\ncookie字段\n\n属性              作用\nname=value      赋值cookie的名称和值\nexpires=date    cookie有效期\npath=path       限制指定的cookie的发送范围的文件目录，默认为当前\ndomain=domain   限制cookie生效的域名，默认为创建cookie的服务域名\nhttponly        不能通过 js 访问 cookie，减少 xss 攻击\nsecure          只能在协议为 https 的请求中携带\nsamesite        浏览器不能在跨域请求中携带 cookie，减少 csrf 攻击\n\n * expires\n\n指定 cookie 有效期。省略 expires 属性时，其有效期仅限于维持浏览器会话（session）时间段内\n\n * domain\n\ncookie作用域\n\n比如，指定 .example.com 后，除 .example.com 以外， www.example.com或 www2.example.com等子域名都可以访问cookie\n\n * secure\n\n限制 web 页面仅在 https 安全连接时，才可以发送 cookie\n\nset-cookie: name=value; secure\n\n\n1\n\n\n以上例子仅当在https://www.example.com/（https）安全连接的情况下才会进行cookie 的回收\n\n当省略 secure 属性时，不论 http还是 https，都会对 cookie 进行回收\n\n * httponly\n\n禁止js脚本访问 cookie\n\nset-cookie: name=value; httponly\n\n\n1\n\n * samesite\n\n是否允许跨域时携带cookie\n\nstrict：任何情况都不允许作为第三方cookie\n\nlax：宽松模式，只能在请求方法为get且请求改变了当前页面或打开新的页面时，允许cookie跨域访问\n\nnone：默认模式，请求自动携带cookie\n\n\n# cookie 请求首部字段\n\n告知服务器，当客户端想获得 http状态管理支持时， 会在请求中包含从服务器接收到的 cookie。 接收到多个cookie 时，同样可以以多个 cookie形式发送。\n\ncookie: status=enable\n\n\n1\n\n\n\n# 请求报文\n\n请求头header细分为\n\n * 请求行\n\n * 请求头\n\nheader包括\n\n 1. 请求方法\n 2. 协议\n 3. 目标url\n\n请求体body，包括请求的内容\n\n\n\n\n# 响应报文\n\n响应行\n\n响应头\n\n响应体\n\n\n\n\n# ✔️ 三次握手\n\n>  1. 建立连接。服务端 初始化创建连接，确认接收后的状态为syn_receive。客户端等待状态为syn_send\n>  2. 收到了客户端的syn，此时服务器处于syn_recd状态\n>  3. 客户端收到服务端的syn/ack数据包后，发送标有ack的数据包。ack=y+1，seq=x+1，作为应答。客户端和服务器端状态变化为established\n\nack(acknowledge number 确认序列号)——32位，确认接收对方的数据，ack 为 1 时该确认序列号字段才有效——解决不丢包的问题\n\nseq(sequence number 序列号)——32位，标识发送数据，连接请求报文段，客户端进入syn_sent，等待服务器确认，发送自己的数据，确保数据通信有序性\n\nsyn(synchronous)——同步序列号，发起一个新连接**(带有syn的过程包不带数据)，第三次握手可携带数据)，消耗一个序号**。syn 标志位和 ack 标志位搭配使用，当连接请求时，syn=1，ack=0连接被响应时，syn=1，ack=1\n\nack(acknowledgement)——标志位，应答确认序号有效，我接收到的信息确实是你所发送的信息。发送方到接收方通道没问题\n\nsyn+ack（验证接收方到发送方通道）——双方通信无误必须是两者互相发送消息都无误\n\n\n\n\n# 为啥3次握手？\n\n> 本质是，信道不可靠，但是通信双方需要就某个问题达成一致。三次通信是理论上最小值，3次握手不是tcp本身的要求，而是为了满足“在不可靠信道上可靠传输信息”这一需求导致的。为了判断双方的接收和发送能力是否正常\n\n> 红蓝军 问题，由于信息可能丢失，为了保证信息传达准确性，我们需多次传递，通信次数越多，信息到达概率越大。tcp 采用三次握手，尽可能可靠\n\n防止已失效的连接请求报文段突然又传送到了服务端，产生错误\n\n在谢希仁著《计算机网络》书中同时举了一个例子，如下：\n\n> “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。\n> \n> 本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。\n> \n> 假设不采用“三次握手”，只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。\n> \n> 但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”\n\n握手次数不过是提高“它是可用的”这个结论的可信度\n\n四次握手没必要\n\n\n# ✅ 四次挥手\n\n【四次挥手是2+2】留下扫尾工作的时间\n\n客户端和服务端均能主动关闭连接\n\nfin=1 ack=1 表示tcp连接释放报文段\n\n\n1\n\n 1. tcp是全双工模式，当主机1发出fin连接释放报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；并停止再发送数据，主动关闭tcp连接。进入fin_wait1(终止等待状态1)，等待服务器确认\n\n但这个时候主机1还是可接受来自主机2的数据\n\n 2. 当主机2返回ack报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1；**服务器：我请求报文接收完了，准备关闭，你也准备吧。**此时服务端处于clse_wait状态，即服务端收到连接释放报文段后即发出确认报文段。此时的tcp处于半关闭状态\n\n 3. 当主机2也发送了fin报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，**我也没有数据要发送了，**之后彼此就会愉快的中断这次tcp连接。服务端发送连接释放报文段，进入last_ack状态，等待客户端确认\n\n 4. 客户端向服务器发送报文段，ack+seq+ack，进入等待time_wait状态。需要过一阵子以确保服务端收到自己的ack报文段后才进入clsed状态，服务器收到报文段后关闭连接，发起方等待一段时间后没有回复，正常关闭。浏览器：我响应报文接收完，准备关闭了，你也准备关闭吧\n\n如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化\n\n * fin_wait_1: fin_wait_1和fin_wait_2状态表示等待对方的fin报文\n\n区别是：fin_wait_1状态是当socket在established状态时，它想主动关闭连接，向对方发送了fin报文，此时该socket即进入到fin_wait_1状态（等待对方的ack报文）\n\n而当对方回应ack报文后，则进入到fin_wait_2状态，在实际正常情况下，无论对方何种情况，都应马上回应ack报文，所以fin_wait_1状态一般比较难见到，而fin_wait_2状态常常可以用netstat看到（主动方——a）\n\n * fin_wait_2：上面已经详细解释了这种状态，实际上fin_wait_2状态下的socket，表示半连接，即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ack信息)，稍后再关闭连接（主动方）\n * close_wait：表示在等待关闭\n\n怎么理解呢？\n\n当对方close一个socket后发送fin报文给自己，你系统毫无疑问回应一个ack报文给对方，此时则进入到close_wait状态。接下来，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有，那么你也可以 close这个socket，发送fin报文给对方，即关闭连接。所以在close_wait状态下，需要完成的事情是等待你去关闭连接（被动方）\n\n * last_ack: 是被动关闭一方在发送fin报文后，最后等待对方的ack报文。当收到ack报文后，即可以进入到closed可用状态（被动方）\n * time_wait: 表示收到了对方的fin报文，并发送出了ack报文，等2msl后即可回到closed可用状态了。如果fin_wait_1状态下，收到了对方同时带fin标志和ack标志的报文时，可以直接进入到time_wait状态**，而无须经过fin_wait_2状态（主动方）**\n * closed: 连接中断\n\n\n# 2msl 等待状态？\n\ntime_wait状态也为2msl等待状态。报文段最大生存时间 msl（maximum segment lifetime）\n\n 1. 保证客户端发送的最后一个ack报文段能够到达server\n 2. 防止“已失效的连接请求报文段”出现在本连接中\n\n客户端发送完最后一个ack报文段后，再经过 2msl，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段\n\n> client端接到第三次挥手的时候，client端不会马上closed，而是等待两个msl再关闭\n> \n> 因为如果client端发送的第四次挥手server端没收到，server可能会重传第三次挥手的包，并且依旧在time_wait状态\n> \n> 这时 如果client直接关闭请求，会导致server端一直重传；有了2msl之后（也就是等一个来回），就可以接收到server端重传的挥手报文，重新进行第四次挥手\n\n为什么是两个msl，一个不可以吗\n\n> 因为server端检测到丢包就需要一个msl，还没等server端重传，client端就closed了\n\n\n# 为啥4次挥手？\n\n当服务端收到客户端的syn连接请求报文后，可以直接发送syn+ack报文。ack 用来 应答，syn 用来 同步\n\n关闭连接时，服务器收到对方的fin报文时，仅表示对方不再发送数据了，但还能接收数据，而自己也未必不发送数据了，所以服务器可立即关闭，也可发送数据，再发送fin报文表示同意关闭连接，因此，服务器ack和fin一般分开发送\n\n\n# syn攻击？\n\n服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器 容易受到syn洪泛攻击\n\nsyn攻击：client在短时间内伪造大量不存在的ip地址，并向server不断地发 送syn包，server回复确认包，并等待client确认，由于源地址不存在，因此server需要不断重发直至超时，这些伪造的syn包将长时间占用未连接队列，导致正常的syn请求因为队列满而被丢弃，引起网络拥塞甚至系统瘫痪\n\n常见的防御 syn 攻击的方法\n\n 1. 缩短超时（syn timeout）时间\n 2. 增加最大半连接数\n 3. 过滤网关防护\n 4. syn cookies技术\n\n\n# 啥时候用tcp/udp？\n\n实时性要求比较高，选择udp，比如游戏，媒体通信和实时视频流，即出现传输错误也可以容忍\n\n其他大部分情况，都是用tcp，因为要求传输内容可靠，不出现丢失\n\n\n# ⚠️tcp、udp？\n\ntcp：transmission control protocol， 传输控制协议\n\nudp ：user datagram protocol 用户数据报协议\n\n\n\n\n# tcp\n\n 1. 面向连接\n 2. 可靠交付\n 3. 无差错，不丢失，无重复，按序到达\n 4. 面向字节流\n 5. 首部20字节，开销大\n 6. 只能点对点全双工可靠信道\n\n\n\n\n# tcp头部很大，具体有哪些报文信息？\n\n\n# udp\n\n 1. 无连接(利用ip提供面向无连接通信服务)\n 2. 尽最大努力交付，不可靠(传输途中出现丢包，不负责重发；当包的到达顺序乱序，不纠正)\n 3. 面向报文\n 4. 无拥塞控制(按照应用程序发来的数据原样发送，即使出现网络拥堵，也不会进行流量控制等避免拥塞的行为)\n 5. 支持一对一，一对多，多对一和多对多的交互通信\n 6. 首部开销小，8字节\n 7. 实时性好，效率高\n 8. 不可靠信道\n 9. 无论应用层交给udp多长的报文，统统发送，一次发送一个报文\n\n简言之：\n\n * tcp向上层提供面向连接的可靠服务，建立连接3次握手、断开连接4次挥手；udp向上层提供无连接不可靠服务，发送端只负责将数据发送到网络，接收端从消息队列读取\n * udp没有tcp传输来的准确，但是在很多实时性要求高的地方有所作为\n * 对数据准确性要求高，速度可以相对较慢，可选用tcp\n * tcp面向字节流，将应用层报文看成一串无结构的字节流，分解为多个tcp报文段传输，在目的站重新装配。udp面向报文，不会拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文上传上层应用\n\n\n# 应用\n\n\n# 🌰 tcp为什么可靠？\n\n可靠：保证接收方进程从缓存区读出的字节流和发送方发出的字节流完全一样\n\n实现可靠传输的机制有 校验、序号、确认和重传\n\n\n# 数据分片和排序\n\ntcp会按 最大传输单元(mtu)合理分片，接收方缓存未按序到达的数据， 重新排序后交给应用层\n\nudp：ip数据报大于1500字节，大于mtu。这时发送方的ip层需要分片，把数据报分成若干片，每一片都小于mtu\n\n而接收方ip层则需要重组 数据报\n\n由于udp的特性，某一片数据丢失时，接收方无法重组数据报，导致丢弃整个udp数据报\n\n\n# 首部校验\n\n接收端用crc检验整个报文段有无损坏\n\n增加伪首部，反码求和\n\ntcp协议规定，tcp的首部字段中有一个字段是校验和，发送方将伪首部、tcp首部、tcp数据使用 累加和校验 方式计算出一个数字，存放在首部的校验和字段里，接收者收到tcp包后重复这个过程，将计算出的校验和 和接收到的首部中的 校验和比较，如果不一致则 说明数据在传输过程中出错。\n\n但这个机制能够保证检查出一切错误吗？显然不能。\n\n因为这种校验方式是累加和，将一系列的数字（tcp协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是小学生都知道a+b=b+a，假如在传输的过程中有前后两个16比特位的数据前后颠倒了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），导致 校验和的计算结果和颠倒之前一样，接收端肯定无法检查出这是错误的数据\n\n解决方案\n\n传输之前先使用md5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据进行md5加密，如果加密结果和摘要一致，则认为没有问题\n\n\n# 确认和重传（重传机制）\n\ntcp面向字节流，一个字节一个序号\n\nack信号，发送方按照顺序给要发送的数据包的每个字节都标上号\n\ntcp实现可靠传输的方式之一，通过 序列号和确认应答 实现\n\n基于序号机制，接收方接收到某个报文段后，发送给发送方一个确认号，采用累计确认法，表示已收到消息\n\n保证因链路故障未能到达数据能被 多次重发\n\n不一定能如上图那么顺利进行正常的数据传输，万一在传输过程中丢失了呢？\n\ntcp针对数据包丢失的情况——重传机制\n\n常见的重传机制\n\n * 超时重传\n * 快速重传\n * sack\n * d-sack\n\n\n# 超时重传\n\n发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ack 确认应答报文，重发该数据\n\n两种情况发生超时重传：\n\n 1. 数据包 丢失\n 2. 确认应答丢失\n\n> 超时时间该设置为多少？\n\nrtt（round-trip time 往返时延）：数据发送时刻到接收到确认的时刻的差值\n\nrto (retransmission timeout超时重传时间)\n\n假设在重传的情况下，超时时间 rto 「较长或较短」时，发生什么事情？\n\n 1. 超时时间 rto 较大，重发就慢，丢了老半天才重发，没有效率，性能差\n\n 2. 超时时间 rto 较小时，导致可能没有丢就重发，于是重发就快，增加网络拥塞，导致更多的超时，更多的超时导致更多的重发\n\n超时重传时间rto的值应该略大于报文往返rtt的值。且rto动态变化\n\n超时触发重传存在的问题，超时周期可能相对较长，可以以更快捷的方式操作吗？——快速重传\n\n\n# 快速重传\n\n发送方收到冗余确认，判断报文段丢失\n\n不以时间为驱动，以数据驱动重传\n\n上图，发送方发出了 1，2，3，4，5 份数据：\n\n * seq1先到了，于是ack回2\n\n * 结果2没有到，3到了，所以ack还是回2\n\n * 后面的4和5都到了，但是ack还是回2，因为2号包没收到\n\n * 发送端收到了3个ack=2的确认，知道2没有收到，在定时器过期前，重传丢失的2\n\n * 最后，接收到了2，因为此时3 4 5包都收到了，所以ack回6\n\n快速重传的工作方式就是当收到3个相同的ack报文时，在定时器过期之前，重传丢失的报文段\n\n面临的问题：重传的时候，是重传之前的一个，还是重传所有？\n\n对以上的例子，重传2？还是重传2 3 4 5 呢？因为发送端并不清楚这三个连续的ack 2是谁传回来的\n\n所以，有了sack方法——解决不知道该重传哪些tcp报文\n\n\n# sack-selective\n\n（ selective acknowledgment 选择性确认）\n\n这种方式需要在 tcp 头部「选项」字段里加一个 sack ，它可以将缓存的地图发送给发送方，这样发送方就知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据\n\n下图，发送方收到了三次同样的 ack 确认报文，于是触发快速重发机制，通过 sack 信息发现只有 200~299 这段数据丢失，重发时，就只选择这个 tcp 段重复发送\n\n如果要主持sack，必须双方都要支持\n\n\n# d-sack-duplicate\n\nduplicate sack 又称 d-sack，其使用了 sack 告诉「发送方」有哪些数据被重复接收了\n\n# 丢包\n\n * 「接收方」发给「发送方」的两个 ack 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）\n\n * 「接收方」发现数据重复收到，于是回了一个 sack = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收，因为 ack 都到了 4000 了，意味着 4000 之前的所有数据都已收到，所以这个 sack 就代表着 d-sack\n\n * 这样「发送方」就知道了，数据没有丢，是「接收方」的 ack 确认报文丢了\n\n# 网络延时\n\n * 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 ack 1500 的确认报文\n * 后面报文到达的三个相同的 ack 确认报文，触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」\n * 所以「接收方」回了一个 sack=1000~1500，因为 ack 已经到了 3000，所以这个 sack 是 d-sack，表示收到了重复的包\n * 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ack 包丢了，而是因为网络延迟\n\n# 好处\n\n 1. 让「发送方」知道，是发出去的包丢了，还是接收方回应的 ack 包丢了\n 2. 知道是不是「发送方」的数据包被网络延迟了\n 3. 知道网络中是不是把「发送方」的数据包给复制了\n\n\n# 流量控制\n\n发送方不能无脑发送数据给接收方，需要考虑接收方处理能力\n\n如果一直发数据给对方，处理不过来会触发重发机制，浪费网络流量\n\n流量控制——为了控制发送方发送速率，保证接收方来得及接收\n\ntcp 提供一种机制可让「发送方」根据「接收方」的实际接收能力控制发送的数据量——流量控制\n\n\n# 保证次序？\n\n“停止等待”\n\n\n\n发送方发送一个包1，这时候接收方确认包1。发送包2，确认包2。\n\n这样一直下去，直到完全发送完所有数据，结束。就解决了丢包，出错，乱序等一些情况！\n\n同时也存在问题。问题：吞吐量非常低。我们发完包1，一定要等确认包1.我们才能发送第二个包\n\n\n# 提高吞吐量？\n\n两个包一起发送，一起确认。可以看出我们改进的方案比之前的好很多，所花的时间只是一个来回的时间\n\n\n# 实现最优解？\n\n> 每次需要发多少个包过去呢？发多少是最合适？\n\n我们可不可以把第一个包和第二个包发过去后，收到第一个确认包就把第三个包发过去呢？ 而不是去等到第二个包的确认包才去发第三个包——"滑动窗口"的实现\n\n为每个数据包确认应答的缺点：包往返时间越长，网络吞吐量越低\n\n\n# 滑动窗口\n\n你一句我一句，效率低。如果你说完一句话，我没有及时回复，你不是要干等着我做完其他事，我回复你，你才能说下一句话，显然不现实\n\n因此，这种传输方式的缺点——数据包的往返时间越长，通信效率越低\n\n为解决这个问题，tcp引入了窗口这个概念，即使往返时间较长，也不会降低网络通信效率\n\n窗口大小：无需等待确认应答，可以继续发送数据的最大值\n\n实际上是os开辟的一个缓存空间，发送方在等到确认应答返回前，必须在缓冲区保留已发送的数据。若按期收到确认应答，此时数据可以从缓存区中清除\n\n假设窗口大小为 3 个 tcp 段，那么发送方就可以「连续发送」 3 个 tcp 段，中途若有 ack 丢失，可以通过「下一个确认应答进行确认」。下图：\n\n只要发送方收到了ack700的确认应答，意味着700之前的所有数据接收方都收到了——累计确认(累计应答)\n\n> 窗口大小谁决定？\n\ntcp 头里有一个字段 window，就是窗口大小\n\n这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端根据这个接收端的处理能力发送数据，而不会导致接收端处理不过来\n\n因此，通常窗口大小由接收方的窗口大小决定\n\n发送方发送的数据不能超过接收方窗口大小，否则接收方无法正常接收数据\n\n> 发送方的滑动窗口\n\n我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：\n\n\n\n在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小为 0 ，表明可用窗口耗尽，没收到 ack 确认之前无法继续发送数据\n\n\n\n在下图，当收到之前发送的数据 32~36 字节的 ack 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52~56 字节又变成了可用窗口，那么后续也就可以发送 52~56 这 5 个字节的数据了\n\n\n\n> 接收方的滑动窗口\n\n接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：\n\n\n\n接收窗口和发送窗口的大小是相等的吗？\n\n并不完全相等，接收窗口大小约等于发送窗口的大小\n\n因为滑动窗口不是一成不变。比如，当接收方的应用进程读取数据的速度非常快的话，这样接收窗口可以很快空缺出来。那么新的接收窗口大小，是通过 tcp 报文中的 windows 字段来告诉发送方。这个传输过程存在时延，所以接收窗口和发送窗口是约等于的关系\n\n\n\n# 正常情况\n\n\n\n4号包已经被对方接收到，窗口往右移一格。我们把11号包读进缓存。进入“待发送”的状态。接下来的操作就是一样的了，确认包后，窗口继续往后移，将未发送的包读进缓存，把“待发送”的包状态变为“已发送”\n\n# 丢包情况\n\n可能我们包发过去，但是对方的ack丢了\n\n也有可能是我们的包并没有发过去\n\n站在发送方的角度看就是我们并没有收到ack\n\n\n\n因此，我们会一直等待ack，若一直等不到，我们也会把读进缓存的待发送的包也一起发过去。但是，这时我们的窗口已经满了，就不能把12号包读进来，而是始终在等待5号包的ack\n\n> 若我们这ack始终不来，咋办？\n\n# 超时重传\n\nack需要按顺序来，必须等到5的ack收到了，才会把6-11的ack发送过去。酱紫也保证了滑动窗口的顺序\n\n\n\n此时，5号包已经接收到了ack，后面的6-8号包也已经发送过去已ack。窗口继续向后移动\n\n\n\nrwnd表示receiver window\n\n> 该协议允许发送方在停止并等待确认前发送多个数据分组。发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量\n\n滑动窗口大小——接收方还有多大的缓冲区可以用于接收数据，用以 解决发送速率过快导致接收方不能接收 的问题。发送方 通过滑动窗口大小确定应该发送多少字节数据。当滑动窗口为 0 时，发送方一般不再发送数据报，两种情况除外，一种情况是可以发送紧急数据\n\n发送方a的发送窗口表示：在没有收到b确认的情况下，a可以连续把窗口内的数据都发送出去，凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用\n\n发送窗口的位置由窗口前沿和后沿位置共同确定：\n\n * 后沿不动——没有收到新的确认\n * 后沿前移——收到了新的确认\n * 前沿前移——收到新的确认，或者接收方的窗口变大\n * 前沿不动——没有收到新的确认，接收方的窗口大小不变，或者收到了新的确认，但接收方的窗口变小\n\n 1. 发送端只能发送接收端指定的报文大小，超过了则暂停发送信息\n\n 2. 滑动窗口由窗口值控制传输流量的大小；利用重发机制解决发送端消息丢失；利用 持续计数器和探测报文解决接收端发送的窗口值丢失导致的无限等待情况\n\n\n# 拥塞控制\n\n流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络中发生了什么\n\n一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵\n\n网络拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 tcp 会重传数据，但是一重传就会导致网络的负担更重，导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....\n\n拥塞控制，避免「发送方」的数据填满整个网络\n\n为了在「发送方」调节所要发送数据的量，定义一个叫做「拥塞窗口」的概念\n\nrtt：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定\n\n对于拥塞控制来说，tcp 每条连接都需要维护两个核心状态:\n\n * 拥塞窗口（congestion window，cwnd**） 把一次性能够发送的数据包多少的窗口**称之为拥塞窗口\n\n拥塞窗口 cwnd 变化规则：\n\n>  * 只要网络中没有出现拥塞，cwnd 增大\n>  * 网络中出现了拥塞，cwnd 减小\n\n * 慢启动阈值（slow start threshold，ssthresh）\n\n> 怎么知道当前网络是否出现了拥塞？\n\n只要「发送方」没有在规定时间内接收到 ack 应答报文，就是发生了超时重传，认为网络出现了拥塞\n\n> 拥塞控制的控制算法？\n\n拥塞控制主要是四个算法：\n\n * 慢启动\n * 拥塞避免\n * 拥塞发生\n * 快速恢复\n\n> mtu 最大传输单元\n\n> mss(最大消息长度)：为tcp数据包每次传输的最大数据分段大小，一般由发送端向对端tcp通知在每个分节能发送的最大tcp数据\n\n\n# 慢开始\n\ntcp 刚建立连接完成后，首先有个慢启动的过程，意思就是一点一点提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？\n\n慢启动的算法记住一个规则就行：当发送方每收到一个 ack，拥塞窗口 cwnd 的大小就会加 1\n\n发包的个数是指数性的增长\n\n有一个叫慢启动门限 ssthresh （slow start threshold）变量\n\n * cwnd < ssthresh 时，使用慢启动算法\n * cwnd >= ssthresh 时，使用「拥塞避免算法」\n\n 1. 连接建好的开始，初始化拥塞窗口cwnd大小为1，表明可以传一个mss大小的数据\n\n 2. 每收到一个ack，cwnd大小加一，线性上升\n\n 3. 每过了一个往返延迟时间rtt(round-trip time)，cwnd大小翻倍，乘以2，指数让升\n\n 4. 还有一个ssthresh（slow start threshold），是一个上限，cwnd >= ssthresh时，进入“拥塞避免算法”\n\n\n# 拥塞避免\n\n拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 进入拥塞避免\n\n过了慢启动阈值后，拥塞避免算法可避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值\n\n进入拥塞避免算法后，规则是：每当收到一个 ack 时，cwnd 增加 1/cwnd\n\n一般来说，tcp拥塞控制默认 认为网络丢包是 由于网络拥塞导致，所以一般 tcp拥塞控制算法以丢包 作为网络进入拥塞状态的信号。对丢包有两种判定方式，\n\n一种是超时重传rto[retransmission timeout]超时\n\n另一个是收到三个重复确认ack\n\n超时重传是tcp协议保证数据可靠性的一个重要机制，原理是在发送一个数据以后开启一个计时 器，一定时间内如果没有得到发送数据报的ack报文，就重新发送数据，直到发送成功\n\n但如果发送端接收到3个以上的重复ack，tcp意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫超时 重传rto[retransmission timeout]超时，tcp会重传数据包。tcp认为这种情况比较糟糕，反应也比较强烈：\n\n发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2\n\ncwnd重置为1 进入慢启动过程是早期的处理办法，但是一丢包就一切重来，cwnd又重置为1，不利于网络数据的稳定传递\n\n就这么一直增长后，网络慢慢进入了拥塞的状况，就会出现丢包现象，这时就需要 重传 丢失的数据包\n\n当触发了重传机制，也就进入了「拥塞发生算法」\n\n\n# 拥塞发生\n\n当网络出现拥塞，会发生数据包重传，重传机制主要有两种：\n\n * 超时重传\n * 快速重传\n\n> 发生超时重传的拥塞发生算法\n\n发生了「超时重传」，就会使用拥塞发生算法\n\n这时，ssthresh 和 cwnd 的值会变化：\n\n * ssthresh 设为 cwnd/2\n * cwnd 重置为 1\n\n\n\n接着，重新开始慢启动，慢启动会突然减少数据流。这真是一旦「超时重传」，马上回到解放前。这种方式太激进了，反应很强烈，会造成网络卡顿\n\n就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。\n\n> 发生快速重传的拥塞发生算法\n\n还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ack，于是发送端就会快速地重传，不必等待超时再重传\n\ntcp 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：\n\n * cwnd = cwnd/2 ，也就是设置为原来的一半\n * ssthresh = cwnd\n * 进入快速恢复算法\n\n\n# 快速恢复\n\n快速重传和快速恢复算法一般同时使用，快速恢复算法认为，你还能收到 3 个重复 ack 说明网络也不那么糟糕，所以没有必要像 rto 超时那么强烈\n\n正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：\n\n * cwnd = cwnd/2 ，设置为原来的一半\n * ssthresh = cwnd\n\n然后，进入快速恢复算法：\n\n * 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）\n * 重传丢失的数据包\n * 如果再收到重复的 ack， cwnd 增加 1\n * 如果收到新数据的 ack 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ack 确认了新的数据，说明从 duplicated ack 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，即再次进入拥塞避免状态\n\n\n\n没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长\n\n\n# 流量控制和拥塞控制？\n\n流量控制：传输网络畅通但接收设备小容量\n\n拥塞控制：内部拥塞是大容量接收设备\n\n流量控制属于通信双方协商；拥塞控制涉及通信链路全局\n\n流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的tcp报文段中窗口值确定\n\n拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整\n\n\n# tcp 缺陷？\n\n * 升级 tcp 工作困难\n * tcp 建立连接的延迟\n * tcp 存在队头阻塞问题\n * 网络迁移需要重新建立 tcp 连接\n\n\n# 升级 tcp 工作困难\n\ntcp协议在内核中实现，应用程序只能使用不能修改，若想要升级tcp只能升级内核\n\n内核升级设计到底层软件和运行库的更新，我们的服务程序需要回归测试是否兼容新的内核版本，服务器的内核升级比较保守且缓慢\n\n\n# tcp 建立连接延迟\n\n基于tcp实现的应用协议，都需要先建立三次握手才能进行数据传输，比如http1.1/1.1、http/2、https\n\n大多数网站都是使用的https，tcp三次握手之后，还需要经过tls四次握手后，才能进行http数据的传输，一定程度增加了数据传输的延迟\n\n\n# tcp 存在队头阻塞问题\n\ntcp是字节流协议，tcp层必须保证收到的字节数据完整且有序，如果序列号较低的tcp段在网络传输中丢失，即使序列号较高的tcp段已经被接收，应用层也无法从内核中读取到这部分数据\n\nhttp/2多个请求是跑在一个tcp连接中的，当tcp丢包时，整个tcp都要等待重传，会阻塞该tcp连接中的所有请求，所以 http/2 队头阻塞问题就是tcp协议导致的\n\n\n\n\n# 网络迁移需重新建立 tcp 连接\n\n基于 tcp 传输协议的 http 协议，通过四元组（源 ip、源端口、目的 ip、目的端口）确定一条 tcp 连接\n\n\n\n当移动设备的网络从 4g 切换到 wifi 时，意味着 ip 地址变化了，就必须要断开连接，重新建立 tcp 连接\n\n建立连接的过程包含 tcp 三次握手和 tls 四次握手的时延，以及 tcp 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本很高\n\n\n# udp 实现可靠传输？\n\ntcp 天然支持可靠传输，为什么还需要基于 udp 实现可靠传输呢？这不是重复造轮子吗？\n\n\n# 通信数据转发程序\n\n\n# 代理\n\n代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时接收服务器返回的响应并转发给客户端\n\n基本行为——接收客户端发送的请求后转发给其他服务器。代理不改变请求url，直接发送给前方持有资源的目标服务器\n\n\n\n\n# 代理方法\n\n# 缓存\n\n代理转发响应时，缓存代理（caching proxy）预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回\n\n# 透明代理\n\n转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（transparent proxy）。反之，对报文内容进行加工的代理被称为非透明代理\n\n\n# 网关\n\n网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关\n\n\n\n\n# 隧道\n\n隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序\n\n\n\n\n# http请求方法\n\n方法        描述\nget       请求指定的页面信息，返回实体主体\nhead      类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头，确认uri的有效性及资源更新的日期时间等\npost      向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。post请求可能会导致新的资源的建立和/或已有资源的修改\nput       从客户端向服务器传送的数据取代指定的文档的内容\ndelete    请求服务器删除指定的页面\nconnect   http/1.1协议中预留给能够将连接改为管道方式的代理服务器\noptions   允许客户端查看服务器的性能；查询针对请求uri 指定的资源支持的方法\ntrace     回显服务器收到的请求，主要用于测试或诊断\n\n\n# options方法？\n\nbrowser自动发起\n\n获取当前url所支持的方法\n\n检查服务器性能\n\n\n# 💚 get、post\n\n\n# get\n\n**不能 传中文，会**乱码！！\n\n根据 rfc 规范，get 是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等\n\nget 请求的参数位置一般写在 url 中，url 规定只能支持 ascii，浏览器会对 url 的长度有限制（http协议本身对 url长度并没有做任何规定）\n\n传送的数据量较小，不能大于2kb\n\n\n# post\n\n根据 rfc 规范，post 是根据请求负荷（报文body）对指定的资源做出处理\n\npost 请求携带数据的位置一般写在报文 body 中，数据可以是任意格式，只要与服务端协商好，且浏览器不会对 body 大小做限制\n\n\n# 区别\n\n幂等：多次执行相同的操作，结果都相同\n\n安全：请求方法不会破坏服务器上的资源\n\n * 大多数浏览器限制url 2kb，大多数服务器处理 64 k url，get可带 body 但不保证可被接收\n * get产生一个tcp 数据包，post 产生2个——有争议！！这个根代码和tcp协议栈有关，和http 无关\n\nget： 浏览器一并发送 http header 和 data，服务器响应200\npost：浏览器先发送 header ，服务器响应100 continue ，browser再发送 data，响应200\n\n\n1\n2\n\n\n * 都是http请求方式，http 基于 tcp/ip ，没实质区别\n\n * 不携带参数时，最大区别是请求行不同\n   \n   1. get：get /uri http/1.1\n   2. post：post /uri http/1.1\n\n * get安全且幂等，可对数据缓存，缓存可以做到浏览器上（彻底避免浏览器发请求），也可以做到代理上（如nginx），可以保存为书签\n\n * post是新增或提交数据，会修改服务器资源，不安全，不幂等。浏览器一般不缓存post请求，也不能保存为书签\n\n * 从传输的角度来说，他俩都不安全，http是明文传输，只要在网络节点抓包就能完整获取数据报文，只有https才能加密安全\n\nget和post的区别本质上被浏览器/服务器限制，而不是http协议限制\n\n\n# get参数写法固定？\n\nrfc 并没规定 get 请求不能带 body 。理论上，任何请求都可以带 body 。只是因为 rfc 定义的 get 请求是获取资源，根据这个语义不需要用到 body\n\nurl 中的查询参数也不是 get 所独有，post 请求的 url 中也可以有参数\n\n解析报文过程：获取tcp数据，正则从数据获取header和body，提取参数，也可以自己约定参数写法，只要后端能够解析出来就行\n\n\n# post比get安全？\n\n如果「安全」放入概念是指信息是否会被泄漏的话，虽然 post 用 body 传输数据，get 用 url 传输，数据会在浏览器地址拦容易看到，但并不能说 get 不如 post 安全\n\nhttp 传输的内容都是明文，在浏览器地址拦看不到 post 提交的 body 数据，但只要抓个包就都能看到\n\n要避免传输过程中数据被窃取——使用 https 协议，所有 http 的数据都被加密传输\n\n\n# get长度限制？\n\nhtpp协议没有对body和url长度限制，是浏览器和服务器原因\n\n服务器原因是处理长url消耗多的资源（防止恶意构造长的url），为了性能和安全\n\n\n# post产生两个tcp数据包？\n\nheader和body分开发送是部分浏览器请求方法，不属于post必然行为\n\n100 continue为了在发送body之前查看服务器是否接受这个实体，属于优化\n\n大多数是尽量在tcp包中将请求发出去，但也确实存在先发header，再发body的情况。具体是多少个tcp包，这个不关http的事，是os tcp协议栈和代码的问题\n\n\n# ⏩ http\n\n\n# 优点\n\n 1. 简单\n    \n    * http 基本报文格式是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用门槛\n\n 2. 灵活 易扩展\n    \n    * http协议里的各类请求方法、uri/url、状态码、头字段等每个组成要求都没有被固定死，允许开发人员自定义和扩充\n    * http 由于工作在应用层（ osi 第七层），它下层可以随意变化\n    * https 就是在 http 与 tcp 层之间增加了 ssl/tls 安全传输层，http/3 甚至把 tcp 层换成了基于 udp 的 quic\n\n 3. 应用广泛和跨平台\n    \n    * http 的应用范围非常广泛，从台式机浏览器到手机上的各种 app，从看新闻到购物、理财，http 的应用遍地开花，天然具有跨平台优越性\n\n 4. 可靠\n    \n    * http对传输数据进行一层包装，加上一个头，调用api，通过tcp/ip协议发送和接收\n\n 5. 使用 请求-应答 通信模式\n\n 6. 无状态，client和server永远处于“无知”状态，每次请求和答复独立。协议不要求server或client记录请求的相关信息\n    \n    tcp有状态：closed——established——fin-wait——closed。http 1.1中总是默认启动keep-alive长连接机制\n\n\n# 缺点\n\n 1. 明文传输，内容可能被窃听\n\n明文意味着在传输过程中的信息，方便阅读。正是这样，http 所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有账号密码信息，那号没了\n\n 2. 不安全，无法验证通信双方身份，也不能判断报文是否修改\n\nhttp 比较严重的缺点是不安全：\n\n * 通信使用明文（不加密），内容可能被窃听。比如，账号信息容易泄漏，那你号没了\n * 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了\n * 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了\n\nhttp 的安全问题，可以用 https 解决，通过引入 ssl/tls 层，在安全上达到极致\n\n 3. 无论是谁发送来的请求都会响应\n\n * 无法确定请求发送至目标的web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的web服务器\n * 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端\n * 无法确定正在通信的对方是否具备访问权限。因为某些web服务器上保存着重要的信息，只想发给特定用户\n * 无法判定请求是来自何方、出自谁手\n * 即使是无意义的请求也会照单全收。无法阻止海量请求下的dos攻击（denial of service，拒绝服务攻击）\n\n 4. 无状态双刃剑\n\n * 无状态的好处，服务器不会记忆 http 的状态，所以不需要额外资源记录状态信息，能减轻服务器的负担，能够把更多的 cpu 和内存用来对外提供服务\n\n * 无状态的坏处，既然服务器没有记忆能力，在完成有关联性的操作时会非常麻烦\n\n例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息\n\n这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？\n\n对于无状态的问题，解法方案有很多种，其中比较简单的方式用 cookie 技术\n\ncookie 通过在请求和响应报文中写入 cookie 信息来控制客户端的状态\n\n相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了\n\n\n\n\n# 一个tcp连接中http请求可一起发送么\n\n（比如一起发三个请求，再三个响应一起接收)?\n\nhttp1.1存在一个问题，单个tcp连接在同一时刻只能处理一个请求。即两个请求的生命周期不能重叠，任意两个http请求从开始到结束的时间在同一个tcp连接中不能重叠\n\n在 http/1.1 存在 pipelining 技术可以完成多个请求同时发送，但由于浏览器默认关闭，所以认为这是不可行的\n\n在 http2 中由于 multiplexing (多路复用)特点的，多个 http 请求可以在同一个 tcp连接中并行进行\n\n在 http/1.1 时代，浏览器如何提高页面加载效率呢？主要有下面两点：\n\n 1. 维持和服务器已经建立的 tcp 连接，在同一连接上顺序处理多个请求\n 2. 和服务器建立多个 tcp 连接\n\n\n# http 0.9\n\n * 只支持get\n * 不支持请求头\n * 只能传输纯文本\n * 无状态连接\n\n\n# http1.0、http1.1\n\n\n\n\n# http1.0\n\n与服务器只保持短暂的连接，每次请求都要与服务器建立一个tcp连接\n\n * 响应不仅限文本\n * 支持响应/请求头\n * 默认短连接，增加keep-alive关键字由短链接变成长连接\n * 支持get post head\n\n\n# http 1.1性能?\n\n * 新增options、put、delete、trace和connect\n\n * 增加host字段\n\n * 长连接\n\n（persistent connection）在一个tcp连接上可传送多个http请求和响应，减少建立、关闭连接的消耗和延迟。默认开启connection : keep-alive\n\n只要任意端没有明确提出断开连接，则保持 tcp 连接状态\n\n如果某个 http 长连接超过一定时间没有任何数据交互，服务端主动断开连接\n\n * 管道网络传输(请求流水线处理)\n\nhttp/1.1 采用长连接的方式，使得管道（pipeline）网络传输成为可能\n\n在同一个 tcp 连接里面，客户端可发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，减少整体响应时间\n\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个 tcp 连接里面，先发送 a 请求，等待服务器做出回应，收到后再发出 b 请求。管道机制则是允许浏览器同时发出 a 请求和 b 请求， 但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应\n\n注意，是按照服务端收到的请求顺序响应，不管哪个请求是先发送，假设客户端先发送 a 请求，后发送 b 请求，如果服务端先收到 b 请求，就先响应 b 请求，再响应 a 请求，但是假设处理 b 请求耗时较长，请求 a 的响应就会被阻塞，称为「队头堵塞」\n\n所以，http/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞\n\n * 队头阻塞\n\n「请求 - 应答」的模式加剧了 http 的性能问题\n\n当顺序发送的请求序列中的一个请求因为某种原因被阻塞，在后面排队的所有请求也一同被阻塞，会导致客户端一直请求不到数据——「队头阻塞」，好比上班的路上塞车\n\n总之 http/1.1 的性能一般般\n\n\n# http1.1相比http1.0\n\n 1. 缓存处理，引入更多缓存头控制缓存策略。http1.0中主要使用header里的if-modified-since，expires来做为缓存判断的标准，http1.1则引入更多的缓存控制策略例如entity tag，if-unmodified-since，if-match，if-none-match等更多可供选择的缓存头控制缓存策略\n 2. 带宽优化及网络连接的使用，增加断点续传功能\n 3. 错误通知的管理：新增24个错误状态码，如409（conflict）表示请求资源与资源当前状态冲突、410（gone）表示服务器上某个资源被永久性删除\n 4. host头处理。随着虚拟主机技术的发展，一台物理服务器上可以存在多个虚拟主机且共享同一个ip。http 1.1请求和响应都支持host头，请求消息中如果缺少host，400（bad request）\n 5. 长连接，改善http1.0短连接造成的性能开销\n 6. 支持管道网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，减少整体响应时间\n\n\n# 二者存在问题：\n\n 1. http传输数据，每次都要3次握手建立连接，增加大量延迟\n 2. 明文传输\n 3. header携带内容过大，增加传输成本\n 4. http1.1支持keep-alive，但是keep-alive使用多了同样给服务端带来大量性能压力，因为文件被请求后，服务端需要保持不必要的连接很长时间\n\n\n# http1.1性能瓶颈\n\n 1. 请求/响应头部未经压缩就发送，首部信息越多延迟越大，只能压缩body部分\n 2. 发送冗长首部.每次发送相同的首部造成浪费\n 3. 服务器按请求的顺序响应，如果服务器响应慢，会导致客户端一直请求不到数据——队头阻塞\n 4. 没有请求优先级控制\n 5. 请求只能从客户端开始，服务器只能被动响应\n\n\n# spdy-http1.x优化\n\nspdy位于http之下，tcp和ssl之上，可轻松兼容老版本的http协议，也可使用已有的ssl功能\n\n\n# 特点\n\n * 降低延迟\n\n针对http高延迟的问题，spdy采取了多路复用（multiplexing）\n\n多路复用通过多个请求stream共享一个tcp连接，解决了hol blocking(队头阻塞)问题，降低延迟同时提高带宽利用率\n\n * 请求优先级（request prioritization）\n\n多路复用的连接共享机制可能导致关键请求被阻塞\n\nspdy允许给每个request设置优先级，重要请求优先得到响应\n\n * header压缩\n\n减少包的大小和数量，酱紫通信产生的数据包数量和发送的字节数就更少了\n\n * 基于https的加密协议传输，提高传输数据的可靠性\n * 服务端推送（server push）\n\n采用了spdy的网页，例如我的网页有一个style.css的请求，在客户端收到style.css数据的同时，服务端会将style.js的文件推送给客户端，当客户端再次尝试获取style.js时就可以直接从缓存中得到，不用再次请求\n\n * 多路复用。通过单一的tcp连接，可以无限制处理多个http请求\n * 服务器提示功能。服务器可主动提示客户端请求所需的资源。在客户端发现资源前就获取资源的存在，在资源已缓存的情况下，避免发送请求\n\n\n# websocket\n\nwebsocket和socket——雷锋和雷峰塔\n\n网络传输协议，浏览器和服务端 全双工通讯的网络技术，位于应用层\n\n节省服务器资源和带宽达到实时通迅\n\n客户端和服务器只需完成一次握手，两者就可创建持久性连接，并进行双向数据传输\n\n\n# 特点\n\n 1. 二进制帧。语法语义和http完全不兼容，对比http2，websocket侧重于 实时通信，http2侧重于提高传输效率，不存在多路复用，优先级等特性；不需要服务器推送\n\n\n# 应用\n\nwebsocket完美继承 tcp 的全双工能力， 还贴心 提供了解决粘包的方案。 适用于需要服务器和客户端（浏览器）频繁交互的大部分场景。 网页/小程序游戏，网页聊天室， 类似飞书 的网页协同办公软件\n\n使用websocket协议的网页游戏里，怪物移动以及攻击玩家的行为是服务器逻辑产生 ，对玩家产生的伤害等数据， 由服务器主动发送给客户端，客户端获得数据后展示效果\n\n * 弹幕\n * 媒体聊天\n * 协同编辑\n * 基于位置的应用\n * 体育实况更新\n\n\n# http不断轮询\n\n伪服务器推的方式——前端不断定时发请求到服务器，服务器收到请求后给客户端响应\n\n场景：扫码登录\n\n问题：\n\n 1. 满屏的http请求，消耗带宽增加服务器负担\n 2. 最坏情况需要等1~2s触发请求，跳转页面，出现卡顿\n\n\n# 长轮询\n\n若http请求将超时设置的很大，在30s内只要服务器收到了扫码请求，就立马返回给客户端，若超时则发下一个请求\n\n场景：百度网盘\n\n长轮询——发起一个请求，在较长时间内等待服务器响应\n\n\n# websocket\n\n\n# ✅ http 2.0\n\n更快 更稳定 更简单\n\n\n\n\n# 特性\n\nhttp/2 协议基于 https\n\nhttp2.0可以说是spdy的升级版本，与spdy的区别如下：\n\n 1. http2.0支持明文http传输，而spdy强制使用https\n 2. http2.0消息头压缩算法使用hpack，而spdy使用deflate\n\nhttp2.0主要目标——改进传输性能，实现低延迟和高吞吐量\n\nhttp2.0升级改造需要考虑：\n\n 1. http2.0支持非https，但主流浏览器如chrome、firefox还是只支持基于tls部署的http2.0协议，所以升级http2.0还是要先升级https\n 2. 升级https后，如果使用nginx，只需要在配置文件中启动相应的协议就可\n 3. http2.0完全兼容http1.x，对于不支持http2.0的浏览器，nginx自动向下兼容\n\n\n# 二进制分帧\n\nhttp/2 不像 http/1.1 纯文本形式的报文，而是全面采用二进制格式**，头信息和数据体都是二进制，统称为帧（frame）：**头信息帧（headers frame）和数据帧（data frame）\n\n帧——http/2 通信最小单位，每个帧都包含帧头，至少会标识出当前帧所属的数据流\n\nhttp/2 连接是永久的，仅需要每个来源 一个连接\n\n\n\n对人不友好，但是对计算机友好，因为计算机只懂二进制，收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，增加了数据传输的效率\n\n(因为是新增的二进制分帧层，所以叫2.0)\n\n不改变http语义，http方法、状态码、url及首部字段。改进传输性能，实现低延迟和高吞吐量\n\nhttp1.x解析基于文本，文本展现形式多样，要做到健壮性考虑的场景必然很多，二进制则只有0和1，更高效健壮\n\n\n# 首部压缩\n\n> http/2 会压缩头（header）如果同时发出多个请求，他们的头一样或是相似，协议会消除重复的部分\n> \n> hpack算法：客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，提高速度\n\nhttp 1.x无首部压缩，gzip只对请求体压缩\n\nspdy和http 2.0都支持首部压缩。使头部帧最大程度复用，减少头部大小，减少内存和流量\n\n比如：第一次请求，包含头部各种信息，后来又发送另外请求，发现大部分字段可以复用，一次只发送一个当前请求特有的头部帧即可\n\n避免重复header传输\n\n 1. http2.0会压缩首部元数据，在client和server使用首部表跟踪和存储之前发送的健值对，对于相同数据，不需每次请求响应都发送\n 2. 所有header必须全部小写，而且请求行要独立为健值对（即header+值）\n\n\n# 多路复用\n\nhttp 1.0：建立连接，请求数据完毕之后立即关闭连接\n\n后采用keep-alive模式使得可以复用连接而不断开，可利用这次连接继续请求\n\n缺点：必须等到server返回上一次的请求数据才进行下一次请求\n\nq：遇到一个请求很久没有响应，后面的请求只能等待？\n\nhttp/2 可以在一个连接中并发请求，不用按照顺序一一对应\n\n多路复用（multiplexing），即连接共享，每一个request都是用作连接共享机制。每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混杂在一起，接收方根据request的id将request归属到不同服务端请求里。客户端只需要一个连接就可以加载一个页面\n\n移除了 http/1.1 中的串行请求，不需要排队等待，不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接利用率\n\n举例来说，在一个 tcp 连接里，服务器收到了客户端 a 和 b 的两个请求，如果发现 a 处理过程非常耗时，于是回应 a 请求已经处理好的部分，接着回应 b 请求，完成后，再回应 a 请求剩下的部分\n\n优点：\n\n 1. 并行交错发送请求，请求之间互不影响\n 2. tcp连接一旦建立可并行发送请求\n 3. 消除不必要延迟，减少页面加载时间\n 4. 可最大程度利用http 1.x\n\n\n# 请求优先级\n\nserver根据流的优先级控制资源分配，响应数据准备好后，把优先级最高的帧发送给client。browser发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序，这时请求不用排队，节省时间，最大限度利用连接\n\n\n# 流量控制\n\n流：不改变协议，允许采用多种流量控制算法\n\n特点：\n\n 1. 流量基于http连接的每一跳进行，不是端到端控制\n 2. 流量基于窗口更新帧进行，接收方可广播准备接收字节\n 3. 流量控制有方向，接收方根据自身情况控制窗口大小\n 4. 流量控制可由接收方禁用\n 5. 只有data帧服从流量控制，其他不会消耗控制窗口的空间\n\n\n# 服务端推送\n\nhttp/2 一定程度上改善了传统的「请求 - 应答」工作模式，服务不再被动响应，也可以主动向客户端发送消息\n\nserver push通过推送那些它认为客户端将会需要使用到的内容到客户端缓存中，避免往返的延迟\n\n\n# 数据流\n\nhttp/2 的数据包不是按顺序发送，同一个连接里面连续的数据包，可能属于不同回应。因此，必须要对数据包做标记，指出它属于哪个回应\n\nhttp/2 中每个请求或相应的所有数据包，称为一个数据流（stream）。每个数据流都标记着一个独一无二的编号（stream id），不同 stream 的帧可乱序发送（因此可并发不同stream ），因为每个帧头部携带 stream id 信息，所以接收端可以通过 stream id 有序组装成 http 消息\n\n客户端和服务器双方都可以建立 stream， stream id 也有区别，客户端建立的 stream 必须是奇数号，而服务器建立的 stream 必须是偶数号\n\n\n\n客户端可以指定数据流的优先级。优先级高的请求，服务器先响应 该请求\n\n\n# 缺陷\n\nhttp/2 通过 stream 的并发能力，解决了 http/1 队头阻塞的问题，看似很完美，但是 http/2 还是存在“队头阻塞”的问题，只不过问题不是在 http 这一层面，而是在 tcp 这一层\n\nhttp/2 基于 tcp 协议传输数据，tcp 是字节流协议，tcp 层必须保证收到的字节数据完整且连续，这样内核才会将缓冲区里的数据返回给 http 应用，当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，http/2 应用层才能从内核中拿到数据—— http/2 队头阻塞问题\n\n\n\n图中发送方发送了很多个 packet，每个 packet 都有自己的序号，可认为是 tcp 的序列号， packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 tcp 数据不连续，接收方的应用层无法从内核中读取，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据\n\n所以，一旦发生丢包现象，会触发 tcp 重传机制，这样在一个 tcp 连接中的所有的 http 请求都必须等待这个丢了的包被重传\n\n\n# http3\n\nhttp3.0 相对于 http2.0 是脱胎换骨的改变！\n\nhttp1.1和http1.2都有队头阻塞的问题\n\n * http1.1中的管道(pipeline)解决了请求的对头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，只能等相应完这个请求后， 才能处理下一个请求。——http 层队头阻塞\n * http/2 虽然通过多个请求复用一个 tcp 连接解决了 http 的队头阻塞 ，但一旦发生丢包，就会阻塞所有 http 请求——tcp 层队头阻塞\n\nhttp/2 队头阻塞的问题是因为 tcp，所以 http/3 把 http 下层的 tcp 协议改成了 udp！！\n\n\n\nudp 不管顺序，也不管丢包，不会像 http/2 出现队头阻塞问题\n\nudp 不可靠传输，但基于 udp 的 quic 协议 可以实现类似 tcp 的可靠传输\n\n\n# 特性\n\n\n# 连接迁移\n\n\n# 无队头阻塞\n\n\n# 自定义拥塞控制\n\n\n# 前向安全和前向纠错\n\n\n# 为什么http3.0使用udp？\n\n\n# 🌰 https=http+ssl/tls\n\nhttps=http+加密+认证+完整性保护\n\n（http secure）\n\n\n\nhttps是加强版的http，是在http和tcp间建立了一个中间层(安全层)，进行加密，tcp必须将数据包解密才能传给上面的http\n\nheader+body整个都加密，啥都看不到\n\nurl信息在header中，自然被加密\n\n\n\n> https加密的内容有？？\n> \n>  * 请求头\n>  * 请求路劲\n>  * 请求参数\n\n不会加密 请求域名！！！\n\n\n# ssl/tls\n\n“secure sockets layer”，叫做“安全套接层”（依靠整数验证服务器身份）一种用于加密和验证应用程序和web服务器间发送的数据的协议\n\n标准化之后的名称改为 tls（“transport layer security”），叫做“传输层安全协议”\n\n> 公钥加密，私钥解密\n\n\n# 作用\n\n认证用户和服务，加密数据，维护数据完整性\n\nssl证书验证服务器身份，并为它们之间的通信进行加密\n\nssl/tls 协议基本流程：\n\n * 客户端向服务器索要并验证服务器的公钥\n * 双方协商生产「会话秘钥」\n * 双方采用「会话秘钥」加密通信\n\n\n# ssl/tls的四次握手\n\n\n\nssl/tls 的「握手阶段」涉及四次通信，可见下图：\n\n\n\n> 服务端生成第一随机数和第二随机数以及自己的公钥发送给客户端，客户端用服务端的公钥锁上预主秘钥（第三随机数），发送给服务端，服务端收到后用自己的私钥解密，取出欲主密钥，后面2者完全使用欲主密钥以对称加密的方式通信\n> \n> 欲主密钥——会话秘钥\n\nssl/tls 协议建立的流程：\n\n 1. clienthello\n\n客户端向服务器发起加密通信请求—— clienthello 请求\n\n客户端主要向服务器发送以下信息：\n\n（1）支持的 ssl/tls 协议版本，如 tls 1.2 版本\n\n（2）第一随机数——客户端生产的随机数（client random），用于后面生成「会话秘钥」条件之一\n\n（3）**客户端支持的加密方法，**如 rsa 公钥加密，此时是明文传输\n\n（4）支持的压缩算法\n\n 2. severhello\n\n服务器收到客户端请求后，向客户端发出响应—— severhello。服务器回应：\n\n（1）确认ssl/tls协议版本，如果浏览器不支持，关闭加密通信\n\n（2）第二随机数——服务器生产的随机数（server random），是生产「会话秘钥」的条件之一\n\n（3）确认使用加密算法\n\n（4）服务器证书(证书包含网站地址，非对称加密公钥，证书领发机构等信息)\n\n 3. 客户端回应\n\n客户端收到服务器的回应之后，通过浏览器或者操作系统中的 ca 公钥，确认服务器的数字证书真实性（颁发机构是否合法，证书中包含网址是否和正在访问的一样），证书过期，会给一个警告，是否选择继续通信\n\n如果证书没有问题，客户端从数字证书中取出服务器的公钥，使用它加密报文，向服务器发送：\n\n（1）第三随机数（pre-master key），用于服务器公钥加密\n\n（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信\n\n（3）客户端握手结束通知，这一项同时把之前所有内容发生改变的数据做个摘要，供服务端校验\n\n服务器和客户端有了这三个随机数（client random、server random、pre-master key），接着用协商的加密算法，各自生成本次通信的「会话秘钥」\n\n> 为啥是3个随机数？\n> \n> 一个伪随机可能不完全随机，可是3个随机数就很接近随机了，每增加一个自由度，随机性增加的可不是一！！\n\n 4. 服务器的最后回应\n\n服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」\n\n然后，向客户端发送最后的信息：\n\n（1）加密通信算法改变通知，随后的信息都将用「会话秘钥」加密通信\n\n（2）服务器握手结束通知，同时把之前所有内容的发生改变的数据做个摘要(内容的hash值)，供客户端校验\n\n至此，整个 ssl/tls 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，完全使用普通的 http 协议，只不过用「会话秘钥」加密内容\n\n\n# 🍪https保证传输安全？\n\n\n# tls1.0\n\n使用rsa密钥交换算法\n\n\n# tls.12\n\n使用ecdhe算法\n\n\n# 🔥 https、http\n\n> 简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取\n\n 1. https 需要申请数字证书（去 ca 申请），保证服务器的身份可信\n 2. https在tcp和http应用层间加入了ssl/tls安全协议，是http的加密版本；http 是超文本传输协议，明文传输不安全\n 3. http 端口 80； https 端口 443\n 4. http 无状态连接，建立连接相对简单，三次握手后即可进行报文传输.https在tcp三次握手之后，还需进行ssl/tls的握手过程，才可进入加密报文传输\n 5. https 协议 由 ssl+http 构建，更安全\n 6. https提供\n    * 数据完整性\n    * 隐私性\n    * 身份认证\n    * 不可否认性\n\n\n# https解决啥问题\n\n\n\n\n# http存在风险\n\n 1. 窃听风险，如通信链路上可以获取通信内容，用户号容易没\n 2. 篡改风险，如强制植入垃圾广告，视觉污染，用户眼容易瞎\n 3. 冒充风险，如冒充淘宝网站，用户钱容易没\n\n\n# https 在 http 与 tcp 层间加入ssl/tls 协议，解决上述风险\n\n 1. 信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没\n 2. 校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告\n 3. 身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没\n\n\n# https 如何解决上面三个风险？\n\n 1. 混合加密实现信息的机密性，解决了窃听的风险\n 2. 摘要算法实现完整性，它能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险\n 3. 将服务器公钥放入到数字证书中，解决了冒充的风险（身份认证）\n 4. 数字签名：不可否定。内容摘要算法得到摘要，私钥加密摘要，对方使用对应公钥解密，得到摘要，再和自己得到的服务器提供的原文摘要对比，一致说明这个内容就是原服务器提供的，由证书说明了服务器的身份\n\n\n\n\n# 混合加密\n\n\n\n对称加密——“加密”和“解密”使用【相同的】密钥\n\n> a发给b的文件需要加密，a用锁锁住文件发给b，然后再把钥匙发给b，b拿到钥匙和文件，解锁\n\n非对称加密——加密 和 解密 使用不同的 密钥 (消耗大)\n\n> a发给b的文件需要加密，b把自己的锁发给a，a锁好后把文件发给b，b的钥匙一直都在自己手上，然后用自己的钥匙（私钥）解自己的锁（公钥），不用担心钥匙在传递过程中被窃取\n\n公钥可以公开给任何人使用，私钥需要保密。公钥加密后只能用私钥解密，相反，私钥加密后只能用公钥解密\n\n\n\n\n\n通过混合加密的方式保证信息的机密性，解决了窃听的风险\n\nhttps 采用对称加密和非对称加密结合的「混合加密」方式：\n\n 1. 在通信建立前采用非对称加密的方式交换「欲主秘钥」，后续就不再使用非对称加密\n 2. 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据\n\n采用「混合加密」方式的原因：\n\n * 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换\n * 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢\n\n\n\n> 非对称加密本质是为了防止私钥加密数据外传\n\n\n\n🌰网站保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，无法破解密文\n\n上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客劫持\n\n因此，在上述加密的基础上仍需加上完整性、身份验证的特性，实现真正的安全——摘要算法\n\n\n# 摘要算法\n\n实现完整性，为数据生成独一无二的「指纹」，校验数据的完整性，解决了篡改的风险\n\n可以理解为一种特殊的压缩算法(生成hash值)，把任意长度数据 压缩 成固定长度，独一无二 的摘要 字符串，就像是给这段数据生成了一个数字 指纹\n\n\n\n客户端在发送明文之前通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据完整\n\n\n# 数字签名\n\n数字签名确定消息确实是由发送方签名并发出来，因为别人假冒不了发送方的签名\n\n> 私钥加密，公钥解密！\n\n如果想篡改，必须篡改原文信息后 私钥加密 才能得到原来的效果，可惜私钥不公开\n\n签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的\n\n\n\n和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥\n\n这时候就需要一个第三方——证书验证机构ca\n\n\n# 数字证书\n\n数字证书作用：\n\n 1. 服务器向浏览器证明自己的身份\n 2. 把公钥传给服务器\n\n客户端先向服务器端索要公钥，公钥加密信息，服务器收到密文后，用自己的私钥解密\n\n这就存在问题，如何保证公钥不被篡改？\n\n所以需要借助第三方权威机构 ca （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的\n\n\n\n 1. 服务器的运营人员向数字证书认证机构提出公开密钥的申请\n 2. 数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名\n 3. 分配这个已签名的公开密钥，将该公开密钥放入公钥证书绑定在一起\n 4. 服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信\n\n接到证书的客户端使用数字证书认证机构的公开密钥，对证书上的数字签名进行验证，一旦验证通过，则证明：\n\n * 认证服务器的公开密钥的是真实有效的数字证书认证机构\n * 服务器的公开密钥值得信赖\n\n\n# https中间人攻击\n\n客户端和服务器之间的桥梁、双向获取并且篡改信息\n\n\n\n标准回答\n\n攻击者通过与客户端和客户端的目标服务器同时建立连接，作为客户端和服务器的桥梁，处理双方的数据，整个会话期间的内容几乎完全被攻击者控制。攻击者可以拦截双方的会话并且插入新的数据内容\n\n加分回答\n\n中间人攻击的过程：\n\n 1. 本地请求被劫持，所有请求均发送到中间人服务器\n 2. 中间人服务器返回中间人自己的证书\n 3. 客户端创建随机数，通过中间人证书中的公钥加密 传送给中间人，凭随机数构造对称加密对传输内容加密传输\n 4. 中间人拥有客户端返回的随机数，可以对内容解密\n 5. 中间人以客户端的请求内容向真的服务器发送请求\n 6. 服务器通过建立的通道返回加密后的数据\n 7. 中间人对加密算法内容解密\n 8. 中间人对内容加密传输\n 9. 客户端通过和中间人建立的对称加密算法对返回数据解密\n\n缺少证书的验证，客户端完全不知道自己的网络被拦截，数据被中间人窃取\n\n\n# https一定安全？\n\nhttps 协议本身到目前为止没有任何漏洞，即使成功进行中间人攻击，本质是利用客户端漏洞（用户点击继续访问/被恶意导入伪造根证书），并不是 https 不够安全\n\n双向认证，客户端验证服务端身份，服务端也会验证客户端身份\n\n\n\n\n# 🌰 dns 解析\n\n将主机名转换为ip地址\n\n>  1. 一个由分层的dns服务器实现的分布式数据库\n>  2. 一个使得主机能查询分布式数据库的应用层协议\n\n\n# 域名\n\n\n\n例如www.xxx.com，www为三级域名、xxx为二级域名、com为顶级域名(tld-top level domain)，系统为用户做了兼容，域名末尾的根域名.一般不需要输入\n\n\n\n还有电脑默认的本地域名服务器\n\n\n# 分布式\n\n世界上没有一台dns服务器拥有因特网上所有主机的映射，每台dns只负责部分映射\n\n\n# 本地dns服务器\n\n本地dns服务器起着代理的作用，负责将该请求转发到dns服务器层次结构中\n\n\n# 递归、迭代查询\n\n * 递归查询：如果 a 请求 b，那么 b 作为请求的接收者一定要给 a 想要的答案\n\n\n\n * 迭代查询：如果接收者 b 没有请求者 a 所需要的准确内容，接收者 b 将告诉请求者 a，如何去获得这个内容，但是自己并不去发出请求\n\n\n\n 1.  浏览器根据地址去缓存查找dns解析记录，没有的话，浏览器查找os中是否有该域名的dns解析记录\n 2.  缓存过期或没有记录，浏览器向域名服务器发请求解析域名\n 3.  主机m向本地dns服务器发送一个dns查询报文，其中包含期待被转换的主机名a.b.com\n 4.  本地dns~无法解析，则将该报文转发到根dns~\n 5.  该根~注意到com前缀，便向本地dns服务器返回com对应的顶级域名dns服务器(tld)的ip地址列表\n 6.  本地dns~则向其中一台tld服务器发送查询报文\n 7.  该tld服务器注意到b.com前缀，于是向本地dns服务器返回权威dns服务器的ip地址\n 8.  本地dns服务器又向其中一台权威dns服务器发送查询报文\n 9.  终于，该权威服务器返回了a.b.com的ip地址\n 10. 本地dns服务器将a.b.com跟ip地址的映射返回给主机m.n.com，m.n.com就可以用该ip向a.b.com发送请求啦\n\n\n\n主机向本地dns服务器dns.n.com发出的查询是递归查询，这个查询是主机m.n.com以自己的名义向本地dns服务器请求想要的ip映射，且本地dns服务器直接返回映射结果到主机\n\n**后继查询为迭代查询，**包括本地dns 服务器向根 dns 服务器发送查询请求、本地 dns 服务器向 tld 服务器发送查询请求、本地 dns 服务器向权威 dns 服务器发送查询请求，所有的请求都是由本地 dns 服务器发出，所有的响应都是直接返回给本地 dns 服务器。\n\n解析结束，撒花✿✿ヽ(°▽°)ノ✿\n\n\n# 所有 dns 查询都必须遵循递归 + 迭代 ？\n\n不是\n\n理论上，任何 dns 查询既可以是递归的，也可以是迭代的\n\n> tld 一定知道权威 dns 服务器的 ip 地址吗？\n\n不一定，有时 tld 只是知道中间的某个 dns 服务器，再由这个中间 dns 服务器去找到权威 dns 服务器。这种时候，整个查询过程就需要更多的 dns 报文\n\n\n# dns 优化和应用\n\n\n# dns缓存\n\n在一个 dns 查询的过程中，当某一台 dns 服务器接收到一个 dns 应答（例如，包含某主机名到 ip 地址的映射）时，它就能够将映射缓存到本地，下次查询就可以直接用缓存\n\n有了缓存，大多数 dns 查询都绕过了根 dns 服务器，需要向根 dns 服务器发起查询的请求很少\n\ndns存在多级缓存，从离浏览器的距离**排序的话**，有以下几种:\n\n * 浏览器缓存\n\n * 系统缓存\n\n * 路由器缓存\n\n * isp(运营商) dns缓存(本地服务器缓存)\n\n * 根域名服务器缓存\n\n * 顶级域名服务器缓存\n\n * 主域名服务器缓存\n\n\n# 负载均衡\n\n(dns重定向) dns负载均衡技术——在dns服务器中为同一个主机名配置多个ip地址\n\n简单说：用户发起的请求都指向调度服务器（反向代理服务器，如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，调度器等待实际服务器的http响应，并将它反馈给用户\n\n# cdn(content delivery network)\n\n利用dns的重定向技术，dns服务器会返回一个跟 用户最接近的点的ip地址给用户，cdn节点的服务器负责响应用户的请求，提供所需的内容\n\n\n# dns-prefetch\n\ndns prefetch 是一种 dns 预解析技术。当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 dns 的解析，减少用户等待时间，提高用户体验\n\n\n# 为啥使用udp？\n\n因为udp快！udp的dns协议只要一个请求一个应答就好\n\n\n# 解析不存在的域名？\n\n如果域名 不存在，浏览器还是会从dns那里解析一下，发现自己 操作系统 本地缓存都没有，cdn也没有，根域名 顶级域名 权威域名 非权威域名都没有\n\ndns解析失败，不会进入http请求流程，不会有状态码错误，只会返回dns解析错误信息\n\n\n# others\n\n\n# tcp/ip协议族？\n\ntcp/ip协议将**应用层，表示层，会话层合并为应用层，**物理层和数据链层合并为网络接口层\n\ntcp/ip协议指的是由 ftp smtp tcp udp ip arp 等协议构成的协议集合\n\ntcp/ip，传输控制协议/网际协议\n\n * tcp（传输控制协议）\n\n一种面向连接的、可靠的、基于字节流的传输层通信协议\n\n * ip（网际协议）\n\n用于封包交换数据网络的协议\n\ntcp/ip协议指一个由ftp、smtp、tcp、udp、ip等协议构成的协议簇，\n\n只是因为在tcp/ip协议中tcp协议和ip协议最具代表性，所以通称为tcp/ip协议族（英语：tcp/ip protocol suite，或tcp/ip protocols）\n\n\n# tcp 协议保证页面文件完整送达浏览器?\n\n * ip 头是 ip 数据包开头的信息，包含 ip 版本、源 ip 地址、目标 ip 地址、生存时间等信息\n * udp 头中除了目的端口，还有源端口号等信息\n * ip 负责把数据包送达目的主机\n * udp 负责把数据包送达具体应用\n * 对于错误的数据包，udp 不提供重发机制，只是丢弃当前的包，不能保证数据的可靠性，但是传输速度非常块\n * tcp 头除了包含了目标端口和本机端口号外，还提供用于排序的序列号，保证了数据完整传输，连接分为三个阶段：建立连接、传输数据和断开连接\n\n\n# ✔️ quic协议\n\nquic（quick udp internet connections）快速udp互联网连接 ，基于udp的传输层协议\n\n降低网络通信的延迟，工作在应用层\n\n可靠性：udp是不可靠协议，但是quic在udp的基础上做了些改造，使得它提供了和tcp类似的可靠性，提供了数据包重传、拥塞控制、调整传输节奏及其他一些tcp中存在的特性\n\n实现了无需、并发字节流：quic的单个数据流可以保证有序交付，但多个数据流之间可能乱序，这意味着单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与 发送方的发送顺序不同\n\n快速握手：quic提供0-rtt和1-rtt的连接建立\n\n使用tls 1.3 传输层安全协议：与更早的tls版本相比，tls 1.3有很多优点，最主要原因是 其握手所花费的往返次数更低，能降低协议的延迟\n\n\n> # 特点\n\n * 0-rtt 建联(首次 建联除外)\n * 类似 tcp的可靠传输\n * 类似 tls 的加密传输，支持完美前向安全\n * 用户空间的拥塞控制，最新的bbr算法\n * 支持h2的基于流的多路复用，但没有tcp的hol问题\n * 前向纠错fec\n * 类似motcp的connection migration\n\n\n\n\n\n\n> # 无队头阻塞\n\n发送窗口和接收窗口的队头阻塞这两个问题的原因都是tcp 必须按序处理数据， tcp 层为了保证数据有序性，只有在处理完有序的数据后，滑动窗口才能往前滑动，否则就停留\n\nhttp/2 抽象出 stream 的概念，实现了 http 并发传输，一个 stream 代表 http/1.1 里的请求和响应\n\n在 http/2 连接上，不同 stream 的帧可以乱序发送（因此可以并发不同的 stream ），因为每个帧头部会携带 stream id 信息，接收端可以通过 stream id 有序组装成 http 消息，而同一 stream 内部的帧必须严格有序\n\n但是 http/2 多个 stream 请求都是在一条 tcp 连接上传输，这意味着多个 stream 共用同一个 tcp 滑动窗口，当数据丢失，滑动窗口无法往前移动，会阻塞所有的 http 请求，这属于 tcp 层队头阻塞\n\nquic 协议也有类似 http/2 stream 与多路复用的概念，也可以在同一条连接上并发传输多个 stream，stream 可认为就是一条 http 请求\n\nquic 有自己一套机制保证传输的可靠性。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，不存在队头阻塞问题。与 http/2 不同，http/2 只要某个流中的数据包丢失了，其他流会因此受影响\n\n但是 quic 给每一个 stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 stream 之间没有依赖关系，都是相互独立，各自控制的滑动窗口\n\n\n\n\n> # 流量控制\n\nquic 基于 udp 传输，而 udp 没有流量控制，因此 quic 实现了自己的流量控制机制。不过，quic 的滑动窗口滑动的条件跟 tcp 有差别\n\n\n> # 更快的连接建立\n\n对于 http/1 和 http/2 协议，tcp 和 tls 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需分批次来握手，先 tcp 握手，再 tls 握手\n\nhttp/3 在传输数据前需要 quic 协议握手，这个握手过程只需要 1 rtt，握手是为确认双方的「连接 id」，连接迁移基于连接 id 实现\n\n但 http/3 的 quic 协议并不是与 tls 分层，而是quic 内部包含了 tls，它在自己的帧携带 tls 里的“记录”，再加上 quic 使用 tls/1.3，因此仅需 1 个 rtt 就可以「同时」完成建立连接与密钥协商，下图：\n\n\n\n甚至，在第二次连接时，应用数据包可以和 quic 握手信息（连接信息 + tls 信息）一起发送，达到 0-rtt 的效果\n\n\n> # 连接迁移\n\n基于 tcp 传输协议的 http 协议，通过四元组（源 ip、源端口、目的 ip、目的端口）确定一条 tcp 连接，当移动设备的网络从 4g 切换到 wifi 时， ip 地址变化，就必须断开连接，重新建立连接。建立连接的过程包含 tcp 三次握手和 tls 四次握手的时延，以及 tcp 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本很高\n\nquic 协议没有用四元组的方式“绑定”连接，而是通过连接 id标记通信的两个端点，客户端和服务器可以各自选择一组 id 标记自己，即使移动设备的网络变化，导致 ip 地址变化，只要仍保有上下文信息（比如连接 id、tls 密钥等），就可以“无缝”复用原连接，消除重连成本，没有丝毫卡顿感，达到了连接迁移的功能\n\n所以， quic 是一个在 udp 之上的伪 tcp + tls + http/2 的多路复用的协议\n\n\n\nquic 是新协议，对于很多网络设备，根本不知道什么是 quic，只会当做 udp，会出现新的问题，因为有的网络设备会丢掉 udp 包，而 quic 基于udp 实现，如果网络设备无法识别 quic 包，就会将其当作 udp包丢弃\n\n所以，http/3 现在普及的进度非常缓慢，不知道未来 udp 是否能够逆袭 tcp\n\n\n> # 优点\n\n具有spdy的所有优点；\n\n0-rtt连接\n\n减少丢包\n\n前向纠错，减少重传时延\n\n自适应拥赛控制，减少重新连接\n\n相当于tls加密\n\nquic主要目标是减少连接延迟，客户端第一次连接服务器时，quic只需要1rtt的延迟就可以建立可靠安全的连接，相对于tcp+tls的1～3次rtt要更加快捷\n\n之后客户端可以在本地缓存加密的认证信息，再次与服务端建立连接时可以实现0rtt的连接建立延迟\n\nquic同时复用了http2.0的多路复用（multiplexing）功能，但由于quic基于udp，避免了http/2的head-of-line bolcking问题\n\nquic基于udp，运行在用户域而不是系统内核，使得quic协议可以快速部署和更新\n\n重传与恢复\n\n与tcp类似，quic每发送一个包后，都会等待回复一个确认包\n\n当丢包率超过协议的纠错阀值，会显示与隐式进行重传\n\n对于某些重要的数据包，在确认丢失前就会进行重传\n\n这样在网络中会有若干个相同包同时传输，任何一个成功抵达就完成了连接，降低丢包率\n\n接收方对于关键数据包的多次发送和普通数据包的超时重传，都采用相同的重复包处理机制\n\nquic在拥塞避免算法上还加入了心跳机包，减少丢包率\n\nquic使用fec（前向纠错）恢复数据，fec采用简单的异或方式\n\n每次发送一组数据，包含若干个数据包后，并对这些数据包依次做异或运算，最后结果作为一个fec包再发送出去\n\n接收方收到一组数据后，根据数据包和fec包即可以进行考验和纠错\n\n安全性\n\nquic对每个散装的udp包都进行了加密和认证的保护，并且避免使用前向依赖（如cbc模式）的方法，这样每个udp包可以独立地根据iv进行加密或者认证处理\n\nquic使用了两级密钥机制：初始密钥和会话密钥。初次连接时不加密，并协商初始密钥\n\n初始密钥协商完毕后再马上协商会话密钥，可以保证密钥的前向安全性，之后通信过程还可以实现密钥的更新\n\n接收方收到密钥更新时，需要用新旧两种密钥对数据进行解密，直到成功才会正式使用新密钥\n\n0rtt握手过程\n\nquic握手过程需要一次数据交互，0rtt即可以完成握手过程的密钥协商，比tls相比效率提供了5倍\n\n初始密钥协商成果后，服务端提供一个临时随机数，双方根据这个随机数生成会话密钥',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"CSS",frontmatter:{title:"CSS",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/77ad0a/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/03.CSS.html",relativePath:"08.专栏/03.CSS.md",key:"v-106c7e08",path:"/pages/77ad0a/",headers:[{level:2,title:"getComputedStyle？",slug:"getcomputedstyle",normalizedTitle:"getcomputedstyle？",charIndex:776},{level:2,title:"font",slug:"font",normalizedTitle:"font",charIndex:1233},{level:2,title:"伪元素和伪类",slug:"伪元素和伪类",normalizedTitle:"伪元素和伪类",charIndex:2596},{level:2,title:"默认！标准(content-box)",slug:"默认-标准-content-box",normalizedTitle:"默认！标准(content-box)",charIndex:2773},{level:2,title:"IE 怪异(border-box)",slug:"ie-怪异-border-box",normalizedTitle:"ie 怪异(border-box)",charIndex:3124},{level:2,title:"link是行内吗？",slug:"link是行内吗",normalizedTitle:"link是行内吗？",charIndex:3459},{level:2,title:"link的伪类？",slug:"link的伪类",normalizedTitle:"link的伪类？",charIndex:3491},{level:2,title:"定位流",slug:"定位流",normalizedTitle:"定位流",charIndex:4098},{level:2,title:"浮动流",slug:"浮动流",normalizedTitle:"浮动流",charIndex:4415},{level:2,title:"正常文档流",slug:"正常文档流",normalizedTitle:"正常文档流",charIndex:4514},{level:2,title:"带来的问题",slug:"带来的问题",normalizedTitle:"带来的问题",charIndex:5041},{level:2,title:"清除浮动",slug:"清除浮动",normalizedTitle:"清除浮动",charIndex:5105},{level:2,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:5756},{level:2,title:"取值",slug:"取值",normalizedTitle:"取值",charIndex:6188},{level:2,title:"层叠上下文和层叠等级",slug:"层叠上下文和层叠等级",normalizedTitle:"层叠上下文和层叠等级",charIndex:6248},{level:2,title:"层叠顺序",slug:"层叠顺序",normalizedTitle:"层叠顺序",charIndex:6463},{level:2,title:"压盖顺序",slug:"压盖顺序",normalizedTitle:"压盖顺序",charIndex:6674},{level:4,title:"JS实现sticky",slug:"js实现sticky",normalizedTitle:"js实现sticky",charIndex:7847},{level:2,title:"创建",slug:"创建-2",normalizedTitle:"创建",charIndex:5756},{level:2,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:8843},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:9123},{level:2,title:"不定宽高",slug:"不定宽高",normalizedTitle:"不定宽高",charIndex:10072},{level:3,title:"水平局中",slug:"水平局中",normalizedTitle:"水平局中",charIndex:10084},{level:2,title:"内联",slug:"内联",normalizedTitle:"内联",charIndex:1513},{level:3,title:"水平居中",slug:"水平居中",normalizedTitle:"水平居中",charIndex:10178},{level:3,title:"垂直居中",slug:"垂直居中",normalizedTitle:"垂直居中",charIndex:10276},{level:3,title:"绝对居中——兼容性好的属性",slug:"绝对居中-兼容性好的属性",normalizedTitle:"绝对居中——兼容性好的属性",charIndex:10387},{level:2,title:"块级",slug:"块级",normalizedTitle:"块级",charIndex:4672},{level:3,title:"水平居中",slug:"水平居中-2",normalizedTitle:"水平居中",charIndex:10178},{level:3,title:"垂直居中",slug:"垂直居中-2",normalizedTitle:"垂直居中",charIndex:10276},{level:2,title:"冷门方式",slug:"冷门方式",normalizedTitle:"冷门方式",charIndex:14962},{level:2,title:"圣杯布局(左右float+负margin)",slug:"圣杯布局-左右float-负margin",normalizedTitle:"圣杯布局(左右float+负margin)",charIndex:16277},{level:2,title:"双飞翼布局(左右float+中margin)",slug:"双飞翼布局-左右float-中margin",normalizedTitle:"双飞翼布局(左右float+中margin)",charIndex:17720},{level:2,title:"两边absolute+中margin",slug:"两边absolute-中margin",normalizedTitle:"两边absolute+中margin",charIndex:19240},{level:2,title:"绝对定位",slug:"绝对定位",normalizedTitle:"绝对定位",charIndex:4137},{level:2,title:"BFC",slug:"bfc-2",normalizedTitle:"bfc",charIndex:4527},{level:2,title:"table",slug:"table",normalizedTitle:"table",charIndex:1392},{level:2,title:"flex",slug:"flex",normalizedTitle:"flex",charIndex:5927},{level:2,title:"grid",slug:"grid",normalizedTitle:"grid",charIndex:5922},{level:2,title:"父容器",slug:"父容器",normalizedTitle:"父容器",charIndex:23951},{level:3,title:"flex-direction",slug:"flex-direction",normalizedTitle:"flex-direction",charIndex:23959},{level:3,title:"flex-wrap",slug:"flex-wrap",normalizedTitle:"flex-wrap",charIndex:23977},{level:3,title:"flex-flow(简写属性)",slug:"flex-flow-简写属性",normalizedTitle:"flex-flow(简写属性)",charIndex:24521},{level:3,title:"justify-content",slug:"justify-content",normalizedTitle:"justify-content",charIndex:10245},{level:3,title:"align-items",slug:"align-items",normalizedTitle:"align-items",charIndex:14376},{level:3,title:"align-content",slug:"align-content",normalizedTitle:"align-content",charIndex:24037},{level:2,title:"子容器",slug:"子容器",normalizedTitle:"子容器",charIndex:23891},{level:3,title:"order",slug:"order",normalizedTitle:"order",charIndex:71},{level:3,title:"flex-grow",slug:"flex-grow",normalizedTitle:"flex-grow",charIndex:24590},{level:3,title:"flex-shrink",slug:"flex-shrink",normalizedTitle:"flex-shrink",charIndex:25628},{level:3,title:"flex-basis",slug:"flex-basis",normalizedTitle:"flex-basis",charIndex:25643},{level:3,title:"flex:1",slug:"flex-1",normalizedTitle:"flex:1",charIndex:15134},{level:3,title:"aline-self",slug:"aline-self",normalizedTitle:"aline-self",charIndex:26669},{level:2,title:"place-items",slug:"place-items",normalizedTitle:"place-items",charIndex:27038},{level:2,title:"可继承",slug:"可继承",normalizedTitle:"可继承",charIndex:28861},{level:2,title:"不可继承",slug:"不可继承",normalizedTitle:"不可继承",charIndex:29145},{level:2,title:"🍅line-height继承？",slug:"🍅line-height继承",normalizedTitle:"🍅line-height继承？",charIndex:29349},{level:2,title:"block，inline，inline-block",slug:"block-inline-inline-block",normalizedTitle:"block，inline，inline-block",charIndex:29842},{level:2,title:"行内元素支持宽高",slug:"行内元素支持宽高",normalizedTitle:"行内元素支持宽高",charIndex:30775},{level:2,title:"解决",slug:"解决",normalizedTitle:"解决",charIndex:2010},{level:2,title:"less",slug:"less",normalizedTitle:"less",charIndex:31076},{level:2,title:"sass",slug:"sass",normalizedTitle:"sass",charIndex:31081},{level:2,title:"相同",slug:"相同",normalizedTitle:"相同",charIndex:6789},{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:3621},{level:2,title:"为啥使用Sass？",slug:"为啥使用sass",normalizedTitle:"为啥使用sass？",charIndex:31631},{level:2,title:"静态布局",slug:"静态布局",normalizedTitle:"静态布局",charIndex:31803},{level:2,title:"自适应布局",slug:"自适应布局",normalizedTitle:"自适应布局",charIndex:31843},{level:2,title:"响应式布局",slug:"响应式布局",normalizedTitle:"响应式布局",charIndex:31914},{level:2,title:"弹性布局",slug:"弹性布局",normalizedTitle:"弹性布局",charIndex:32623},{level:3,title:"rem/em",slug:"rem-em",normalizedTitle:"rem/em",charIndex:32629},{level:3,title:"flex",slug:"flex-2",normalizedTitle:"flex",charIndex:5927},{level:2,title:"流式布局",slug:"流式布局",normalizedTitle:"流式布局",charIndex:31978},{level:2,title:"vw、vh",slug:"vw、vh",normalizedTitle:"vw、vh",charIndex:33392},{level:2,title:"换算",slug:"换算",normalizedTitle:"换算",charIndex:34086},{level:3,title:"JS直接实现",slug:"js直接实现",normalizedTitle:"js直接实现",charIndex:34304},{level:3,title:"SVG（可伸缩矢量图形）",slug:"svg-可伸缩矢量图形",normalizedTitle:"svg（可伸缩矢量图形）",charIndex:34339},{level:3,title:"CSS3 transition",slug:"css3-transition",normalizedTitle:"css3 transition",charIndex:34454},{level:3,title:"transform(不是动画)",slug:"transform-不是动画",normalizedTitle:"transform(不是动画)",charIndex:34813},{level:3,title:"CSS3 animation3",slug:"css3-animation3",normalizedTitle:"css3 animation3",charIndex:35549},{level:3,title:"transition和animation区别",slug:"transition和animation区别",normalizedTitle:"transition和animation区别",charIndex:36058},{level:3,title:"Canvas",slug:"canvas",normalizedTitle:"canvas",charIndex:36346},{level:3,title:"requestAnimationFrame",slug:"requestanimationframe",normalizedTitle:"requestanimationframe",charIndex:37044},{level:3,title:"RAF、setTimeout",slug:"raf、settimeout",normalizedTitle:"raf、settimeout",charIndex:37628},{level:3,title:"setInterval",slug:"setinterval",normalizedTitle:"setinterval",charIndex:38515},{level:2,title:"JS动画",slug:"js动画",normalizedTitle:"js动画",charIndex:38617},{level:2,title:"CSS动画",slug:"css动画",normalizedTitle:"css动画",charIndex:36034},{level:2,title:"单行溢出",slug:"单行溢出",normalizedTitle:"单行溢出",charIndex:38843},{level:3,title:"white-space",slug:"white-space",normalizedTitle:"white-space",charIndex:29291},{level:2,title:"多行溢出",slug:"多行溢出",normalizedTitle:"多行溢出",charIndex:39482},{level:2,title:"💚 超出自动换行",slug:"超出自动换行",normalizedTitle:"💚 超出自动换行",charIndex:39597},{level:2,title:"reflow",slug:"reflow",normalizedTitle:"reflow",charIndex:39839},{level:2,title:"repaint",slug:"repaint",normalizedTitle:"repaint",charIndex:40827},{level:2,title:"合成",slug:"合成",normalizedTitle:"合成",charIndex:28465},{level:2,title:"优化",slug:"优化",normalizedTitle:"优化",charIndex:28318},{level:2,title:"client 主要与可视区有关",slug:"client-主要与可视区有关",normalizedTitle:"client 主要与可视区有关",charIndex:42233},{level:2,title:"offset 主要与自身有关",slug:"offset-主要与自身有关",normalizedTitle:"offset 主要与自身有关",charIndex:42281},{level:2,title:"scroll 滚动系列",slug:"scroll-滚动系列",normalizedTitle:"scroll 滚动系列",charIndex:43107},{level:2,title:"共同点",slug:"共同点",normalizedTitle:"共同点",charIndex:43345},{level:2,title:"window相关宽高属性",slug:"window相关宽高属性",normalizedTitle:"window相关宽高属性",charIndex:43370}],headersStr:"getComputedStyle？ font 伪元素和伪类 默认！标准(content-box) IE 怪异(border-box) link是行内吗？ link的伪类？ 定位流 浮动流 正常文档流 带来的问题 清除浮动 创建 取值 层叠上下文和层叠等级 层叠顺序 压盖顺序 JS实现sticky 创建 特点 应用 不定宽高 水平局中 内联 水平居中 垂直居中 绝对居中——兼容性好的属性 块级 水平居中 垂直居中 冷门方式 圣杯布局(左右float+负margin) 双飞翼布局(左右float+中margin) 两边absolute+中margin 绝对定位 BFC table flex grid 父容器 flex-direction flex-wrap flex-flow(简写属性) justify-content align-items align-content 子容器 order flex-grow flex-shrink flex-basis flex:1 aline-self place-items 可继承 不可继承 🍅line-height继承？ block，inline，inline-block 行内元素支持宽高 解决 less sass 相同 区别 为啥使用Sass？ 静态布局 自适应布局 响应式布局 弹性布局 rem/em flex 流式布局 vw、vh 换算 JS直接实现 SVG（可伸缩矢量图形） CSS3 transition transform(不是动画) CSS3 animation3 transition和animation区别 Canvas requestAnimationFrame RAF、setTimeout setInterval JS动画 CSS动画 单行溢出 white-space 多行溢出 💚 超出自动换行 reflow repaint 合成 优化 client 主要与可视区有关 offset 主要与自身有关 scroll 滚动系列 共同点 window相关宽高属性",content:'writing-mode:vertical-lr ;改变文字的显示方向\n\n\n# CSS3新属性\n\n * 弹性盒布局\n\n三个边框属性\n\n * border-radius：圆角边框\n * box-shadow：添加阴影\n * border-image：使用图片绘制边框\n\n> box-shadow\n\n设置元素阴影，设置属性如下：\n\n * 水平阴影\n * 垂直阴影\n * 模糊距离(虚实)\n * 阴影尺寸(影子大小)\n * 阴影颜色\n * 内/外阴影\n\n其中水平阴影和垂直阴影必须设置\n\n> 过渡\n\ntransition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)\n\n\n1\n\n\n/*宽度从原始值到制定值的一个过渡，运动曲线ease，运动时间0.5秒，0.2秒后执行过渡*/\ntransition：width,.5s,ease,.2s\n\n\n1\n2\n\n\n/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/\ntransition：all,.5s\n\n\n1\n2\n\n\n也可分开写\n\ntransition-property: width;\ntransition-duration: 1s;\ntransition-timing-function: linear;\ntransition-delay: 2s;\n\n\n1\n2\n3\n4\n\n\ntext-justify 改变字与字之间的间距使得每行对齐\n\nword-wrap:normal | break-word，检索或设置对象中的单词之间间隔\n\noutline：CSS2 的复合属性。设置或检索对象外的线条轮廓。outline画在border外面\n\n处理文字溢出时使用 text-overflow ，文字突破限制12像素使用 transform: scale（0.5）\n\n\n# getComputedStyle？\n\n * 普通： 获取当前元素所有最终CSS属性值，等价document.defaultView.getComputedStyle\n * 详细： window.getComputedStyle(elem,null).getPropertyValue("height")可能的值为 100px，就算是css上写的是 inherit， getComputedStyle也会把它最终计算出来。不过注意，如果元素的背景色透明， getComputedStyle获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色\n * getComputedStyle会引起回流，因为它需要获取祖先节点的一些信息计算（譬如宽高等），慎用，回流引起性能问题。合适的话会将话题引导回流，重绘，浏览器渲染原理等等。也可以列举一些其它会引发回流的操作，如 offsetXXX， scrollXXX， clientXXX， currentStyle等\n\n\n# font\n\nfont:italic 20px/1.5 arial;\n\n\n1\n\n\n是 font-style, font-variant, font-weight, font-size, line-height 和 font-family 的简写\n\nvertical-align：指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式\n\ntext-indent：定义一个块元素首行文本内容之前的缩进量\n\n\n# 选择器优先级\n\n比较规则是: 从左往右比较 ，较大者胜，如果相等，则继续往右移动一位比较 。如果4位全部相等，后面覆盖前面\n\n内联>id> 类(属性、伪类) > 标签(伪元素)>通配符\n\n\n1\n\n\n内联——CSS直接写在HTML标签中\n\n嵌入 ——CSS写在style标签中\n\n内联>嵌入>外部\n\n\n\n> 内联样式： 1000；如 style="color: green"；\n> \n> ID ： 100\n> \n> 类、属性、伪类： 10，如.foo, :first-child, div[class="foo"]\n> \n> 标签、伪元素：1，如 div::first-line\n> \n> 通配符、子类、兄弟，如* > +：0\n> \n> 继承样式没有权值\n> \n> 加有!important的权值最大，优先级最高\n\n“[id=p33]”形式的选择器被视为属性选择器(权值为10)，即使id属性在源文档的文档类型中被定义为“id选择器”\n\n * *通配符 和关系选择符(+ > ~ \'\' ||)和否定伪类(:not()) 对优先级没影响，但 :not 内部声明的选择器会影响优先级\n\n> 注意事项\n\n * !important优先级最高。避免使用，会破坏样式表中固有的级联规则！！\n * 一定要优先考虑使用样式规则的优先级来解决问题而不是 !important\n * 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important\n * 永远不要在插件中使用 !important\n * 不在全站范围使用 !important\n * 样式表来源不同时 优先级顺序为：内联>内部>外部>浏览器用户自定义>浏览器默认\n\n兄弟 li ~ a\n\n相邻兄弟 li + a\n\n后代 li a\n\n儿子 li>a\n\n属性选 a[rel="external"]\n\n伪类 a:hover, li:nth-child\n\n通配 *{}\n\n类型h1{}\n\n:link ：选择未被访问的链接\n:visited：选取已被访问的链接\n:active：选择活动链接\n:focus ：选择具有焦点的\n:first-child：父元素的首个子元素\n\n\n1\n2\n3\n4\n5\n\n * 伪元素\n\n::first-letter ：用于选取指定选择器的首字母\n::first-line ：选取指定选择器的首行\n::before : 选择器在被选元素的内容前面插入内容\n::after : 选择器在被选元素的内容后面插入内容\n\n\n1\n2\n3\n4\n\n\nbackground:red;这个样式从表面来说，和background-color:red;一样的效果，使用复合写法，不光加载背景颜色样式，还加载了其他样式——非常不合理！！\n\n\n# 伪元素和伪类\n\n(:)用于伪类，(::)用于伪元素\n\n伪元素：设置元素指定部分的样式，::after，::first-line，::first-letter ，::before\n\n伪类：定义元素的特殊状态，常见的有 :hover，:active，:checked，:focus，:first-child\n\n操作文档已有的元素\n\n\n# 🍅盒模型\n\n\n# 默认！标准(content-box)\n\nwidth只包含内容宽度，不包含border和padding\n\n盒子总宽度=margin+border+padding+width\n\n> box-sizing 属性以特定的方式定义某个区域特定元素，设置对象的盒模型组成模式\n\nbox-sizing: content-box;//定义引擎如何计算元素的总高度和总宽度\n\n\n1\n\n * content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致\n * border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致\n * inherit 指定 box-sizing 属性的值，从父元素继承\n\n\n# IE 怪异(border-box)\n\nwidth=content+padding+border\n\n盒子总宽度=margin+width\n\nbox-sizing:border-box;\n\n\n1\n\n\n\n# link、@import\n\n都是外部引用CSS的方式\n\n * link是XHTML标签，除加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS\n * link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载\n * link无兼容问题；@import在CSS2.1提出，低版本的浏览器不支持\n * link支持使用JS控制DOM改变样式；而@import不支持\n\nlink 权重高于@import\n\n\n# link是行内吗？\n\n个人觉得啥也不是，就是个 空标签\n\n\n# link的伪类？\n\n<div id="content">\n        <h3>\n            <a class="a1" href="#">\n                a标签伪类link，hover，active，visited，focus区别\n            </a>\n    </h3>\n</div>  \n<style>\na.a1:link{        /*链接未被访问时的状态*/\n  color: blue;\n}\na.a1:visited{     /*链接访问后的状态*/\n  color: green;  \n}\na.a1:hover{       /*鼠标悬浮的状态*/\n  color: red;\n}\na.a1:focus{       /*鼠标点击后，刚松开的状态*/\n color: orange;   \n}\na.a1:active{      /*点击中的状态，鼠标未松开时*/\n  color: yellow;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\na:link 未设置超链接则无效\n\na:visited 针对URL，若两个a标签指向一个链接，点击一个另一个也有visited属性\n\n> LOVE AND HATE\n\n\n# 定位方案\n\n\n# 定位流\n\n元素的属性 position 为 absolute 或 fixed，绝对定位\n\n绝对/fixed 定位中 元素整体脱离普通流，绝对定位元素不会对其兄弟元素造成影响，元素具体的位置由绝对定位的坐标决定\n\n定位相对于它的包含块，设置top、bottom、left、right在二维空间进行定位；可使用z-index放置三维空间\n\n对 position: absolute，元素定位相对于上级元素最近的一个relative、fixed、absolute，如果没有则相对于body\n\n对position:fixed，正常来说相对于浏览器窗口定位，但是当元素祖先的 transform 属性非 none 时，相对于该祖先定位\n\n\n# 浮动流\n\n属于是 半脱离文档流，因为它仍然占据位置，其他的文本内容按照顺序排列\n\n元素首先按照普通流的位置出现，然后根据浮动的方向尽可能向左/右偏移**，效果与印刷排版中的文本环绕相似**\n\n\n# 正常文档流\n\n普通流就是指BFC中的FC\n\nFC(Formatting Context)——格式化上下文，是页面中的一块渲染区域，有一套渲染规则，决定其子元素如何布局，以及和其他元素之间的关系和作用\n\n普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程，行内元素水平排列，直到当行被占满然后换行。块级元素则被渲染为完整的新行\n\n除非指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定\n\ntext-align 属性规定元素中的文本的水平对齐方式\n\n\n# 浮动\n\n最初浮动 为了 解决左边图片，右边文字的需求\n\n浮动元素碰到包含它的边框或浮动元素的边框停留\n\n浮动元素不在文档流中，所以文档流的块框表现得像浮动框不存在\n\n块级元素认为浮动元素不存在，浮动元素会影响行内元素的布局，浮动元素通过行内元素间接影响包含块的布局\n\n1、脱离文档流，不影响普通元素布局\n\n2、内联排序，多个浮动的元素类似 行内元素\n\n> 浮动元素摆放遵循规则：\n\n * 尽量靠上\n * 尽量靠左\n * 尽量一个挨一个\n * 可能超出包含块\n * 不能超过所在行的最高点\n * 行内元素绕着浮动元素摆放\n\n\n# 带来的问题\n\n * 高度塌陷——因为子元素浮动脱离了文档流，无法撑起父元素\n * 与浮动元素同级的非浮动元素 紧随其后\n\n\n# 清除浮动\n\n容器高度auto，且容器中有浮动的元素，会导致 容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器之外 破坏 我们的布局——浮动溢出\n\n * 父级div定义height\n * 给父元素 添加clearfix(浮动类)——常用\n * 浮动元素末尾 加空div，设置clear:both——增加多余标签，不够优雅，不易维护，一般不采用(但非 不推荐)\n * 父级div定义zoom\n * 父级overflow：hidden/auto**（不推荐）**——BFC\n\n> 大型项目一般多层嵌套，若父元素设置浮动，父亲的父亲可能也要设置浮动，页面布局容易乱\n\n * 浮动元素容器添加浮动（不推荐，会使整体浮动，影响布局）\n * after伪元素清除浮动，元素尾部添加一个看不见的块元素清理浮动，设置clear:both（推荐）\n * before和after双伪元素清除浮动\n\n总结 3种\n\n1、clear属性\n\n2、BFC\n\n3、::after伪元素\n\n\n# 💙 层叠上下文\n\n * 普通元素的层叠等级优先由其所在的层叠上下文决定\n * 层叠等级的比较只有在当前层叠上下文才有意义\n * css3新属性也可以产生层级上下文\n * 两个兄弟元素，一个设置了background，一个设置了z-index:-1，background优先级低\n * z-index: auto不生成层叠上下文，z-index:0生成为0的层叠上下文\n   * 两个为0的z-index，后一个优先级大\n\n\n# 创建\n\n根元素（HTML）——根层叠上下文\n\n> 这就是为什么，绝对定位元素在left/top等值定位时，若没有其他定位元素限制，相对浏览器窗口定位的原因\n\n 1.  HTML\n 2.  定位(relative/absolute)且 z-index 不为 auto\n 3.  position为 fixed/sticky\n 4.  grid/flex 的子元素且z-index不为auto\n 5.  opacity 小于 1\n 6.  will-change 指定上述任意属性之一，即便你没有直接定义这些属性\n 7.  isolation为isolate\n 8.  mix-blend-mode 不是 normal\n 9.  reflection属性\n 10. overflow不为 visible\n 11. transform /filter / mask 不为 none\n\nbody的子元素，该元素的z-index为10？？？\n\n\n# z-index\n\n\n# 取值\n\n数字无单位\n\n * auto(默认)和其父元素一样的层叠等级\n\n * 整数\n\n * inherit继承\n\n\n# 层叠上下文和层叠等级\n\n\n\n对每一个网页来说，默认创建一个层叠上下文(可类比一张桌子)，这个桌子就是html元素，html元素的所有子元素都位于这个默认层叠上下文中的某个层叠等级(类似于桌子上放了一个盆儿，盆上放了一个果盘，果盘上放了一个水杯……)\n\n将元素的z-index属性设置为非auto时，会创建一个新的层叠上下文，它及其包含的层叠等级独立于其他层叠上下文和层叠等级(类似于搬了一张新桌子过来，和旧桌子完全独立)\n\n\n# 层叠顺序\n\ndiv默认在html之上，及div的层级高于html\n\n一个层叠上下文可能出现7个层叠等级，从低到高排列为\n\n 1. 背景和边框\n 2. z-index为负数\n 3. block盒模型(位于正常文档流，块级，非定位)\n 4. float盒模型(浮动，非定位)\n 5. inline盒模型(位于正常文档流，内联，非定位)\n 6. z-index=0\n 7. z-index为正数(数值越大越靠上方)\n\n\n\n\n# 压盖顺序\n\n自定义压盖顺序：使用属性z-index\n\n * 不只有定位元素(position属性明确设置为absolute、fixed或relative)可使用z-index，后来更新了，flex也可以\n * 如果z-index值相同，html结果在后面的压盖住在前面的\n * 父子都有z-index，父亲z-index数值小时，儿子数值再大没用\n\n> 为啥定位元素会层叠在普通元素之上？\n\n因为元素一旦成为定位元素，z-index自动生效，默认auto，即0级别，就会覆盖inline、block和float元素\n\n层叠上下文和定位元素一个层叠顺序，发生层叠时，遵循"后来居上"\n\n\n# 🔥 position\n\n\n\nMDN参考-position\n\n1、relative：相对定位 给元素设置相对于原本位置的定位，不脱离文档流，原本位置被保留，其他元素位置不受影响。body默认relative，子绝父相\n\n使用top bottom left right 移动位置后不会改变？？？？？？其所占空间位置，可使用z-index属性\n\n2、absolute：***脱离文档流，影响页面布局***，相对于包含块偏移（包含块——最近的position不为static的外层元素），可使用top bottom left right z-index\n\n元素为absolute定位时，如果为内联元素，会变为块级元素；如果为块级元素，宽度由100%变位auto\n\n3、fixed：脱离文档流，相对于viewport定位。特殊版的 absolute，父元素使用transform时以父元素定位\n\n绝对定位将元素固定在相对于其位置最近的祖先，若没有，则为 初始包含它的块\n\n使用场景：侧边栏或者广告图\n\n4**、static：默认**。元素处于正常的文档流中，忽略 left、top、right、bottom 和 z-index 属性\n\n5、sticky：css3新增，粘性定位，relative和fixed的混合。正常情况保持原先布局(和relative相同)，到达边缘条件后，元素的表现情况和fixed一样，粘在某个位置\n\n使用场景 使导航栏随页面滚动直到特定点，然后粘贴到页面顶部\n\n> top影响定位元素垂直位置，对非定位元素没有影响\n> \n>  * position: absolute/fixed; top将元素上边缘设置为其最近定位祖先的上边缘上方/下方的单位\n>  * position: relative; top使元素上边缘在其正常位置上方/下方移动\n>  * position: sticky; top当元素在视口内时，属性的行为类似于它的位置，当它在外面时它的位置是固定的\n>  * position：static; top无效\n\n * # JS实现sticky\n\n获取 dom相对于窗口的位置 ，获取元素大小及其相对视口的位置\n\n    function sticky(dom,height){\n      window.onscroll = function(){\n        const rect = dom.getBoundingClientRect();\n        if(rect.top <= height){\n          dom.style.position = \'fixed\'\n          dom.style.top = height + \'px\';\n        }else{\n          dom.style.position = \'relative\'\n          dom.style.top = height + \'px\'\n        }\n      }\n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n6、inherit：继承\n\n悬浮在右下角，随滚动而滚动\n\nposition: fixed;\nbottom: 0px;\nright: 0px;\n\n\n1\n2\n3\n\n\n\n# ✅ BFC\n\n> 块格式化上下文（Block Formatting Context）\n\nBFC 决定元素如何对其内容定位，及与其他元素的关系和相互作用，是一个独立的容器，元素按照一定规则布局，与其他环境元素的布局互不影响\n\n除了 BFC，还有：\n\n * IFC（行级格式化上下文）- inline 内联\n * GFC（网格布局格式化上下文）- display: grid\n * FFC（自适应格式化上下文）- display: flex或display: inline-flex\n\n注意：同一个元素不能同时存在于两个 BFC 中\n\n\n# 创建\n\n * html根元素\n * float 不为 none\n * display： inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid\n * position ： absolute、fixed\n * overflow 值不为 visible，即为 auto、scroll、hidden\n\n\n# 特点\n\n * 垂直方向上，自上而下，与文档流排列方式一致\n\n * 同一 BFC 下的相邻块级元素可能发生margin折叠，创建新的 BFC 可以避免margin折叠\n\n * BFC不与浮动容器重叠\n   \n   * 两栏布局\n   \n   * float + overflow:hidden\n\n * 计算BFC高度时，浮动元素！参与！！计算\n\n * 每个元素的左margin和容器的左border相接触，即 每个元素的外边距盒（margin box）的左边与包含块边框盒（border box）的左边相接触（从右向左的格式的话，则相反），即使存在浮动\n\n\n# 应用\n\n * 解决margin重叠\n   * 块级元素的上外边距和下外边距合并（或折叠）为一个外边距，取其中较大者——外边距折叠，这个发生在属同一 BFC 下的块级元素间\n   * 解决：两个元素变成两个BFC\n * 左列浮动，右列 overflow: hidden; 触发BFC\n * 父子元素margin重叠\n   * 如果父元素与其第一/最后一个子元素间不存在边框、内边距、行内内容，没有创建 块格式化上下文/清除浮动将两者外边距 分开，子元素的外边距会“溢出”到父元素的外面\n   * 解决\n     * 父元素触发BFC\n     * 父元素添加border\n     * 父元素添加padding\n\n\n   /**\n    本来父元素距离顶部只有 20px，被子元素溢出影响，外边距重叠，取较大的值，则距离顶部 30px\n     */\n    #parent {\n        width: 200px;\n        height: 200px;\n        background-color: green;\n        margin-top: 20px;\n        overflow: hidden;\n    }\n    #child {\n        width: 100px;\n        height: 100px;\n        background-color: red;\n        margin-top: 30px;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 清除浮动，解决父元素高度塌陷\n   * 子元素浮动，脱离文档流，父元素高度只有边框部分高度\n   * clear:both；overflower:hidden；display: flow-root\n * 其他盒子看不见被float的元素，但是其他盒子里的文本看得见\n\n文字环绕效果\n\n第二个元素被浮动元素遮盖部分，但是——文字不会被覆盖，因为文字看得见被float的元素，需要避开元素被覆盖，可触发 第二个元素的BFC，加入overflow:hidden\n\n> 还可实现 自适应两栏布局\n\n\n# 居中\n\n\n# 不定宽高\n\n\n * # 水平局中\n\n * 定位+margin:auto\n\n * 定位+transform\n\n * 定位+margin:负值\n\n * flex布局\n\n * grid布局\n\n\n# 内联\n\n\n * # 水平居中\n\n * 行内元素可设置：text-align: center\n\n * flex布局设置父元素：display: flex; justify-content: center\n\n\n * # 垂直居中\n\n * 单行文本父元素确认高度：height === line-height\n\n * 多行文本父元素确认高度：disaply: table-cell; vertical-align: middle\n\n\n * # 绝对居中——兼容性好的属性\n\n<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        .a{\n            display:inline-block;\n            text-align:center;\n            width:100px;\n            height:100px;\n            background-color:yellow;\n        }\n        .a::before {\n            content: \'\';\n            display: inline-block;\n            height: 100%;\n            vertical-align: middle;\n        }\n        .b{\n            /*vertical-align需要参考的对象，因此在前面插入内容比较*/\n            vertical-align:middle;\n        }\n    </style>\n</head>\n<body>\n<span class="a">\n\t<span class="b">luo</span>\n</span>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 块级\n\n\n * # 水平居中\n\n * absolute+margin auto ，宽高固定，对应方向平分\n\n        .box {\n            position: relative;\n            background-color: green;\n        }\n        .small {\n            background-color: red;\n            position: absolute;\n            top: 0;\n            right: 0;\n            bottom: 0;\n            left: 0;\n            margin: auto;\n            width: 100px;\n            height: 100px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * absolute+calc\n\n .box {\n            position: relative;\n            background-color: red;\n        }\n        .small {\n            background-color: green;\n            position: absolute;\n            top: calc(50% - 50px);\n            left: calc(50% - 50px);\n            width: 100px;\n            height: 100px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * absolute+负margin， left: 50% 和 top: 50% 将子元素左上角移到父元素中心位置，margin-left 和 margin-top 以子元素自身一半宽高负值赋值（PC端有兼容性要求推荐）\n\n .box {\n            position: relative;\n            background-color: red;\n        }\n        .small {\n            background-color: black;\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            margin: -50px 0 0 -50px;\n            width: 100px;\n            height: 100px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n * # 垂直居中\n\n\n\n * position: absolute设置left、top、margin-left、margin-top(定高)\n * display: table-cell\n * transform: translate(x, y)\n * flex(不定高，不定宽)\n * grid(不定高，不定宽)，兼容性相对比较差\n\n\n# 💚 绝对居中\n\n * 定位+transform: translate(-50%,-50%)，translate属性值百分比基于自身宽高计算得出\n\n        .box{\n            background-color: red;\n            position: relative;\n            width: 100px;\n            height: 100px;\n        }\n        .small{\n            background-color: green;\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%,-50%);\n            width: 50px;\n            height: 50px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 父元素text-align为center水平局中；子元素设置inline-block和vertical-align:middle垂直居中，line-height继承父元素\n\n        .box{\n            background-color: red;\n            line-height: 100px;\n            text-align: center;\n        }\n        .small{\n            width: 50px;\n            height: 50px;\n            background-color: green;\n            vertical-align: middle;\n            display: inline-block;\n            line-height: inherit;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * table table-cell，使用table属性，但不想写table元素（PC端有兼容性要求推荐）\n\n        .box {\n            display: table-cell;\n            text-align: center;\n            vertical-align: middle;\n            background-color: red;\n            width: 100px;\n            height: 100px;\n        }\n        .small {\n            width: 50px;\n            height: 50px;\n            display: inline-block;\n            background-color: green;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * table PC有兼容性要求，宽高不固定，推荐\n * flex（PC端无兼容性要求，不考虑IE的话，grid也可）（移动端使用推荐，grid作为备选）\n\n .box {\n            display: flex;\n            justify-content: center;\n            background-color: red;\n            width: 100px;\n            height: 100px;\n        }\n        .small {\n            width: 20px;\n            height: 20px;\n            align-self: center;\n            background-color: green;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * flex +margin:auto，兼容性好\n * grid + align-items兼容性不行，和flex相似\n\n.box {\n    display: grid;\n    justify-items: center;\n    align-items: center;\n}\n\n\n1\n2\n3\n4\n5\n\n\n        .box {\n            display: grid;\n            background-color: red;\n            width: 100px;\n            height: 100px;\n        }\n        .small {\n            width: 50px;\n            height: 50px;\n            background-color: green;\n            justify-self: center;\n            align-self: center;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n.box {\n    display: grid;\n    justify-items: center;\n}\n.small {\n    align-self: center;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 冷门方式\n\n伪类元素\n\ngrid-container\n\ngrid-template-rows\n\n> 注意\n\n不要float 、position一起用\n\n不要对display:table-cell使用百分比设置宽高\n\n\n# 两栏布局\n\n左边宽度固定，右边宽度自适应\n\n * 利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1\n * 利用浮动。左边元素宽度为200px+左浮动。右边元素的margin-left为200px+宽度为auto（默认为auto，撑满整个父元素），需要设置高度。margin-left/padding-left/calc\n * 利用浮动。左元素宽度固定 ，向左浮动。右侧元素 overflow: hidden; 右边触发了 BFC ，BFC 的区域不会与浮动元素重叠，所以两侧不会重叠 float + overflow:hidden\n\n .left {\n        background-color: #3e8dce;\n        float: left;\n        height: 200px;\n        width: 400px;\n        margin-right: 20px;\n    }\n\n    .right {\n        background-color: red;\n        overflow: hidden;\n        height: 300px;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n左列左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行位置\n\n右列利用自身流特性占满整行\n\n右列设置overflow，触发BFC特性，使自身和左列浮动元素隔开，不占满整行\n\n * 绝对定位 父级相对定位 左边absolute定位，宽度固定。设置右边margin-left为左边元素的宽度值。\n * 绝对定位，父级元素相对定位。左边元素宽度固定，右边元素absolute定位，left为宽度大小，其余方向为0。(有歧义，谨慎使用!)\n * 使用 calc 计算\n\n.left {\n  display: inline-block;\n  width: 240px;\n}\n.right {\n  display: inline-block;\n  width: calc(100% - 240px);\n}\n//使用 calc() 函数计算 <div> 元素的宽度\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * grid\n\ngrid-template-columns: minmax(<min>, <max>) …)\n\n.par{\n    display:grid;\n    grid-template-columns:minmax(150px,25%) 1fr;\n}\n\n\n1\n2\n3\n4\n\n\n将最小侧边栏大小设置为150px，但在更大的屏幕上，让它伸展出25%。侧边栏将始终占据父级水平空间的25%，直到25%变得小于150px。\n\n\n# 🍅三栏布局\n\n其中一列宽度自适应\n\n\n# 圣杯布局(左右float+负margin)\n\n缺点：需要多加一层标签，html顺序不对，占用了布局框的margin属性\n\n核心是左、中、右 三栏都通过float浮动，通过负margin调整\n\n * center使用双层标签，外层浮动，以便左中右能在同一行显示\n * 左margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧\n * 右margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<style>\n    .container{\n        font-size: 26px;\n        color: white;\n    }\n    .left,\n    .main,\n    .right{\n        height: 300px;\n    }\n    .main-warpper{\n        float: left;\n        width: 100%;\n    }\n    .left,\n    .right{\n        float: left;\n        width: 200px;\n        margin-left: -100%;\n        background-color: green;\n    }\n\n    .right {\n        margin-left: -200px;\n        /*同自身宽度*/\n    }\n\n    .main {\n        margin: 0 210px;\n        background-color: red;\n    }\n</style>\n<body>\n<div class="container">\n    <div class="main-warpper">\n        <div class="main">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Animi asperiores assumenda, at autem consequatur cum eaque, eius est eveniet fugit id itaque necessitatibus perferendis perspiciatis quia, ratione sint temporibus voluptatum?</div>\n    </div>\n    <div class="left">左边固定宽度</div>\n    <div class="right">右边固定宽度</div>\n</div>\n</body>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n缺点：\n\n * 增加了一层，结构变复杂\n * 使用负margin，相对麻烦\n\n\n# 双飞翼布局(左右float+中margin)\n\n> 双飞翼布局——圣杯布局的改进方案\n\n双飞翼布局前两步和圣杯布局一样，只是处理中间栏部分内容被遮挡问题的解决方案有所不同：\n\n既然main部分的内容会被遮挡，就在main内部再加一个content，设置其margin避开遮挡\n\n原理：\n\n * 两变固定，中间自适应\n * 中间元素margin值控制两边间距\n * 宽度小于左右部分宽度之和时，右侧被挤下去\n\n缺点\n\n * html结构不正确，主体内容最后加载\n * float布局需要清除浮动，因为float会脱离文档流，造成高度塌陷\n * 右边在主体内容之前，若是响应式设计，不能简单的换行展示\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <style>\n        .main {\n            float: left;\n            width: 100%;\n        }\n        .content {\n            height: 200px;\n            margin-left: 110px;\n            margin-right: 220px;\n            background-color: green;\n        }\n        /*创建一个伪元素，作为已选中元素的最后一个子元素。*/\n        .main::after {\n            display: block;\n            content: \'\';\n            font-size: 0;\n            height: 0;\n            /*在main后面加一个元素来清除浮动。*/\n            clear: both;\n            zoom: 1;\n        }\n        .left {\n            float: left;\n            height: 200px;\n            width: 200px;\n            margin-left: -100%;\n            background-color: red;\n        }\n        .right {\n            width: 200px;\n            height: 200px;\n            float: left;\n            margin-left: -200px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n<div>\n    <div class="main">\n        <div class="content"></div>\n    </div>\n    <div class="left"></div>\n    <div class="right"></div>\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n\n\n# 两边absolute+中margin\n\n基于绝对定位\n\n优点 快捷，方便，不容易出问题，你可以很快想出这种布局方式。要求父级要有非static定位，如果没有，左右框容易偏移出去\n\n缺点 绝**对定位脱离文档流，相对最近的已经定位的祖先元素定位，无需考虑HTML中顺序。**意味着下面的所有子元素也会脱离文档流，导致这种方法的有效性和可使用性比较差\n\n子绝父相，父元素设置为relative，左右两栏设置为absolute+中间一栏margin\n\n * 两边使用绝对定位，固定在两侧\n * 中间占满一行，通过margin和左右两边留出间隔\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<style>\n    .main {\n        position: relative;\n        font-size: 25px;\n        color: white;\n    }\n\n    .left,\n    .center,\n    .right {\n        height: 400px;\n    }\n\n    .left {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 300px;\n        background-color: red;\n    }\n\n    .right {\n        position: absolute;\n        right: 0;\n        top: 0;\n        width: 300px;\n        background-color: blue;\n    }\n\n    .center {\n        margin: 0 300px;\n        background-color: green;\n        /*overflow: auto;*/\n    }\n</style>\n<section class="main">\n    <div class="left">左边固定宽度</div>\n    <div class="center">中间自适应</div>\n    <div class="right">右边固定宽度</div>\n</section>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 绝对定位\n\n三栏均设置为absolute+left+right\n\n\n# BFC\n\n将main变成BFC，就不会和浮动元素重叠\n\n父元素设置overflow: hidden;\n\n\n# table\n\n优点 很少有人使用，flex布局不兼容的情况下table还可以尝试\n\n缺点 使用相对繁琐，代码量大，存在缺陷，当单元格的一个格子超出高度之后，两侧就会一起触发跟着一起变高\n\n * 最外层设置display:table，设置table-layout:fixed，表示列宽自身宽度决定，而不是自动计算\n * 内层的左中右设置 display:table-cell 为表格单元\n * 左右设置固定宽度，中间width:100%，填充剩下的宽度\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<style>\n    .table {\n        display: table;\n        width: 100%;\n        color: white;\n        font-size: 30px;\n        height: 400px;\n        table-layout: fixed;\n    }\n\n    .left,\n    .center,\n    .right {\n        display: table-cell;\n    }\n\n    .left ,\n    .right{\n        width: 200px;\n        background-color: green;\n    }\n    .center {\n        background-color: blue;\n    }\n\n</style>\n<div class="table">\n    <div class="left">左边固定宽度</div>\n    <div class="center">中间自适应</div>\n    <div class="right">右边固定宽度</div>\n</div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# flex\n\n利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1（flex: 1; === flex: 1 1 auto）\n\n * 盒内元素两端对齐，中间设为100%宽度或flex:1，即可填充空白\n * 盒内元素高度撑开容器高度\n\n优点：\n\n * 结构简单直观\n * 实现更多效果，order调整显示顺序，让主题内容优先加载，但显示在中间\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<style>\n    .flex {\n        display: flex;\n        justify-content: space-between;\n        color: white;\n        font-size: 30px;\n    }\n\n    .left,\n    .center,\n    .right {\n        height: 300px;\n    }\n\n    .left {\n        width: 100px;\n        background-color: blue;\n    }\n\n    .center {\n        /*flex: 1;*/\n\n        width: 100%;\n        margin: 0 20px;\n        background-color: green;\n    }\n\n    .right {\n        width: 300px;\n        background-color: red;\n    }\n</style>\n<section class="flex">\n    <div class="left">left</div>\n    <div class="center">center</div>\n    <div class="right">right</div>\n</section>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# grid\n\n优点 比较超前一点的布局自然有其独特的魅力\n\n缺点 兼容性\n\ngrid-template-columns 该属性是基于 网格列. 的维度，去定义网格线的名称和网格轨道的尺寸大小。\n\n用单位 fr 来定义网格轨道大小的弹性系数。 每个定义了 <flex> 的网格轨道会按比例分配剩余的可用空间。当外层用一个 minmax() 表示时，它将是一个自动最小值(即 minmax(auto, <flex>) ) .\n\n\n1\n2\n3\n\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n<style>\n    .grid {\n        display: grid;\n        /*grid-template-columns: 300px 3fr 300px;*/\n\n        grid-template-columns: 300px auto 300px;\n        width: 100%;\n\n        font-size: 30px;\n        color: white;\n    }\n    .left,\n    .center,\n    .right{\n        height: 400px;\n    }\n\n    .left {\n        background-color: red;\n    }\n\n    .center {\n        background-color:blue;\n    }\n\n    .right {\n        background-color:green;\n    }\n</style>\n<section class="grid">\n    <article class="left">\n        <h1>我是grid栅格布局左框</h1>\n    </article>\n    <article class="center">\n        <h1>我是grid栅格布局中间框</h1>\n    </article>\n    <article class="right">\n        <h1>我是grid栅格布局右框</h1>\n    </article>\n</section>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# ❤️ flex布局\n\n简便、完整、响应式地实现各种页面布局。为盒模型提供最大的灵活性\n\n会使元素变为块级元素\n\n> 父 子容器构成，通过主轴和交叉轴控制子容器布局，子元素float、clear和vertical-align属性失效\n\n\n# 父容器\n\n * flex-direction\n * flex-wrap\n * flex-flow\n * justify-content\n * align-items\n * align-content\n\n\n# flex-direction\n\n文字也会跟着flex-direction属性值排列，即，从左往右，从右往左……\n\n.container {   \n    flex-direction: row | row-reverse | column | column-reverse;  \n} \n\n\n1\n2\n3\n\n\n决定主轴方向，子元素的排列方向\n\n * row（默认值）：主轴为水平方向，起点在左端\n * row-reverse：主轴为水平方向，起点在右端\n * column：主轴为垂直方向，起点在上沿\n * column-reverse：主轴为垂直方向，起点在下沿\n\n\n# flex-wrap\n\n.container {  \n    flex-wrap: nowrap | wrap | wrap-reverse;\n}  \n\n\n1\n2\n3\n\n\n弹性元素永远沿主轴排列，如果主轴排不下，flex-wrap决定容器内项目是否可换行\n\n默认nowrap，但不会任由元素溢出，它会缩小以适应容器；若项目无法缩小，nowrap会溢出\n\n\n\n\n# flex-flow(简写属性)\n\n是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n\n当flex-grow之和小于1时，只能按比例分配部分剩余空间，而不是全部。\n\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n\n\n1\n2\n3\n\n\n\n# justify-content\n\n定义项目在主轴上对齐方式\n\n.box {\n    justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n\n\n1\n2\n3\n\n * flex-start（默认）：左对齐\n * flex-end：右对齐\n * center：居中\n * **space-between：**平分剩余空间，所以元素 间隔 相等\n * space-around：项目两侧间隔相等，平分剩余空间\n\n\n# align-items\n\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n\n\n1\n2\n3\n\n\n定义项目在交叉轴上如何对齐\n\n默认 垂直方向\n\n * flex-start：交叉轴的起点对齐\n * flex-end：交叉轴的终点对齐\n * center：交叉轴的中点对齐\n * baseline: 项目的第一行文字的基线对齐\n * stretch（默认）\n\n> 这就是为啥 flex元素会默认被拉伸到最高元素的高度，实际上，它们被拉伸来填满 flex容器——最高元素定义 容器高度\n\n\n\n\n# align-content\n\n.box {\n    align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n\n\n1\n2\n3\n\n\n定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n * flex-start：与交叉轴的起点对齐\n * flex-end：与交叉轴的终点对齐\n * center：与交叉轴的中点对齐\n * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布\n * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍\n * stretch（默认值）：轴线占满整个交叉轴\n\n\n# 子容器\n\n * order\n * flex-grow\n * flex-shrink\n * flex-basis\n * flex\n * align-self\n\n\n# order\n\n定义item排列顺序，越小越靠前，默认0\n\n> 可用空间\n> \n> flex子项目属性改变了flex容器中的可用空间\n\n\n# flex-grow\n\n定义项目延主轴 的放大比例（容器宽度>元素总宽度时如何伸展）\n\n默认0，存在剩余空间也不放大\n\nflex-warp：nowrap；不换行的时候，container宽度不够分时，弹性元素会根据flex-grow来决定\n\n如果所有项目的flex-grow为1，它们将平分可用空间\n\n如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍\n\n弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效\n\n\n# flex-shrink\n\n定义项目的缩小比例（容器宽度<元素总宽度时如何收缩），默认为1，即如果空间不足，该项目将缩小\n\nflex 元素仅在默认宽度之和大于容器的时候才会收缩\n\n> 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小\n> \n> 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小\n\n\n\n\n# flex-basis\n\n定义分配多余空间前，占据主轴空间 ，默认auto\n\n元素在主轴上的初始尺寸，初始尺寸——元素在flex-grow和flex-shrink生效前的尺寸\n\n> 这就解释了：我们只要给flex元素父元素声明display:flex，所有子元素就会排成一行，且自动分配大小 以 充分展示内容\n\n\n# flex:1\n\nflex 是 flex-grow、flex-shrink 和 flex-basis 的简写，默认为 0 1 auto。后两个属性可选\n\n0 1 auto\ngrow为0——flex元素不会超过他们basis的尺寸\nshrink为1——可以缩小flex元素防止溢出\nbasis为auto——flex元素可在主轴上设置，也可根据内容自动获得\n\n\n1\n2\n3\n4\n\n\n优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值\n\nflex: 1 = 1 1 0\n\nflex: 2 = 2 1 0\n\nflex: auto = 1 1 auto(既可以拉伸 也可以收缩)\n\nflex: none = 0 0 auto(不可伸缩)\n\n\n# aline-self\n\n默认值为auto，继承父元素的align-items属性，如果没有父元素，等同于stretch\n\n允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性\n\n左边固定右边自适应\n\n//垂直居中\nflex-direction:row/column;\nalign-items:center\n\n//水平局中\nflex-direction:row/column;\njustify-content:center;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nflex: 1 = flex: 1 1 0%\nflex: 2 = flex: 2 1 0%\nflex: auto = flex: 1 1 auto\nflex: none = flex: 0 0 auto，常用于固定尺寸不伸缩\n\n\n1\n2\n3\n4\n\n\n\n# place-items\n\n设置 align-items 和 justify-items 的快速方法\n\n\n# 隐藏元素\n\ndisplay:none\n\n * 不会在页面占据位置\n * 渲染树不会包含该渲染对象\n * 不会绑定响应事件\n * 会导致浏览器进行重排和重绘\n\nvisibility:hidden（性能更好，因为display引起页面回流，而visibility导致重绘）\n\n * 占据位置，不更改布局\n * 不会响应绑定事件\n * 不会重排但会重绘\n\nvisibility: visible;\nvisibility: hidden;\nvisibility: collapse;\n\n\n1\n2\n3\n\n\nopacity:0\n\n * 元素透明度设置为0\n * 占据位置\n * 能响应绑定事件\n * 不能控制子元素展示\n * 不会引发重排，一般会引发重绘\n\n> 如果利用 animation 动画，对 opacity 做变化（animation会默认触发GPU加速），则只会触发 GPU 层面的 composite，不会触发重绘\n\n设置height width为0\n\n将影响元素盒模型的属性设置为0，若有元素内有子元素或内容，应该设置其overflow:hidden来隐藏其子元素。\n\n * 元素不可见\n * 不占据空间\n * 不响应点击事件\n\nposition：absolute\n\n * 将元素移除可视区域\n * 元素不可见\n * 不影响页面布局\n\ntransform: scale(0,0)\n\n缩放为0\n\n * 占据位置\n\n * 不响应绑定事件\n\n * 不会触发浏览器重排\n\n              DISPLAY: NONE   VISIBILITY: HIDDEN   OPACITY: 0\n页面中           不存在             存在                   存在\n重排            会               不会                   不会\n重绘            会               会                    不一定\n自身绑定事件        不触发             不触发                  可触发\ntransition    不支持             支持                   支持\n子元素可复原        不能              能                    不能\n被遮挡的元素可触发事件   能               能                    不能\n\n> visibility:hidden、 display:none\n\n * 普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置\n * 进一步， display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大\n * 再进一步，当一个页面某个元素经常需要切换 display时如何优化，一般会用复合层优化，或者要求低一点用 absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流， absolute文档流，复合图层的区别，\n * 再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）\n\n> 上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖\n\n> opacity、rgba\n\nopacity 取值在0到1之间，0表示完全透明，1表示完全不透明\n\n.aa{opacity: 0.5;}\n\n\n1\n\n\nrgba中的R表示红色，G表示绿色，B表示蓝色，三种颜色的值都可以是正整数或百分数。A表示Alpha透明度。取值0~1之间，类似opacity\n\n.aa{background: rgba(255,0,0,0.5);}\n\n\n1\n\n\nrgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。\n\n**总结：**opacity会继承父元素的 opacity 属性，而RGBA设置的元素的后代元素不会继承不透明属性\n\n\n# 🙋 不可/可继承\n\n\n# 可继承\n\n * 字体属性\n\nfont-family\n\nfont-size\n\n * 元素可见性\n * 列表/列表 布局属性\n\nlinst-style\n\n * 生成内容属性\n * 光标属性\n * 文本系列属性\n\ntext-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：增加或减少单词间的空白（即字间隔） letter-spacing：增加或减少字符间的空白（字符间距） text-transform：控制文本大小写 direction：规定文本的书写方向 color：文本颜色\n\n\n# 不可继承\n\n * 盒子模型属性\n * display\n * 背景属性\n * 定位属性\n * 生成内容、轮廓样式、页面样式、声音样式\n * 文本属性\n\nvertical-align：垂直文本对齐\n\ntext-decoration：规定添加到文本的装饰\n\ntext-shadow：文本阴影效果\n\nwhite-space：空白符的处理\n\nunicode-bidi：设置文本的方向\n\nborder不可继承！\n\n\n# 🍅line-height继承？\n\n * 父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。\n * 父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。\n * 父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 fontSize * 200% 计算出来的值。\n\n\n# 💚 display\n\n属性值            作用\nnone           不显示，会从文档流中移除\nblock          块类型。默认宽度为父元素宽度，可设置宽高，换行显示\ninline         默认！！！行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示\ninline-block   默认宽度为内容宽度，可设置宽高，同行显示\nlist-item      像块类型一样显示，添加样式列表标记\ntable          作为块级表格显示，换行显示\ninherit        继承\n\n\n# block，inline，inline-block\n\nblock：占据一行，可以设置宽高、行高、内外边距\n\n<h1>~<h6>\n<p>\n<div>\n<ul>\n<ol>\n<li>\n<div>\n<dl>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ninline：占据一行的小部分，多个行内元素水平排版；可设置内外边距，但只对左右起作用；宽只和内容有关；只能容纳文本或其他行内元素；不可设置宽高\n\n<a >\n<strong>\n<b>\n<em>\n<i>\n<del>\n<span >\n<img> \n<input> \n<select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ninline-block：跟行内元素类似，可设置宽高，保留 上下 外边距/内边距，可设置margin-left，inline-block可设置padding-left\n\n> button ，img ， input, select, label，textarea\n\ninput元素的type属性——password、text、file、button\n\n\n1\n\n\n空元素\n\n<br> <hr> <img> <input> <link> <meta>\n\n\n1\n\n\n> 行内元素\n\n * 水平居中\n   \n   div{text-align:center} /*DIV内的行内元素均会水平居中*/ \n   \n   \n   1\n   \n\n * 垂直居中\n   \n   div{height:30px; line-height:30px} /*DIV内的行内元素均会垂直居中*/ \n   \n   \n   1\n   \n\n> 块级元素\n\n * 水平居中\n\ndiv p{margin:0 auto; width:500px} /*块级元素p一定要设置宽度，才能相当于DIV父容器水平居中*/\n\n\n1\n\n * 垂直居中\n\ndiv{width:500px} /*DIV父容器设置宽度*/      \ndiv p{margin:0 aut0; height:30px; line-height:30px} /*块级元素p也可以加个宽度，         以达到相对于DIV父容器的水平居中效果*/\n\n\n1\n2\n\n\n\n# 行内元素支持宽高\n\n\n# 💙 高度塌陷\n\n父元素的子元素脱离文档流，本身没设置高度，则它的高度=0\n\n\n# 解决\n\n 1. BFC\n 2. 新增一个空的div或伪元素，设置清除 ，clear:both;\n\n\n# margin合并\n\n外边框塌陷/外边距重叠，区别 高度塌陷！\n\n2个垂直margin相遇会形成一个外边距，合并后的，margin等于2个合并的margin高度中的较大值\n\n\n\n> 只有普通文档流中块级框的垂直margin才会发生重叠，行内框、浮动框或绝对定位 不会重叠\n\n不想要合并的元素可创建一个 BFC，即 在第一个元素新建一个空元素，配置 overflow: hidden\n\n\n# less、sass\n\n都是CSS预处理器。用专门的编程语言，进行web页面样式设计，再通过编译器转换为正常的css文件\n\n\n# less\n\n是一门CSS预处理语言，扩展了CSS语言，增加了变量等特性\n\n\n# sass\n\nSass 是一种编译成 CSS 的样式表语言\n\n变量、嵌套规则、混合、函数等，具有完全与 CSS 兼容的语法。助于保持大型样式表井井有条，共享设计变得容易\n\n\n# 相同\n\n 1. 混入(Mixins)——class中的class\n 2. 参数混入——可以传递参数的class，就像函数一样\n 3. 嵌套规则——Class中嵌套class，从而减少重复的代码\n 4. 运算——CSS中用上数学\n 5. 颜色功能——可以编辑颜色\n 6. 名字空间(namespace)——分组样式，从而可以被调用\n 7. 作用域——局部修改样式\n 8. JavaScript 赋值——在CSS中使用JavaScript表达式赋值\n\n\n# 区别\n\n主要不同是实现方式\n\n 1. Less基于JS，客户端处理\n 2. Sass基于Ruby，服务端处理\n 3. 变量：Less用@ Sass用$\n 4. Less没有输出设置\n 5. Sass支持条件语句，Less不允许\n 6. Less环境比Sass简单\n\n\n# 为啥使用Sass？\n\n 1. Compass使用Sass，成熟的框架\n 2. 国外讨论热度高\n 3. 学习教程好\n 4. Sass是成熟的CSS预处理器之一，维护好\n 5. Scss对sass语法做了改良\n\nSCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能\n\n\n# 🙋 移动端布局\n\n\n# 静态布局\n\n设置的长宽不变，不管屏幕多大，分辨率不会变\n\n会出现滚动条\n\n\n# 自适应布局\n\n元素位置会变 但大小不变\n\n兼容不同分辨率设备\n\n屏幕大了 会拥挤，只是长度或图片变小了，不会根据不同设备展示不同样式\n\n\n# 响应式布局\n\nContent is like water\n\n从以下几方面思考：\n\n * 弹性盒子和媒体查询\n * 百分比布局创建流式布局的弹性UI，使用媒体查询限制元素的尺寸和内容变更范围\n * 相对单位使得内容自适应\n\n缺点：\n\n * 仅适用布局、信息、框架并不复杂的部门类型网站\n * 兼容各种设备工作量大，效率低下\n * 代码累赘，出现隐藏无用的元素，加载时间加长\n * 一定程度上改变了网站原有的布局结构\n\n媒体查询/vw/vh\n\n根据用户行为和设备环境进行调整和响应，不同屏幕分辨率 不同展示方式\n\n一套代码兼容web端、平板、手机端\n\n> rem适配方案已被淘汰\n\n代替方案——viewport(视图 视窗\n\nviewport分为 layout viewport、visual viewport、 ideal viewport\n\n大部分浏览器把 viewport 的宽度设为 980px，浏览器默认视图叫 layout viewport，document.documentElement.clientWidth获取\n\nlayout viewport 的宽度远大于浏览器宽度，因此 我们需要新的 viewport 代表浏览器可视区域宽度，被称为 visual viewport ，使用 window.innerWidth 获取\n\n因为越来越多的网站都会为移动设备 单独设计，所以需要有一个能完美适配 移动设备的 ideal viewport\n\nideal viewport没有固定的尺寸，不同设备有不同的ideal viewport，iphone5 的 ideal viewport 是 320px\n\n\n# 弹性布局\n\nrem/em/flex\n\n * 关键元素高度和位置都不变，只有容器做伸缩变换\n * 开发原则：文字流式控件弹性，图片等比缩放\n\n\n# rem/em\n\nrem 布局原理——等比缩放\n\n根据根元素font-size 将font-size设置成屏幕宽度clientWidth和设计稿宽度 750 的比值，按照设计稿的尺寸重构页面，使用 rem 即 自动乘以 font-size计算出 适配不同屏幕的尺寸\n\n\n1\n2\n3\n\n\n// 以750设计稿，计算rem font-size\nlet clientWidth = document.documentElement.clientWidth || document.body.clientWidth;\nlet ft = (clientWidth / 7.5).toFixed(2);\n// 设置页面根字号\ndocument.documentElement.style.fontSize = ft + "px";\n\n\n1\n2\n3\n4\n5\n\n\n不同屏幕分辨率下元素的宽高等比例缩放\n\n完美适应屏幕宽高比\n\n\n# flex\n\nflex 简单、完整、响应式 实现各种布局\n\n可用于 三栏 布局、垂直水平居中布局\n\n\n# 流式布局\n\n百分比布局\n\n元素宽度按照屏幕分辨率适配调整，像瀑布一样往下流\n\n灵活、充分利用空间\n\n对大屏幕来说 体验不好\n\n类似 抖音 视频、微博消息、朋友圈等布局\n\n\n# 媒体查询\n\n不同条件下使用不同样式，页面在不同终端设备下达到不同效果\n\n允许添加表达式用以 媒体查询，选择不同样式表，自适应不同屏幕分辨率\n\n\n# ✅ 单位\n\npx % em 这几个单位，可以适用于大部分项目开发，且拥有较好兼容性\n\nCSS单位    \n相对长度单位   em、ex、ch、rem、vw、vh、vmin、vmax、%\n绝对长度单位   cm、mm、in、px、pt、pc\n\n * px 固定像素单位，一个像素表示终端屏幕能显示的最小的区域，无响应式\n\n * % ：元素的宽高可随浏览器的变化而变化，实现响应式，一般子元素的百分比相对于直接父元素\n\n * em 根据父元素 字体大小 设置，作为其他属性单位时，相对自身字体大小按比例计算\n\n * rem CSS3新增，基于 html 的大小设置字体大小，作用于根元素字体大小时，相对于其初始字体大小（16px）\n\nhtml {  font-size: 20px;}\n/* 作用于非根元素，相对于根元素字体大小，40px */\np {  font-size: 2rem;}\n\n\n1\n2\n3\n\n\n\n# vw、vh\n\n单位 vw、vh将 viewport(视图窗口)分为 一百份\n\n * 1vw 等于 视图单位的 1% 宽度\n * 1vh 等于 视图单位的 1% 高度\n\n设计稿视图Wie375px ，所以，1vw=3.75px\n\n在项目的index.html 的head标签中，添加以下代码\n\n<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">\n\n\n1\n\n * vm\n * rpx\n\nresponsive pixel（动态像素）\n\nrpx是微信小程序独有的，解决屏幕自适应\n\n小程序内部实现的响应式——rpx\n\n\n1\n\n\n根据屏幕宽度进行自适应，无论屏幕大小，规定屏幕宽度为750rpx\n\nrpx和px的换算\n\n> iPhone6的屏幕宽度为375px，有750个物理像素，则750rpx=375px=750个物理像素\n\n1rpx=0.5px=1物理像素\n\n1px=2rpx\n\n\n# 换算\n\nbrowser默认字体16px\n\n1em=16px\n\n12px=0.75em\n\n10px=0.625em\n\n\n# 🌈 动画\n\nCSS3动画优点\n\n 1. 性能好，浏览器会对CSS3的动画优化(如专门新建图层跑动画)\n 2. 代码相对简单\n\n\n# JS直接实现\n\nJS实现动画导致页面频繁性重排重绘，消耗性能\n\n\n# SVG（可伸缩矢量图形）\n\n 1. 控制动画延时\n 2. 控制属性的连续改变\n 3. 控制颜色变化\n 4. 控制如缩放，旋转等几何变化\n 5. 控制SVG内元素的移动路径\n\nSVG是对图形的渲染，HTML是对DOM的渲染\n\n\n# CSS3 transition\n\n过渡动画\n\n不能实现独立 动画，只能在某个标签 样式/状态改变时进行平滑 动画效果过渡， 不是马上改变\n\n注意\n\n移动端开发 直接使用transition 会让页面变慢甚至卡顿\n\n以我们通常 transform:translate3D(0,0,0)/transform:translateZ(0) 开启 GPU加速，让动画过程更加流畅\n\ntransition:transform 1s ease;\n\n\n1\n\n\nstyle="transform: translate(304px, 256px);"\n\n\n1\n\n\n动态改变transform的值，实现拖拽移动的效果\n\n使用场景：\n\n 1. 实现激活状态的过渡效果(宽度和透明度变化)\n 2. 和transform结合实现动画过渡\n\n\n# transform(不是动画)\n\ntransform: rotate(45deg) translateX(150px);\n/*先顺时针旋转45度，再向右下角平移150px*/\n\n\n1\n2\n\n\ntransform(变换、变形)是CSS3的属性\n\n给元素做 2D和3D 变换，,rotate(旋转),scale(缩放),skew(扭曲),translate(移动)和matrix(矩阵变换)\n\nthis.img.style.transform = `translate(${this.center.x}px,${this.center.y}px) scale(${this.scale}`; //先执行scale再执行前面，从后往前执行\n\n\n1\n\n\n> 矩阵\n\ntransform通过矩阵完成对元素的控制\n\n2x2的矩阵能够描述二维空间的变换\n\ngetComputedStyle 获取transform 属性， DOMMatrix 生成矩阵对象，方便获取矩阵参数\n\n使用场景：\n\n 1. transition和position: absolute;实现绝对居中\n 2. 放大，旋转，倾斜，矩阵变换 效果\n 3. js 改变transform属性值实现动画过渡效果\n\ntransform本身 没有过渡效果，它只是对元素做大小,旋转,倾斜等各种变换, 和transition/animation 结合,可以让 变换过程具有动画 效果, 通常只有一个到达态,中间态的过渡 通过和transition/animation 结合 ,也可 通过js设置定时器 实现\n\ntranslate是transform的属性值：2D变换\n\ntransition——动画展示过程，CSS3属性\n\n\n# CSS3 animation3\n\n算是真正意义的CSS3动画，定义动画过渡效果\n\n@(-webkit-)keyframes定义动画名称及 行为——>animation 相关属性定义动画的执行效果\n\n控制 关键帧和循环次数，元素根据设定好的样式改变进行平滑过渡\n\n比较\n\nCSS3最大的优势是摆脱了js的控制，利用硬件加速实现复杂动画效果\n\nCSS animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的简写形式\n\nanimation-name 属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列\n\nanimation-duration属性指定一个动画周期的时长\n\nCSS animation-timing-function属性定义CSS动画在每一动画周期中执行的节奏。\n\n\n# transition和animation区别\n\ntransition一般 定义单个或多个css属性 变化时的过渡动画，width,opacity。css属性变化时执行过渡动画，animation动画一旦定义，就在页面加载完成后自动执行\n\ntransition定义的动画触发一次执行一次,想要再次执行 再次触发\n\nanimation定义的动画可以指定播放次数或者无限循环播放\n\ntransition: 需要用户操作，执行次数固定\n\ntransition定义的动画只有两个状态，开始态和结束态\n\nanimation可以定义多个动画中间态，且可以控制多个复杂动画的有序执行\n\n\n# Canvas\n\nH5新增\n\n运行绘制图案，可用于 动画 游戏 数据可视化 图片编辑器 和实时视频处理等\n\n操作步骤\n\n 1. 创建canvas元素\n 2. JS获取canvas标签\n 3. 在canvas获取绘制工具\n 4. 绘制图形\n\n> 通过啥？？？？属性设置或返回如何将一个源图像绘制到目 标图像上——globalCompositeOperation\n> \n> https://blog.csdn.net/Yannnnnm/article/details/109256793\n\n只有width和height两个属性\n\nclearRect可用于清空整个canvas画布\n\nCanvas 绘图只有一个元素canvas，不能直接绑定事件\n\n> canvas有几种context\n\n> 2d context有什么信息\n\n开始于元素左上角，原点坐标是(0,0)\n\n> 画一个五角星\n\ncanvas、svg\n\nCANVAS         SVG\nJS动态生成元素       XML描述元素（类似HTML元素那样，可用多个元素来描述一个图形）\n位图（受屏幕分辨率影响）   矢量图（不受屏幕分辨率影响）\n不支持事件          支持事件\n数据发生变化需要重绘     不需要重绘\n\ncanvas依赖分辨率，放大会失真；SVG不会失真\n\ncanvas不支持事件处理器；SVG支持\n\ncanvas适合图像密集型的游戏、频繁绘制图像；SVG绘制复杂度高时渲染速度慢\n\ncanvas文本渲染能力弱；SVG有强文本渲染能力\n\ncanvas绘制的图形可保存为多种格式；SVG只能以.svg格式保存\n\n\n# requestAnimationFrame\n\nWeb API——请求动画帧，告诉浏览器 希望执行一个动画，且要求浏览器**重绘前**调用指定回调更新动画\n\n性能更好\n\n> 我们将执行动画的每一步传到requestAnimationFrame，每次执行完后异步回调来连续触发动画效果\n\n刷新频率即图像更新速度，屏幕上图像每秒出现次数(单位是HZ)，一般是60HZ，受屏幕分辨率、屏幕尺寸和显卡影响\n\n动画本质是 让人眼看到图像刷新引起的视觉效果，这个变化要 连贯、平滑地过渡\n\n在一帧(一般是16ms)间隔内根据选择浏览器情况执行相关动作\n\n**raf按照系统刷新的节奏调用！！**若刷新率为60HZ，回调就16.7ms执行一次，若刷新率是75HZ，时间间隔变为1000/75=13.3ms，所以它能保证回调在屏幕的每次刷新间隔被执行一次，不会引起丢帧和卡顿\n\n页面最小化或切换为后台标签时，不可见，触发visibilitychange并设置document.hidden为true\n\n> 执行过程\n\n 1. 判断document.hidden是否为false\n 2. 清空上一轮动画函数\n 3. 方法返回的handlerId和callback进入动画帧请求回调队列\n 4. 遍历回调列表，根据handlerId大小依次执行\n\nRAF既不是微任务，也不是宏任务\n\n\n# RAF、setTimeout\n\nsetTimeout设置间隔时间不断改变图像位置达到动画效果，可能出现卡顿、抖动现象\n\n原因\n\n * setTimeout时间不确定，setTimeout任务放进一步队列，只有主线程的任务执行完 才会检查该队列任务是否需执行，所以setTimeout的实际执行时间一般比其设定的时间晚\n * setTimeout只能设置固定时间间隔，不一定和屏幕刷新时间相同\n\n导致setTimeout执行步调和屏幕刷新步调不一致，引起 丢帧\n\n**setTimeout执行只是在内存中对图像属性作修改，这个变化必须等屏幕下次刷新才会更新！**若二者步调不一致，导致某一帧的操作被跨越，直接更新下一帧\n\nRAF最大优势——由系统决定回调执行时机，它保证回调在屏幕每一次的刷新间隔中执行一次，不引起丢帧，不会出现卡顿\n\nvar progress = 0;\n//回调函数\nfunction render() {  \n  progress += 1; //修改图像的位置  \n  if (progress < 100) {  //在动画没有结束前，递归渲染    \n    window.requestAnimationFrame(render); \n  }\n}\n//第一帧渲染\nwindow.requestAnimationFrame(render);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 优势\n\n * CPU节能\n\n页面被隐藏时，setTimeout仍然在后台执行动画任务，但是页面处于不可见/不可用状态，刷新没有意义，浪费资源\n\nRAF在页面未激活时 页面的屏幕刷新任务被被暂停，页面被激活时，动画从上次停留的地方继续执行\n\n * 函数节流\n\n高频率事件(scroll，resize)中，为防止一个刷新间隔内函数多次执行，使用RAF可保证 一个刷新间隔内，函数执行一次，保证流畅性，节省开销；多次绘制没有意义，因为显示器16.7ms才刷新一次\n\nRAF把每一帧的所有DOM操作集中，一次回流搞定，回流的时间间隔紧跟浏览器的刷新频率\n\n\n# setInterval\n\n和setTimeout问题一样，甚至更甚，执行会延迟，时间与一帧时间不一致，若添加当前setInterval事件，上一个还在任务队列未被执行，当前回调可能被丢弃\n\n\n# CSS、JS动画\n\n\n# JS动画\n\n 1. JS在主线程运行，主线程还有其他JS脚本需运行(样式计算、布局、绘制任务等)，对其干扰可能出现阻塞，造成丢帧\n\n 2. 代码复杂度高于CSS\n\n 3. JS动画控制能力强(开始、暂停、回放、终止、取消等)\n\n 4. 动画效果丰富\n\n 5. 大多没有兼容问题\n\n\n# CSS动画\n\n 1. 浏览器可对动画优化\n\n硬件加速，GPU提高性能\n\n 1. 运行控制过程较弱\n 2. 代码冗长\n\n\n# 🌰 文本溢出\n\n\n# 单行溢出\n\n * text-overflow：当文本溢出时，显示省略符号代表被修剪的文本\n * white-space：处理元素中的空白\n * overflow：文字长度超出限定宽度，隐藏超出的内容\n\noverflow:hidden，普通情况用在块级元素的外层隐藏内部溢出元素，或配合以下两个属性实现文本溢出省略\n\n> overflow 值可以是 auto、hidden 或 scroll\n\nwhite-space:nowrap，设置文本不换行，是overflow:hidden和text-overflow:ellipsis生效的基础\n\ntext-overflow属性值如下：\n\n * clip：对象内文本溢出部分裁掉\n * ellipsis：对象内文本溢出时显示...\n\n\n# white-space\n\n               换行符   空格和制表符   文字换行   行尾空格\nnormal         合并    合并       换行     删除\nnowrap         合并    合并       不换行    删除\npre            保留    保留       不换行    保留\npre-wrap       保留    保留       换行     挂起\npre-line       保留    合并       换行     删除\nbreak-spaces   保留    保留       换行     换行\n\n\n# 多行溢出\n\n> 基于高度截断\n\n伪元素+定位\n\n通过伪元素绝对定位到行尾并遮住文字，再通过overflow:hidden，隐藏多余文字\n\n优点\n\n * 兼容性好\n * 响应式截断，根据不同宽度做出调整\n\n> 基于行数截断\n\n\n# 💚 超出自动换行\n\n文字超出自动换行，white-space:normal(默认)\n\n英文\n\nword-break:break-all，以字母作为换行依据\n\nword-wrap: break-word，以单词作为换行依据\n\n\n# 渲染层合并\n\n浏览器在渲染HTML元素时，创建多个层绘制，在每个层绘制结束后，合并成一个完整图层，最终渲染到屏幕上\n\n\n# 🙋 重排、重绘和合成\n\n参考文档\n\n涉及页面生成过程\n\n回流一定触发重绘，重绘不一定触发回流。重绘开销小，回流代价高\n\n\n# reflow\n\n回流/重排\n\n元素的尺寸、结构或属性变化，re-render部分/全部文档，重新计算页面元素位置/几何结构的过程\n\n触发回流的操作:\n\n * 初次渲染\n\n * 窗口大小改变(resize事件)\n\n * 元素属性、尺寸、位置、内容改变\n\n * 元素字体大小变化\n\n * 添加或者删除可见 dom 元素\n\n * 激活 CSS 伪类(如 :hover)\n\n * 一个“即时性”和“准确性”。\n\n常见引起重排属性和方法               --                         --                   --\nwidth                     height                     margin               padding\ndisplay                   border-width               border               position\noverflow                  font-size                  vertical-align       min-height\nclientWidth               clientHeight               clientTop            clientLeft\noffsetWidth               offsetHeight               offsetTop            offsetLeft\nscrollWidth               scrollHeight               scrollTop            scrollLeft\nscrollIntoView()          scrollTo()                 getComputedStyle()   \ngetBoundingClientRect()   scrollIntoViewIfNeeded()                        \n\n修改样式时，**避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用，最好将值缓存起来。\n\n\n# repaint\n\n重绘\n\n元素的样式如 外观/风格 改变，但不影响其在文档流中的位置/布局，浏览器会对元素重新绘制\n\n不再执行布局阶段，直接进入绘制阶段\n\n属性：               --                 --                    --\ncolor             border-style       visibility            background\ntext-decoration   background-image   background-position   background-repeat\noutline-color     outline            outline-style         border-radius\noutline-width     box-shadow         background-size       \n\n\n# 合成\n\n利用transform、opacity和filter可实现合成效果，即GPU加速\n\n避开布局 分块和绘制阶段\n\n能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息改变、布局改变、颜色改变，都不会设计，涉及到的话就牵扯到重排或重绘了\n\n能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换不会影响到图层的内容\n\n比如滚动内容，页面内容没有变化，只是对图层做上下移动——这个操作直接在合成线程完成\n\n\n# 优化\n\n * 最小化重绘和重排：样式集中改变，使用添加新样式类名\n * absolute或 fixed使元素脱离文档流\n * GPU加速。transform opacity will-change等，改变元素位置，translate比使用绝对定位改变其left或top更高效，因为它不触发重排/重绘，**transform使浏览器为元素创建一个GPU图层，使得动画元素在一个独立的层中进行渲染，**当元素内容没有改变就没必要渲染\n * visibility替换 display: none ，前者引起重绘，后者引发回流（改变了布局）\n * DOM 离线修改，如：先把 DOM 设为display:none(有一次 Reflow)，然后修改再显示，只会触发一次回流\n * 不把 DOM 结点属性值放循环当成变量\n * 不使用 table 布局，很小的改动会造成整个 table 重新布局\n * 动画速度越快，回流次数越多，可使用 requestAnimationFrame\n * CSS 选择符从右往左匹配查找，避免节点层级过多\n * 浏览器可快速找到ID，ID最有效，同时可能牺牲语义和可维护性\n * 后代选择最糟糕\n * 伪类标签选择器非常消耗性能\n * 频繁运行的动画变为图层，能阻止该节点回流影响别的元素。对 video 标签，浏览器自动变为图层\n * documentFragment创建DOM文档片段，批量操作DOM，完成后再添加到文档，只触发一次回流\n\n> documentFragment不是ADOM的一部分，变化不会触发DOM树的re-render，不会导致性能问题\n> \n> 效果不甚明显，因为现代浏览器会使用队列存储储存多次修改进行优化\n\n\n# 📒 client、offset、scroll\n\n\n# client 主要与可视区有关\n\n客户区大小指的是元素内容及其内边距所占据空间大小\n\n\n\n\n# offset 主要与自身有关\n\n偏移量，可动态得到元素的位置（偏移），大小。**元素在屏幕上占用的所有可见空间。**元素高度宽度包括内边距，滚动条和边框\n\noffsetParent是一个只读属性，返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetParent 为最近的 table， td， th或body元素。当元素的 style.display 设置为 “none” 时，offsetParent 返回 null\n\n\n\n\n\n属性                     描述\nelement.clientWidth    获取元素可视区的宽度，不包括垂直滚动条\nelement.offsetWidth    获取元素的宽度= boder + padding + content\nelement.clientHeight   获取元素可视区的高度，不包括水平滚动条\nelement.offsetHeight   获取元素的高度= boder + padding + content\n\n * clientWidth 和 clientHeight 获取的值不包含边框\n * offsetWidth 和 offsetHeight 获取的值包含左右边框\n\n属性                   描述\nelement.clientTop    **获取元素的上边框宽度，**不包括顶部外边距和内边距，以 像素 表示！！不是 em！\nelement.clientLeft   获取元素的左边框宽度\nelement.offsetTop    获取元素到有定位的父盒子的顶部距离\nelement.offsetLeft   获取元素到有定位的父盒子的左侧距离\n\n属性          描述\ne.clientX   鼠标距离可视区的左侧距离\ne.clientY   鼠标距离可视区的顶部距离\n\n\n# scroll 滚动系列\n\n动态获得元素大小，滚动距离等。具有兼容问题\n\n\n\n * scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小\n * scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\n * 垂直滚动 scrollTop > 0\n * 水平滚动 scrollLeft > 0\n * 将元素的 scrollLeft 和 scrollTop 设置为 0，可以重置元素的滚动位置\n\n\n# 共同点\n\n返回数字时，均不带单位\n\n只读\n\n\n# window相关宽高属性\n\nwindow.innerHeight 窗口高度\n\nwindow.screen.availHeight声明显示浏览器的屏幕的可用高度，以像素计。除去我们底部任务栏外的屏幕高度\n\nwindow.screen.availWidth声明显示浏览器的屏幕的可用宽度，以像素计\n\n\n# padding百分比\n\npadding-top：数字/百分比(相对于relative的最近父元素计算高度)\n\n如**果父元素有宽度，相对于父元素宽度**，否则，找其父辈元素宽度，均没宽度时，相对于屏幕的宽度\n\n同理 margin的left 、right、bottom和top参考的都是width！！\n\n记错了，笔试还考过！\n\n> 为啥不是height\n\n正常流的大多数元素都足够高包含其子元素，若一个元素上下外边距是父亲的height的%，会导致死循环，父亲的height增加，以适应子元素上下外边距增加，相应的，上下外边距因为父亲height增加又增加……循环……\n\n> 使用场景\n\n移动端，手持设备屏幕宽度不同，不能给满屏图片设置固定宽高，此时padding起作用了\n\n给图片设置固定宽高比，也可以给图片外层加一个固定宽高比的盒子，实现图片 自适应\n\n\n# background-size\n\n设置背景图片大小。图片可以保有其原有的尺寸、拉伸到新的尺寸，或者在保持原有比例的同时缩放到元素的可用空间的尺寸\n\n div{\n            width: 300px;\n            height: 200px;\n            background: url("https://interview.yuadh.com/assets/2.jpg") no-repeat;\n            border: 1px solid red;\n            /*background-size: 100%;*/\n            background-size: cover;\n        }\n/*若图片宽度250px，宽度为250px，让该图片完全铺满整个div区域，设置background-size*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 属性\n\n100%：整个图片铺满div\n\ncover：整个图片铺满div，缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 相反，cover 尽可能大地缩放背景图像并保持图像的宽高比例（图像不会被压扁）。背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪\n\ncontain：不能铺满整个div，缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能地缩放背景并保持图像的宽高比例（图像不会被压缩）。背景图会填充所在容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）显示由 background-color 设置的背景颜色\n\nauto：不能铺满整个div，以背景图片比例缩放背景图片',normalizedContent:'writing-mode:vertical-lr ;改变文字的显示方向\n\n\n# css3新属性\n\n * 弹性盒布局\n\n三个边框属性\n\n * border-radius：圆角边框\n * box-shadow：添加阴影\n * border-image：使用图片绘制边框\n\n> box-shadow\n\n设置元素阴影，设置属性如下：\n\n * 水平阴影\n * 垂直阴影\n * 模糊距离(虚实)\n * 阴影尺寸(影子大小)\n * 阴影颜色\n * 内/外阴影\n\n其中水平阴影和垂直阴影必须设置\n\n> 过渡\n\ntransition： css属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)\n\n\n1\n\n\n/*宽度从原始值到制定值的一个过渡，运动曲线ease，运动时间0.5秒，0.2秒后执行过渡*/\ntransition：width,.5s,ease,.2s\n\n\n1\n2\n\n\n/*所有属性从原始值到制定值的一个过渡，运动曲线ease,运动时间0.5秒*/\ntransition：all,.5s\n\n\n1\n2\n\n\n也可分开写\n\ntransition-property: width;\ntransition-duration: 1s;\ntransition-timing-function: linear;\ntransition-delay: 2s;\n\n\n1\n2\n3\n4\n\n\ntext-justify 改变字与字之间的间距使得每行对齐\n\nword-wrap:normal | break-word，检索或设置对象中的单词之间间隔\n\noutline：css2 的复合属性。设置或检索对象外的线条轮廓。outline画在border外面\n\n处理文字溢出时使用 text-overflow ，文字突破限制12像素使用 transform: scale（0.5）\n\n\n# getcomputedstyle？\n\n * 普通： 获取当前元素所有最终css属性值，等价document.defaultview.getcomputedstyle\n * 详细： window.getcomputedstyle(elem,null).getpropertyvalue("height")可能的值为 100px，就算是css上写的是 inherit， getcomputedstyle也会把它最终计算出来。不过注意，如果元素的背景色透明， getcomputedstyle获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色\n * getcomputedstyle会引起回流，因为它需要获取祖先节点的一些信息计算（譬如宽高等），慎用，回流引起性能问题。合适的话会将话题引导回流，重绘，浏览器渲染原理等等。也可以列举一些其它会引发回流的操作，如 offsetxxx， scrollxxx， clientxxx， currentstyle等\n\n\n# font\n\nfont:italic 20px/1.5 arial;\n\n\n1\n\n\n是 font-style, font-variant, font-weight, font-size, line-height 和 font-family 的简写\n\nvertical-align：指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式\n\ntext-indent：定义一个块元素首行文本内容之前的缩进量\n\n\n# 选择器优先级\n\n比较规则是: 从左往右比较 ，较大者胜，如果相等，则继续往右移动一位比较 。如果4位全部相等，后面覆盖前面\n\n内联>id> 类(属性、伪类) > 标签(伪元素)>通配符\n\n\n1\n\n\n内联——css直接写在html标签中\n\n嵌入 ——css写在style标签中\n\n内联>嵌入>外部\n\n\n\n> 内联样式： 1000；如 style="color: green"；\n> \n> id ： 100\n> \n> 类、属性、伪类： 10，如.foo, :first-child, div[class="foo"]\n> \n> 标签、伪元素：1，如 div::first-line\n> \n> 通配符、子类、兄弟，如* > +：0\n> \n> 继承样式没有权值\n> \n> 加有!important的权值最大，优先级最高\n\n“[id=p33]”形式的选择器被视为属性选择器(权值为10)，即使id属性在源文档的文档类型中被定义为“id选择器”\n\n * *通配符 和关系选择符(+ > ~ \'\' ||)和否定伪类(:not()) 对优先级没影响，但 :not 内部声明的选择器会影响优先级\n\n> 注意事项\n\n * !important优先级最高。避免使用，会破坏样式表中固有的级联规则！！\n * 一定要优先考虑使用样式规则的优先级来解决问题而不是 !important\n * 只有在需要覆盖全站或外部 css 的特定页面中使用 !important\n * 永远不要在插件中使用 !important\n * 不在全站范围使用 !important\n * 样式表来源不同时 优先级顺序为：内联>内部>外部>浏览器用户自定义>浏览器默认\n\n兄弟 li ~ a\n\n相邻兄弟 li + a\n\n后代 li a\n\n儿子 li>a\n\n属性选 a[rel="external"]\n\n伪类 a:hover, li:nth-child\n\n通配 *{}\n\n类型h1{}\n\n:link ：选择未被访问的链接\n:visited：选取已被访问的链接\n:active：选择活动链接\n:focus ：选择具有焦点的\n:first-child：父元素的首个子元素\n\n\n1\n2\n3\n4\n5\n\n * 伪元素\n\n::first-letter ：用于选取指定选择器的首字母\n::first-line ：选取指定选择器的首行\n::before : 选择器在被选元素的内容前面插入内容\n::after : 选择器在被选元素的内容后面插入内容\n\n\n1\n2\n3\n4\n\n\nbackground:red;这个样式从表面来说，和background-color:red;一样的效果，使用复合写法，不光加载背景颜色样式，还加载了其他样式——非常不合理！！\n\n\n# 伪元素和伪类\n\n(:)用于伪类，(::)用于伪元素\n\n伪元素：设置元素指定部分的样式，::after，::first-line，::first-letter ，::before\n\n伪类：定义元素的特殊状态，常见的有 :hover，:active，:checked，:focus，:first-child\n\n操作文档已有的元素\n\n\n# 🍅盒模型\n\n\n# 默认！标准(content-box)\n\nwidth只包含内容宽度，不包含border和padding\n\n盒子总宽度=margin+border+padding+width\n\n> box-sizing 属性以特定的方式定义某个区域特定元素，设置对象的盒模型组成模式\n\nbox-sizing: content-box;//定义引擎如何计算元素的总高度和总宽度\n\n\n1\n\n * content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致\n * border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致\n * inherit 指定 box-sizing 属性的值，从父元素继承\n\n\n# ie 怪异(border-box)\n\nwidth=content+padding+border\n\n盒子总宽度=margin+width\n\nbox-sizing:border-box;\n\n\n1\n\n\n\n# link、@import\n\n都是外部引用css的方式\n\n * link是xhtml标签，除加载css外，还可以定义rss等其他事务；@import属于css范畴，只能加载css\n * link引用css时，在页面载入时同时加载；@import需要页面网页完全载入以后加载\n * link无兼容问题；@import在css2.1提出，低版本的浏览器不支持\n * link支持使用js控制dom改变样式；而@import不支持\n\nlink 权重高于@import\n\n\n# link是行内吗？\n\n个人觉得啥也不是，就是个 空标签\n\n\n# link的伪类？\n\n<div id="content">\n        <h3>\n            <a class="a1" href="#">\n                a标签伪类link，hover，active，visited，focus区别\n            </a>\n    </h3>\n</div>  \n<style>\na.a1:link{        /*链接未被访问时的状态*/\n  color: blue;\n}\na.a1:visited{     /*链接访问后的状态*/\n  color: green;  \n}\na.a1:hover{       /*鼠标悬浮的状态*/\n  color: red;\n}\na.a1:focus{       /*鼠标点击后，刚松开的状态*/\n color: orange;   \n}\na.a1:active{      /*点击中的状态，鼠标未松开时*/\n  color: yellow;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\na:link 未设置超链接则无效\n\na:visited 针对url，若两个a标签指向一个链接，点击一个另一个也有visited属性\n\n> love and hate\n\n\n# 定位方案\n\n\n# 定位流\n\n元素的属性 position 为 absolute 或 fixed，绝对定位\n\n绝对/fixed 定位中 元素整体脱离普通流，绝对定位元素不会对其兄弟元素造成影响，元素具体的位置由绝对定位的坐标决定\n\n定位相对于它的包含块，设置top、bottom、left、right在二维空间进行定位；可使用z-index放置三维空间\n\n对 position: absolute，元素定位相对于上级元素最近的一个relative、fixed、absolute，如果没有则相对于body\n\n对position:fixed，正常来说相对于浏览器窗口定位，但是当元素祖先的 transform 属性非 none 时，相对于该祖先定位\n\n\n# 浮动流\n\n属于是 半脱离文档流，因为它仍然占据位置，其他的文本内容按照顺序排列\n\n元素首先按照普通流的位置出现，然后根据浮动的方向尽可能向左/右偏移**，效果与印刷排版中的文本环绕相似**\n\n\n# 正常文档流\n\n普通流就是指bfc中的fc\n\nfc(formatting context)——格式化上下文，是页面中的一块渲染区域，有一套渲染规则，决定其子元素如何布局，以及和其他元素之间的关系和作用\n\n普通流中，元素按照其在 html 中的先后位置至上而下布局，在这个过程，行内元素水平排列，直到当行被占满然后换行。块级元素则被渲染为完整的新行\n\n除非指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 html 文档中的位置决定\n\ntext-align 属性规定元素中的文本的水平对齐方式\n\n\n# 浮动\n\n最初浮动 为了 解决左边图片，右边文字的需求\n\n浮动元素碰到包含它的边框或浮动元素的边框停留\n\n浮动元素不在文档流中，所以文档流的块框表现得像浮动框不存在\n\n块级元素认为浮动元素不存在，浮动元素会影响行内元素的布局，浮动元素通过行内元素间接影响包含块的布局\n\n1、脱离文档流，不影响普通元素布局\n\n2、内联排序，多个浮动的元素类似 行内元素\n\n> 浮动元素摆放遵循规则：\n\n * 尽量靠上\n * 尽量靠左\n * 尽量一个挨一个\n * 可能超出包含块\n * 不能超过所在行的最高点\n * 行内元素绕着浮动元素摆放\n\n\n# 带来的问题\n\n * 高度塌陷——因为子元素浮动脱离了文档流，无法撑起父元素\n * 与浮动元素同级的非浮动元素 紧随其后\n\n\n# 清除浮动\n\n容器高度auto，且容器中有浮动的元素，会导致 容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器之外 破坏 我们的布局——浮动溢出\n\n * 父级div定义height\n * 给父元素 添加clearfix(浮动类)——常用\n * 浮动元素末尾 加空div，设置clear:both——增加多余标签，不够优雅，不易维护，一般不采用(但非 不推荐)\n * 父级div定义zoom\n * 父级overflow：hidden/auto**（不推荐）**——bfc\n\n> 大型项目一般多层嵌套，若父元素设置浮动，父亲的父亲可能也要设置浮动，页面布局容易乱\n\n * 浮动元素容器添加浮动（不推荐，会使整体浮动，影响布局）\n * after伪元素清除浮动，元素尾部添加一个看不见的块元素清理浮动，设置clear:both（推荐）\n * before和after双伪元素清除浮动\n\n总结 3种\n\n1、clear属性\n\n2、bfc\n\n3、::after伪元素\n\n\n# 💙 层叠上下文\n\n * 普通元素的层叠等级优先由其所在的层叠上下文决定\n * 层叠等级的比较只有在当前层叠上下文才有意义\n * css3新属性也可以产生层级上下文\n * 两个兄弟元素，一个设置了background，一个设置了z-index:-1，background优先级低\n * z-index: auto不生成层叠上下文，z-index:0生成为0的层叠上下文\n   * 两个为0的z-index，后一个优先级大\n\n\n# 创建\n\n根元素（html）——根层叠上下文\n\n> 这就是为什么，绝对定位元素在left/top等值定位时，若没有其他定位元素限制，相对浏览器窗口定位的原因\n\n 1.  html\n 2.  定位(relative/absolute)且 z-index 不为 auto\n 3.  position为 fixed/sticky\n 4.  grid/flex 的子元素且z-index不为auto\n 5.  opacity 小于 1\n 6.  will-change 指定上述任意属性之一，即便你没有直接定义这些属性\n 7.  isolation为isolate\n 8.  mix-blend-mode 不是 normal\n 9.  reflection属性\n 10. overflow不为 visible\n 11. transform /filter / mask 不为 none\n\nbody的子元素，该元素的z-index为10？？？\n\n\n# z-index\n\n\n# 取值\n\n数字无单位\n\n * auto(默认)和其父元素一样的层叠等级\n\n * 整数\n\n * inherit继承\n\n\n# 层叠上下文和层叠等级\n\n\n\n对每一个网页来说，默认创建一个层叠上下文(可类比一张桌子)，这个桌子就是html元素，html元素的所有子元素都位于这个默认层叠上下文中的某个层叠等级(类似于桌子上放了一个盆儿，盆上放了一个果盘，果盘上放了一个水杯……)\n\n将元素的z-index属性设置为非auto时，会创建一个新的层叠上下文，它及其包含的层叠等级独立于其他层叠上下文和层叠等级(类似于搬了一张新桌子过来，和旧桌子完全独立)\n\n\n# 层叠顺序\n\ndiv默认在html之上，及div的层级高于html\n\n一个层叠上下文可能出现7个层叠等级，从低到高排列为\n\n 1. 背景和边框\n 2. z-index为负数\n 3. block盒模型(位于正常文档流，块级，非定位)\n 4. float盒模型(浮动，非定位)\n 5. inline盒模型(位于正常文档流，内联，非定位)\n 6. z-index=0\n 7. z-index为正数(数值越大越靠上方)\n\n\n\n\n# 压盖顺序\n\n自定义压盖顺序：使用属性z-index\n\n * 不只有定位元素(position属性明确设置为absolute、fixed或relative)可使用z-index，后来更新了，flex也可以\n * 如果z-index值相同，html结果在后面的压盖住在前面的\n * 父子都有z-index，父亲z-index数值小时，儿子数值再大没用\n\n> 为啥定位元素会层叠在普通元素之上？\n\n因为元素一旦成为定位元素，z-index自动生效，默认auto，即0级别，就会覆盖inline、block和float元素\n\n层叠上下文和定位元素一个层叠顺序，发生层叠时，遵循"后来居上"\n\n\n# 🔥 position\n\n\n\nmdn参考-position\n\n1、relative：相对定位 给元素设置相对于原本位置的定位，不脱离文档流，原本位置被保留，其他元素位置不受影响。body默认relative，子绝父相\n\n使用top bottom left right 移动位置后不会改变？？？？？？其所占空间位置，可使用z-index属性\n\n2、absolute：***脱离文档流，影响页面布局***，相对于包含块偏移（包含块——最近的position不为static的外层元素），可使用top bottom left right z-index\n\n元素为absolute定位时，如果为内联元素，会变为块级元素；如果为块级元素，宽度由100%变位auto\n\n3、fixed：脱离文档流，相对于viewport定位。特殊版的 absolute，父元素使用transform时以父元素定位\n\n绝对定位将元素固定在相对于其位置最近的祖先，若没有，则为 初始包含它的块\n\n使用场景：侧边栏或者广告图\n\n4**、static：默认**。元素处于正常的文档流中，忽略 left、top、right、bottom 和 z-index 属性\n\n5、sticky：css3新增，粘性定位，relative和fixed的混合。正常情况保持原先布局(和relative相同)，到达边缘条件后，元素的表现情况和fixed一样，粘在某个位置\n\n使用场景 使导航栏随页面滚动直到特定点，然后粘贴到页面顶部\n\n> top影响定位元素垂直位置，对非定位元素没有影响\n> \n>  * position: absolute/fixed; top将元素上边缘设置为其最近定位祖先的上边缘上方/下方的单位\n>  * position: relative; top使元素上边缘在其正常位置上方/下方移动\n>  * position: sticky; top当元素在视口内时，属性的行为类似于它的位置，当它在外面时它的位置是固定的\n>  * position：static; top无效\n\n * # js实现sticky\n\n获取 dom相对于窗口的位置 ，获取元素大小及其相对视口的位置\n\n    function sticky(dom,height){\n      window.onscroll = function(){\n        const rect = dom.getboundingclientrect();\n        if(rect.top <= height){\n          dom.style.position = \'fixed\'\n          dom.style.top = height + \'px\';\n        }else{\n          dom.style.position = \'relative\'\n          dom.style.top = height + \'px\'\n        }\n      }\n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n6、inherit：继承\n\n悬浮在右下角，随滚动而滚动\n\nposition: fixed;\nbottom: 0px;\nright: 0px;\n\n\n1\n2\n3\n\n\n\n# ✅ bfc\n\n> 块格式化上下文（block formatting context）\n\nbfc 决定元素如何对其内容定位，及与其他元素的关系和相互作用，是一个独立的容器，元素按照一定规则布局，与其他环境元素的布局互不影响\n\n除了 bfc，还有：\n\n * ifc（行级格式化上下文）- inline 内联\n * gfc（网格布局格式化上下文）- display: grid\n * ffc（自适应格式化上下文）- display: flex或display: inline-flex\n\n注意：同一个元素不能同时存在于两个 bfc 中\n\n\n# 创建\n\n * html根元素\n * float 不为 none\n * display： inline-block、table-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid\n * position ： absolute、fixed\n * overflow 值不为 visible，即为 auto、scroll、hidden\n\n\n# 特点\n\n * 垂直方向上，自上而下，与文档流排列方式一致\n\n * 同一 bfc 下的相邻块级元素可能发生margin折叠，创建新的 bfc 可以避免margin折叠\n\n * bfc不与浮动容器重叠\n   \n   * 两栏布局\n   \n   * float + overflow:hidden\n\n * 计算bfc高度时，浮动元素！参与！！计算\n\n * 每个元素的左margin和容器的左border相接触，即 每个元素的外边距盒（margin box）的左边与包含块边框盒（border box）的左边相接触（从右向左的格式的话，则相反），即使存在浮动\n\n\n# 应用\n\n * 解决margin重叠\n   * 块级元素的上外边距和下外边距合并（或折叠）为一个外边距，取其中较大者——外边距折叠，这个发生在属同一 bfc 下的块级元素间\n   * 解决：两个元素变成两个bfc\n * 左列浮动，右列 overflow: hidden; 触发bfc\n * 父子元素margin重叠\n   * 如果父元素与其第一/最后一个子元素间不存在边框、内边距、行内内容，没有创建 块格式化上下文/清除浮动将两者外边距 分开，子元素的外边距会“溢出”到父元素的外面\n   * 解决\n     * 父元素触发bfc\n     * 父元素添加border\n     * 父元素添加padding\n\n\n   /**\n    本来父元素距离顶部只有 20px，被子元素溢出影响，外边距重叠，取较大的值，则距离顶部 30px\n     */\n    #parent {\n        width: 200px;\n        height: 200px;\n        background-color: green;\n        margin-top: 20px;\n        overflow: hidden;\n    }\n    #child {\n        width: 100px;\n        height: 100px;\n        background-color: red;\n        margin-top: 30px;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 清除浮动，解决父元素高度塌陷\n   * 子元素浮动，脱离文档流，父元素高度只有边框部分高度\n   * clear:both；overflower:hidden；display: flow-root\n * 其他盒子看不见被float的元素，但是其他盒子里的文本看得见\n\n文字环绕效果\n\n第二个元素被浮动元素遮盖部分，但是——文字不会被覆盖，因为文字看得见被float的元素，需要避开元素被覆盖，可触发 第二个元素的bfc，加入overflow:hidden\n\n> 还可实现 自适应两栏布局\n\n\n# 居中\n\n\n# 不定宽高\n\n\n * # 水平局中\n\n * 定位+margin:auto\n\n * 定位+transform\n\n * 定位+margin:负值\n\n * flex布局\n\n * grid布局\n\n\n# 内联\n\n\n * # 水平居中\n\n * 行内元素可设置：text-align: center\n\n * flex布局设置父元素：display: flex; justify-content: center\n\n\n * # 垂直居中\n\n * 单行文本父元素确认高度：height === line-height\n\n * 多行文本父元素确认高度：disaply: table-cell; vertical-align: middle\n\n\n * # 绝对居中——兼容性好的属性\n\n<!doctype html>\n<html>\n<head>\n    <style>\n        .a{\n            display:inline-block;\n            text-align:center;\n            width:100px;\n            height:100px;\n            background-color:yellow;\n        }\n        .a::before {\n            content: \'\';\n            display: inline-block;\n            height: 100%;\n            vertical-align: middle;\n        }\n        .b{\n            /*vertical-align需要参考的对象，因此在前面插入内容比较*/\n            vertical-align:middle;\n        }\n    </style>\n</head>\n<body>\n<span class="a">\n\t<span class="b">luo</span>\n</span>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 块级\n\n\n * # 水平居中\n\n * absolute+margin auto ，宽高固定，对应方向平分\n\n        .box {\n            position: relative;\n            background-color: green;\n        }\n        .small {\n            background-color: red;\n            position: absolute;\n            top: 0;\n            right: 0;\n            bottom: 0;\n            left: 0;\n            margin: auto;\n            width: 100px;\n            height: 100px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * absolute+calc\n\n .box {\n            position: relative;\n            background-color: red;\n        }\n        .small {\n            background-color: green;\n            position: absolute;\n            top: calc(50% - 50px);\n            left: calc(50% - 50px);\n            width: 100px;\n            height: 100px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * absolute+负margin， left: 50% 和 top: 50% 将子元素左上角移到父元素中心位置，margin-left 和 margin-top 以子元素自身一半宽高负值赋值（pc端有兼容性要求推荐）\n\n .box {\n            position: relative;\n            background-color: red;\n        }\n        .small {\n            background-color: black;\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            margin: -50px 0 0 -50px;\n            width: 100px;\n            height: 100px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n * # 垂直居中\n\n\n\n * position: absolute设置left、top、margin-left、margin-top(定高)\n * display: table-cell\n * transform: translate(x, y)\n * flex(不定高，不定宽)\n * grid(不定高，不定宽)，兼容性相对比较差\n\n\n# 💚 绝对居中\n\n * 定位+transform: translate(-50%,-50%)，translate属性值百分比基于自身宽高计算得出\n\n        .box{\n            background-color: red;\n            position: relative;\n            width: 100px;\n            height: 100px;\n        }\n        .small{\n            background-color: green;\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%,-50%);\n            width: 50px;\n            height: 50px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 父元素text-align为center水平局中；子元素设置inline-block和vertical-align:middle垂直居中，line-height继承父元素\n\n        .box{\n            background-color: red;\n            line-height: 100px;\n            text-align: center;\n        }\n        .small{\n            width: 50px;\n            height: 50px;\n            background-color: green;\n            vertical-align: middle;\n            display: inline-block;\n            line-height: inherit;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * table table-cell，使用table属性，但不想写table元素（pc端有兼容性要求推荐）\n\n        .box {\n            display: table-cell;\n            text-align: center;\n            vertical-align: middle;\n            background-color: red;\n            width: 100px;\n            height: 100px;\n        }\n        .small {\n            width: 50px;\n            height: 50px;\n            display: inline-block;\n            background-color: green;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * table pc有兼容性要求，宽高不固定，推荐\n * flex（pc端无兼容性要求，不考虑ie的话，grid也可）（移动端使用推荐，grid作为备选）\n\n .box {\n            display: flex;\n            justify-content: center;\n            background-color: red;\n            width: 100px;\n            height: 100px;\n        }\n        .small {\n            width: 20px;\n            height: 20px;\n            align-self: center;\n            background-color: green;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * flex +margin:auto，兼容性好\n * grid + align-items兼容性不行，和flex相似\n\n.box {\n    display: grid;\n    justify-items: center;\n    align-items: center;\n}\n\n\n1\n2\n3\n4\n5\n\n\n        .box {\n            display: grid;\n            background-color: red;\n            width: 100px;\n            height: 100px;\n        }\n        .small {\n            width: 50px;\n            height: 50px;\n            background-color: green;\n            justify-self: center;\n            align-self: center;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n.box {\n    display: grid;\n    justify-items: center;\n}\n.small {\n    align-self: center;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 冷门方式\n\n伪类元素\n\ngrid-container\n\ngrid-template-rows\n\n> 注意\n\n不要float 、position一起用\n\n不要对display:table-cell使用百分比设置宽高\n\n\n# 两栏布局\n\n左边宽度固定，右边宽度自适应\n\n * 利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1\n * 利用浮动。左边元素宽度为200px+左浮动。右边元素的margin-left为200px+宽度为auto（默认为auto，撑满整个父元素），需要设置高度。margin-left/padding-left/calc\n * 利用浮动。左元素宽度固定 ，向左浮动。右侧元素 overflow: hidden; 右边触发了 bfc ，bfc 的区域不会与浮动元素重叠，所以两侧不会重叠 float + overflow:hidden\n\n .left {\n        background-color: #3e8dce;\n        float: left;\n        height: 200px;\n        width: 400px;\n        margin-right: 20px;\n    }\n\n    .right {\n        background-color: red;\n        overflow: hidden;\n        height: 300px;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n左列左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行位置\n\n右列利用自身流特性占满整行\n\n右列设置overflow，触发bfc特性，使自身和左列浮动元素隔开，不占满整行\n\n * 绝对定位 父级相对定位 左边absolute定位，宽度固定。设置右边margin-left为左边元素的宽度值。\n * 绝对定位，父级元素相对定位。左边元素宽度固定，右边元素absolute定位，left为宽度大小，其余方向为0。(有歧义，谨慎使用!)\n * 使用 calc 计算\n\n.left {\n  display: inline-block;\n  width: 240px;\n}\n.right {\n  display: inline-block;\n  width: calc(100% - 240px);\n}\n//使用 calc() 函数计算 <div> 元素的宽度\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * grid\n\ngrid-template-columns: minmax(<min>, <max>) …)\n\n.par{\n    display:grid;\n    grid-template-columns:minmax(150px,25%) 1fr;\n}\n\n\n1\n2\n3\n4\n\n\n将最小侧边栏大小设置为150px，但在更大的屏幕上，让它伸展出25%。侧边栏将始终占据父级水平空间的25%，直到25%变得小于150px。\n\n\n# 🍅三栏布局\n\n其中一列宽度自适应\n\n\n# 圣杯布局(左右float+负margin)\n\n缺点：需要多加一层标签，html顺序不对，占用了布局框的margin属性\n\n核心是左、中、右 三栏都通过float浮动，通过负margin调整\n\n * center使用双层标签，外层浮动，以便左中右能在同一行显示\n * 左margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧\n * 右margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<style>\n    .container{\n        font-size: 26px;\n        color: white;\n    }\n    .left,\n    .main,\n    .right{\n        height: 300px;\n    }\n    .main-warpper{\n        float: left;\n        width: 100%;\n    }\n    .left,\n    .right{\n        float: left;\n        width: 200px;\n        margin-left: -100%;\n        background-color: green;\n    }\n\n    .right {\n        margin-left: -200px;\n        /*同自身宽度*/\n    }\n\n    .main {\n        margin: 0 210px;\n        background-color: red;\n    }\n</style>\n<body>\n<div class="container">\n    <div class="main-warpper">\n        <div class="main">lorem ipsum dolor sit amet, consectetur adipisicing elit. animi asperiores assumenda, at autem consequatur cum eaque, eius est eveniet fugit id itaque necessitatibus perferendis perspiciatis quia, ratione sint temporibus voluptatum?</div>\n    </div>\n    <div class="left">左边固定宽度</div>\n    <div class="right">右边固定宽度</div>\n</div>\n</body>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n缺点：\n\n * 增加了一层，结构变复杂\n * 使用负margin，相对麻烦\n\n\n# 双飞翼布局(左右float+中margin)\n\n> 双飞翼布局——圣杯布局的改进方案\n\n双飞翼布局前两步和圣杯布局一样，只是处理中间栏部分内容被遮挡问题的解决方案有所不同：\n\n既然main部分的内容会被遮挡，就在main内部再加一个content，设置其margin避开遮挡\n\n原理：\n\n * 两变固定，中间自适应\n * 中间元素margin值控制两边间距\n * 宽度小于左右部分宽度之和时，右侧被挤下去\n\n缺点\n\n * html结构不正确，主体内容最后加载\n * float布局需要清除浮动，因为float会脱离文档流，造成高度塌陷\n * 右边在主体内容之前，若是响应式设计，不能简单的换行展示\n\n<!doctype html>\n<html lang="en">\n<head>\n    <style>\n        .main {\n            float: left;\n            width: 100%;\n        }\n        .content {\n            height: 200px;\n            margin-left: 110px;\n            margin-right: 220px;\n            background-color: green;\n        }\n        /*创建一个伪元素，作为已选中元素的最后一个子元素。*/\n        .main::after {\n            display: block;\n            content: \'\';\n            font-size: 0;\n            height: 0;\n            /*在main后面加一个元素来清除浮动。*/\n            clear: both;\n            zoom: 1;\n        }\n        .left {\n            float: left;\n            height: 200px;\n            width: 200px;\n            margin-left: -100%;\n            background-color: red;\n        }\n        .right {\n            width: 200px;\n            height: 200px;\n            float: left;\n            margin-left: -200px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n<div>\n    <div class="main">\n        <div class="content"></div>\n    </div>\n    <div class="left"></div>\n    <div class="right"></div>\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n\n\n# 两边absolute+中margin\n\n基于绝对定位\n\n优点 快捷，方便，不容易出问题，你可以很快想出这种布局方式。要求父级要有非static定位，如果没有，左右框容易偏移出去\n\n缺点 绝**对定位脱离文档流，相对最近的已经定位的祖先元素定位，无需考虑html中顺序。**意味着下面的所有子元素也会脱离文档流，导致这种方法的有效性和可使用性比较差\n\n子绝父相，父元素设置为relative，左右两栏设置为absolute+中间一栏margin\n\n * 两边使用绝对定位，固定在两侧\n * 中间占满一行，通过margin和左右两边留出间隔\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<style>\n    .main {\n        position: relative;\n        font-size: 25px;\n        color: white;\n    }\n\n    .left,\n    .center,\n    .right {\n        height: 400px;\n    }\n\n    .left {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 300px;\n        background-color: red;\n    }\n\n    .right {\n        position: absolute;\n        right: 0;\n        top: 0;\n        width: 300px;\n        background-color: blue;\n    }\n\n    .center {\n        margin: 0 300px;\n        background-color: green;\n        /*overflow: auto;*/\n    }\n</style>\n<section class="main">\n    <div class="left">左边固定宽度</div>\n    <div class="center">中间自适应</div>\n    <div class="right">右边固定宽度</div>\n</section>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 绝对定位\n\n三栏均设置为absolute+left+right\n\n\n# bfc\n\n将main变成bfc，就不会和浮动元素重叠\n\n父元素设置overflow: hidden;\n\n\n# table\n\n优点 很少有人使用，flex布局不兼容的情况下table还可以尝试\n\n缺点 使用相对繁琐，代码量大，存在缺陷，当单元格的一个格子超出高度之后，两侧就会一起触发跟着一起变高\n\n * 最外层设置display:table，设置table-layout:fixed，表示列宽自身宽度决定，而不是自动计算\n * 内层的左中右设置 display:table-cell 为表格单元\n * 左右设置固定宽度，中间width:100%，填充剩下的宽度\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<style>\n    .table {\n        display: table;\n        width: 100%;\n        color: white;\n        font-size: 30px;\n        height: 400px;\n        table-layout: fixed;\n    }\n\n    .left,\n    .center,\n    .right {\n        display: table-cell;\n    }\n\n    .left ,\n    .right{\n        width: 200px;\n        background-color: green;\n    }\n    .center {\n        background-color: blue;\n    }\n\n</style>\n<div class="table">\n    <div class="left">左边固定宽度</div>\n    <div class="center">中间自适应</div>\n    <div class="right">右边固定宽度</div>\n</div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# flex\n\n利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1（flex: 1; === flex: 1 1 auto）\n\n * 盒内元素两端对齐，中间设为100%宽度或flex:1，即可填充空白\n * 盒内元素高度撑开容器高度\n\n优点：\n\n * 结构简单直观\n * 实现更多效果，order调整显示顺序，让主题内容优先加载，但显示在中间\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<style>\n    .flex {\n        display: flex;\n        justify-content: space-between;\n        color: white;\n        font-size: 30px;\n    }\n\n    .left,\n    .center,\n    .right {\n        height: 300px;\n    }\n\n    .left {\n        width: 100px;\n        background-color: blue;\n    }\n\n    .center {\n        /*flex: 1;*/\n\n        width: 100%;\n        margin: 0 20px;\n        background-color: green;\n    }\n\n    .right {\n        width: 300px;\n        background-color: red;\n    }\n</style>\n<section class="flex">\n    <div class="left">left</div>\n    <div class="center">center</div>\n    <div class="right">right</div>\n</section>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# grid\n\n优点 比较超前一点的布局自然有其独特的魅力\n\n缺点 兼容性\n\ngrid-template-columns 该属性是基于 网格列. 的维度，去定义网格线的名称和网格轨道的尺寸大小。\n\n用单位 fr 来定义网格轨道大小的弹性系数。 每个定义了 <flex> 的网格轨道会按比例分配剩余的可用空间。当外层用一个 minmax() 表示时，它将是一个自动最小值(即 minmax(auto, <flex>) ) .\n\n\n1\n2\n3\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n<style>\n    .grid {\n        display: grid;\n        /*grid-template-columns: 300px 3fr 300px;*/\n\n        grid-template-columns: 300px auto 300px;\n        width: 100%;\n\n        font-size: 30px;\n        color: white;\n    }\n    .left,\n    .center,\n    .right{\n        height: 400px;\n    }\n\n    .left {\n        background-color: red;\n    }\n\n    .center {\n        background-color:blue;\n    }\n\n    .right {\n        background-color:green;\n    }\n</style>\n<section class="grid">\n    <article class="left">\n        <h1>我是grid栅格布局左框</h1>\n    </article>\n    <article class="center">\n        <h1>我是grid栅格布局中间框</h1>\n    </article>\n    <article class="right">\n        <h1>我是grid栅格布局右框</h1>\n    </article>\n</section>\n\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# ❤️ flex布局\n\n简便、完整、响应式地实现各种页面布局。为盒模型提供最大的灵活性\n\n会使元素变为块级元素\n\n> 父 子容器构成，通过主轴和交叉轴控制子容器布局，子元素float、clear和vertical-align属性失效\n\n\n# 父容器\n\n * flex-direction\n * flex-wrap\n * flex-flow\n * justify-content\n * align-items\n * align-content\n\n\n# flex-direction\n\n文字也会跟着flex-direction属性值排列，即，从左往右，从右往左……\n\n.container {   \n    flex-direction: row | row-reverse | column | column-reverse;  \n} \n\n\n1\n2\n3\n\n\n决定主轴方向，子元素的排列方向\n\n * row（默认值）：主轴为水平方向，起点在左端\n * row-reverse：主轴为水平方向，起点在右端\n * column：主轴为垂直方向，起点在上沿\n * column-reverse：主轴为垂直方向，起点在下沿\n\n\n# flex-wrap\n\n.container {  \n    flex-wrap: nowrap | wrap | wrap-reverse;\n}  \n\n\n1\n2\n3\n\n\n弹性元素永远沿主轴排列，如果主轴排不下，flex-wrap决定容器内项目是否可换行\n\n默认nowrap，但不会任由元素溢出，它会缩小以适应容器；若项目无法缩小，nowrap会溢出\n\n\n\n\n# flex-flow(简写属性)\n\n是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n\n当flex-grow之和小于1时，只能按比例分配部分剩余空间，而不是全部。\n\n.box {\n  flex-flow: <flex-direction> || <flex-wrap>;\n}\n\n\n1\n2\n3\n\n\n\n# justify-content\n\n定义项目在主轴上对齐方式\n\n.box {\n    justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n\n\n1\n2\n3\n\n * flex-start（默认）：左对齐\n * flex-end：右对齐\n * center：居中\n * **space-between：**平分剩余空间，所以元素 间隔 相等\n * space-around：项目两侧间隔相等，平分剩余空间\n\n\n# align-items\n\n.box {\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n\n\n1\n2\n3\n\n\n定义项目在交叉轴上如何对齐\n\n默认 垂直方向\n\n * flex-start：交叉轴的起点对齐\n * flex-end：交叉轴的终点对齐\n * center：交叉轴的中点对齐\n * baseline: 项目的第一行文字的基线对齐\n * stretch（默认）\n\n> 这就是为啥 flex元素会默认被拉伸到最高元素的高度，实际上，它们被拉伸来填满 flex容器——最高元素定义 容器高度\n\n\n\n\n# align-content\n\n.box {\n    align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n\n\n1\n2\n3\n\n\n定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n * flex-start：与交叉轴的起点对齐\n * flex-end：与交叉轴的终点对齐\n * center：与交叉轴的中点对齐\n * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布\n * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍\n * stretch（默认值）：轴线占满整个交叉轴\n\n\n# 子容器\n\n * order\n * flex-grow\n * flex-shrink\n * flex-basis\n * flex\n * align-self\n\n\n# order\n\n定义item排列顺序，越小越靠前，默认0\n\n> 可用空间\n> \n> flex子项目属性改变了flex容器中的可用空间\n\n\n# flex-grow\n\n定义项目延主轴 的放大比例（容器宽度>元素总宽度时如何伸展）\n\n默认0，存在剩余空间也不放大\n\nflex-warp：nowrap；不换行的时候，container宽度不够分时，弹性元素会根据flex-grow来决定\n\n如果所有项目的flex-grow为1，它们将平分可用空间\n\n如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍\n\n弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效\n\n\n# flex-shrink\n\n定义项目的缩小比例（容器宽度<元素总宽度时如何收缩），默认为1，即如果空间不足，该项目将缩小\n\nflex 元素仅在默认宽度之和大于容器的时候才会收缩\n\n> 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小\n> \n> 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小\n\n\n\n\n# flex-basis\n\n定义分配多余空间前，占据主轴空间 ，默认auto\n\n元素在主轴上的初始尺寸，初始尺寸——元素在flex-grow和flex-shrink生效前的尺寸\n\n> 这就解释了：我们只要给flex元素父元素声明display:flex，所有子元素就会排成一行，且自动分配大小 以 充分展示内容\n\n\n# flex:1\n\nflex 是 flex-grow、flex-shrink 和 flex-basis 的简写，默认为 0 1 auto。后两个属性可选\n\n0 1 auto\ngrow为0——flex元素不会超过他们basis的尺寸\nshrink为1——可以缩小flex元素防止溢出\nbasis为auto——flex元素可在主轴上设置，也可根据内容自动获得\n\n\n1\n2\n3\n4\n\n\n优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值\n\nflex: 1 = 1 1 0\n\nflex: 2 = 2 1 0\n\nflex: auto = 1 1 auto(既可以拉伸 也可以收缩)\n\nflex: none = 0 0 auto(不可伸缩)\n\n\n# aline-self\n\n默认值为auto，继承父元素的align-items属性，如果没有父元素，等同于stretch\n\n允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性\n\n左边固定右边自适应\n\n//垂直居中\nflex-direction:row/column;\nalign-items:center\n\n//水平局中\nflex-direction:row/column;\njustify-content:center;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nflex: 1 = flex: 1 1 0%\nflex: 2 = flex: 2 1 0%\nflex: auto = flex: 1 1 auto\nflex: none = flex: 0 0 auto，常用于固定尺寸不伸缩\n\n\n1\n2\n3\n4\n\n\n\n# place-items\n\n设置 align-items 和 justify-items 的快速方法\n\n\n# 隐藏元素\n\ndisplay:none\n\n * 不会在页面占据位置\n * 渲染树不会包含该渲染对象\n * 不会绑定响应事件\n * 会导致浏览器进行重排和重绘\n\nvisibility:hidden（性能更好，因为display引起页面回流，而visibility导致重绘）\n\n * 占据位置，不更改布局\n * 不会响应绑定事件\n * 不会重排但会重绘\n\nvisibility: visible;\nvisibility: hidden;\nvisibility: collapse;\n\n\n1\n2\n3\n\n\nopacity:0\n\n * 元素透明度设置为0\n * 占据位置\n * 能响应绑定事件\n * 不能控制子元素展示\n * 不会引发重排，一般会引发重绘\n\n> 如果利用 animation 动画，对 opacity 做变化（animation会默认触发gpu加速），则只会触发 gpu 层面的 composite，不会触发重绘\n\n设置height width为0\n\n将影响元素盒模型的属性设置为0，若有元素内有子元素或内容，应该设置其overflow:hidden来隐藏其子元素。\n\n * 元素不可见\n * 不占据空间\n * 不响应点击事件\n\nposition：absolute\n\n * 将元素移除可视区域\n * 元素不可见\n * 不影响页面布局\n\ntransform: scale(0,0)\n\n缩放为0\n\n * 占据位置\n\n * 不响应绑定事件\n\n * 不会触发浏览器重排\n\n              display: none   visibility: hidden   opacity: 0\n页面中           不存在             存在                   存在\n重排            会               不会                   不会\n重绘            会               会                    不一定\n自身绑定事件        不触发             不触发                  可触发\ntransition    不支持             支持                   支持\n子元素可复原        不能              能                    不能\n被遮挡的元素可触发事件   能               能                    不能\n\n> visibility:hidden、 display:none\n\n * 普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置\n * 进一步， display由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大\n * 再进一步，当一个页面某个元素经常需要切换 display时如何优化，一般会用复合层优化，或者要求低一点用 absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流， absolute文档流，复合图层的区别，\n * 再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）\n\n> 上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖\n\n> opacity、rgba\n\nopacity 取值在0到1之间，0表示完全透明，1表示完全不透明\n\n.aa{opacity: 0.5;}\n\n\n1\n\n\nrgba中的r表示红色，g表示绿色，b表示蓝色，三种颜色的值都可以是正整数或百分数。a表示alpha透明度。取值0~1之间，类似opacity\n\n.aa{background: rgba(255,0,0,0.5);}\n\n\n1\n\n\nrgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。\n\n**总结：**opacity会继承父元素的 opacity 属性，而rgba设置的元素的后代元素不会继承不透明属性\n\n\n# 🙋 不可/可继承\n\n\n# 可继承\n\n * 字体属性\n\nfont-family\n\nfont-size\n\n * 元素可见性\n * 列表/列表 布局属性\n\nlinst-style\n\n * 生成内容属性\n * 光标属性\n * 文本系列属性\n\ntext-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：增加或减少单词间的空白（即字间隔） letter-spacing：增加或减少字符间的空白（字符间距） text-transform：控制文本大小写 direction：规定文本的书写方向 color：文本颜色\n\n\n# 不可继承\n\n * 盒子模型属性\n * display\n * 背景属性\n * 定位属性\n * 生成内容、轮廓样式、页面样式、声音样式\n * 文本属性\n\nvertical-align：垂直文本对齐\n\ntext-decoration：规定添加到文本的装饰\n\ntext-shadow：文本阴影效果\n\nwhite-space：空白符的处理\n\nunicode-bidi：设置文本的方向\n\nborder不可继承！\n\n\n# 🍅line-height继承？\n\n * 父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。\n * 父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。\n * 父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 fontsize * 200% 计算出来的值。\n\n\n# 💚 display\n\n属性值            作用\nnone           不显示，会从文档流中移除\nblock          块类型。默认宽度为父元素宽度，可设置宽高，换行显示\ninline         默认！！！行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示\ninline-block   默认宽度为内容宽度，可设置宽高，同行显示\nlist-item      像块类型一样显示，添加样式列表标记\ntable          作为块级表格显示，换行显示\ninherit        继承\n\n\n# block，inline，inline-block\n\nblock：占据一行，可以设置宽高、行高、内外边距\n\n<h1>~<h6>\n<p>\n<div>\n<ul>\n<ol>\n<li>\n<div>\n<dl>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ninline：占据一行的小部分，多个行内元素水平排版；可设置内外边距，但只对左右起作用；宽只和内容有关；只能容纳文本或其他行内元素；不可设置宽高\n\n<a >\n<strong>\n<b>\n<em>\n<i>\n<del>\n<span >\n<img> \n<input> \n<select>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\ninline-block：跟行内元素类似，可设置宽高，保留 上下 外边距/内边距，可设置margin-left，inline-block可设置padding-left\n\n> button ，img ， input, select, label，textarea\n\ninput元素的type属性——password、text、file、button\n\n\n1\n\n\n空元素\n\n<br> <hr> <img> <input> <link> <meta>\n\n\n1\n\n\n> 行内元素\n\n * 水平居中\n   \n   div{text-align:center} /*div内的行内元素均会水平居中*/ \n   \n   \n   1\n   \n\n * 垂直居中\n   \n   div{height:30px; line-height:30px} /*div内的行内元素均会垂直居中*/ \n   \n   \n   1\n   \n\n> 块级元素\n\n * 水平居中\n\ndiv p{margin:0 auto; width:500px} /*块级元素p一定要设置宽度，才能相当于div父容器水平居中*/\n\n\n1\n\n * 垂直居中\n\ndiv{width:500px} /*div父容器设置宽度*/      \ndiv p{margin:0 aut0; height:30px; line-height:30px} /*块级元素p也可以加个宽度，         以达到相对于div父容器的水平居中效果*/\n\n\n1\n2\n\n\n\n# 行内元素支持宽高\n\n\n# 💙 高度塌陷\n\n父元素的子元素脱离文档流，本身没设置高度，则它的高度=0\n\n\n# 解决\n\n 1. bfc\n 2. 新增一个空的div或伪元素，设置清除 ，clear:both;\n\n\n# margin合并\n\n外边框塌陷/外边距重叠，区别 高度塌陷！\n\n2个垂直margin相遇会形成一个外边距，合并后的，margin等于2个合并的margin高度中的较大值\n\n\n\n> 只有普通文档流中块级框的垂直margin才会发生重叠，行内框、浮动框或绝对定位 不会重叠\n\n不想要合并的元素可创建一个 bfc，即 在第一个元素新建一个空元素，配置 overflow: hidden\n\n\n# less、sass\n\n都是css预处理器。用专门的编程语言，进行web页面样式设计，再通过编译器转换为正常的css文件\n\n\n# less\n\n是一门css预处理语言，扩展了css语言，增加了变量等特性\n\n\n# sass\n\nsass 是一种编译成 css 的样式表语言\n\n变量、嵌套规则、混合、函数等，具有完全与 css 兼容的语法。助于保持大型样式表井井有条，共享设计变得容易\n\n\n# 相同\n\n 1. 混入(mixins)——class中的class\n 2. 参数混入——可以传递参数的class，就像函数一样\n 3. 嵌套规则——class中嵌套class，从而减少重复的代码\n 4. 运算——css中用上数学\n 5. 颜色功能——可以编辑颜色\n 6. 名字空间(namespace)——分组样式，从而可以被调用\n 7. 作用域——局部修改样式\n 8. javascript 赋值——在css中使用javascript表达式赋值\n\n\n# 区别\n\n主要不同是实现方式\n\n 1. less基于js，客户端处理\n 2. sass基于ruby，服务端处理\n 3. 变量：less用@ sass用$\n 4. less没有输出设置\n 5. sass支持条件语句，less不允许\n 6. less环境比sass简单\n\n\n# 为啥使用sass？\n\n 1. compass使用sass，成熟的框架\n 2. 国外讨论热度高\n 3. 学习教程好\n 4. sass是成熟的css预处理器之一，维护好\n 5. scss对sass语法做了改良\n\nscss 是 sass 3 引入新的语法，其语法完全兼容 css3，并且继承了 sass 的强大功能\n\n\n# 🙋 移动端布局\n\n\n# 静态布局\n\n设置的长宽不变，不管屏幕多大，分辨率不会变\n\n会出现滚动条\n\n\n# 自适应布局\n\n元素位置会变 但大小不变\n\n兼容不同分辨率设备\n\n屏幕大了 会拥挤，只是长度或图片变小了，不会根据不同设备展示不同样式\n\n\n# 响应式布局\n\ncontent is like water\n\n从以下几方面思考：\n\n * 弹性盒子和媒体查询\n * 百分比布局创建流式布局的弹性ui，使用媒体查询限制元素的尺寸和内容变更范围\n * 相对单位使得内容自适应\n\n缺点：\n\n * 仅适用布局、信息、框架并不复杂的部门类型网站\n * 兼容各种设备工作量大，效率低下\n * 代码累赘，出现隐藏无用的元素，加载时间加长\n * 一定程度上改变了网站原有的布局结构\n\n媒体查询/vw/vh\n\n根据用户行为和设备环境进行调整和响应，不同屏幕分辨率 不同展示方式\n\n一套代码兼容web端、平板、手机端\n\n> rem适配方案已被淘汰\n\n代替方案——viewport(视图 视窗\n\nviewport分为 layout viewport、visual viewport、 ideal viewport\n\n大部分浏览器把 viewport 的宽度设为 980px，浏览器默认视图叫 layout viewport，document.documentelement.clientwidth获取\n\nlayout viewport 的宽度远大于浏览器宽度，因此 我们需要新的 viewport 代表浏览器可视区域宽度，被称为 visual viewport ，使用 window.innerwidth 获取\n\n因为越来越多的网站都会为移动设备 单独设计，所以需要有一个能完美适配 移动设备的 ideal viewport\n\nideal viewport没有固定的尺寸，不同设备有不同的ideal viewport，iphone5 的 ideal viewport 是 320px\n\n\n# 弹性布局\n\nrem/em/flex\n\n * 关键元素高度和位置都不变，只有容器做伸缩变换\n * 开发原则：文字流式控件弹性，图片等比缩放\n\n\n# rem/em\n\nrem 布局原理——等比缩放\n\n根据根元素font-size 将font-size设置成屏幕宽度clientwidth和设计稿宽度 750 的比值，按照设计稿的尺寸重构页面，使用 rem 即 自动乘以 font-size计算出 适配不同屏幕的尺寸\n\n\n1\n2\n3\n\n\n// 以750设计稿，计算rem font-size\nlet clientwidth = document.documentelement.clientwidth || document.body.clientwidth;\nlet ft = (clientwidth / 7.5).tofixed(2);\n// 设置页面根字号\ndocument.documentelement.style.fontsize = ft + "px";\n\n\n1\n2\n3\n4\n5\n\n\n不同屏幕分辨率下元素的宽高等比例缩放\n\n完美适应屏幕宽高比\n\n\n# flex\n\nflex 简单、完整、响应式 实现各种布局\n\n可用于 三栏 布局、垂直水平居中布局\n\n\n# 流式布局\n\n百分比布局\n\n元素宽度按照屏幕分辨率适配调整，像瀑布一样往下流\n\n灵活、充分利用空间\n\n对大屏幕来说 体验不好\n\n类似 抖音 视频、微博消息、朋友圈等布局\n\n\n# 媒体查询\n\n不同条件下使用不同样式，页面在不同终端设备下达到不同效果\n\n允许添加表达式用以 媒体查询，选择不同样式表，自适应不同屏幕分辨率\n\n\n# ✅ 单位\n\npx % em 这几个单位，可以适用于大部分项目开发，且拥有较好兼容性\n\ncss单位    \n相对长度单位   em、ex、ch、rem、vw、vh、vmin、vmax、%\n绝对长度单位   cm、mm、in、px、pt、pc\n\n * px 固定像素单位，一个像素表示终端屏幕能显示的最小的区域，无响应式\n\n * % ：元素的宽高可随浏览器的变化而变化，实现响应式，一般子元素的百分比相对于直接父元素\n\n * em 根据父元素 字体大小 设置，作为其他属性单位时，相对自身字体大小按比例计算\n\n * rem css3新增，基于 html 的大小设置字体大小，作用于根元素字体大小时，相对于其初始字体大小（16px）\n\nhtml {  font-size: 20px;}\n/* 作用于非根元素，相对于根元素字体大小，40px */\np {  font-size: 2rem;}\n\n\n1\n2\n3\n\n\n\n# vw、vh\n\n单位 vw、vh将 viewport(视图窗口)分为 一百份\n\n * 1vw 等于 视图单位的 1% 宽度\n * 1vh 等于 视图单位的 1% 高度\n\n设计稿视图wie375px ，所以，1vw=3.75px\n\n在项目的index.html 的head标签中，添加以下代码\n\n<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">\n\n\n1\n\n * vm\n * rpx\n\nresponsive pixel（动态像素）\n\nrpx是微信小程序独有的，解决屏幕自适应\n\n小程序内部实现的响应式——rpx\n\n\n1\n\n\n根据屏幕宽度进行自适应，无论屏幕大小，规定屏幕宽度为750rpx\n\nrpx和px的换算\n\n> iphone6的屏幕宽度为375px，有750个物理像素，则750rpx=375px=750个物理像素\n\n1rpx=0.5px=1物理像素\n\n1px=2rpx\n\n\n# 换算\n\nbrowser默认字体16px\n\n1em=16px\n\n12px=0.75em\n\n10px=0.625em\n\n\n# 🌈 动画\n\ncss3动画优点\n\n 1. 性能好，浏览器会对css3的动画优化(如专门新建图层跑动画)\n 2. 代码相对简单\n\n\n# js直接实现\n\njs实现动画导致页面频繁性重排重绘，消耗性能\n\n\n# svg（可伸缩矢量图形）\n\n 1. 控制动画延时\n 2. 控制属性的连续改变\n 3. 控制颜色变化\n 4. 控制如缩放，旋转等几何变化\n 5. 控制svg内元素的移动路径\n\nsvg是对图形的渲染，html是对dom的渲染\n\n\n# css3 transition\n\n过渡动画\n\n不能实现独立 动画，只能在某个标签 样式/状态改变时进行平滑 动画效果过渡， 不是马上改变\n\n注意\n\n移动端开发 直接使用transition 会让页面变慢甚至卡顿\n\n以我们通常 transform:translate3d(0,0,0)/transform:translatez(0) 开启 gpu加速，让动画过程更加流畅\n\ntransition:transform 1s ease;\n\n\n1\n\n\nstyle="transform: translate(304px, 256px);"\n\n\n1\n\n\n动态改变transform的值，实现拖拽移动的效果\n\n使用场景：\n\n 1. 实现激活状态的过渡效果(宽度和透明度变化)\n 2. 和transform结合实现动画过渡\n\n\n# transform(不是动画)\n\ntransform: rotate(45deg) translatex(150px);\n/*先顺时针旋转45度，再向右下角平移150px*/\n\n\n1\n2\n\n\ntransform(变换、变形)是css3的属性\n\n给元素做 2d和3d 变换，,rotate(旋转),scale(缩放),skew(扭曲),translate(移动)和matrix(矩阵变换)\n\nthis.img.style.transform = `translate(${this.center.x}px,${this.center.y}px) scale(${this.scale}`; //先执行scale再执行前面，从后往前执行\n\n\n1\n\n\n> 矩阵\n\ntransform通过矩阵完成对元素的控制\n\n2x2的矩阵能够描述二维空间的变换\n\ngetcomputedstyle 获取transform 属性， dommatrix 生成矩阵对象，方便获取矩阵参数\n\n使用场景：\n\n 1. transition和position: absolute;实现绝对居中\n 2. 放大，旋转，倾斜，矩阵变换 效果\n 3. js 改变transform属性值实现动画过渡效果\n\ntransform本身 没有过渡效果，它只是对元素做大小,旋转,倾斜等各种变换, 和transition/animation 结合,可以让 变换过程具有动画 效果, 通常只有一个到达态,中间态的过渡 通过和transition/animation 结合 ,也可 通过js设置定时器 实现\n\ntranslate是transform的属性值：2d变换\n\ntransition——动画展示过程，css3属性\n\n\n# css3 animation3\n\n算是真正意义的css3动画，定义动画过渡效果\n\n@(-webkit-)keyframes定义动画名称及 行为——>animation 相关属性定义动画的执行效果\n\n控制 关键帧和循环次数，元素根据设定好的样式改变进行平滑过渡\n\n比较\n\ncss3最大的优势是摆脱了js的控制，利用硬件加速实现复杂动画效果\n\ncss animation 属性是 animation-name，animation-duration, animation-timing-function，animation-delay，animation-iteration-count，animation-direction，animation-fill-mode 和 animation-play-state 属性的简写形式\n\nanimation-name 属性指定应用的一系列动画，每个名称代表一个由@keyframes定义的动画序列\n\nanimation-duration属性指定一个动画周期的时长\n\ncss animation-timing-function属性定义css动画在每一动画周期中执行的节奏。\n\n\n# transition和animation区别\n\ntransition一般 定义单个或多个css属性 变化时的过渡动画，width,opacity。css属性变化时执行过渡动画，animation动画一旦定义，就在页面加载完成后自动执行\n\ntransition定义的动画触发一次执行一次,想要再次执行 再次触发\n\nanimation定义的动画可以指定播放次数或者无限循环播放\n\ntransition: 需要用户操作，执行次数固定\n\ntransition定义的动画只有两个状态，开始态和结束态\n\nanimation可以定义多个动画中间态，且可以控制多个复杂动画的有序执行\n\n\n# canvas\n\nh5新增\n\n运行绘制图案，可用于 动画 游戏 数据可视化 图片编辑器 和实时视频处理等\n\n操作步骤\n\n 1. 创建canvas元素\n 2. js获取canvas标签\n 3. 在canvas获取绘制工具\n 4. 绘制图形\n\n> 通过啥？？？？属性设置或返回如何将一个源图像绘制到目 标图像上——globalcompositeoperation\n> \n> https://blog.csdn.net/yannnnnm/article/details/109256793\n\n只有width和height两个属性\n\nclearrect可用于清空整个canvas画布\n\ncanvas 绘图只有一个元素canvas，不能直接绑定事件\n\n> canvas有几种context\n\n> 2d context有什么信息\n\n开始于元素左上角，原点坐标是(0,0)\n\n> 画一个五角星\n\ncanvas、svg\n\ncanvas         svg\njs动态生成元素       xml描述元素（类似html元素那样，可用多个元素来描述一个图形）\n位图（受屏幕分辨率影响）   矢量图（不受屏幕分辨率影响）\n不支持事件          支持事件\n数据发生变化需要重绘     不需要重绘\n\ncanvas依赖分辨率，放大会失真；svg不会失真\n\ncanvas不支持事件处理器；svg支持\n\ncanvas适合图像密集型的游戏、频繁绘制图像；svg绘制复杂度高时渲染速度慢\n\ncanvas文本渲染能力弱；svg有强文本渲染能力\n\ncanvas绘制的图形可保存为多种格式；svg只能以.svg格式保存\n\n\n# requestanimationframe\n\nweb api——请求动画帧，告诉浏览器 希望执行一个动画，且要求浏览器**重绘前**调用指定回调更新动画\n\n性能更好\n\n> 我们将执行动画的每一步传到requestanimationframe，每次执行完后异步回调来连续触发动画效果\n\n刷新频率即图像更新速度，屏幕上图像每秒出现次数(单位是hz)，一般是60hz，受屏幕分辨率、屏幕尺寸和显卡影响\n\n动画本质是 让人眼看到图像刷新引起的视觉效果，这个变化要 连贯、平滑地过渡\n\n在一帧(一般是16ms)间隔内根据选择浏览器情况执行相关动作\n\n**raf按照系统刷新的节奏调用！！**若刷新率为60hz，回调就16.7ms执行一次，若刷新率是75hz，时间间隔变为1000/75=13.3ms，所以它能保证回调在屏幕的每次刷新间隔被执行一次，不会引起丢帧和卡顿\n\n页面最小化或切换为后台标签时，不可见，触发visibilitychange并设置document.hidden为true\n\n> 执行过程\n\n 1. 判断document.hidden是否为false\n 2. 清空上一轮动画函数\n 3. 方法返回的handlerid和callback进入动画帧请求回调队列\n 4. 遍历回调列表，根据handlerid大小依次执行\n\nraf既不是微任务，也不是宏任务\n\n\n# raf、settimeout\n\nsettimeout设置间隔时间不断改变图像位置达到动画效果，可能出现卡顿、抖动现象\n\n原因\n\n * settimeout时间不确定，settimeout任务放进一步队列，只有主线程的任务执行完 才会检查该队列任务是否需执行，所以settimeout的实际执行时间一般比其设定的时间晚\n * settimeout只能设置固定时间间隔，不一定和屏幕刷新时间相同\n\n导致settimeout执行步调和屏幕刷新步调不一致，引起 丢帧\n\n**settimeout执行只是在内存中对图像属性作修改，这个变化必须等屏幕下次刷新才会更新！**若二者步调不一致，导致某一帧的操作被跨越，直接更新下一帧\n\nraf最大优势——由系统决定回调执行时机，它保证回调在屏幕每一次的刷新间隔中执行一次，不引起丢帧，不会出现卡顿\n\nvar progress = 0;\n//回调函数\nfunction render() {  \n  progress += 1; //修改图像的位置  \n  if (progress < 100) {  //在动画没有结束前，递归渲染    \n    window.requestanimationframe(render); \n  }\n}\n//第一帧渲染\nwindow.requestanimationframe(render);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 优势\n\n * cpu节能\n\n页面被隐藏时，settimeout仍然在后台执行动画任务，但是页面处于不可见/不可用状态，刷新没有意义，浪费资源\n\nraf在页面未激活时 页面的屏幕刷新任务被被暂停，页面被激活时，动画从上次停留的地方继续执行\n\n * 函数节流\n\n高频率事件(scroll，resize)中，为防止一个刷新间隔内函数多次执行，使用raf可保证 一个刷新间隔内，函数执行一次，保证流畅性，节省开销；多次绘制没有意义，因为显示器16.7ms才刷新一次\n\nraf把每一帧的所有dom操作集中，一次回流搞定，回流的时间间隔紧跟浏览器的刷新频率\n\n\n# setinterval\n\n和settimeout问题一样，甚至更甚，执行会延迟，时间与一帧时间不一致，若添加当前setinterval事件，上一个还在任务队列未被执行，当前回调可能被丢弃\n\n\n# css、js动画\n\n\n# js动画\n\n 1. js在主线程运行，主线程还有其他js脚本需运行(样式计算、布局、绘制任务等)，对其干扰可能出现阻塞，造成丢帧\n\n 2. 代码复杂度高于css\n\n 3. js动画控制能力强(开始、暂停、回放、终止、取消等)\n\n 4. 动画效果丰富\n\n 5. 大多没有兼容问题\n\n\n# css动画\n\n 1. 浏览器可对动画优化\n\n硬件加速，gpu提高性能\n\n 1. 运行控制过程较弱\n 2. 代码冗长\n\n\n# 🌰 文本溢出\n\n\n# 单行溢出\n\n * text-overflow：当文本溢出时，显示省略符号代表被修剪的文本\n * white-space：处理元素中的空白\n * overflow：文字长度超出限定宽度，隐藏超出的内容\n\noverflow:hidden，普通情况用在块级元素的外层隐藏内部溢出元素，或配合以下两个属性实现文本溢出省略\n\n> overflow 值可以是 auto、hidden 或 scroll\n\nwhite-space:nowrap，设置文本不换行，是overflow:hidden和text-overflow:ellipsis生效的基础\n\ntext-overflow属性值如下：\n\n * clip：对象内文本溢出部分裁掉\n * ellipsis：对象内文本溢出时显示...\n\n\n# white-space\n\n               换行符   空格和制表符   文字换行   行尾空格\nnormal         合并    合并       换行     删除\nnowrap         合并    合并       不换行    删除\npre            保留    保留       不换行    保留\npre-wrap       保留    保留       换行     挂起\npre-line       保留    合并       换行     删除\nbreak-spaces   保留    保留       换行     换行\n\n\n# 多行溢出\n\n> 基于高度截断\n\n伪元素+定位\n\n通过伪元素绝对定位到行尾并遮住文字，再通过overflow:hidden，隐藏多余文字\n\n优点\n\n * 兼容性好\n * 响应式截断，根据不同宽度做出调整\n\n> 基于行数截断\n\n\n# 💚 超出自动换行\n\n文字超出自动换行，white-space:normal(默认)\n\n英文\n\nword-break:break-all，以字母作为换行依据\n\nword-wrap: break-word，以单词作为换行依据\n\n\n# 渲染层合并\n\n浏览器在渲染html元素时，创建多个层绘制，在每个层绘制结束后，合并成一个完整图层，最终渲染到屏幕上\n\n\n# 🙋 重排、重绘和合成\n\n参考文档\n\n涉及页面生成过程\n\n回流一定触发重绘，重绘不一定触发回流。重绘开销小，回流代价高\n\n\n# reflow\n\n回流/重排\n\n元素的尺寸、结构或属性变化，re-render部分/全部文档，重新计算页面元素位置/几何结构的过程\n\n触发回流的操作:\n\n * 初次渲染\n\n * 窗口大小改变(resize事件)\n\n * 元素属性、尺寸、位置、内容改变\n\n * 元素字体大小变化\n\n * 添加或者删除可见 dom 元素\n\n * 激活 css 伪类(如 :hover)\n\n * 一个“即时性”和“准确性”。\n\n常见引起重排属性和方法               --                         --                   --\nwidth                     height                     margin               padding\ndisplay                   border-width               border               position\noverflow                  font-size                  vertical-align       min-height\nclientwidth               clientheight               clienttop            clientleft\noffsetwidth               offsetheight               offsettop            offsetleft\nscrollwidth               scrollheight               scrolltop            scrollleft\nscrollintoview()          scrollto()                 getcomputedstyle()   \ngetboundingclientrect()   scrollintoviewifneeded()                        \n\n修改样式时，**避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用，最好将值缓存起来。\n\n\n# repaint\n\n重绘\n\n元素的样式如 外观/风格 改变，但不影响其在文档流中的位置/布局，浏览器会对元素重新绘制\n\n不再执行布局阶段，直接进入绘制阶段\n\n属性：               --                 --                    --\ncolor             border-style       visibility            background\ntext-decoration   background-image   background-position   background-repeat\noutline-color     outline            outline-style         border-radius\noutline-width     box-shadow         background-size       \n\n\n# 合成\n\n利用transform、opacity和filter可实现合成效果，即gpu加速\n\n避开布局 分块和绘制阶段\n\n能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息改变、布局改变、颜色改变，都不会设计，涉及到的话就牵扯到重排或重绘了\n\n能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换不会影响到图层的内容\n\n比如滚动内容，页面内容没有变化，只是对图层做上下移动——这个操作直接在合成线程完成\n\n\n# 优化\n\n * 最小化重绘和重排：样式集中改变，使用添加新样式类名\n * absolute或 fixed使元素脱离文档流\n * gpu加速。transform opacity will-change等，改变元素位置，translate比使用绝对定位改变其left或top更高效，因为它不触发重排/重绘，**transform使浏览器为元素创建一个gpu图层，使得动画元素在一个独立的层中进行渲染，**当元素内容没有改变就没必要渲染\n * visibility替换 display: none ，前者引起重绘，后者引发回流（改变了布局）\n * dom 离线修改，如：先把 dom 设为display:none(有一次 reflow)，然后修改再显示，只会触发一次回流\n * 不把 dom 结点属性值放循环当成变量\n * 不使用 table 布局，很小的改动会造成整个 table 重新布局\n * 动画速度越快，回流次数越多，可使用 requestanimationframe\n * css 选择符从右往左匹配查找，避免节点层级过多\n * 浏览器可快速找到id，id最有效，同时可能牺牲语义和可维护性\n * 后代选择最糟糕\n * 伪类标签选择器非常消耗性能\n * 频繁运行的动画变为图层，能阻止该节点回流影响别的元素。对 video 标签，浏览器自动变为图层\n * documentfragment创建dom文档片段，批量操作dom，完成后再添加到文档，只触发一次回流\n\n> documentfragment不是adom的一部分，变化不会触发dom树的re-render，不会导致性能问题\n> \n> 效果不甚明显，因为现代浏览器会使用队列存储储存多次修改进行优化\n\n\n# 📒 client、offset、scroll\n\n\n# client 主要与可视区有关\n\n客户区大小指的是元素内容及其内边距所占据空间大小\n\n\n\n\n# offset 主要与自身有关\n\n偏移量，可动态得到元素的位置（偏移），大小。**元素在屏幕上占用的所有可见空间。**元素高度宽度包括内边距，滚动条和边框\n\noffsetparent是一个只读属性，返回一个指向最近的（closest，指包含层级上的最近）包含该元素的定位元素。如果没有定位的元素，则 offsetparent 为最近的 table， td， th或body元素。当元素的 style.display 设置为 “none” 时，offsetparent 返回 null\n\n\n\n\n\n属性                     描述\nelement.clientwidth    获取元素可视区的宽度，不包括垂直滚动条\nelement.offsetwidth    获取元素的宽度= boder + padding + content\nelement.clientheight   获取元素可视区的高度，不包括水平滚动条\nelement.offsetheight   获取元素的高度= boder + padding + content\n\n * clientwidth 和 clientheight 获取的值不包含边框\n * offsetwidth 和 offsetheight 获取的值包含左右边框\n\n属性                   描述\nelement.clienttop    **获取元素的上边框宽度，**不包括顶部外边距和内边距，以 像素 表示！！不是 em！\nelement.clientleft   获取元素的左边框宽度\nelement.offsettop    获取元素到有定位的父盒子的顶部距离\nelement.offsetleft   获取元素到有定位的父盒子的左侧距离\n\n属性          描述\ne.clientx   鼠标距离可视区的左侧距离\ne.clienty   鼠标距离可视区的顶部距离\n\n\n# scroll 滚动系列\n\n动态获得元素大小，滚动距离等。具有兼容问题\n\n\n\n * scrollwidth 和 scrollheight 主要用于确定元素内容的实际大小\n * scrollleft 和 scrolltop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\n * 垂直滚动 scrolltop > 0\n * 水平滚动 scrollleft > 0\n * 将元素的 scrollleft 和 scrolltop 设置为 0，可以重置元素的滚动位置\n\n\n# 共同点\n\n返回数字时，均不带单位\n\n只读\n\n\n# window相关宽高属性\n\nwindow.innerheight 窗口高度\n\nwindow.screen.availheight声明显示浏览器的屏幕的可用高度，以像素计。除去我们底部任务栏外的屏幕高度\n\nwindow.screen.availwidth声明显示浏览器的屏幕的可用宽度，以像素计\n\n\n# padding百分比\n\npadding-top：数字/百分比(相对于relative的最近父元素计算高度)\n\n如**果父元素有宽度，相对于父元素宽度**，否则，找其父辈元素宽度，均没宽度时，相对于屏幕的宽度\n\n同理 margin的left 、right、bottom和top参考的都是width！！\n\n记错了，笔试还考过！\n\n> 为啥不是height\n\n正常流的大多数元素都足够高包含其子元素，若一个元素上下外边距是父亲的height的%，会导致死循环，父亲的height增加，以适应子元素上下外边距增加，相应的，上下外边距因为父亲height增加又增加……循环……\n\n> 使用场景\n\n移动端，手持设备屏幕宽度不同，不能给满屏图片设置固定宽高，此时padding起作用了\n\n给图片设置固定宽高比，也可以给图片外层加一个固定宽高比的盒子，实现图片 自适应\n\n\n# background-size\n\n设置背景图片大小。图片可以保有其原有的尺寸、拉伸到新的尺寸，或者在保持原有比例的同时缩放到元素的可用空间的尺寸\n\n div{\n            width: 300px;\n            height: 200px;\n            background: url("https://interview.yuadh.com/assets/2.jpg") no-repeat;\n            border: 1px solid red;\n            /*background-size: 100%;*/\n            background-size: cover;\n        }\n/*若图片宽度250px，宽度为250px，让该图片完全铺满整个div区域，设置background-size*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 属性\n\n100%：整个图片铺满div\n\ncover：整个图片铺满div，缩放背景图片以完全覆盖背景区，可能背景图片部分看不见。和 contain 相反，cover 尽可能大地缩放背景图像并保持图像的宽高比例（图像不会被压扁）。背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪\n\ncontain：不能铺满整个div，缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能地缩放背景并保持图像的宽高比例（图像不会被压缩）。背景图会填充所在容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）显示由 background-color 设置的背景颜色\n\nauto：不能铺满整个div，以背景图片比例缩放背景图片',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Git",frontmatter:{title:"Git",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/8564fd/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/04.Git.html",relativePath:"08.专栏/04.Git.md",key:"v-c427e130",path:"/pages/8564fd/",headers:[{level:2,title:"git merge",slug:"git-merge",normalizedTitle:"git merge",charIndex:232},{level:2,title:"gie rebase",slug:"gie-rebase",normalizedTitle:"gie rebase",charIndex:389},{level:2,title:"git reset重置",slug:"git-reset重置",normalizedTitle:"git reset重置",charIndex:1151},{level:2,title:"git revert回退",slug:"git-revert回退",normalizedTitle:"git revert回退",charIndex:1622},{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:1825},{level:2,title:"HEAD",slug:"head",normalizedTitle:"head",charIndex:1506},{level:2,title:"工作树和索引",slug:"工作树和索引",normalizedTitle:"工作树和索引",charIndex:2472},{level:2,title:"fork(叉子——>分叉)",slug:"fork-叉子-分叉",normalizedTitle:"fork(叉子——&gt;分叉)",charIndex:null},{level:2,title:"clone",slug:"clone",normalizedTitle:"clone",charIndex:12},{level:2,title:"branch",slug:"branch",normalizedTitle:"branch",charIndex:184}],headersStr:"git merge gie rebase git reset重置 git revert回退 区别 HEAD 工作树和索引 fork(叉子——>分叉) clone branch",content:'# 常用指令\n\ngit clone 克隆 git init 初始化，会生隐藏文件 git add 添加到暂存区 git commit 推送代码告诉别人这个推送做了什么操作 git pull 更新本地代码 git push pull了之后就是通过该命令推送代码 git fetch 更新本地的代码，不同于pull不会进行合并 git checkout 切换分支 git branch 显示本地的所有分支 git status 查看状态\n\n\n# git rebase、git merge\n\nrebase 重定基地，重新设立起点\n\n都是将一个分支的更改并入另一个分支，只不过方式不同\n\n\n# git merge\n\n将当前分支合并到指定分支\n\n通过其合并分支会新增一个merge commit，再将两个分支历史联系起来\n\n非破坏性的操作，对现有分支不会有更改，历史记录相对复杂\n\n\n# gie rebase\n\n将当前分支移植到指定分支或指定commit上\n\n将整个分支移动到另一个分支上，有效整合所有分支的提交\n\n历史记录清晰，消除了git merge所需的不必要的合并提交\n\ngit rebase -i <commit>\ngit rebase --continue//解决冲突后，继续rebase\n\n\n1\n2\n\n\n\n# git缓存代码\n\n\n# git stash\n\n保存当前工作进度，把暂存区和工作区的改动保存，修改存在栈上\n\n当前文件修改了，需要提交commit保持工作区干净才能切分支\n\n> 当想记录工作目录和索引的目前状态，但又想返回一个干净的工作目录时，用它。该命令将保存本地修改，并恢复工作目录以匹配头部提交\n\n恢复代码\n\ngit stash apply\n\n# 保存当前未commit的代码\ngit stash\n\n# 保存当前未commit的代码并添加备注\ngit stash save "备注的内容"\n\n# 列出stash的所有记录\ngit stash list\n\n# 删除stash的所有记录\ngit stash clear\n\n# 应用最近一次的stash\ngit stash apply\n\n# 应用最近一次的stash，随后删除该记录\ngit stash pop\n\n# 删除最近的一次stash\ngit stash drop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 迁移仓库，同时保留原有提交记录和分支？\n\ngit clone 仓库地址\ncd 项目\ngit push --mirror 新的仓库地址\n\n\n1\n2\n3\n\n\n\n# git reset、git revert\n\n都有 撤销、回退 的意思\n\n\n# git reset重置\n\ngit reset --hard\n\n代码完全回退到本次提交时的状态，工作暂存区和本次提交后的**提交内容完全被清除，包括记录**\n\ngit push -f 强制提交\n\ngit status查看状态\n\nreset是彻底的回退，该commit后的所有修改完全消失，包括提交记录\n\n * 彻底回退 指定版本，干净清爽\n * 提交时间线情绪，没有冗杂\n * 记录彻底清除，无法再恢复\n\nreset --soft\n\n> 完全不接触索引文件和工作树，使所有更改的文件更改为“要提交的更改”\n\n回退已提交的commit，将commit的修改内容放在暂存区\n\n> reset \\--hard\n\n让commit记录强制回溯到某一节点\n\n# 恢复最近一次 commit\ngit reset --soft HEAD^\n\n\n1\n2\n\n\n以上针对未push的commit，对已push的commit，也可以使用该命令，但再次push时，因为远程分支和本地有差异，需要强制推送 git push \\-f 覆盖被reset的commit\n\n\n# git revert回退\n\n在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不改变历史，用于安全取消过去发布的提交\n\n此次操作之前和之后的 commit和history都会保留，且把这次撤销作为最新的提交，如下：\n\n撤销（revert）作为 撤销公开的提交（比如已经push）的安全方式，git reset重设本地更改\n\n重设完全移除一堆更改，而撤销保留原来更改，用新的提交实现撤销\n\n\n# 区别\n\n * git revert是新的commit回滚之前的commit，git reset直接删除指定commit\n * git reset 把HEAD向后移动，git revert是HEAD继续前进，只是新commit的内容和要revert的内容相反，抵消要被revert的内容\n * 回滚这一操作上看，效果差不多，但在日后merge 以前的老版本时有区别\n\n> git revert用一次逆向的commit“中和”之前的提交，日后合并老的branch时，之前提交合并的代码仍存在，导致不能重新合并\n> \n> git reset把某些commit在某个branch上删除，和老branch再次merge时，被回滚的commit应该还会被引入\n\n如果回退分支的代码以后还要用——使用git revert\n\n如果分支是提错了没用的，并且不想让别人发现这些错误——使用git reset\n\n\n# git pull、git fetch\n\ngit pull 从另一个存储库或本地分支获取并整合\n\ngit fetch 从另一个存储库下载对象和引用\n\n\n\ngit pull=git fetch+git merge\n\n\n# HEAD、工作树、索引？\n\n\n# HEAD\n\ngit很多分支的本质是一个指向commit对象的可变指针，head是一个指向你正在工作中国的本地分支的指针。\n\n通过git checkout test切换分支，head->test\n\nHEAD指针——>分支指针——>最新提交\n\n\n# 工作树和索引\n\n索引为了向数据库提交作准备的渔区——暂存区\n\n工作树——查看和编辑文件的实际内容(本地工作区)\n\n\n# fork，clone，branch\n\n\n# fork(叉子——>分叉)\n\n克隆出一个仓库的新拷贝\n\n若想要将修改合并，通过pull request 将提交贡献给原仓库\n\n\n# clone\n\n下载本地，形成本地代码库\n\ngit push\n\n\n# branch\n\n开启另一个分支\n\ngit checkout切换分支\n\n\n# git add -A、git add .\n\ngit add -A 提交所有变化\n\ngit add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\n\ngit add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件\n\n\n# git log\n\n查看提交日志\n\n\n# git合并冲突\n\n手动处理\n\n可使用git diff查看文件不同\n\n合并冲突后再git add ，git commit 最后 git push\n\n\n# git cherry-pick\n\n阮一峰 git cherry-pick教程\n\n将指定的提交（commit）应用于其他分支\n\n\n# git分支开发错了怎么办\n\n第一步，暂存\n\ngit stash\n\n第二步，切换分支\n\ngit checkout <分支名>\n\n第三步，取出暂存代码\n\ngit stash pop\n\n\n# git将多个commit合并为一个\n\ngit rebase -i commitId ，commitId 是想要合并的多个记录前的提交记录commitId',normalizedContent:'# 常用指令\n\ngit clone 克隆 git init 初始化，会生隐藏文件 git add 添加到暂存区 git commit 推送代码告诉别人这个推送做了什么操作 git pull 更新本地代码 git push pull了之后就是通过该命令推送代码 git fetch 更新本地的代码，不同于pull不会进行合并 git checkout 切换分支 git branch 显示本地的所有分支 git status 查看状态\n\n\n# git rebase、git merge\n\nrebase 重定基地，重新设立起点\n\n都是将一个分支的更改并入另一个分支，只不过方式不同\n\n\n# git merge\n\n将当前分支合并到指定分支\n\n通过其合并分支会新增一个merge commit，再将两个分支历史联系起来\n\n非破坏性的操作，对现有分支不会有更改，历史记录相对复杂\n\n\n# gie rebase\n\n将当前分支移植到指定分支或指定commit上\n\n将整个分支移动到另一个分支上，有效整合所有分支的提交\n\n历史记录清晰，消除了git merge所需的不必要的合并提交\n\ngit rebase -i <commit>\ngit rebase --continue//解决冲突后，继续rebase\n\n\n1\n2\n\n\n\n# git缓存代码\n\n\n# git stash\n\n保存当前工作进度，把暂存区和工作区的改动保存，修改存在栈上\n\n当前文件修改了，需要提交commit保持工作区干净才能切分支\n\n> 当想记录工作目录和索引的目前状态，但又想返回一个干净的工作目录时，用它。该命令将保存本地修改，并恢复工作目录以匹配头部提交\n\n恢复代码\n\ngit stash apply\n\n# 保存当前未commit的代码\ngit stash\n\n# 保存当前未commit的代码并添加备注\ngit stash save "备注的内容"\n\n# 列出stash的所有记录\ngit stash list\n\n# 删除stash的所有记录\ngit stash clear\n\n# 应用最近一次的stash\ngit stash apply\n\n# 应用最近一次的stash，随后删除该记录\ngit stash pop\n\n# 删除最近的一次stash\ngit stash drop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 迁移仓库，同时保留原有提交记录和分支？\n\ngit clone 仓库地址\ncd 项目\ngit push --mirror 新的仓库地址\n\n\n1\n2\n3\n\n\n\n# git reset、git revert\n\n都有 撤销、回退 的意思\n\n\n# git reset重置\n\ngit reset --hard\n\n代码完全回退到本次提交时的状态，工作暂存区和本次提交后的**提交内容完全被清除，包括记录**\n\ngit push -f 强制提交\n\ngit status查看状态\n\nreset是彻底的回退，该commit后的所有修改完全消失，包括提交记录\n\n * 彻底回退 指定版本，干净清爽\n * 提交时间线情绪，没有冗杂\n * 记录彻底清除，无法再恢复\n\nreset --soft\n\n> 完全不接触索引文件和工作树，使所有更改的文件更改为“要提交的更改”\n\n回退已提交的commit，将commit的修改内容放在暂存区\n\n> reset \\--hard\n\n让commit记录强制回溯到某一节点\n\n# 恢复最近一次 commit\ngit reset --soft head^\n\n\n1\n2\n\n\n以上针对未push的commit，对已push的commit，也可以使用该命令，但再次push时，因为远程分支和本地有差异，需要强制推送 git push \\-f 覆盖被reset的commit\n\n\n# git revert回退\n\n在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不改变历史，用于安全取消过去发布的提交\n\n此次操作之前和之后的 commit和history都会保留，且把这次撤销作为最新的提交，如下：\n\n撤销（revert）作为 撤销公开的提交（比如已经push）的安全方式，git reset重设本地更改\n\n重设完全移除一堆更改，而撤销保留原来更改，用新的提交实现撤销\n\n\n# 区别\n\n * git revert是新的commit回滚之前的commit，git reset直接删除指定commit\n * git reset 把head向后移动，git revert是head继续前进，只是新commit的内容和要revert的内容相反，抵消要被revert的内容\n * 回滚这一操作上看，效果差不多，但在日后merge 以前的老版本时有区别\n\n> git revert用一次逆向的commit“中和”之前的提交，日后合并老的branch时，之前提交合并的代码仍存在，导致不能重新合并\n> \n> git reset把某些commit在某个branch上删除，和老branch再次merge时，被回滚的commit应该还会被引入\n\n如果回退分支的代码以后还要用——使用git revert\n\n如果分支是提错了没用的，并且不想让别人发现这些错误——使用git reset\n\n\n# git pull、git fetch\n\ngit pull 从另一个存储库或本地分支获取并整合\n\ngit fetch 从另一个存储库下载对象和引用\n\n\n\ngit pull=git fetch+git merge\n\n\n# head、工作树、索引？\n\n\n# head\n\ngit很多分支的本质是一个指向commit对象的可变指针，head是一个指向你正在工作中国的本地分支的指针。\n\n通过git checkout test切换分支，head->test\n\nhead指针——>分支指针——>最新提交\n\n\n# 工作树和索引\n\n索引为了向数据库提交作准备的渔区——暂存区\n\n工作树——查看和编辑文件的实际内容(本地工作区)\n\n\n# fork，clone，branch\n\n\n# fork(叉子——>分叉)\n\n克隆出一个仓库的新拷贝\n\n若想要将修改合并，通过pull request 将提交贡献给原仓库\n\n\n# clone\n\n下载本地，形成本地代码库\n\ngit push\n\n\n# branch\n\n开启另一个分支\n\ngit checkout切换分支\n\n\n# git add -a、git add .\n\ngit add -a 提交所有变化\n\ngit add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\n\ngit add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件\n\n\n# git log\n\n查看提交日志\n\n\n# git合并冲突\n\n手动处理\n\n可使用git diff查看文件不同\n\n合并冲突后再git add ，git commit 最后 git push\n\n\n# git cherry-pick\n\n阮一峰 git cherry-pick教程\n\n将指定的提交（commit）应用于其他分支\n\n\n# git分支开发错了怎么办\n\n第一步，暂存\n\ngit stash\n\n第二步，切换分支\n\ngit checkout <分支名>\n\n第三步，取出暂存代码\n\ngit stash pop\n\n\n# git将多个commit合并为一个\n\ngit rebase -i commitid ，commitid 是想要合并的多个记录前的提交记录commitid',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"HTML",frontmatter:{title:"HTML",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/5798b5/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/05.HTML.html",relativePath:"08.专栏/05.HTML.md",key:"v-61f931e4",path:"/pages/5798b5/",headers:[{level:2,title:"新增",slug:"新增",normalizedTitle:"新增",charIndex:688},{level:2,title:"移除",slug:"移除",normalizedTitle:"移除",charIndex:1235},{level:2,title:"限制iframe访问另一个页面",slug:"限制iframe访问另一个页面",normalizedTitle:"限制iframe访问另一个页面",charIndex:3203},{level:2,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:2670},{level:2,title:"name属性",slug:"name属性",normalizedTitle:"name属性",charIndex:4100},{level:3,title:"description",slug:"description",normalizedTitle:"description",charIndex:4153},{level:3,title:"keywords",slug:"keywords",normalizedTitle:"keywords",charIndex:4189},{level:3,title:"viewpoint",slug:"viewpoint",normalizedTitle:"viewpoint",charIndex:4254},{level:2,title:"表引用的标签?",slug:"表引用的标签",normalizedTitle:"表引用的标签?",charIndex:4800},{level:2,title:"表列表的标签?",slug:"表列表的标签",normalizedTitle:"表列表的标签?",charIndex:4832},{level:2,title:"h标签，表段落的标签？",slug:"h标签-表段落的标签",normalizedTitle:"h标签，表段落的标签？",charIndex:4902},{level:2,title:"Service Worker",slug:"service-worker",normalizedTitle:"service worker",charIndex:5330}],headersStr:"新增 移除 限制iframe访问另一个页面 属性 name属性 description keywords viewpoint 表引用的标签? 表列表的标签? h标签，表段落的标签？ Service Worker",content:'# HTML文档结构\n\n2个元素提供HTML文档的外部结构\n\n * DOCUTYPE element，告诉浏览器正在处理 HTML 文档\n * html element，他们间的内容标记网页，body标记网页可见内容\n\n<!DOCUTYPE HTML>\n<html>\n    <title></title>\n    <head>\n        元数据提供文档\n    </head>\n    <body>\n        <h1>\n            \n        </h1>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 🍅DOCUTYPE\n\nDOCTYPE是document type (文档类型) 的缩写\n\n文档类型声明，**告诉浏览器文档的类型，便于解析文档 ** 不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JS 脚本的解析 它必须声明在HTML⽂档的第⼀⾏.\n\n浏览器渲染页面的两种模式\n\n * CSS1 Compat：标准模式（Strick mode），浏览器使用W3C的标准解析渲染页面 浏览器以其支持的最高标准呈现页面\n\n * BackCompat：怪异模式(混杂模式)(Quick mode)，默认模式，页面以一种比较宽松的向后兼容的方式显示\n\n> DOCTYPE 不存在或者形式不正确会导致HTML或XHTML文档以混杂模式呈现，就是把如何渲染html页面的权利交给了浏览器，有多少种浏览器就有多少种展示方式 因此要提高浏览器兼容性就必须重视\n\n\n# HTML5特性\n\n\n# 新增\n\n * 新的选择器 document.querySelector、document.querySelectorAll\n * 媒体播放的 video 和 audio 标签\n   * 以前用的flash实现\n * 本地存储 localStorage 和 sessionStorage\n * 浏览器通知 Notifications\n * 语义化标签，例如 header，nav，footer，section，article 等标签\n * 地理位置 Geolocation\n   * 鉴于隐私性，除非用户统一，否则不可获取用户地理位置信息\n * 离线应用 manifest\n * 全双工通信协议 websocket\n * 浏览器历史对象 history\n * 多任务处理 web worker\n   * 运行在后台的JS，独立于其他脚本，不影响性能\n * 拖拽相关API\n * 增强表单控件 url，date，time，email，calendar，search\n * 页面可见性改变事件 visibilitychange\n * 跨窗口通信 PostMessage\n * 表单 FormData 对象\n * canvas+SVG\n * contenteditable——元素是否可被编辑\n\n\n# 移除\n\n * 纯表现的元素：basefont、big、center、font、 s、strike、tt、u\n * 对可用性产生负面影响的元素：frame、frameset、noframes\n\n 1. 不要将section作为页面容器\n 2. 如果artcle、aside、nav更符合条件，就不要使用section\n\n\n# HTML5比HTML4性能优化/标签\n\ndefer和sync\n\nHTML5视频播放 流畅清晰，省电；HTML5游戏小巧流畅，画面质量高，易上手；HTML5广告摆脱了以前网页广告的悬浮、滚动和弹出，更容易让用户接受\n\nHTML5代码贴合用户有明确释义，对开发者有利，搜索引擎也更容易识别到网页上的内容，让网站获得更多流量\n\nHTML5可跨平台，多数核心代码不用重写，应用于包括移动应用、移动网站、PC网站、各种浏览器插件。对用户来说，不用下载APP，直接打开浏览器就能访问应用，避开各类应用商店的审核程序\n\n实时更新，维护更简单，HTML5游戏是马上的、即时的更新。\n\n使用门槛低，容易推广\n\nHTML5应用导流入口很多，超级 App (如微信朋友圈)、搜索引擎、应用市场、浏览器……而原生 App 的流量入口只有应用市场\n\n更精美的动画效果，更低的开发成本\n\n应用HTML5技术做出来的网页能给人眼前一亮的感觉，基于html5和CSS3共同实现，HTML5还支持自适应，“一次设计，普遍适用。”不用单独开发，为企业降低开发成本\n\n\n# 🍅语义化\n\n根据内容的结构选择合适的标签\n\n> 优点\n\n * 增加代码可读性，结构清晰，便于开发和维护\n * 对机器友好，文字表现力丰富，有利于SEO SEO(Search Engine Optimization)是搜索引擎优化，为了让用户在搜索和网站相关的关键词的时候，可以使网站在搜索引擎的排名尽量靠前\n * 方便设备解析（如盲人阅读器等）\n * 在没有 CSS 样式下，页面也能呈现出很好的内容结构、代码结构\n\n> 常见的语义化标签\n\ntitle ：页面主体内容\n\nheader ： 页眉通常包括网站标志、主导航、全站链接以及搜索框\n\nnav ： 标记导航，仅对文档中重要的链接群使用\n\nsection ： 定义文档中的节（section、区段） 比如章节、页眉、页脚或文档中的其他部分\n\nmain，帮助到搜索引擎以及搜索工程师找到网站的主要内容\n\narticle： 文档、页面、应用或站点的独立部分，大体可独立分配/重复使用，可是论坛帖子、杂志、新闻、博客条目、用户评论，互动小工具、任何其他独立项目的内容，专用于结构化文章，特别是要发布的，如博客、页面内容、论坛帖子\n\naside ： 定义其所处内容之外的内容 如侧栏、文章的一组链接、广告、友情链接、相关产品列表等\n\nfooter：页脚，只有当父级是body时，才是整个页面的页脚\n\naddress： 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）\n\n\n# xhtml、html\n\nML——Markup Language（标记语言）\n\nHTML——HyperText Markup Language，超文本标记语言\n\nXHTML——Extensive Markup Language，可扩展标记语言，是以XML格式编写的HTML\n\nXHTML目标是取代HTML，是更严格更纯净的HTML版本\n\n\n# data-\n\ndata-属性赋予页面 私有 自定义 属性\n\n存储的数据能够被JS利用\n\n例如图片懒加载\n\n\n# 渐进式渲染\n\n提高网页性能，尽快呈现页面的技术\n\n> 体现\n\n图片懒加载：当用户滚动页面到图片部分时，JS加载并显示图像\n\n确定显示内容优先级\n\n初步加载HTML片段\n\n\n# img标签title、alt\n\nalt：图片加载失败时，显示alt的内容，利于SEO\n\ntitle：鼠标移动到图片上时，显示title的内容\n\n\n# src、href\n\nsrc——source，指向外部资源位置，将资源下载到页面，解析到该元素时 浏览器对文件进行解析，编译和执行，导致整个页面加载被暂停\n\nhref—— Hypertext Reference ，超文本引用，指向资源位置，建立与目标文件的链接\n\n浏览器遇到href 并行下载不会停止对当前文档的处理\n\n所以建议 使用link加载css，而不是@import？？关css啥事？\n\n\n# iframe\n\niframe 元素 可以在一个网站里面嵌入另一个网站内容\n\n优点\n\n 1. 实现一个窗口同时加载多个第三方域名下内容\n 2. 增加代码复用性\n\n缺点：\n\n 1. 搜索引擎无法识别\n 2. 影响首页首屏加载时间\n 3. 兼容性差\n\n\n# 限制iframe访问另一个页面\n\n设置X-Frame-Options 响应头 ——是否允许网页通过iframe 嵌套\n\n * deny：完全禁止任何网页嵌套\n * sameorigin：只允许同源域名访问\n * allow-from url：允许url的域名可嵌套\n\n设置Content-Security-Policy\n\nCSP，内容安全策略，限定网页允许加载的资源，防范XSS攻击\n\n"Content-Security-Policy": "frame-ancestors \'self\'"//限定iframe的嵌套\n\n\n1\n\n\n判断 window.top 页面顶级窗口和 自身窗口 window.self 是否相等，若不等则是嵌入了iframe\n\n\n# meta标签\n\nMetadata——元数据，描述数据 的数据，主要描述数据 属性 的信息\n\n> meta**是文档级元数据元素，**表示那些不由其他HTML相关元素(<base>、<link>, <script>、<style>或 <title>）之一表示的任何元数据\n\n目的：传递信息\n\n<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport" />\n\n\n1\n\n * width=device-width: 自适应手机屏幕的尺寸宽度\n * maximum-scale:缩放比例的最大值\n * inital-scale:缩放的初始化\n * user-scalable:用户可以缩放\n\n\n# 属性\n\n * name 提供文档级别的元数据\n * charset 声明字符集，告诉文档使用哪种字符编码\n * itemprop 提供用户定义的元数据\n * http-equiv相当于HTTP头文件的作用\n\nhttp-equiv="X-UA-Compatible"  IE浏览器兼容性设置\ncontent="IE=edge" IE8/9及以后的版本都会以最高版本IE来渲染页面\n\n\n1\n2\n\n\n\n# name属性\n\nname和content一起使用，前者表示要表示的元数据的名称，后者是元数据的值\n\n\n# description\n\n是一段简短而精确的、对页面内容的描述\n\n\n# keywords\n\n与页面内容相关的关键词，使用逗号分隔。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。\n\n\n# viewpoint\n\n为 viewport（视口）的初始大小提供指示。目前仅用于移动设备\n\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n\n\n1\n\n\nwidth用来设置 viewport 的宽度为设备宽度;\n\ninitial-scale为设备宽度与 viewport 大小之间的缩放比例\n\nuser-scalable 可对页面进行缩放，no 禁止缩放\n\n<meta \n  name="viewport" \n  content="\n    width=device-width,  // viewport的宽等于屏幕宽，避免 横向滚动条\n    initial-scale=1.0,  // 初始缩放为1\n    maximum-scale=1.0, \n    user-scalable=no,  // 不允许手动缩放\n    viewport-fit=cover // 缩放以填充满屏幕\n    " \n>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 标签\n\nSTRONG   重要文本\nem       强调文本\nb        粗体文本\nbig      大号字体效果\n\n\n# 表引用的标签?\n\n<cite></cite>\n\n\n1\n\n\n\n# 表列表的标签?\n\n1、无序列表，使用“ul”标签定义\n\n2、有序列表，使用“ol”标签定义\n\n3、自定义列表，使用“dl”标签定义\n\n\n# h标签，表段落的标签？\n\nh标签有6个\n\n<p></p>\n\n\n1\n\n\n\n# 🙋 Web Worker\n\nJS采用单线程模型，前面任务没做完 后面的任务只能等着\n\nweb worker为JS创造多线程环境，允许主线程创建worker线程，将一些任务分配给后者运行，主线程运行的同时，worker线程在后台，互不干扰，worker完成计算任务 将结果返回 主线程\n\n好处：计算密集型/高延迟的任务 由worker负担，主线程流畅\n\nworker线程一旦创建 ，始终运行，不会被主线程上的活动打断，有利响应主线程的通信，缺点：worker消耗资源，不该过度使用\n\n> 注意\n\n * 同源限制\n * DOM限制\n * 无法读取主线程所在网页的DOM对象，但可读navigator/location对象\n * worker线程和主线程不在同一个上下文环境，不能直接通信\n * worker不能执行alert()/confirm()，但可以发出Ajax请求\n\n\n# Service Worker\n\n是web worker的一个类型\n\n> 本质 充当application与浏览器间的代理服务器，旨在创建有效的离线体验，拦截网络请求并基于网络是否可用，以及更新的资源是否驻留，在服务器上来采取适当的动作\n\n运行在浏览器背后的独立线程， 通常用来 缓存文件，提高首屏速度\n\n不仅是cache，还通过worker的方式进一步优化，基于H5的web worker，不会阻塞JS线程执行\n\nSW最重要的是\n\n 1. 后台线程：独立于当前网络线程\n 2. 网络代理：在网页发起请求时代理，缓存文件\n\n使用SW的话，传输协议必须是HTTPS。Service Worker涉及请求拦截，必须用HTTPS协议保障安全。它可让我们自由控制缓存文件、如何匹配缓存、如何读取缓存',normalizedContent:'# html文档结构\n\n2个元素提供html文档的外部结构\n\n * docutype element，告诉浏览器正在处理 html 文档\n * html element，他们间的内容标记网页，body标记网页可见内容\n\n<!docutype html>\n<html>\n    <title></title>\n    <head>\n        元数据提供文档\n    </head>\n    <body>\n        <h1>\n            \n        </h1>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 🍅docutype\n\ndoctype是document type (文档类型) 的缩写\n\n文档类型声明，**告诉浏览器文档的类型，便于解析文档 ** 不同的渲染模式会影响浏览器对 css 代码甚⾄ js 脚本的解析 它必须声明在html⽂档的第⼀⾏.\n\n浏览器渲染页面的两种模式\n\n * css1 compat：标准模式（strick mode），浏览器使用w3c的标准解析渲染页面 浏览器以其支持的最高标准呈现页面\n\n * backcompat：怪异模式(混杂模式)(quick mode)，默认模式，页面以一种比较宽松的向后兼容的方式显示\n\n> doctype 不存在或者形式不正确会导致html或xhtml文档以混杂模式呈现，就是把如何渲染html页面的权利交给了浏览器，有多少种浏览器就有多少种展示方式 因此要提高浏览器兼容性就必须重视\n\n\n# html5特性\n\n\n# 新增\n\n * 新的选择器 document.queryselector、document.queryselectorall\n * 媒体播放的 video 和 audio 标签\n   * 以前用的flash实现\n * 本地存储 localstorage 和 sessionstorage\n * 浏览器通知 notifications\n * 语义化标签，例如 header，nav，footer，section，article 等标签\n * 地理位置 geolocation\n   * 鉴于隐私性，除非用户统一，否则不可获取用户地理位置信息\n * 离线应用 manifest\n * 全双工通信协议 websocket\n * 浏览器历史对象 history\n * 多任务处理 web worker\n   * 运行在后台的js，独立于其他脚本，不影响性能\n * 拖拽相关api\n * 增强表单控件 url，date，time，email，calendar，search\n * 页面可见性改变事件 visibilitychange\n * 跨窗口通信 postmessage\n * 表单 formdata 对象\n * canvas+svg\n * contenteditable——元素是否可被编辑\n\n\n# 移除\n\n * 纯表现的元素：basefont、big、center、font、 s、strike、tt、u\n * 对可用性产生负面影响的元素：frame、frameset、noframes\n\n 1. 不要将section作为页面容器\n 2. 如果artcle、aside、nav更符合条件，就不要使用section\n\n\n# html5比html4性能优化/标签\n\ndefer和sync\n\nhtml5视频播放 流畅清晰，省电；html5游戏小巧流畅，画面质量高，易上手；html5广告摆脱了以前网页广告的悬浮、滚动和弹出，更容易让用户接受\n\nhtml5代码贴合用户有明确释义，对开发者有利，搜索引擎也更容易识别到网页上的内容，让网站获得更多流量\n\nhtml5可跨平台，多数核心代码不用重写，应用于包括移动应用、移动网站、pc网站、各种浏览器插件。对用户来说，不用下载app，直接打开浏览器就能访问应用，避开各类应用商店的审核程序\n\n实时更新，维护更简单，html5游戏是马上的、即时的更新。\n\n使用门槛低，容易推广\n\nhtml5应用导流入口很多，超级 app (如微信朋友圈)、搜索引擎、应用市场、浏览器……而原生 app 的流量入口只有应用市场\n\n更精美的动画效果，更低的开发成本\n\n应用html5技术做出来的网页能给人眼前一亮的感觉，基于html5和css3共同实现，html5还支持自适应，“一次设计，普遍适用。”不用单独开发，为企业降低开发成本\n\n\n# 🍅语义化\n\n根据内容的结构选择合适的标签\n\n> 优点\n\n * 增加代码可读性，结构清晰，便于开发和维护\n * 对机器友好，文字表现力丰富，有利于seo seo(search engine optimization)是搜索引擎优化，为了让用户在搜索和网站相关的关键词的时候，可以使网站在搜索引擎的排名尽量靠前\n * 方便设备解析（如盲人阅读器等）\n * 在没有 css 样式下，页面也能呈现出很好的内容结构、代码结构\n\n> 常见的语义化标签\n\ntitle ：页面主体内容\n\nheader ： 页眉通常包括网站标志、主导航、全站链接以及搜索框\n\nnav ： 标记导航，仅对文档中重要的链接群使用\n\nsection ： 定义文档中的节（section、区段） 比如章节、页眉、页脚或文档中的其他部分\n\nmain，帮助到搜索引擎以及搜索工程师找到网站的主要内容\n\narticle： 文档、页面、应用或站点的独立部分，大体可独立分配/重复使用，可是论坛帖子、杂志、新闻、博客条目、用户评论，互动小工具、任何其他独立项目的内容，专用于结构化文章，特别是要发布的，如博客、页面内容、论坛帖子\n\naside ： 定义其所处内容之外的内容 如侧栏、文章的一组链接、广告、友情链接、相关产品列表等\n\nfooter：页脚，只有当父级是body时，才是整个页面的页脚\n\naddress： 作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）\n\n\n# xhtml、html\n\nml——markup language（标记语言）\n\nhtml——hypertext markup language，超文本标记语言\n\nxhtml——extensive markup language，可扩展标记语言，是以xml格式编写的html\n\nxhtml目标是取代html，是更严格更纯净的html版本\n\n\n# data-\n\ndata-属性赋予页面 私有 自定义 属性\n\n存储的数据能够被js利用\n\n例如图片懒加载\n\n\n# 渐进式渲染\n\n提高网页性能，尽快呈现页面的技术\n\n> 体现\n\n图片懒加载：当用户滚动页面到图片部分时，js加载并显示图像\n\n确定显示内容优先级\n\n初步加载html片段\n\n\n# img标签title、alt\n\nalt：图片加载失败时，显示alt的内容，利于seo\n\ntitle：鼠标移动到图片上时，显示title的内容\n\n\n# src、href\n\nsrc——source，指向外部资源位置，将资源下载到页面，解析到该元素时 浏览器对文件进行解析，编译和执行，导致整个页面加载被暂停\n\nhref—— hypertext reference ，超文本引用，指向资源位置，建立与目标文件的链接\n\n浏览器遇到href 并行下载不会停止对当前文档的处理\n\n所以建议 使用link加载css，而不是@import？？关css啥事？\n\n\n# iframe\n\niframe 元素 可以在一个网站里面嵌入另一个网站内容\n\n优点\n\n 1. 实现一个窗口同时加载多个第三方域名下内容\n 2. 增加代码复用性\n\n缺点：\n\n 1. 搜索引擎无法识别\n 2. 影响首页首屏加载时间\n 3. 兼容性差\n\n\n# 限制iframe访问另一个页面\n\n设置x-frame-options 响应头 ——是否允许网页通过iframe 嵌套\n\n * deny：完全禁止任何网页嵌套\n * sameorigin：只允许同源域名访问\n * allow-from url：允许url的域名可嵌套\n\n设置content-security-policy\n\ncsp，内容安全策略，限定网页允许加载的资源，防范xss攻击\n\n"content-security-policy": "frame-ancestors \'self\'"//限定iframe的嵌套\n\n\n1\n\n\n判断 window.top 页面顶级窗口和 自身窗口 window.self 是否相等，若不等则是嵌入了iframe\n\n\n# meta标签\n\nmetadata——元数据，描述数据 的数据，主要描述数据 属性 的信息\n\n> meta**是文档级元数据元素，**表示那些不由其他html相关元素(<base>、<link>, <script>、<style>或 <title>）之一表示的任何元数据\n\n目的：传递信息\n\n<meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport" />\n\n\n1\n\n * width=device-width: 自适应手机屏幕的尺寸宽度\n * maximum-scale:缩放比例的最大值\n * inital-scale:缩放的初始化\n * user-scalable:用户可以缩放\n\n\n# 属性\n\n * name 提供文档级别的元数据\n * charset 声明字符集，告诉文档使用哪种字符编码\n * itemprop 提供用户定义的元数据\n * http-equiv相当于http头文件的作用\n\nhttp-equiv="x-ua-compatible"  ie浏览器兼容性设置\ncontent="ie=edge" ie8/9及以后的版本都会以最高版本ie来渲染页面\n\n\n1\n2\n\n\n\n# name属性\n\nname和content一起使用，前者表示要表示的元数据的名称，后者是元数据的值\n\n\n# description\n\n是一段简短而精确的、对页面内容的描述\n\n\n# keywords\n\n与页面内容相关的关键词，使用逗号分隔。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。\n\n\n# viewpoint\n\n为 viewport（视口）的初始大小提供指示。目前仅用于移动设备\n\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n\n\n1\n\n\nwidth用来设置 viewport 的宽度为设备宽度;\n\ninitial-scale为设备宽度与 viewport 大小之间的缩放比例\n\nuser-scalable 可对页面进行缩放，no 禁止缩放\n\n<meta \n  name="viewport" \n  content="\n    width=device-width,  // viewport的宽等于屏幕宽，避免 横向滚动条\n    initial-scale=1.0,  // 初始缩放为1\n    maximum-scale=1.0, \n    user-scalable=no,  // 不允许手动缩放\n    viewport-fit=cover // 缩放以填充满屏幕\n    " \n>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 标签\n\nstrong   重要文本\nem       强调文本\nb        粗体文本\nbig      大号字体效果\n\n\n# 表引用的标签?\n\n<cite></cite>\n\n\n1\n\n\n\n# 表列表的标签?\n\n1、无序列表，使用“ul”标签定义\n\n2、有序列表，使用“ol”标签定义\n\n3、自定义列表，使用“dl”标签定义\n\n\n# h标签，表段落的标签？\n\nh标签有6个\n\n<p></p>\n\n\n1\n\n\n\n# 🙋 web worker\n\njs采用单线程模型，前面任务没做完 后面的任务只能等着\n\nweb worker为js创造多线程环境，允许主线程创建worker线程，将一些任务分配给后者运行，主线程运行的同时，worker线程在后台，互不干扰，worker完成计算任务 将结果返回 主线程\n\n好处：计算密集型/高延迟的任务 由worker负担，主线程流畅\n\nworker线程一旦创建 ，始终运行，不会被主线程上的活动打断，有利响应主线程的通信，缺点：worker消耗资源，不该过度使用\n\n> 注意\n\n * 同源限制\n * dom限制\n * 无法读取主线程所在网页的dom对象，但可读navigator/location对象\n * worker线程和主线程不在同一个上下文环境，不能直接通信\n * worker不能执行alert()/confirm()，但可以发出ajax请求\n\n\n# service worker\n\n是web worker的一个类型\n\n> 本质 充当application与浏览器间的代理服务器，旨在创建有效的离线体验，拦截网络请求并基于网络是否可用，以及更新的资源是否驻留，在服务器上来采取适当的动作\n\n运行在浏览器背后的独立线程， 通常用来 缓存文件，提高首屏速度\n\n不仅是cache，还通过worker的方式进一步优化，基于h5的web worker，不会阻塞js线程执行\n\nsw最重要的是\n\n 1. 后台线程：独立于当前网络线程\n 2. 网络代理：在网页发起请求时代理，缓存文件\n\n使用sw的话，传输协议必须是https。service worker涉及请求拦截，必须用https协议保障安全。它可让我们自由控制缓存文件、如何匹配缓存、如何读取缓存',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"JS",frontmatter:{title:"JS",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/1f9ab3/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/06.JS.html",relativePath:"08.专栏/06.JS.md",key:"v-4d580af8",path:"/pages/1f9ab3/",headers:[{level:2,title:"isNaN、number.isNaN",slug:"isnan、number-isnan",normalizedTitle:"isnan、number.isnan",charIndex:596},{level:2,title:"isFinite、isNaN",slug:"isfinite、isnan",normalizedTitle:"isfinite、isnan",charIndex:1026},{level:2,title:"parseInt、parseFloat",slug:"parseint、parsefloat",normalizedTitle:"parseint、parsefloat",charIndex:1446},{level:2,title:"escape、encodeURI、encodeURIComponent",slug:"escape、encodeuri、encodeuricomponent",normalizedTitle:"escape、encodeuri、encodeuricomponent",charIndex:2032},{level:2,title:"栈",slug:"栈",normalizedTitle:"栈",charIndex:3987},{level:2,title:"堆",slug:"堆",normalizedTitle:"堆",charIndex:4304},{level:2,title:"null、undefined",slug:"null、undefined",normalizedTitle:"null、undefined",charIndex:4576},{level:2,title:"数字处理",slug:"数字处理",normalizedTitle:"数字处理",charIndex:5214},{level:3,title:"toFixed(n)",slug:"tofixed-n",normalizedTitle:"tofixed(n)",charIndex:5530},{level:3,title:"parseInt()",slug:"parseint",normalizedTitle:"parseint()",charIndex:476},{level:4,title:"['1', '2', '3'].map(parseInt)",slug:"_1-2-3-map-parseint",normalizedTitle:"['1', '2', '3'].map(parseint)",charIndex:6236},{level:3,title:"toPrecision()",slug:"toprecision",normalizedTitle:"toprecision()",charIndex:6460},{level:2,title:"🔥 Symbol",slug:"symbol",normalizedTitle:"🔥 symbol",charIndex:6576},{level:2,title:"创建数组",slug:"创建数组",normalizedTitle:"创建数组",charIndex:7933},{level:2,title:"改变原数组",slug:"改变原数组",normalizedTitle:"改变原数组",charIndex:8550},{level:3,title:"数组内存不够了，但还是要继续push元素咋办？",slug:"数组内存不够了-但还是要继续push元素咋办",normalizedTitle:"数组内存不够了，但还是要继续push元素咋办？",charIndex:8582},{level:2,title:"不改变原数组",slug:"不改变原数组",normalizedTitle:"不改变原数组",charIndex:9757},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:6713},{level:2,title:"特殊情况",slug:"特殊情况",normalizedTitle:"特殊情况",charIndex:5129},{level:2,title:"遍历",slug:"遍历",normalizedTitle:"遍历",charIndex:10876},{level:2,title:"集合转换为数组",slug:"集合转换为数组",normalizedTitle:"集合转换为数组",charIndex:13569},{level:2,title:"for",slug:"for",normalizedTitle:"for",charIndex:3107},{level:2,title:"for in (ES5)",slug:"for-in-es5",normalizedTitle:"for in (es5)",charIndex:15015},{level:2,title:"for of (ES6)",slug:"for-of-es6",normalizedTitle:"for of (es6)",charIndex:15298},{level:2,title:"every/some",slug:"every-some",normalizedTitle:"every/some",charIndex:15625},{level:2,title:"fliter",slug:"fliter",normalizedTitle:"fliter",charIndex:15676},{level:2,title:"forEach()",slug:"foreach",normalizedTitle:"foreach()",charIndex:13156},{level:2,title:"map()",slug:"map",normalizedTitle:"map()",charIndex:11194},{level:3,title:'["1", "2", "3"].map(parseInt)',slug:"_1-2-3-map-parseint-2",normalizedTitle:"[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseint)",charIndex:null},{level:2,title:"对比",slug:"对比",normalizedTitle:"对比",charIndex:16405},{level:2,title:"replace",slug:"replace",normalizedTitle:"replace",charIndex:18613},{level:3,title:"参数",slug:"参数",normalizedTitle:"参数",charIndex:625},{level:3,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:10},{level:3,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:4517},{level:2,title:"str. trim()",slug:"str-trim",normalizedTitle:"str. trim()",charIndex:20199},{level:2,title:"截取字符串",slug:"截取字符串",normalizedTitle:"截取字符串",charIndex:20262},{level:3,title:"substring()",slug:"substring",normalizedTitle:"substring()",charIndex:20272},{level:3,title:"substr()",slug:"substr",normalizedTitle:"substr()",charIndex:20518},{level:3,title:"split()",slug:"split",normalizedTitle:"split()",charIndex:20735},{level:2,title:"String.prototype.padStart()",slug:"string-prototype-padstart",normalizedTitle:"string.prototype.padstart()",charIndex:20934},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:3311},{level:3,title:"exec()",slug:"exec",normalizedTitle:"exec()",charIndex:21377},{level:3,title:"compile()",slug:"compile",normalizedTitle:"compile()",charIndex:21420},{level:3,title:"match()",slug:"match",normalizedTitle:"match()",charIndex:21469},{level:2,title:"new RegExp()、字面量",slug:"new-regexp-、字面量",normalizedTitle:"new regexp()、字面量",charIndex:21483},{level:2,title:"校验规则",slug:"校验规则",normalizedTitle:"校验规则",charIndex:21817},{level:2,title:"捕获、非捕获",slug:"捕获、非捕获",normalizedTitle:"捕获、非捕获",charIndex:22634},{level:2,title:"标记",slug:"标记",normalizedTitle:"标记",charIndex:22686},{level:2,title:"千分位分隔",slug:"千分位分隔",normalizedTitle:"千分位分隔",charIndex:22811},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:25004},{level:3,title:"实现Object.create()",slug:"实现object-create",normalizedTitle:"实现object.create()",charIndex:25630},{level:2,title:". 和[]？",slug:"和",normalizedTitle:". 和[]？",charIndex:29220},{level:2,title:"for-in",slug:"for-in",normalizedTitle:"for-in",charIndex:6703},{level:2,title:"Object.keys()",slug:"object-keys",normalizedTitle:"object.keys()",charIndex:6943},{level:2,title:"Object.getOwnPropertyNames()",slug:"object-getownpropertynames",normalizedTitle:"object.getownpropertynames()",charIndex:29039},{level:2,title:"Object.getOwnPropertySymbols()",slug:"object-getownpropertysymbols",normalizedTitle:"object.getownpropertysymbols()",charIndex:29098},{level:2,title:"Reflect.ownKeys()",slug:"reflect-ownkeys",normalizedTitle:"reflect.ownkeys()",charIndex:29157},{level:2,title:"Object.values",slug:"object-values",normalizedTitle:"object.values",charIndex:30593},{level:2,title:"Object.entries",slug:"object-entries",normalizedTitle:"object.entries",charIndex:30520},{level:2,title:"toPrimitive",slug:"toprimitive",normalizedTitle:"toprimitive",charIndex:7888},{level:2,title:"toString、valueOf",slug:"tostring、valueof",normalizedTitle:"tostring、valueof",charIndex:33513},{level:3,title:"toString()",slug:"tostring",normalizedTitle:"tostring()",charIndex:17996},{level:3,title:"'1'.toString()为啥可以调用？",slug:"_1-tostring-为啥可以调用",normalizedTitle:"'1'.tostring()为啥可以调用？",charIndex:34003},{level:3,title:"123['toString'].length+123",slug:"_123-tostring-length-123",normalizedTitle:"123['tostring'].length+123",charIndex:34122},{level:2,title:"... 应用",slug:"应用",normalizedTitle:"... 应用",charIndex:35322},{level:2,title:"rest特点",slug:"rest特点",normalizedTitle:"rest特点",charIndex:35462},{level:2,title:"转换为数组",slug:"转换为数组",normalizedTitle:"转换为数组",charIndex:13571},{level:2,title:"typeof",slug:"typeof",normalizedTitle:"typeof",charIndex:4907},{level:2,title:"区分null和Object",slug:"区分null和object",normalizedTitle:"区分null和object",charIndex:40083},{level:2,title:"instanceof",slug:"instanceof",normalizedTitle:"instanceof",charIndex:40101},{level:2,title:"Object.prototype.toString.call()",slug:"object-prototype-tostring-call",normalizedTitle:"object.prototype.tostring.call()",charIndex:41205},{level:2,title:"constructor",slug:"constructor",normalizedTitle:"constructor",charIndex:3423},{level:2,title:"判断数组类型？",slug:"判断数组类型",normalizedTitle:"判断数组类型？",charIndex:42892},{level:2,title:"typeof、instanceof",slug:"typeof、instanceof",normalizedTitle:"typeof、instanceof",charIndex:43162},{level:2,title:"浅拷贝",slug:"浅拷贝",normalizedTitle:"浅拷贝",charIndex:8044},{level:3,title:"Object.assing()",slug:"object-assing",normalizedTitle:"object.assing()",charIndex:43679},{level:3,title:"扩展运算符",slug:"扩展运算符",normalizedTitle:"扩展运算符",charIndex:13608},{level:3,title:"数组浅拷贝",slug:"数组浅拷贝",normalizedTitle:"数组浅拷贝",charIndex:44512},{level:4,title:"Array.prototype.slice()",slug:"array-prototype-slice",normalizedTitle:"array.prototype.slice()",charIndex:44521},{level:4,title:"Array.prototype.concat()",slug:"array-prototype-concat",normalizedTitle:"array.prototype.concat()",charIndex:44822},{level:3,title:"应用场景",slug:"应用场景-2",normalizedTitle:"应用场景",charIndex:25004},{level:3,title:"手撕",slug:"手撕",normalizedTitle:"手撕",charIndex:45176},{level:2,title:"深拷贝",slug:"深拷贝",normalizedTitle:"深拷贝",charIndex:43565},{level:3,title:"JSON.stringify()",slug:"json-stringify",normalizedTitle:"json.stringify()",charIndex:34861},{level:3,title:"lodash库",slug:"lodash库",normalizedTitle:"lodash库",charIndex:46243},{level:3,title:"应用场景",slug:"应用场景-3",normalizedTitle:"应用场景",charIndex:25004},{level:3,title:"手撕",slug:"手撕-2",normalizedTitle:"手撕",charIndex:45176},{level:4,title:"基础递归",slug:"基础递归",normalizedTitle:"基础递归",charIndex:49611},{level:4,title:"优化递归",slug:"优化递归",normalizedTitle:"优化递归",charIndex:50179},{level:5,title:"第一版本",slug:"第一版本",normalizedTitle:"第一版本",charIndex:50187},{level:5,title:"第二版本",slug:"第二版本",normalizedTitle:"第二版本",charIndex:52197},{level:5,title:"第三版本",slug:"第三版本",normalizedTitle:"第三版本",charIndex:53017},{level:2,title:"对象转换为基本类型",slug:"对象转换为基本类型",normalizedTitle:"对象转换为基本类型",charIndex:55419},{level:2,title:"显式强制类型转换",slug:"显式强制类型转换",normalizedTitle:"显式强制类型转换",charIndex:56167},{level:2,title:"隐式强制类型转换",slug:"隐式强制类型转换",normalizedTitle:"隐式强制类型转换",charIndex:56821},{level:2,title:"==、===",slug:"、",normalizedTitle:"==、===",charIndex:58875},{level:2,title:"让其相等？",slug:"让其相等",normalizedTitle:"让其相等？",charIndex:61054},{level:2,title:"call、apply",slug:"call、apply",normalizedTitle:"call、apply",charIndex:61744},{level:2,title:"bind",slug:"bind",normalizedTitle:"bind",charIndex:61739},{level:2,title:"绑定规则",slug:"绑定规则",normalizedTitle:"绑定规则",charIndex:65213},{level:2,title:"全局上下文",slug:"全局上下文",normalizedTitle:"全局上下文",charIndex:65490},{level:2,title:"函数上下文",slug:"函数上下文",normalizedTitle:"函数上下文",charIndex:64829},{level:3,title:"进入执行上下文",slug:"进入执行上下文",normalizedTitle:"进入执行上下文",charIndex:65859},{level:3,title:"代码执行",slug:"代码执行",normalizedTitle:"代码执行",charIndex:328},{level:2,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:3071},{level:3,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:6671},{level:3,title:"啥时候不能用",slug:"啥时候不能用",normalizedTitle:"啥时候不能用",charIndex:66517},{level:2,title:"bind 函数",slug:"bind-函数",normalizedTitle:"bind 函数",charIndex:66908},{level:2,title:"setTimeout、setInterval",slug:"settimeout、setinterval",normalizedTitle:"settimeout、setinterval",charIndex:67049},{level:2,title:"new Function",slug:"new-function",normalizedTitle:"new function",charIndex:67703},{level:2,title:"函数声明",slug:"函数声明",normalizedTitle:"函数声明",charIndex:4153},{level:2,title:"函数表达式",slug:"函数表达式",normalizedTitle:"函数表达式",charIndex:68367},{level:2,title:"函数声明、函数表达式",slug:"函数声明、函数表达式",normalizedTitle:"函数声明、函数表达式",charIndex:69043},{level:2,title:"高阶函数",slug:"高阶函数",normalizedTitle:"高阶函数",charIndex:70069},{level:2,title:"普通函数",slug:"普通函数",normalizedTitle:"普通函数",charIndex:70217},{level:2,title:"自执行函数",slug:"自执行函数",normalizedTitle:"自执行函数",charIndex:70350},{level:2,title:"函数按值传参",slug:"函数按值传参",normalizedTitle:"函数按值传参",charIndex:70419},{level:2,title:"函数式编程",slug:"函数式编程",normalizedTitle:"函数式编程",charIndex:70741},{level:2,title:"纯函数",slug:"纯函数",normalizedTitle:"纯函数",charIndex:17411},{level:2,title:"自执行函数IIEE",slug:"自执行函数iiee",normalizedTitle:"自执行函数iiee",charIndex:71110},{level:2,title:"解释阶段",slug:"解释阶段",normalizedTitle:"解释阶段",charIndex:71986},{level:2,title:"执行阶段",slug:"执行阶段",normalizedTitle:"执行阶段",charIndex:72023},{level:2,title:"全局作用域",slug:"全局作用域",normalizedTitle:"全局作用域",charIndex:65169},{level:2,title:"局部作用域",slug:"局部作用域",normalizedTitle:"局部作用域",charIndex:73420},{level:3,title:"函数作用域",slug:"函数作用域",normalizedTitle:"函数作用域",charIndex:70289},{level:3,title:"块级作用域(ES6增)",slug:"块级作用域-es6增",normalizedTitle:"块级作用域(es6增)",charIndex:73669},{level:3,title:"for循环的setTimeout输出，var和let定义变量区别",slug:"for循环的settimeout输出-var和let定义变量区别",normalizedTitle:"for循环的settimeout输出，var和let定义变量区别",charIndex:73982},{level:2,title:"词法作用域",slug:"词法作用域",normalizedTitle:"词法作用域",charIndex:71912},{level:2,title:"作用域链",slug:"作用域链",normalizedTitle:"作用域链",charIndex:25432},{level:2,title:"是啥",slug:"是啥",normalizedTitle:"是啥",charIndex:75158},{level:2,title:"作用",slug:"作用",normalizedTitle:"作用",charIndex:2206},{level:2,title:"运用",slug:"运用",normalizedTitle:"运用",charIndex:75818},{level:2,title:"垃圾回收算法",slug:"垃圾回收算法",normalizedTitle:"垃圾回收算法",charIndex:76539},{level:3,title:"引用计数",slug:"引用计数",normalizedTitle:"引用计数",charIndex:76671},{level:3,title:"标记清除",slug:"标记清除",normalizedTitle:"标记清除",charIndex:76953},{level:3,title:"复制算法",slug:"复制算法",normalizedTitle:"复制算法",charIndex:77284},{level:3,title:"标记整理",slug:"标记整理",normalizedTitle:"标记整理",charIndex:77584},{level:2,title:"分代式",slug:"分代式",normalizedTitle:"分代式",charIndex:78190},{level:3,title:"新老生代",slug:"新老生代",normalizedTitle:"新老生代",charIndex:78368},{level:3,title:"新生代",slug:"新生代",normalizedTitle:"新生代",charIndex:77931},{level:3,title:"老生代",slug:"老生代",normalizedTitle:"老生代",charIndex:77822},{level:2,title:"识别",slug:"识别",normalizedTitle:"识别",charIndex:80018},{level:2,title:"造成内存泄露",slug:"造成内存泄露",normalizedTitle:"造成内存泄露",charIndex:80245},{level:2,title:"作用域",slug:"作用域-2",normalizedTitle:"作用域",charIndex:4171},{level:3,title:"原始事件模型",slug:"原始事件模型",normalizedTitle:"原始事件模型",charIndex:83494},{level:3,title:"标准事件模型",slug:"标准事件模型",normalizedTitle:"标准事件模型",charIndex:83876},{level:3,title:"IE事件模型",slug:"ie事件模型",normalizedTitle:"ie事件模型",charIndex:84638},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:11729},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:10299},{level:2,title:"阻止冒泡",slug:"阻止冒泡",normalizedTitle:"阻止冒泡",charIndex:86704},{level:2,title:"e.target、e.currentTarget",slug:"e-target、e-currenttarget",normalizedTitle:"e.target、e.currenttarget",charIndex:86836},{level:2,title:"addEventListener、onClick()",slug:"addeventlistener、onclick",normalizedTitle:"addeventlistener、onclick()",charIndex:87073},{level:2,title:"事件劫持？",slug:"事件劫持",normalizedTitle:"事件劫持？",charIndex:87566},{level:2,title:"实例方法",slug:"实例方法",normalizedTitle:"实例方法",charIndex:34049},{level:2,title:"构造函数方法",slug:"构造函数方法",normalizedTitle:"构造函数方法",charIndex:92088},{level:3,title:"all()",slug:"all",normalizedTitle:"all()",charIndex:35995},{level:3,title:"allSettled",slug:"allsettled",normalizedTitle:"allsettled",charIndex:93475},{level:3,title:"any",slug:"any",normalizedTitle:"any",charIndex:20793},{level:3,title:"race",slug:"race",normalizedTitle:"race",charIndex:94389},{level:2,title:"场景",slug:"场景",normalizedTitle:"场景",charIndex:25006},{level:2,title:"实现Promise",slug:"实现promise",normalizedTitle:"实现promise",charIndex:94908},{level:2,title:"实现Promise.then()",slug:"实现promise-then",normalizedTitle:"实现promise.then()",charIndex:94922},{level:2,title:"栗子",slug:"栗子",normalizedTitle:"栗子",charIndex:94943},{level:2,title:"异步场景?",slug:"异步场景",normalizedTitle:"异步场景?",charIndex:96418},{level:2,title:"回调",slug:"回调",normalizedTitle:"回调",charIndex:13168},{level:2,title:"发布/订阅",slug:"发布-订阅",normalizedTitle:"发布/订阅",charIndex:96607},{level:2,title:"Promise",slug:"promise-2",normalizedTitle:"promise",charIndex:3139},{level:2,title:"事件循环",slug:"事件循环",normalizedTitle:"事件循环",charIndex:82417},{level:2,title:"Generator",slug:"generator",normalizedTitle:"generator",charIndex:100431},{level:3,title:"iterator",slug:"iterator",normalizedTitle:"iterator",charIndex:7862},{level:3,title:"Generator",slug:"generator-2",normalizedTitle:"generator",charIndex:100431},{level:2,title:"async/await",slug:"async-await",normalizedTitle:"async/await",charIndex:102962},{level:2,title:"定时器原理",slug:"定时器原理",normalizedTitle:"定时器原理",charIndex:104540},{level:2,title:"原型",slug:"原型-2",normalizedTitle:"原型",charIndex:3180},{level:2,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:3180},{level:2,title:"创建没有原型的对象",slug:"创建没有原型的对象",normalizedTitle:"创建没有原型的对象",charIndex:34554},{level:2,title:"_proto_、prototype",slug:"proto、prototype",normalizedTitle:"<em>proto</em>、prototype",charIndex:null},{level:2,title:"原型、原型链",slug:"原型、原型链",normalizedTitle:"原型、原型链",charIndex:107644},{level:2,title:"Object是Function实例，那Function是谁的实例",slug:"object是function实例-那function是谁的实例",normalizedTitle:"object是function实例，那function是谁的实例",charIndex:108340},{level:2,title:"栗子",slug:"栗子-2",normalizedTitle:"栗子",charIndex:94943},{level:2,title:"原型链",slug:"原型链-2",normalizedTitle:"原型链",charIndex:3180},{level:2,title:"构造函数(经典继承)",slug:"构造函数-经典继承",normalizedTitle:"构造函数(经典继承)",charIndex:111549},{level:2,title:"组合继承",slug:"组合继承",normalizedTitle:"组合继承",charIndex:112327},{level:2,title:"原型式继承",slug:"原型式继承",normalizedTitle:"原型式继承",charIndex:64417},{level:2,title:"寄生式继承",slug:"寄生式继承",normalizedTitle:"寄生式继承",charIndex:114402},{level:2,title:"寄生组合式继承",slug:"寄生组合式继承",normalizedTitle:"寄生组合式继承",charIndex:114648},{level:2,title:"class",slug:"class",normalizedTitle:"class",charIndex:3174},{level:3,title:"class原理",slug:"class原理",normalizedTitle:"class原理",charIndex:116145},{level:3,title:"super",slug:"super",normalizedTitle:"super",charIndex:117098},{level:2,title:"工厂方法",slug:"工厂方法",normalizedTitle:"工厂方法",charIndex:117456},{level:2,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:3212},{level:2,title:"原型模式",slug:"原型模式",normalizedTitle:"原型模式",charIndex:110683},{level:2,title:"构造函数+原型模式",slug:"构造函数-原型模式",normalizedTitle:"构造函数+原型模式",charIndex:117483},{level:2,title:"动态原型",slug:"动态原型",normalizedTitle:"动态原型",charIndex:117497},{level:2,title:"寄生构造函数",slug:"寄生构造函数",normalizedTitle:"寄生构造函数",charIndex:117536},{level:2,title:"稳妥构造函数",slug:"稳妥构造函数",normalizedTitle:"稳妥构造函数",charIndex:117547},{level:2,title:"Reflect",slug:"reflect",normalizedTitle:"reflect",charIndex:27678},{level:2,title:"lazy",slug:"lazy",normalizedTitle:"lazy",charIndex:120457},{level:2,title:"offsetTop",slug:"offsettop",normalizedTitle:"offsettop",charIndex:120599},{level:2,title:"getBoundingClientRect",slug:"getboundingclientrect",normalizedTitle:"getboundingclientrect",charIndex:120628},{level:2,title:"Intersection Observer",slug:"intersection-observer",normalizedTitle:"intersection observer",charIndex:123598},{level:2,title:"防抖",slug:"防抖",normalizedTitle:"防抖",charIndex:75832},{level:3,title:"普通版",slug:"普通版",normalizedTitle:"普通版",charIndex:124569},{level:3,title:"非立即执行版",slug:"非立即执行版",normalizedTitle:"非立即执行版",charIndex:125434},{level:3,title:"立即执行版",slug:"立即执行版",normalizedTitle:"立即执行版",charIndex:125435},{level:3,title:"双剑合璧版",slug:"双剑合璧版",normalizedTitle:"双剑合璧版",charIndex:126514},{level:3,title:"加强版",slug:"加强版",normalizedTitle:"加强版",charIndex:127370},{level:3,title:"取消debounce（终极版）",slug:"取消debounce-终极版",normalizedTitle:"取消debounce（终极版）",charIndex:128005},{level:2,title:"节流",slug:"节流",normalizedTitle:"节流",charIndex:75834},{level:3,title:"时间戳 首节流",slug:"时间戳-首节流",normalizedTitle:"时间戳 首节流",charIndex:128728},{level:3,title:"定时器 尾节流",slug:"定时器-尾节流",normalizedTitle:"定时器 尾节流",charIndex:129145},{level:3,title:"双剑合璧版",slug:"双剑合璧版-2",normalizedTitle:"双剑合璧版",charIndex:126514},{level:2,title:"应用场景",slug:"应用场景-4",normalizedTitle:"应用场景",charIndex:25004},{level:2,title:"特点",slug:"特点-2",normalizedTitle:"特点",charIndex:6671},{level:2,title:"CommonJS",slug:"commonjs",normalizedTitle:"commonjs",charIndex:130656},{level:3,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:130924},{level:3,title:"exports、module.exports",slug:"exports、module-exports",normalizedTitle:"exports、module.exports",charIndex:131691},{level:3,title:"循环引入",slug:"循环引入",normalizedTitle:"循环引入",charIndex:131944},{level:3,title:"多次引入",slug:"多次引入",normalizedTitle:"多次引入",charIndex:132352},{level:3,title:"路径解析",slug:"路径解析",normalizedTitle:"路径解析",charIndex:132725},{level:2,title:"AMD",slug:"amd",normalizedTitle:"amd",charIndex:131606},{level:2,title:"CMD",slug:"cmd",normalizedTitle:"cmd",charIndex:133534},{level:2,title:"ES6",slug:"es6",normalizedTitle:"es6",charIndex:3034},{level:3,title:"基本语法",slug:"基本语法-2",normalizedTitle:"基本语法",charIndex:130924},{level:3,title:"循环引入",slug:"循环引入-2",normalizedTitle:"循环引入",charIndex:131944},{level:2,title:"对比总结",slug:"对比总结",normalizedTitle:"对比总结",charIndex:136274},{level:3,title:"为什么模块循环依赖不会死循环？CommonJS和ES Module的处理不同？",slug:"为什么模块循环依赖不会死循环-commonjs和es-module的处理不同",normalizedTitle:"为什么模块循环依赖不会死循环？commonjs和es module的处理不同？",charIndex:136613},{level:2,title:"操作",slug:"操作",normalizedTitle:"操作",charIndex:4558},{level:2,title:"DOM事件",slug:"dom事件",normalizedTitle:"dom事件",charIndex:83184},{level:2,title:"location",slug:"location",normalizedTitle:"location",charIndex:138441},{level:2,title:"HTMLCollection、NodeList",slug:"htmlcollection、nodelist",normalizedTitle:"htmlcollection、nodelist",charIndex:139249},{level:3,title:"HTMLCollection",slug:"htmlcollection",normalizedTitle:"htmlcollection",charIndex:138103},{level:3,title:"NodeList",slug:"nodelist",normalizedTitle:"nodelist",charIndex:100900},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:11758},{level:2,title:"获取DOM大小",slug:"获取dom大小",normalizedTitle:"获取dom大小",charIndex:141024},{level:2,title:"Ajax",slug:"ajax",normalizedTitle:"ajax",charIndex:94873},{level:2,title:"axios洋葱模型",slug:"axios洋葱模型",normalizedTitle:"axios洋葱模型",charIndex:141335},{level:3,title:"请求步骤",slug:"请求步骤",normalizedTitle:"请求步骤",charIndex:141352},{level:3,title:"Promise封装Ajax请求",slug:"promise封装ajax请求",normalizedTitle:"promise封装ajax请求",charIndex:141901},{level:3,title:"Ajax底层实现？",slug:"ajax底层实现",normalizedTitle:"ajax底层实现？",charIndex:142661},{level:2,title:"Fetch",slug:"fetch",normalizedTitle:"fetch",charIndex:141185},{level:3,title:"fetch能监听网络请求超时吗",slug:"fetch能监听网络请求超时吗",normalizedTitle:"fetch能监听网络请求超时吗",charIndex:142890},{level:2,title:"Axios",slug:"axios",normalizedTitle:"axios",charIndex:141191},{level:3,title:"设置接口请求前缀",slug:"设置接口请求前缀",normalizedTitle:"设置接口请求前缀",charIndex:143423},{level:3,title:"设置请求头和超时时间",slug:"设置请求头和超时时间",normalizedTitle:"设置请求头和超时时间",charIndex:143709},{level:3,title:"封装请求方法",slug:"封装请求方法",normalizedTitle:"封装请求方法",charIndex:144147},{level:2,title:"axios和fetch",slug:"axios和fetch",normalizedTitle:"axios和fetch",charIndex:144515},{level:2,title:"过程",slug:"过程",normalizedTitle:"过程",charIndex:50712},{level:2,title:"组成",slug:"组成",normalizedTitle:"组成",charIndex:2327},{level:2,title:"location.replace/ href",slug:"location-replace-href",normalizedTitle:"location.replace/ href",charIndex:146574},{level:2,title:"前端路由",slug:"前端路由-2",normalizedTitle:"前端路由",charIndex:146565},{level:2,title:"SPA路由跳转实现",slug:"spa路由跳转实现",normalizedTitle:"spa路由跳转实现",charIndex:146920},{level:3,title:"hash模式",slug:"hash模式",normalizedTitle:"hash模式",charIndex:147002},{level:4,title:"触发hashchange",slug:"触发hashchange",normalizedTitle:"触发hashchange",charIndex:147301},{level:4,title:"特点",slug:"特点-3",normalizedTitle:"特点",charIndex:6671},{level:3,title:"history模式",slug:"history模式",normalizedTitle:"history模式",charIndex:147009},{level:4,title:"history.back()、history.forward()、history.go()",slug:"history-back-、history-forward-、history-go",normalizedTitle:"history.back()、history.forward()、history.go()",charIndex:148187},{level:4,title:"history.pushState()",slug:"history-pushstate",normalizedTitle:"history.pushstate()",charIndex:148466},{level:4,title:"history.replaceState()",slug:"history-replacestate",normalizedTitle:"history.replacestate()",charIndex:149512},{level:4,title:"popstate事件",slug:"popstate事件",normalizedTitle:"popstate事件",charIndex:148572},{level:4,title:"特点",slug:"特点-4",normalizedTitle:"特点",charIndex:6671},{level:2,title:"DOMContentLoaded",slug:"domcontentloaded",normalizedTitle:"domcontentloaded",charIndex:151167},{level:3,title:"不会阻塞 DOMContentLoaded 的脚本",slug:"不会阻塞-domcontentloaded-的脚本",normalizedTitle:"不会阻塞 domcontentloaded 的脚本",charIndex:151948},{level:2,title:"onload",slug:"onload",normalizedTitle:"onload",charIndex:85786},{level:2,title:"onunload",slug:"onunload",normalizedTitle:"onunload",charIndex:152155},{level:2,title:"onbeforeunload",slug:"onbeforeunload",normalizedTitle:"onbeforeunload",charIndex:152311},{level:2,title:"readyState",slug:"readystate",normalizedTitle:"readystate",charIndex:141671},{level:2,title:"sync 同步",slug:"sync-同步",normalizedTitle:"sync 同步",charIndex:153836},{level:2,title:"async 异步",slug:"async-异步",normalizedTitle:"async 异步",charIndex:153850},{level:2,title:"defer 延迟",slug:"defer-延迟",normalizedTitle:"defer 延迟",charIndex:153940},{level:2,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:11758},{level:2,title:"数组、链表",slug:"数组、链表",normalizedTitle:"数组、链表",charIndex:154435},{level:3,title:"链表在JS的应用",slug:"链表在js的应用",normalizedTitle:"链表在js的应用",charIndex:154728},{level:2,title:"选择排序",slug:"选择排序",normalizedTitle:"选择排序",charIndex:154787},{level:2,title:"冒泡",slug:"冒泡",normalizedTitle:"冒泡",charIndex:83253},{level:3,title:"优化",slug:"优化",normalizedTitle:"优化",charIndex:14891},{level:2,title:"❤️ 插入排序",slug:"插入排序",normalizedTitle:"❤️ 插入排序",charIndex:156616},{level:2,title:"❤️ 希尔排序",slug:"希尔排序",normalizedTitle:"❤️ 希尔排序",charIndex:157276},{level:2,title:"💙 归并(讲过)",slug:"归并-讲过",normalizedTitle:"💙 归并(讲过)",charIndex:158031},{level:2,title:"💙 快排",slug:"快排",normalizedTitle:"💙 快排",charIndex:159066},{level:2,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:159820},{level:2,title:"计数排序",slug:"计数排序",normalizedTitle:"计数排序",charIndex:159959},{level:3,title:"优化",slug:"优化-2",normalizedTitle:"优化",charIndex:14891},{level:2,title:"桶排序",slug:"桶排序",normalizedTitle:"桶排序",charIndex:160504},{level:2,title:"基数排序",slug:"基数排序",normalizedTitle:"基数排序",charIndex:160593},{level:2,title:"总结",slug:"总结-3",normalizedTitle:"总结",charIndex:11758},{level:2,title:"UTF-8、UTF-16、Unicode",slug:"utf-8、utf-16、unicode",normalizedTitle:"utf-8、utf-16、unicode",charIndex:160809},{level:2,title:"JS二进制",slug:"js二进制",normalizedTitle:"js二进制",charIndex:161105},{level:2,title:"base64",slug:"base64",normalizedTitle:"base64",charIndex:161214},{level:2,title:"位运算",slug:"位运算",normalizedTitle:"位运算",charIndex:161601},{level:2,title:"点击事件延迟",slug:"点击事件延迟",normalizedTitle:"点击事件延迟",charIndex:162119},{level:2,title:"滚动穿透",slug:"滚动穿透",normalizedTitle:"滚动穿透",charIndex:162578},{level:2,title:"滚动溢出",slug:"滚动溢出",normalizedTitle:"滚动溢出",charIndex:162886},{level:2,title:"with",slug:"with",normalizedTitle:"with",charIndex:135714},{level:2,title:"if内的函数？",slug:"if内的函数",normalizedTitle:"if内的函数？",charIndex:163129},{level:2,title:"polyfills",slug:"polyfills",normalizedTitle:"polyfills",charIndex:163360},{level:2,title:"use strict",slug:"use-strict",normalizedTitle:"use strict",charIndex:70226},{level:2,title:"定时刷新",slug:"定时刷新",normalizedTitle:"定时刷新",charIndex:164038},{level:2,title:"切面编程",slug:"切面编程",normalizedTitle:"切面编程",charIndex:164202},{level:2,title:"尾递归",slug:"尾递归",normalizedTitle:"尾递归",charIndex:165203},{level:2,title:"解构赋值",slug:"解构赋值",normalizedTitle:"解构赋值",charIndex:3097},{level:2,title:"ES2022",slug:"es2022",normalizedTitle:"es2022",charIndex:165540},{level:2,title:"拖拽",slug:"拖拽",normalizedTitle:"拖拽",charIndex:130400}],headersStr:"isNaN、number.isNaN isFinite、isNaN parseInt、parseFloat escape、encodeURI、encodeURIComponent 栈 堆 null、undefined 数字处理 toFixed(n) parseInt() ['1', '2', '3'].map(parseInt) toPrecision() 🔥 Symbol 创建数组 改变原数组 数组内存不够了，但还是要继续push元素咋办？ 不改变原数组 其他 特殊情况 遍历 集合转换为数组 for for in (ES5) for of (ES6) every/some fliter forEach() map() [\"1\", \"2\", \"3\"].map(parseInt) 对比 replace 参数 函数 用法 str. trim() 截取字符串 substring() substr() split() String.prototype.padStart() 方法 exec() compile() match() new RegExp()、字面量 校验规则 捕获、非捕获 标记 千分位分隔 应用场景 实现Object.create() . 和[]？ for-in Object.keys() Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Reflect.ownKeys() Object.values Object.entries toPrimitive toString、valueOf toString() '1'.toString()为啥可以调用？ 123['toString'].length+123 ... 应用 rest特点 转换为数组 typeof 区分null和Object instanceof Object.prototype.toString.call() constructor 判断数组类型？ typeof、instanceof 浅拷贝 Object.assing() 扩展运算符 数组浅拷贝 Array.prototype.slice() Array.prototype.concat() 应用场景 手撕 深拷贝 JSON.stringify() lodash库 应用场景 手撕 基础递归 优化递归 第一版本 第二版本 第三版本 对象转换为基本类型 显式强制类型转换 隐式强制类型转换 ==、=== 让其相等？ call、apply bind 绑定规则 全局上下文 函数上下文 进入执行上下文 代码执行 箭头函数 特点 啥时候不能用 bind 函数 setTimeout、setInterval new Function 函数声明 函数表达式 函数声明、函数表达式 高阶函数 普通函数 自执行函数 函数按值传参 函数式编程 纯函数 自执行函数IIEE 解释阶段 执行阶段 全局作用域 局部作用域 函数作用域 块级作用域(ES6增) for循环的setTimeout输出，var和let定义变量区别 词法作用域 作用域链 是啥 作用 运用 垃圾回收算法 引用计数 标记清除 复制算法 标记整理 分代式 新老生代 新生代 老生代 识别 造成内存泄露 作用域 原始事件模型 标准事件模型 IE事件模型 原理 实现 阻止冒泡 e.target、e.currentTarget addEventListener、onClick() 事件劫持？ 实例方法 构造函数方法 all() allSettled any race 场景 实现Promise 实现Promise.then() 栗子 异步场景? 回调 发布/订阅 Promise 事件循环 Generator iterator Generator async/await 定时器原理 原型 原型链 创建没有原型的对象 _proto_、prototype 原型、原型链 Object是Function实例，那Function是谁的实例 栗子 原型链 构造函数(经典继承) 组合继承 原型式继承 寄生式继承 寄生组合式继承 class class原理 super 工厂方法 构造函数 原型模式 构造函数+原型模式 动态原型 寄生构造函数 稳妥构造函数 Reflect lazy offsetTop getBoundingClientRect Intersection Observer 防抖 普通版 非立即执行版 立即执行版 双剑合璧版 加强版 取消debounce（终极版） 节流 时间戳 首节流 定时器 尾节流 双剑合璧版 应用场景 特点 CommonJS 基本语法 exports、module.exports 循环引入 多次引入 路径解析 AMD CMD ES6 基本语法 循环引入 对比总结 为什么模块循环依赖不会死循环？CommonJS和ES Module的处理不同？ 操作 DOM事件 location HTMLCollection、NodeList HTMLCollection NodeList 总结 获取DOM大小 Ajax axios洋葱模型 请求步骤 Promise封装Ajax请求 Ajax底层实现？ Fetch fetch能监听网络请求超时吗 Axios 设置接口请求前缀 设置请求头和超时时间 封装请求方法 axios和fetch 过程 组成 location.replace/ href 前端路由 SPA路由跳转实现 hash模式 触发hashchange 特点 history模式 history.back()、history.forward()、history.go() history.pushState() history.replaceState() popstate事件 特点 DOMContentLoaded 不会阻塞 DOMContentLoaded 的脚本 onload onunload onbeforeunload readyState sync 同步 async 异步 defer 延迟 总结 数组、链表 链表在JS的应用 选择排序 冒泡 优化 ❤️ 插入排序 ❤️ 希尔排序 💙 归并(讲过) 💙 快排 堆排序 计数排序 优化 桶排序 基数排序 总结 UTF-8、UTF-16、Unicode JS二进制 base64 位运算 点击事件延迟 滚动穿透 滚动溢出 with if内的函数？ polyfills use strict 定时刷新 切面编程 尾递归 解构赋值 ES2022 拖拽",content:"# ❤️ 全局属性/函数\n\n属性          描述\nInfinity    正无穷大\nNaN         某个值是不是数字值\nundefined   未定义\n\n函数                     描述\ndecodeURI()            解码某个编码的 URI\ndecodeURIComponent()   解码一个编码的 URI 组件\nencodeURI()            把字符串编码为 URI\nencodeURIComponent()   把字符串编码为 URI 组件\nescape()               对字符串进行编码\neval()                 计算 JS 字符串，把它作为脚本代码执行\nisFinite()             检查某个值是否为有穷大的数\nisNaN()                检查某个值是否是数字\nNumber()               把对象的值转换为数字\nparseFloat()           解析一个字符串返回一个浮点数\nparseInt()             解析一个字符串返回一个整数\nString()               把对象的值转换为字符串\nunescape()             对由 escape() 编码的字符串解码\n\n\n# isNaN、number.isNaN\n\nisNaN 尝试将参数转换为数值，任何不能被转换为数值的的值都返回 true，因此非数字值传入也返回 true ，会影响 NaN 的判断\n\nNumber.isNaN 先判断参数是否为数字，如果是数字继续判断是否为 NaN ，对于 NaN 的判断更为准确\n\nfunction typeOfNaN(x) {\n  if (Number.isNaN(x)) {\n    return 'Number NaN';\n  }\n  if (isNaN(x)) {\n    return 'NaN';\n  }\n}\n\nconsole.log(typeOfNaN('100F'));\n// expected output: \"NaN\"\n\nconsole.log(typeOfNaN(NaN));\n// expected output: \"Number NaN\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# isFinite、isNaN\n\n * Infinity和-Infinity是特殊数值\n\n * NaN代表一个error\n\n都是number类型，但不是\"普通\"数字\n\nisNaN(val)，将val转换为数字，再测试是否为NaN\n\nisNaN(NaN);//true\nisNaN('merry');//true\n\n\n1\n2\n\n\nNaN独一无二，不等于任何东西，包括自身\n\nNaN===NaN;//false\n\n\n1\n\n\nisFinite(val)将val转换为数字，若是常规数字而不是NaN/Infinity/-Infinity，则返回true\n\nisFinite(11);//true\nisFinite(\"merry\");//false 因为是NaN\nisFinite(Infinity);//false 因为是Infinity\n\n\n1\n2\n3\n\n\n> 在所有数字函数中，包括isFinite，空字符串或只有空格的字符串都被视为0\n\n\n# parseInt、parseFloat\n\n> +'le'==parseInt('le')//false\n> \n> 因为NaN不等于NaN\n\n+和Number()转换数字是严格的，若一个值不完全是数字，会失败\n\nconsole.log(+\"100px\");//NaN\nconsole.log(+\" \");//0\n\n\n1\n2\n\n\n从\"100px\"，\"12pt\"中将数值提取出来，parseInt和parseFloat派上用场，它们可以从字符串中读取数字，直到无法读取位置，若出现error，则返回收集到的数字\n\nparseInt(\"100px\");//100\nparseInt(\"11.22px\");//11\n\nparseFloat(\"12.33px\");//12.33\nparseFloat(\"12.3.4\");//12.3\n\n\n1\n2\n3\n4\n5\n\n\n没有数字可读取时，返回NaN\n\nparseInt(\"a123\");//NaN\n\n\n1\n\n\n> parseInt(str,radix)\n\nalert( parseInt('0xff', 16) ); // 255\nalert( parseInt('ff', 16) ); // 255，没有 0x 仍然有效\n\nalert( parseInt('2n9c', 36) ); // 123456\n\n\n1\n2\n3\n4\n\n\n\n# escape、encodeURI、encodeURIComponent\n\nescapeURI(已废弃)，16进制转义序列。当该值小于等于 0xFF 时，用一个 2 位转义序列: %xx 表示。大于则使用 4 位序列：%uxxxx 表示\n\n对整个 URI 转义，将非法字符转换为合法字符，一些特殊意义的字符不会转义\n\nescape和encodeURI作用相同，对Unicode编码为0xFF之外字符有区别\n\n * escape直接在字符Unicode编码前加上%u\n * encodeURI将字符转换为UTF-8格式，再在每个字符前加上%\n\nencodeURIComponent 对URI 的组成部分转义，一些特殊字符也会转义\n\nencodeURIComponent和encodeURI异同？\n\nvar set1 = \";,/?:@&=+$\";  // 保留字符\nvar set2 = \"-_.!~*'()\";   // 不转义字符\nvar set3 = \"#\";           // 数字标志\nvar set4 = \"ABC abc 123\"; // 字母数字字符和空格\n\nconsole.log(encodeURI(set1)); // ;,/?:@&=+$\nconsole.log(encodeURI(set2)); // -_.!~*'()\nconsole.log(encodeURI(set3)); // #\nconsole.log(encodeURI(set4)); // ABC%20abc%20123 (空格被编码为 %20)\n\nconsole.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24\nconsole.log(encodeURIComponent(set2)); // -_.!~*'()\nconsole.log(encodeURIComponent(set3)); // %23\nconsole.log(encodeURIComponent(set4)); // ABC%20abc%20123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n为避免服务器收到不可预知的请求，对用户输入的任何作为URI的部分都应使用encodeURIComponent转义\n\n\n# ES6特性\n\n 1. const、let\n\n 2. 模板字符串\n\n 3. 箭头函数\n\n 4. 函数参数默认值\n\n 5. 对象、解构赋值\n\n 6. for...of 用于数组，for...in用于对象\n\n 7. Promise\n\n 8. 展开运算符(...)\n\n 9. 对象字面量、class(原型链的语法糖)\n    \n    // ES5\n    // 构造函数\n    function Person(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n    // 原型方法\n    Person.prototype.getName = function() {\n      return this.name\n    }\n    // ES6\n    class Person {\n      constructor(name, age) {  // 构造函数\n        this.name = name;\n        this.age = age;\n      }\n      getName() {   // 这种写法表示将方法添加到原型中\n        return this.name\n      }\n      static a = 20;  // 等同于 Person.a = 20\n      c = 20;   // 表示在构造函数中添加属性 构造函数中等同于 this.c = 20\n    // 箭头函数的写法表示在构造函数中添加方法，构造函数中等同于this.getAge = function() {}\n      getAge = () => this.age   \n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n\n\n# 🌈 内存空间\n\n\n# 栈\n\n一块连续内存区域，容量小 ，基本用完就回收，相对 存取速度更快，为先进先出结构，自动分配 固定大小的内存空间，系统自动释放\n\n基本数据类型按值存在栈内存中，占用内存空间由 系统自动分配和释放，内存可及时回收，容易管理内存空间\n\n栈空间就是JS的调用栈，存储执行上下文及执行上下文中基本类型的小数据\n\n> 变量环境：存放var和函数声明的变量，编译时确定，不受块级作用域影响\n> \n> 词法缓存：存放let和const声明的变量空间，编译时不能完全确定，受块级作用域影响\n\nV8把数字分成 ：smi 和 heapNumber\n\nsmi是 -2³¹ 到 2³¹-1的整数，栈中直接存值；其余数字类型都是heapNumber，另外开辟堆空间储存，变量保存引用\n\n\n# 堆\n\n不连续内存区域，容量大，存储大数据，堆中对象不会随方法结束而销毁，没有被引用时被回收掉 ，动态分配内存，内存大小不固定，不会自动释放，无序的树状结构\n\n\n# ⭐️数据类型\n\n引用数据类型包括对象、数组和函数等\n\n> 原始类型\n\nUndefined ,Null ,Boolean,Number,String\n\nES6新增Symbol和BigInt\n\n * Symbol 代表独一无二的值，用法是为对象定义唯一属性名\n * BigInt 表示任意大小的整数， 指安全存储、操作大整数\n\n> 引用类型\n\n\n# null、undefined\n\n * 两个基本数据类型\n * undefined 未定义，null 空对象。一般变量声明了但没有定义返回 undefined，null 主要给一些可能返回对象的变量赋值，作为初始化\n * undefined 在 js 中不是一个保留字，我们可以使用 undefined 作为一个变量名，这样非常危险，它会影响我们对 undefined 的判断。但我们可以获得安全的 undefined 值，比如说 void 0(此运算符优先级较高)\n\n> let undefiend = 'test' 覆盖 JS自身undefined？\n\nJS为全局创建一个只读的undefined，但没有彻底禁止局部undefined变量的定义\n\n * 使用 typeof ，Null 返回 “object”，历史遗留问题。当我们使用==比较两种类型 时返回 true，使用===返回 false\n\n> typeof null=\"Object\"?\n\n在第一版JS中，变量的值被设计保存在一个32位内存单元中。在变量的机器码的低位 1-3 位存储其 类型信息\n\n 1. 000：对象\n\n 2. 1：int\n\n 3. 010：double\n\n 4. 100：string\n\n 5. 110：boolean\n\n特殊情况：\n\n * undefined -2^30（超出当时整型取值范围的一个数）\n * null 空指针，所有机器码均为 0\n\nnull 被误判为Object\n\n\n# 数字处理\n\n * parseInt(5.4) 只保留整数部分，有基模式\n * parseFloat() 值转换成浮点数，没有基模式\n * Number() 转换成数字（可以是整数或浮点数），Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值\n * Math.floor(4.33) 向下取整\n * Math.ceil(6.7) 向上取整\n * Math.round(6.19) 四舍五入的 整数\n * Math.random() [0,1)，生成随机数\n * Math.abs(-1) 绝对值\n * String() 把给定的值转换成字符串\n\n\n# toFixed(n)\n\n数字舍入到小数点后n位(四舍五入)，以字符串形式返回\n\n为啥？\n\n6.35.toFixed(1);//6.3\n\n\n1\n\n\n6.35的小数部分是一个无限的二进制，存储造成精度损失\n\nalert( 6.35.toFixed(20) ); // 6.34999999999999964473\n\n\n1\n\n\n酱紫，数字就变小一点\n\n解决办法——舍入之前，使其更接近整数\n\nalert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000\nalert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4\n\n\n1\n2\n\n\n乘除法，将数字舍入到固定n位\n\nlet num=1.23456\nMath.round(num*100)/100;\n//1.23456->123.456->123->1.23\n\n\n1\n2\n3\n\n\n\n# parseInt()\n\n解析一个字符串，返回整数。parseInt相比Number，没那么严格，parseInt逐个解析字符，遇到不能转换的字符就停下来\n\nparseInt(string, radix)\n\n\n1\n\n\nstring 必需。要被解析的字符串\n\nradix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间\n\n如果省略该参数或其值为 ‘0‘，则数字将以 10 为基础解析，如果以 ‘”0x”‘ 或 ‘”0X”‘ 开头，将以 16 为基数\n\n如果该参数小于 2 或者大于 36，则 parseInt()返回 NaN\n\n# ['1', '2', '3'].map(parseInt)\n\n 1. parseInt('1', 0) //radix为0，string参数不以“0x”/“0”开头，按10为基数处理。返回1\n 2. parseInt('2', 1) //基数为1表示的数最大值小于2，无法解析，返回NaN\n 3. parseInt('3', 2) //基数为2表示的数最大值小于3，无法解析，返回NaN\n\nmap返回数组，结果为[1, NaN, NaN]\n\n\n# toPrecision()\n\n把数字格式化为指定的长度:\n\nvar num = new Number(13.3714); \nvar n=num.toPrecision(2);\nconsole.log(n)\n\n\n1\n2\n3\n\n\n\n# 🔥 Symbol\n\n表示唯一标识符\n\n只有两种原始类型可作为对象属性键\n\n 1. 字符串\n 2. Symbol\n\n> 应用\n\n * 属性名(避免冲突)\n * 定义私有\n * 唯一值\n\n> 特点\n\n * 不能使用new\n * 不能使用 .\n * 不能使用for-in\n\n使用其他类型，会被转换为字符串\n\nobj[1]===obj[\"1\"]\nobj[true]===obj[\"true\"]\n\n\n1\n2\n\n\nlet id1=Symbol(\"id1\");\nlet id2=Symbol(\"id2\");\nid1===id2;//false\n//描述只是一个标签，不影响任何东西\n\n\n1\n2\n3\n4\n\n\nSymbol不会被自动转换为字符串——防止“混乱”的语言保护，字符串和Symbol有着本质的不同\n\nSymbol属性不参加for-in循环、Object.keys()\n\n因为Symbol是“隐藏的属性部分”\n\n但是，Object.assign()会同时复制字符串和Symbol属性\n\nlet id = Symbol(\"id\");\nlet user = {\n  [id]: 123\n};\n\nlet clone = Object.assign({}, user);\n\nalert( clone[id] ); // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n因为合并对象时，肯定希望一个不落合并所有属性啊！！\n\n全局Symbol——可随处访问\n\n// 从全局注册表中读取\nlet id = Symbol.for(\"id\"); // 如果该 symbol 不存在，则创建它\n\n// 再次读取（可能是在代码中的另一个位置）\nlet idAgain = Symbol.for(\"id\");\n\n// 相同的 symbol\nalert( id === idAgain ); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n//通过 name 获取 Symbol \nSymbol.for('a') === Symbol.for('a')  //true\n Symbol('a') === Symbol('a')  //false\n\n\n1\n2\n3\n\n\n> “隐藏 ”属性\n\nSymbol可创建对象的“隐藏”属性，其他地方不能访问或修改\n\nlet user = { // 属于另一个代码\n  name: \"John\"\n};\n\nlet id = Symbol(\"id\");\n\nuser[id] = 1;\nalert( user[id] ); // 我们可以使用 symbol 作为键来访问数据\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用“id”和Symbol(\"id\")作为对象的键有啥区别？\n\n防止意外重写属性\n\n尽管Symbol的description一样，但是Symbol总是不同\n\n而且我们添加的Symbol属性不会被意外访问到\n\nJS 使用了许多系统 symbol，这些 symbol 可以作为 Symbol.* 访问。可以使用它们改变一些内建行为。例如，使用 Symbol.iterator 进行 迭代 操作，用Symbol.toPrimitive 设置 对象原始值的转换 等\n\n\n# 💛 Array方法\n\n\n# 创建数组\n\n * new Array()\n\nlet arr=new Array(\"merry\",\"aa\");\n\n\n1\n\n\n单个数字参数调用new Array，创建一个指定长度没有项的数组\n\n * Array.from() 浅拷贝\n\nconst dp=Array(5).fill();\nconst dp = Array.from(Array(m+1), () => Array(n+1).fill(0));\n let res = new Array(n).fill(0).map(() => new Array(n).fill(0));\n\n\n1\n2\n3\n\n\n类数组对象或者可迭代对象中创建新的数组实例\n\nArray.from 可接受第二个参数，类似于数组的map方法，处理每个元素，处理后的值放入返回的数组\n\n * Array.of()\n\n根据一组参数创建新的数组实例，支持任意参数数量和类型，没有参数时返回 []，参数只有一个的时候，实际上是指定数组的长度\n\n> 注意\n\n数组没有Symbol.toPrimitive，也没有valueOf，它们只能执行toString转换\n\nalert( [] + 1 ); // \"1\"\nalert( [1] + 1 ); // \"11\"\nalert( [1,2] + 1 ); // \"1,21\"\n\n\n1\n2\n3\n\n\n当+运算符把一些项加到字符串后时，加号后面的项也会被转换为字符串\n\n\n\n\n# 改变原数组\n\n * push\n\n返回数组最新长度\n\n\n * # 数组内存不够了，但还是要继续push元素咋办？\n\n内存都不够了，还push，直接报错 栈溢出\n\n扩容机制？？\n\n * pop()\n\n为啥作用于数组末端比首端快呢？\n\n * shift需要做3件事：\n\n1、移除索引为0的元素\n\n2、把所有元素向左移动，并重新编号\n\n3、更新length属性\n\n * unshift()\n\n返回新数组长度\n\n * splice\n\ndelete obj.key通过key移除对应的值3\n\nlet arr = [\"I\", \"go\", \"home\"];\n\ndelete arr[1]; // remove \"go\"\n\nalert( arr[1] ); // undefined\n\n// now arr = [\"I\",  , \"home\"];\nalert( arr.length ); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nsplice删除或替换现有元素或原地添加新元素修改数组，返回被修改数组\n\n***会改变原数组！！***\n\n返回值由被删除元素组成的数组，若只删除一个元素，则返回只包含一个元素的数组，若没有删除元素，则返回 []\n\n[2, 3, 4].splice(0, 1); // 0位置删除一个，返回[2]\n[2, 3, 4].splice(0, 1, 5); // 0位置删除1个，插入5，原数组是[5, 3, 4]，返回[2]\narrayObject.splice(start,deleteCount,item1,.....,itemX)\nstart 必需。添加/删除项目位置，负数可从数组结尾处规定位置\ndeleteCount 必需。删除项目数量。设置为 0，则不会删除项目\nitem1, ..., itemX 可选。向数组添加新项目\n\n\n1\n2\n3\n4\n5\n6\n\n\n * shift()\n\n * sort()\n\n默认 将元素转为字符串，比较UTF-16代码单元值序列\n\n无法保证排序的时间/空间复杂性\n\na-b 是正数，根据规则，b会被移到a的前面\n\na-b 是负数，根据规则，a会排列到b的前面\n\n//升序\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\n\n1\n2\n3\n4\n\n\nfunction compareNumeric(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\n\nlet arr = [ 1, 2, 15 ];\n\narr.sort(compareNumeric);\n\nalert(arr);  // 1, 2, 15\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * reverse()\n\n\n# 不改变原数组\n\n * concat()\n\n返回新数组\n\n * slice(start,end)左闭右开，可以为负数\n\n返回一个包含原有数组中一个或多个元素的新数组\n\n * filter\n\n判断所有元素，将满足条件的元素作为一个新的数组返回\n\n * join()\n * find()\n * findIndex()\n * indexOf()\n * includes()\n\n\n# 其他\n\n * copyWithin()\n\n将指定位置的成员复制到其他位置（会覆盖原有成员），返回当前数组\n\n 1. target（必需）：从该位置开始替换数据。负值表示倒数\n 2. start（可选）：从该位置开始读取数据，默认 0。负值表示从末尾开始计算\n 3. end（可选）：到该位置前停止读取数据，默认等于数组长度。负值，表示从末尾开始计算\n\n[1, 2, 3, 4, 5].copyWithin(0, 3);\n// 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2\n// [4, 5, 3, 4, 5] \n\n\n1\n2\n3\n\n * fill()\n\n可以接受第二个和第三个参数，指定填充的起始位置和结束位置\n\n如果填充的类型为对象，则是浅拷贝\n\n实现\n\nfunction fill (n, m) {\n    n--\n    if(n) {\n        return [m].concat(fill(n, m))\n    } else {\n        return m\n    }\n}\n\nconsole.log(fill(3,4))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * reduce\n\n不改变原始数组\n\n每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值\n\nvar numbers = [65, 44, 12, 4];\n \nfunction getSum(total, num) {\n    return total + num;\n}\nlet sum = numbers.reduce(getSum);\n//语法\nlet val=arr.reduce((pre,cur,index,arr)=>{\n    //...\n},[initial]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n应用\n\n>  1. 累加器\n>  2. 求数组最大/小值\n>  3. 提取URL参数\n>  4. 二维数组转为一维\n>  5. 数组拍平\n>  6. 字符统计\n>  7. 反转串\n\n * reduceRight\n\n和reduce功能一样，遍历顺序从右到左\n\n * some(不用遍历整个数组，就能得到结果)\n\n判断所有元素，若存在元素满足条件，返回 true，若所有元素都不满足条件，返回 false\n\n> 类似的API？\n> \n> find?\n> \n> findIndex?\n\n * every\n\n判断 所有元素返回一个布尔值，如果所有元素都满足条件，则返回 true，否则为 false\n\n * flat()，flatMap()\n\n数组扁平化，返回新数组，对原数据没有影响\n\nflat()默认“拉平”一层，如果想要“拉平”多层嵌套数组，参数为整数，表示想要拉平的层数，默认为1\n\nflatMap()对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，对返回值组成的数组执行flat()。返回新数组，不改变原数组\n\nflatMap()`方法还可以有第二个参数，绑定遍历函数里面的`this\n\n\n1\n\n * arr.at(i)\n\n> 若i>=0，就和arr[i]完全相同\n> \n> 若i<0，倒数\n\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\n// 与 fruits[fruits.length-1] 相同\nalert( fruits.at(-1) ); // Plum\n\n\n1\n2\n3\n4\n\n * delete\n\n删除对象的属性/数组元素，删除对象属性本身，不会删除属性指向的对象\n\n若 delete 数组某位元素，数组长度不变，只是元素为 empty item\n\n原型中声明的属性/对象自带属性无法被删除\n\nvar声明的变量和通过function声明的函数拥有dontdelete属性，不能被删除\n\n * map\n\nmap() 返回新数组，数组中元素为原始数组元素调用函数处理后的值\n\nmap() 按照原始数组元素顺序依次处理元素\n\n * forEach\n\n基本数据类型——>死都改不动原数组！拷贝值\n\n引用类型——>类似对象数组可以改变，拷贝地址\n\nforEach原理是for循环，使用arr[index]赋值改变\n\n> 总结\n\n几乎所有调用函数的数组方法都支持可选附加参数'thisArg'，除了sort\n\nlet army={\n    a:1,\n    canJoin:function(user){\n        if(user!=='c'){\n            console.log(user)\n        }\n    }\n}\nlet users=['a','b','c']\nconst ans=users.filter(user => army.canJoin(user))\nconsole.log(ans)\nconst ans1=users.filter(army.canJoin, army)\nconsole.log(ans1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 不用全部遍历数组就能得出结果的api，比如some，除此之外 还有哪些？\n\n\n# 🌱 Set集合\n\nSet 允许存储任何类型的唯一值\n\nSet 是值的集合，可以存储任意类型的值，Set 可以按照插入顺序遍历输出，插入的值会自动去重\n\n\n# 特殊情况\n\n * 0 和 -0 不会去重\n * NaN 不等于 NaN，但是 NaN 和 NaN 会去重，只能存储一个\n\nlet mySet = new Set();\n\nmySet.add(1); // Set [ 1 ]\nmySet.add(5); // Set [ 1, 5 ]\nmySet.add(5); // Set [ 1, 5 ]\nmySet.add(\"some text\"); // Set [ 1, 5, \"some text\" ]\nlet o = {a: 1, b: 2};\nmySet.add(o);\n\nmySet.add({a: 1, b: 2}); // o 指向的是不同的对象，所以没问题\n\nmySet.has(1); // true\nmySet.has(3); // false\nmySet.has(5);              // true\nmySet.has(Math.sqrt(25));  // true\nmySet.has(\"Some Text\".toLowerCase()); // true\nmySet.has(o); // true\n\nmySet.size; // 5\n\nmySet.delete(5);  // true,  从set中移除5\nmySet.has(5);     // false, 5已经被移除\n\nmySet.size; // 4, 刚刚移除一个值\n\nconsole.log(mySet);\n// logs Set(4) [ 1, \"some text\", {…}, {…} ] in Firefox\n// logs Set(4) { 1, \"some text\", {…}, {…} } in Chrome\nmySet.clear()//清楚所有成员，没有返回值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 遍历\n\n * keys()：返回键名的遍历器\n * values()：返回键值的遍历器\n * entries()：返回键值对的遍历器\n * forEach()：使用回调函数遍历每个成员\n\nSet的遍历顺序就是插入顺序\n\nkeys方法、values方法、entries方法 都是 返回 遍历器对象\n\n实现并集、交集、和差集:\n\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// （a 相对于 b 的）差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 集合转换为数组\n\nArray.from(arrayLike object)\n\n扩展运算符(...)\n\nforEach\n\nlet ans=Array.prototype.slice.apply(set)？？？待考究\n\n\n# Map字典\n\nkey值不能重复！\n\nmap.size // 属性返回 Map 结构的成员总数\nconst m = new Map().set('key1', 'val1')\n\nMap.prototype.set(key, value) // 方法设置键名key对应的键值为value，返回整个 Map 。如果key已经有值，键值会被更新，否则就新生成该键\n// set方法返回的是当前的Map对象，因此可以采用链式写法\n\nMap.prototype.get(key) // 读取key对应的键值，如果找不到key，返回undefined\n\nMap.prototype.has(key) // 返回一个布尔值，表示某个键是否在当前 Map 对象之中\n\nMap.prototype.delete(key) // 删除某个键，返回true。如果删除失败，返回false\n\nMap.prototype.clear() // 清除所有成员，没有返回值\n\nMap.prototype.keys()：// 返回键名的遍历器\nMap.prototype.values()：// 返回键值的遍历器\nMap.prototype.entries()：// 返回所有成员的遍历器\nMap.prototype.forEach()：// 遍历 Map 的所有成员\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 判断是否存在某个值\n\n * array.indexOf(item,from) //return 下标或-1\n\n * array.lastIndexOf(item,from)\n\n * array.includes(item,from)\n\n判断字符串/数组是否包含另一个字符，返回 true/false，第二个参数表示搜索的起始位置，默认0，为负数表示倒数\n\n以上3种方法和字符串操作具有相同的语法！！使用===比较！\n\n * array.find() 返回满足条件的第一个元素的值\n\nlet res=arr.find((item,index,arr)=>{\n   //返回true，则返回item并停止迭代\n    //返回false，则返回undefined\n});\n\n\n1\n2\n3\n4\n\n * array.findIndex() 返回满足条件的第一个元素下标，没有找到返回-1\n\n> find和findIndex都可以接受第二个参数，绑定回调函数的this\n\n\n# 遍历语法比较\n\n\n\n（for、forEach、map、 for...in、for...of的区别）\n\n数组遍历各个方法的速度：传统的for循环最快，for-in最慢\n\n> for-in > for > for-of > forEach > map > for-in\n\n\n# for\n\n速度最快，兼容旧版本浏览器\n\n优化一下\n\nlet arr=[1,2,3,4,5];\nfor(let i=0,len=arr.length;i<len;i++){\n    \n}\n\n\n1\n2\n3\n4\n\n\n临时变量存储len，避免重复获取数组长度，只有len较大时优化才明显\n\n\n# for in (ES5)\n\n * 枚举对象属性包括继承属性，除Symbol\n * 不建议使用 for in 遍历数组\n\n因为输出属性名的顺序不可预测，效率低\n\n是第一个能迭代对象键的JS语句，循环对象键与在数组上循环不同，引擎会执行额外的工作跟踪已迭代的属性\n\n * 如果迭代对象的变量值是 null 或 undefined, for in 不执行，建议使用 for in 循环之前，先检查\n * 遍历数组索引，得到对象的key或数组，字符串下标\n * 遍历数组的话，类数组有length和索引属性，也可能有其它非数字的属性和方法，for-in会全部列出来\n\n\n# for of (ES6)\n\n * for…of 语句在可迭代对象上创建一个迭代循环，调用自定义迭代钩子，为每个不同属性的值执行语句\n * 得到对象的value或数组、字符串的值，还可以遍历Map和Set\n * for of 循环数组时怎么拿到数组索引？\n\nES6之前的遍历方法都会跳过数组未赋值过的位置，即空位，但是ES6新增的for of 不会跳过\n\n 1. 可使用break\n 2. 避开了for-in所有缺陷\n 3. 可正确响应break、continue和return\n 4. 支持字符串遍历\n\n> Object没有iterator属性，因此它不是可迭代对象，没有for-of方法，不过我们可以自定义方法实现遍历\n\n性能优于for-in\n\n\n# every/some\n\n返回布尔值\n\nevery判断数组每一项，some当某一项满足条件返回\n\n\n# fliter\n\n过滤数组成员，满足条件的成员组成一个新数组返回，否则返回[]\n\n不改变原数组\n\n\n# forEach()\n\n> foreach不是es6的方法，是es3的\n\n修改原数组，遍历可迭代对象，不返回执行结果，而是undefined，return无法终止 有continue效果\n\n中断forEach\n\n 1. 使用try监视代码块，中断地方抛出异常\n 2. 替换：every和some碰到return false时，中止循环\n\nfunction log(msg, time) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log(msg);\n            resolve();\n        }, time);\n    });\n};\n(async () => {\n    [1, 2, 3, 4].forEach(async (i,index,array) => {\n        await log(i, 1000);\n    });\n})();\n// 1s 后依次输出1 2 3 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n对于异步代码，forEach不能保证按顺序执行\n\nfor...of /in可解决问题，不像forEach简单粗暴遍历执行，而是采用迭代器遍历\n\n\n# map()\n\n遍历可迭代对象\n\n分配内存并返回新数组，不改变原数组\n\n不能break，否则引发异常\n\n可使用for循环/for-in/for-of中断循环\n\n> 关于map和forEach的性能对比问题，我也没有找到答案，网络上众说纷纭，其实也不用太纠结它们的速度快慢\n\n\n# [\"1\", \"2\", \"3\"].map(parseInt)\n\n[1, NaN, NaN]\n\n\n1\n\n\nparseInt() 解析字符串，返回整数，两个参数 (val, radix)，radix 表要解析数字的基数\n\n（该值介于 2 ~ 36 之间，且字符串中的数字不能大于 radix 才能正确返回结果）\n\n此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 \"1-0\", \"2-1\", \"3-2\"\n\n因为字符串的值不能大于基数，后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1\n\n> 同理\n\nlet res=['1','2','100'].map(parseInt);//[1,NaN,4]\n\n\n1\n\n\n\n# 对比\n\nfor、forEach\n\n * 都是遍历数组\n * forEach永远返回undefined\n * map是映射，返回新数组\n * map()效率更高不用太过纠结速度快慢，因为我也没找着答案\n * 二者均不能中断\n * 可以使用简单的for循环或for-of/for-in中断循环\n * 遍历可迭代对象\n * 当只想遍历数据而修改时，使用forEach\n * 建议用map转换数组元素\n * for不创建函数\n * forEach创建每次调用的函数\n * 函数单独作用，产生额外开销\n * 开发不考虑性能，forEach更具可读性\n * 都可以接受第二个参数，绑定回调内的 this ，将回调内部的 this指向第二个参数，间接操作这个参数\n * map()和filter()都会跳过空位，for 和 while 不会\n\n\n# 🍅String方法\n\n * charAt(index) 返回指定索引处的字符串，没找着返回空串\n * charCodeAt(index) 返回指定索引处的字符的 Unicode值\n\n// toLowerCase()转换成小写 toUpperCase()转换成大写\nvar x = \"a\".toLowerCase().charCodeAt(0)\n//x = 97\n\n\n1\n2\n3\n\n * concat(str1, str2, ... ) 连接多个字符串，返回连接后串的副本，纯函数\n * fromCharCode() 将 Unicode 值转换成实际的字符串\n\nString.fromCharCode(97)\n// 返回\"a\"\n\n\n1\n2\n\n * indexOf(str) 返回 str 在父串中第一次出现的位置，若没有则返回-1\n * lastIndexOf(str) 返回 str 在父串中最后一次出现的位置，若没有返回-1\n * match(regex) 搜索字符串，返回正则表达式的所有匹配\n * search(regex) 基于正则表达式搜索字符串，返回第一个匹配的位置\n * slice(start, end) 返回字符索引在 start 和 end（不含）间的子串\n * split(sep，limit) 将字符串分割为字符数组，limit 为从头开始执行分割的最大数量\n * substr(start，length) 从字符索引 start 的位置开始，返回长度为 length 的子串\n * substring(from, to) 返回字符索引在 from 和 to（不含）之间的子串，和slice几乎相同，但它允许from>to，不支持负参数，slice支持负参数\n * toLowerCase() 将字符串转换为小写\n * toUpperCase() 将字符串转换为大写\n * valueOf() 返回原始字符串值\n * toString() 把 Number 对象转换为字符串，返回结果\n\n{} 的 valueOf 结果为 {} ，toString 的结果为 \"[object Object]\"\n\n[] 的 valueOf 结果为 [] ，toString 的结果为 \"\"\n\n\n1\n2\n3\n\n * str.codePointAt(pos) 返回在pos位置的字符编码\n\n// 不同的字母有不同的代码\nalert( \"z\".codePointAt(0) ); // 122\nalert( \"Z\".codePointAt(0) ); // 90\n\n\n1\n2\n3\n\n * String.fromCodePoint(code) 通过code创建字符\n\nalert( String.fromCodePoint(90) ); // Z\n\n//\\u后跟十六进制代码，通过代码添加Unicode字符\n// 在十六进制系统中 90 为 5a\nalert( '\\u005a' ); // Z\n\n\n1\n2\n3\n4\n5\n\n\n> 'a'>'Z'\n> \n> 因为字符通过数字代码比较，a(97)>Z(90)\n\n// 英文是否大写\nfunction upperCase(num) {\n\tvar reg = /^[A-Z]+$/;\n\treturn reg.test(num);\n}\n\n\n1\n2\n3\n4\n5\n\n * repeat() 返回新的字符串 =重复了指定次数的原始字符串\n\n\n# replace\n\n不会修改原字符串！\n\n第二个参数可传入要替换的目标串，这种用法中replace只会匹配一次\n\n第二个参数也可以传入一个函数，若原始字符串中有n个我们查找的字符串，函数就会执行n次，且这个函数返回一个字符串，用来替换每次匹配到的字符串\n\n\n# 参数\n\n> $&\n\n匹配的字符串\n\nvar sStr='讨论一下正则表达式中的replace的用法';\nsStr.replace(/正则表达式/,'《$&》');\n// \"讨论一下《正则表达式》中的replace的用法\"\n\n\n1\n2\n3\n\n\n> $`\n\n匹配字符串左边的所有字符\n\nvar sStr='讨论一下正则表达式中的replace的用法';\nsStr.replace(/正则表达式/,'《$`》');\n// \"讨论一下《讨论一下》中的replace的用法\"\n\n\n1\n2\n3\n\n\n> $'\n\n匹配字符串右边的所有字符，既然有单引号，外面的引号必须双引号，如果不可以双引号，只能把单引号转义\n\nvar sStr='讨论一下正则表达式中的replace的用法';\nsStr.replace(/正则表达式/,\"《$'》\");\n// \"讨论一下《中的replace的用法》中的replace的用法\"\n\n\n1\n2\n3\n\n\n> 1,2,3,4……n\n\n依次匹配子表达式\n\nvar sStr='讨论一下正则表达式中的replace的用法';\nsStr.replace(/(正则)(.+?)(式)/,\"《$1》$2<$3>\");\n//\"讨论一下《正则》表达<式>中的replace的用法\"\n\n\n1\n2\n3\n\n\n\n# 函数\n\nvar sStr='讨论一下正则表达式中的replace的用法';\nsStr.replace(/(正则).+?(式)/,function() {\n    console.log(arguments);\n});\n// [\"正则表达式\", \"正则\", \"式\", 4, \"讨论一下正则表达式中的replace的用法\"]\n\n\n1\n2\n3\n4\n5\n\n\n参数：\n\n * 匹配到的字符串\n * 若正则使用了分组匹配就是多个，否则无此参数\n * 匹配字符串的索引位置\n * 原始字符串\n\n或者使用命名形参：\n\nvar sStr='讨论一下正则表达式中的replace的正则表达式用法';\nsStr.replace(/(正则).+?(式)/g,function($1) {\n    console.log($1);\n    return $1 + 'a';\n});\n\n\n1\n2\n3\n4\n5\n\n\n\n# 用法\n\n\\s匹配任何空白字符（空格，制表符，换行符）\n\nstr = str.replace(/\\s*/g); //去除所有空格 \nstr = str.replace(/^\\s*|\\s*$/g, \"\");//去除首尾空格\nstr = str.replace(/^\\s*/, \"\");\nstr = str.replace(/\\s*&/, \"\");\n\n\n1\n2\n3\n4\n\n\n\\w 匹配任何单词字符，包括 字母 数字 下划线\n\nname = \"Doe, John\";\nlet a=name.replace(/(\\w+)\\s*, \\s*(\\w+)/, \"$2 $1\");\nconsole.log(a)\n//John Doe\n\n\n1\n2\n3\n4\n\n\n\\b 匹配单词字符和非单词字符的边界位置\n\n//首字母大写\nlet name = 'aaa bbb ccc';\nlet uw=name.replace(/\\b\\w+\\b/g, function(word){\n    return word.substring(0,1).toUpperCase()+word.substring(1);}\n);\n\n\n1\n2\n3\n4\n5\n\n\n\n# str. trim()\n\n删除串两端空白字符并返回**，不影响原来字符串，返回新串**\n\n> 只能去除字符串两端空格\n\n\n# 截取字符串\n\n\n# substring()\n\n左闭右开，提取串中介于两个指定下标间的字符\n\nsubstring(start,stop)\n\n\n1\n\n\n * start：非负整数，提取子串的第一个字符索引，必写\n\n * stop：非负整数，比要提取子串的最后一个字符在字符串上的位置多 1，可写可不写，如果不写则返回子串会一直到字符串的结尾\n\n该字符串的长度为stop-start\n\n如果参数 start 与 stop 相等，返回空串，如果 start 比 stop 大，该方法在提取之前会先交换这两个参数\n\n\n# substr()\n\n抽取从 start 下标开始的指定数目的字符\n\nsubstr(start,length)\n\n\n1\n\n * start：要截取的子串的起始下标，必须是数值。如果是负数，该参数从字符串的尾部开始算。-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推，必需写\n * length：子串中的字符数，必须是数值。如果不填，返回字符串的开始位置到结尾的字符。如果length 为0 或者负数，返回一个空串\n\n\n# split()\n\n把一个字符串分割成字符串数组\n\nstringObject.split(separator,howmany)\n\n\n1\n\n\n * separator：字符串或正则表达式，从该参数指定的地方分割字符串。必须写\n\n * howmany：指返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。可选\n\n\n# String.prototype.padStart()\n\n用另一个串填充当前字符串 (如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串左侧开始填充\n\n\n# ✅ 正则\n\nregular expression\n\n\n# 方法\n\n方法         描述\nexec       执行查找匹配的RegExp方法，返回数组（未匹配到则返回 null）\ntest       字符串中测试是否匹配，返回 true 或 false\nmatch      执行查找匹配字符串，返回数组，未匹配时返回 null\nmatchAll   执行查找所有匹配的String方法，返回迭代器（iterator）\nsearch     测试匹配的String方法，返回匹配到的位置索引，失败返回-1\nreplace    执行查找匹配的String方法，使用替换字符串替换掉匹配到的子字符串\nsplit      使用正则表达式或固定字符串分隔字符串，将分隔后的子字符串存储到数组中\n\n\n# exec()\n\n检索字符串中指定值，返回结果数组，若没有，则返回null\n\n\n\n\n# compile()\n\n改变RegExp，可改变检索模式也可add或delete第二个参数\n\n\n# match()\n\n\n\n\n# new RegExp()、字面量\n\n使用字面量效率更高\n\n//正则表达字面量\nvar re = /\\\\/gm;\n\n//正则构造函数\nvar reg = new RegExp(\"\\\\\\\\\", \"gm\");\n\nvar foo = \"abc\\\\123\"; // foo的值为\"abc\\123\"\nconsole.log(re.test(foo)); //true\nconsole.log(reg.test(foo)); //true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用构造函数时，要使用四个反斜杠才能匹配单个反斜杠。使得正则表达式模式更长，难以阅读。当使用 RegExp()构造函数时，不仅要转义引号（即\"表示\"），通常还需要双反斜杠（即\\表示一个\\）\n\n\n# 校验规则\n\n规则        描述\n\\         转义\n.         默认匹配除换行符之外的任何单个字符\nx(?=y)    匹配'x'仅仅当'x'后面跟着'y'——先行断言\n(?<=y)x   匹配'x'仅当'x'前面是'y'——后行断言\nx(?!y)    仅当'x'后面不跟着'y'时匹配'x'——正向否定查找\n(?<!y)x   仅当'x'前面不是'y'时匹配'x'——反向否定查找\nx|y       匹配‘x’或者‘y’\n{n}       n 是正整数，匹配前面一个字符刚好出现了 n 次\n{n,}      n是正整数，匹配前一个字符至少出现了n次\n{n,m}     n 和 m 都是整数。匹配前面的字符至少n次，最多m次\n[xyz]     一个字符集合。匹配方括号中的任意字符\n[^xyz]    匹配任何没有包含在方括号中的字符\n\\b        匹配一个词的边界，例如在字母和空格之间\n\\B        匹配一个非单词边界\n\\d        匹配一个数字\n\\D        匹配一个非数字字符\n\\f        匹配一个换页符\n\\n        匹配一个换行符\n\\r        匹配一个回车符\n\\s        匹配一个空白字符，包括空格、制表符、换页符和换行符\n\\S        匹配一个非空白字符\n\\w        匹配一个单字字符**（字母、数字或者下划线）**\n\\W        匹配一个非单字字符\n\n> 先行断言 从左往右看\n> \n> 后行断言 从右往左看\n\nx(?=y)`匹配x`仅当x后面跟着y，不会将y包含在结果中正向先行断言\nx(?!y) 仅当x后面不是y时`匹配x` ，负向先行断言\n(?<=y)x `匹配x`仅当x前面是y ，正向后行断言\n(?<!y)x 仅当x前面不是y时`匹配x `,反向否定查找（负向后行断言）\n\n\n1\n2\n3\n4\n\n\n\n# 捕获、非捕获\n\n\n\n捕获——可通过序号/名称使用这些匹配结果\n\n非捕获——标识不需要捕获的分组\n\n\n# 标记\n\n标志   描述\ng    全局搜索\ni    不区分大小写搜索\nm    多行搜索\ns    允许 . 匹配换行符\nu    使用unicode码的模式匹配\ny    执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始\n\n\n# 千分位分隔\n\n正则+replace\n\nfunction format(num) {\n    const reg = /(\\d)(?=(\\d{3})+\\.)/g;\n    return num && num.toString().replace(reg, function (s2) {\n        return s2 + ',';\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nfunction numFormat(num){\n    const reg=/(\\d)(?=(\\d{3})+$)/g;\n    const res=num.toString().replace(/\\d+/, function(n){ // 先提取整数部分\n        return n.replace(reg,function(s1){\n            return s1+\",\";\n        });\n    })\n    return res;\n}\n//就它最正宗，不报错，点名表扬！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nx(?=y) 仅当x后面为y时，匹配x\n\nfunction numberWithCommas(x) {\n    var parts = x.toString().split(\".\");\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n    return parts.join(\".\");\n}\nnumberWithCommas(33333333333.3333333333)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nx(?=y) 仅当x后面是y时匹配x\n\n(?<!y)x 仅当x前面不是y时匹配x\n\nx(?!y) 仅当x后面不是y时匹配x\n\nfunction numberWithCommas(x) {\n    return x.toString().replace(/\\B(?<!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, \",\");\n}\nnumberWithCommas(1111111111.1111111111)\n\n\n1\n2\n3\n4\n\n\n利用 正则 + 循环\n\nfunction numberWithCommas(x) {\n    x = x.toString();\n    var pattern = /(-?\\d+)(\\d{3})/;\n    while (pattern.test(x)){\n        x = x.replace(pattern, \"$1,$2\");   \n    }\n    return x;\n}\nnumberWithCommas(12312124545);//'12,312,124,545'\nnumberWithCommas(123121245.45);//'123,121,245.45'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n将数字转换为字符串，循环整个数组，每三位增加分隔逗号，最后合并成字符串，分隔符从后往前添加\n\nfunction format2(num) {\n    num = num.toString().split(\".\");\n    let arr = num[0].split(\"\").reverse();\n    let res = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n        if (i % 3 === 0 && i !== 0) {\n            res.push(\",\");\n        }\n        res.push(arr[i]);\n    }\n    res.reverse();\n    if (num[1]) {\n        res = res.join(\"\").concat(\".\" + num[1]);\n    } else {\n        res = res.join(\"\");\n    }\n    return res;\n}\nformat2(12345678.987654)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n调用API\n\nfunction format1(number) {\n    return Intl.NumberFormat().format(number)\n}\n//Intl 对象是 ECMAScript 国际化 API 的一个命名空间，提供了精确的字符串对比、数字格式化，和日期时间格式化\n// Intl.NumberFormat.prototype.format 属性返回一个根据NumberFormat对象的语言环境和格式化选项，来格式化一个数字的getter函数\n\n\n1\n2\n3\n4\n5\n\n\nfunction format2(number) {\n    return number.toLocaleString('en')\n}\n//toLocaleString() 方法返回这个数字在特定语言环境下的表示字符串\n\n\n1\n2\n3\n4\n\n\n\n# 应用场景\n\n// 匹配 16 进制颜色值\nvar regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;\n\n// 匹配日期，如 yyyy-mm-dd 格式\nvar regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;\n\n//匹配 qq 号\nvar regex = /^[1-9][0-9]{4,10}$/g;\n\n// 手机号码正则\nvar regex = /^1[34578]\\d{9}$/g;\n\n//用户名正则\nvar regex = /^[a-zA-Z\\$][a-zA-Z0-9_\\$]{4,16}$/;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 初始化对象\n\nObject.create()、字面量、new\n\n创建一个对象，推荐字面量方式（无论性能上还是可读性）\n\nnew Object() 创建对象要通过作用域链一层层找到 Object，但使用字面量方式就没这个问题\n\nvar Person = {}; //相当于 var Person = new Object();\nvar Person = {\n    name: 'Nike';\n    age: 29;\n}\n\n\n1\n2\n3\n4\n5\n\n\nES5新增Object.create——内部定义对象，接受一个原型对象并创建指向它的新对象\n\n\n * # 实现Object.create()\n\nF.prototype对象赋值为 引进对象/函数o，return新对象\n\nObject.create =  function (o) {\n    var F = function () {};\n    F.prototype = o;\n    return new F();\n};\n\n\n1\n2\n3\n4\n5\n\n\nnew 是新建对象o1，让o1的 __proto__ 指向 Base.prototype 对象，使用call 强转作用环境，实现对象创建\n\nvar o1 = new Object();\no1.[[Prototype]] = Base.prototype;\nBase.call(o1);\n\n\n1\n2\n3\n\n\n> 区别\n\nvar Base = function () {\n    this.a = 2\n}\nvar o1 = new Base();\nvar o2 = Object.create(Base);\nconsole.log(o1.a); // 2\nconsole.log(o2.a); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nObject.create 失去了原来对象属性的访问\n\n比较     NEW                OBJECT.CREATE\n构造函数   保留原构造函数属性          丢失原构造函数属性\n原型链    原构造函数prototype属性   原构造函数/（对象）本身\n作用对象   function           function、object\n\nlet o=new Object()\nlet o={}\nlet o=new Object\n\nlet o=Object (×)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 💜 对象方法\n\n> 可选链\n\nlet user = {}; // user 没有 address 属性\nalert( user?.address?.street ); // undefined（不报错）\n\n\n1\n2\n\n\nObject.is()\n\n严格判断两个值是否相等，与严格比较运算符（===）基本一致，不同之处\n\n+0 === -0 //true\nNaN === NaN // false\n\nObject.is(+0, -0) // false\nObject.is(NaN, NaN) // true\n\n\n1\n2\n3\n4\n5\n\n\nObject.assign()\n\n * 用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target\n * 第一个参数是目标对象，后面的参数都是源对象\n\nconsole.log(Object.assign([1, 2, 3], [4, 5])); //4,5,3\n\n\n1\n\n\n数组视为对象，目标数组视为属性为0、1、2的对象，所以源数组的0、1属性的值覆盖了目标对象的值\n\nObject.getOwnPropertyDescriptors()\n\n * 返回指定对象所有自身属性（非继承属性）的描述对象\n\nObject.setPrototypeOf()\n\n * 设置一个对象的原型对象\n\nObject.getPrototypeOf()\n\n * 读取一个对象的原型对象\n\nObject.fromEntries()\n\n * 将一个键值对数组转为对象\n\nObject.fromEntries([\n  ['foo', 'bar'],\n  ['baz', 42]\n])\n// { foo: \"bar\", baz: 42 }\n\n\n1\n2\n3\n4\n5\n\n\nObject.defineProperty()\n\n直接在对象上定义新的属性，修改一个已经存在的属性\n\nObject.defineProperty(obj, props, desc):\n\n * obj: 需要定义属性的当前对象\n * props: 当前准备定义的属性名\n * desc: 对定义属性的描述\n\nisPrototypeOf() 测试对象是否存在于另一对象的原型链上\n\n> 哪些属性是函数function a(){}独有，对象const b = new Object()没有的?\n> \n>  * constructor\n>  * [proto]\n>  * isPrototypeOf\n>  * prototype(√)\n\n判断对象是否为空？(没有任何属性可以用什么方法)\n\n\n# 判断对象是否有属性\n\n. / []+undefined\n\n判断对象自身属性和继承属性\n\n属性名存在 但 值为undefined时，不能返回想要的结果——in 解决\n\n1、in\n\n如果属性来自对象的原型，仍然返回true\n\nlet obj={name:'aa'};\n'name' in obj;//true\n'toString' in obj;//true\n\n\n1\n2\n3\n\n\n2、Reflect.has()\n\n检查属性是否在对象中，和in一样作为函数工作\n\nconst obj={name:111};\nReflect.has(obj,'name');//true\nReflect.has(obj,'toString');//true\n\n\n1\n2\n3\n\n\n3、hasOwnProperty()\n\n返回布尔值，对象是否具有指定属性作为它**自己的属性**(不是继承)\n\n可正确区分对象本身属性和其原型的属性\n\nconst obj={a:1};\nobj.hasOwnProperty('a');//true\nobj.hasOwnProperty('toString');//false\n\n\n1\n2\n3\n\n\n缺点：如果对象用Object.create(null)创建，不能使用这个方法\n\nconst obj=Object.create(null);\nobj.name='merry';\nobj.hasOwnProperty('name');\n//Uncaught TypeError: obj.hasOwnProperty is not a function\n\n\n1\n2\n3\n4\n\n\n4、Object.prototype.hasOwnProperty()\n\n可解决3的问题，直接调用内置有效函数，跳过原型链\n\nconst obj=Object.create(null);\nobj.name='merry';\nObject.prototype.hasOwnProperty.call(obj,'name');//true\nObject.prototype.hasPwnProperty.call(obj,'toString');//false\n\n\n1\n2\n3\n4\n\n\nObject.propertyIsEnumerable() 判断对象是否包含某个属性，且这个属性是否可枚举（通过原型继承的属性除外）\n\n5、Object.hasOwn()\n\n若指定对象具有指定属性作为自己的属性，Object.hasOwn()静态方法返回true，若属性被继承或不存在，返回false\n\nconst obj=Object.create(null);\nobj.name='merry';\nObject.hasOwn(obj,'name');//true\nObject.hasOwn(obj,'toString');//false\n\n\n1\n2\n3\n4\n\n\n6、Object.keys()\n\n返回对象本身可枚举类型(不含 继承 和Symbol 属性)的数组\n\nObject.freeze() 冻结对象。一个被冻结的对象不能被修改，不能添加新的属性，不能删除已有属性，不能修改已有属性的任何属性 包括 值。冻结对象后该对象的原型也不能被修改\n\n\n# 🙋‍♂ 对象遍历\n\n                                 可枚举属性   不可枚举属性   继承属性   SYMBOL\nfor-in                           √       ×        √      ×\nObject.keys()                    √       ×        ×      ×\nObject.getOwnPropertyNames()     √       √        ×      ×\nObject.getOwnPropertySymbols()   ×       √        ×      √\nReflect.ownKeys()                √       √        ×      √\n\n\n# . 和[]？\n\n[]语法 通过变量访问属性\n\n如果属性包含空格，就不能通过 . 访问它。属性名可以包含非字母非数字，使用[]访问它\n\n除非必须使用变量访问属性，否则我们使用点表示法\n\n注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]\n\nconst keyA = {a: 1};\nconst keyB = {b: 2};\n\nconst myObject = {\n  [keyA]: 'valueA',\n  [keyB]: 'valueB'\n};\n\nmyObject // Object {[object Object]: \"valueB\"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# for-in\n\n遍历自身和继承的可枚举属性（不含 Symbol ）\n\n对象属性没有顺序，for-in输出的顺序不可预测\n\nlet obj = {\n    name: 'Scarlett',\n    age: 37,\n    [Symbol()]: 'Johansson'\n}\nfor (let key in obj) {\n    console.log(key) // name age\n}\n// 在原型上添加一个可枚举属性\nObject.prototype.nationality = 'America'\n// 在obj对象上添加一个不可枚举属性\nObject.defineProperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\nfor (let key in obj) {\n    console.log(key, obj[key])\n}\n/* 输出结果：包含对象自身的可枚举属性和原型上的可枚举属性\nname Scarlett\nage 37\nnationality America\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Object.keys()\n\n返回对象key组成的数组\n\n数组成员是对象本身的 (不含继承)所有可枚举属性(不含 Symbol )的键名\n\nlet obj = {\n    name: 'Scarlett',\n    age: 37,\n    [Symbol()]: 'Johansson'\n}\n\n// 在原型上添加一个可枚举属性\nObject.prototype.nationality = 'America'\n\n// 在obj对象上添加一个不可枚举属性\nObject.defineProperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\n// 获取对象自有的可枚举属性\nObject.keys(obj).map(key => {\n    console.log(key);   // name  age\n})\n\nconsole.log(Object.entries(obj)); // [[\"name\", \"Scarlett\"], [\"age\", 37]]\nconsole.log(Object.values(obj)); // [\"Scarlett\", 37]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Object.getOwnPropertyNames()\n\n对象自身所有属性（不含 Symbol，但包括不可枚举属性）的键名\n\nlet obj = {\n    name: 'Scarlett',\n    age: 37,\n    [Symbol()]: 'Johansson'\n}\n\n// 在原型上添加一个可枚举属性\nObject.prototype.nationality = 'America'\n\n// 在obj对象上添加一个不可枚举属性\nObject.defineProperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\nconsole.log(Object.getOwnPropertyNames(obj))  // [\"name\", \"age\", \"occupation\"]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nlet obj = {\n    name: 'Scarlett',\n    age: 37,\n    [Symbol()]: 'Johansson'\n}\n\n// 在原型上添加一个可枚举属性\nObject.prototype.nationality = 'America'\n\n// 在obj对象上添加一个不可枚举属性\nObject.defineProperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\nconst getAllPropertyNames = (obj) => {\n    let props = Object.assign([], Object.getOwnPropertyNames(obj))\n    // 得到所有的可枚举属性（自有的和继承的属性）\n    for (let key in obj) {\n        // 过滤自有的不可枚举属性\n        if (!Object.getOwnPropertyNames(obj).includes(key)) {\n            props.push(key)\n        }\n    }\n    return props;\n};\ngetAllPropertyNames(obj);  // [\"name\", \"age\", \"occupation\", \"nationality\"] \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Object.getOwnPropertySymbols()\n\n对象自身的所有 Symbol 属性键名\n\nlet obj = {\n    name: 'Scarlett',\n    age: 37,\n    [Symbol()]: 'Johansson'\n}\n\n// 在原型上添加一个可枚举属性\nObject.prototype.nationality = 'America'\n\n// 在obj对象上添加一个不可枚举属性\nObject.defineProperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\nvar symbolsArr = Object.getOwnPropertySymbols(obj);\nfor( let sym of symbolsArr){\n    console.log(sym, obj[sym]); // Symbol() \"Johansson\"\n}\n\n// 给对象添加一个不可枚举的Symbol属性\nObject.defineProperties(obj, {\n    [Symbol('aa')]: {\n          value: 'localSymbol',\n          enumerable: false\n     }\n})\nObject.getOwnPropertySymbols(obj).map(key => {\n    console.log(key, obj[key]); // Symbol() \"Johansson\", Symbol(aa) \"localSymbol\"\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# Reflect.ownKeys()\n\n对象自身（不含继承的）所有键名，不管键名是 Symbol /字符串，也不管是否可枚举\n\nlet obj = {\n    name: 'Scarlett',\n    age: 37,\n    [Symbol()]: 'Johansson'\n}\n\n// 在原型上添加一个可枚举属性\nObject.prototype.nationality = 'America'\n\n// 在obj对象上添加一个不可枚举属性\nObject.defineProperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\nReflect.ownKeys(obj).map(key => {\n    console.log(key, obj[key])\n})\n\n/* 输出结果：\nname Scarlett\nage 37\noccupation actress\nSymbol() \"Johansson\"\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Object.values\n\n返回对象value组成的数组\n\n数组成员是对象本身的 (不含继承)所有可枚举属性的键值\n\n\n# Object.entries\n\n返回对象key-value组成的数组\n\n数组成员是对象本身的 (不含继承)所有可枚举属性的键值对数组\n\n\n# Object转换\n\n\n# toPrimitive\n\nJS中，若想要将对象转换成基本类型 ，再从基本类型转换为对应的String或Number，实质 是调用valueOf和toSting——拆箱转换\n\ntoPrimitive(input,preferedType)\n//参数是要转换的对象，期望转换的基本类型(字符串、数字，选填，默认为number)\n\n\n1\n2\n\n\n\n# toString、valueOf\n\n对于String优先调用toString，若不存在，调用valueOf方法\n\ntoString返回字符串\"[object Object]\"\n\nvalueOf返回对象自身(历史原因，别问我为啥，可假设它根本不存在)\n\n\n# toString()\n\nObject.prototype.toString()返回表示该对象的字符串\n\n每个对象都有toString()方法\n\n数字转换为二进制\n\n * 是正数\n * 可能有小数\n * 小数部分最多保留8位\n\nfunction translate(num){\n    let a=num.toString(2);\n    let b=a.split('.');\n    let c='';\n    if(b[1].length>8){\n        c=b[1].slice(0,8);\n        return b[0]+'.'+c;\n    }\n    return a;\n}\nconsole.log(translate(1.0))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# '1'.toString()为啥可以调用？\n\n进行以下几步\n\n 1. 创建实例\n 2. 调用实例方法\n 3. 销毁实例\n\nvar s=new Object('1');\ns.toString();\ns=null;\n\n\n1\n2\n3\n\n\n\n# 123['toString'].length+123\n\nfunction的length——第一个具有默认值之前的参数个数！\n\n剩余参数不算进length的计算中\n\n\n# 对象、Map\n\n对象和 Map 可以枚举\n\nObject本质是哈希结构的键值对的集合，只能用字符串、数字或者Symbol等简单数据类型当作键，有限制；Map 的 key 可以是任意值\n\nMap继承Object，对Object做拓展，Map键可以是任意数据类型\n\n对象 在堆开辟一块内存，Map的键存的就是这块内存的地址。只要地址不一样，就是不同键，解决同名属性碰撞问题，传统的Object做不到这一点\n\n对象键值对无序\n\nMap 能记住键的原始插入顺序\n\n         MAP                    OBJECT\n意外的键     默认情况不包含任何键。只包含显式插入的键   有原型，原型链上的键名可能和自己设置的键名冲突。可以用 Object.create(null) 创建没有原型的对象\n键的类型     键可以是任意值                的键必须是String/Symbol\n键的顺序     键有序。迭代时，Map对象以插入顺序返回   目前有序，但不总是这样，而且这个顺序复杂\nSize     键值个数可通过 size 获取        键值对个数只能手动计算\n迭代       可迭代的                   没有 迭代协议，使用 JS的 for...of 不能直接迭代\n性能       频繁增删键值对的场景下表现更好        在频繁添加和删除键值对的场景下未优化\n序列化和解析   没有元素的序列化和解析的           使用 JSON.stringify()\n\n\n# WeakSet、WeakMap\n\nWeakMap、WeakSet 的 key 是弱引用，相应对象被回收时，key 被回收，因为不可控，所以不可枚举\n\nWeakSet 只能存储对象的集合\n\nWeakSet 可检测循环引用，递归调用自身的函数需要一种方式 ，跟踪哪些对象已被处理\n\nWeakMap 的 key 只能是对象（null 除外）\n\nWeakMap 无属性读取键值的个数\n\n\n# ... 与rest？\n\n... 扩展运算符可用于 扩展 数组对象和字符串，将可迭代对象转为用 逗号 分隔的参数序列\n\n> 应用\n\n * 展开数组、对象、字符串\n * 类数组对象转为数组\n * 函数传参\n * 用于具有Iterator接口的对象\n\nRest为解决传入的参数数量不一定；不会为每个变量给一个单独的名称，参数对象包含所有参数传递给函数；arguments不是真正的数组，rest参数是真实的数组\n\n剩余参数只包含那些没有对应形参的实参，arguments包含传给函数的所有实参\n\n\n# ... 应用\n\nES6通过扩展元素符...，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\n\n函数调用的时候，将一个数组变为参数序列\n\n将某些数据结构转为数组\n\n合并数组\n\n**注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组\n\n\n# rest特点\n\n减少代码\n\n//以前函数\nfunction f(a, b) {\nvar args = Array.prototype.slice.call(arguments, f.length);\n}\n// 等效于\nfunction f(a, b, ...args) {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nrest参数可以被解构\n\n\n# arguments\n\n另一种对象类型，也叫类对象数组（类数组）\n\nJS的每个函数都会有一个arguments对象实例，它引用函数的实参，有length和callee属性\n\ncallee引用函数本身（返回正被执行的Function对象），实现匿名的递归函数\n\nvar sum = function (n) {\n        if (1 == n) {\n            return 1;\n        } else {\n            return n + arguments.callee(n - 1);\n        }\n   }\n   alert(sum(6));输出结果：21\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 转换为数组\n\n 1. Array.prototype.slice.call()\n\nfunction sum(a, b) {\n  let args = Array.prototype.slice.call(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n1\n2\n3\n4\n5\n\n\nfunction exam(a, b, c, d, e) {\n\n  // 先看看函数的自带属性 arguments 什么是样子的\n  console.log(arguments);\n\n  // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变\n  var arg = [].slice.call(arguments);\n\n  console.log(arg);\n}\n\nexam(2, 8, 9, 10, 3);\n\n// result:\n// { '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 }\n// [ 2, 8, 9, 10, 3 ]\n//\n// 也常常使用该方法将DOM中的nodelist转换为数组\n// [].slice.call( document.getElementsByTagName('li') );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n 2. Array.prototype.splice.call(arrayLike,0)\n\n 3. Array.form\n\n对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例\n\nfunction sum(a,b){\n    let args=Array.from(arguments);\n    console.log(args.reduce((sum,cur)=>sum+cur));\n}\nsum(1,2);\n\n\n1\n2\n3\n4\n5\n\n 3. ES6扩展运算符\n\nfunction sum(a,b){\n    let args=[...arguments];\n    console.log(args.reduce((sum,cur)=>sum+cur));\n}\nsum(1,2);\n\n\n1\n2\n3\n4\n5\n\n 4. concat+apply or apply\n\nfunction sum(a,b){\n    let args=Array.prototype.concat.apply([],arguments); //apply会把第二个参数展开\n    console.log(args.reduce((sum,cur)=>sum+cur));\n}\n\n\n1\n2\n3\n4\n\n\n古老for循环\n\n\n# 💜 数组拍平\n\n * ES6的语法，arr.flat([depth])，depth默认不填，数值为1，参数可以是Infinity，表示全部展开\n * toString+replace+split\n\nlet arr = [1, [2, [3, [4, 5]]], 6];\nfunction flatten(arr) {\n  let str = JSON.stringify(arr);\n   str=str.replace(/(\\[|\\])/g,'')\n  str = '[' + str + ']';\n  return JSON.parse(str); \n}\nconsole.log(flatten(arr));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * replace+JSON.parse\n * 递归\n\nfunction flatten(arr,n){\n    if(n<2){\n        return arr;\n    }\n    let res=[];\n    const dfs=(arr,n)=>{\n        if(n<2){\n            res.push(arr);\n            return res;\n        }\n        for(let item of arr){\n            if(Array.isArray(item) && n){\n                dfs(item,n-1);\n            }else{\n                res.push(item);\n            }\n        }\n    }\n    dfs(arr,n);\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 利用reduce函数迭代\n\nconst arr3 = [\n\t[1, 2],\n\t[3, 4],\n\t[5, [7, [9, 10], 8], 6],\n];\nconsole.log(flatten(arr3,2)); \nfunction flatten(_arr, depth = 1) {\n    if (depth === 0) {\n        return _arr;\n    }\n    return _arr.reduce((pre, cur) =>\n        pre.concat(Array.isArray(cur) && depth>1 ?\n            flatten(cur, depth - 1) :\n            cur),[])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nfunction flatten(_arr, depth = 1) {\n    if (depth === 0) {\n        return _arr;\n    }\n    return _arr.reduce((pre,cur)=>{\n        return Array.isArray(cur) && depth>1 ?\n            [...pre,...flatten(cur,depth-1)]:\n        [...pre,cur];\n    },[])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 扩展运算符\n\nwhile(arr.some(Array.isArray)){\n    arr=[].concat(...arr);\n}\n\n\n1\n2\n3\n\n * toString+split+map\n\nconst str=[1,2,3,[5,6,[7,8]]].toString();\nconst _arr=str.split(\",\");\nconst newArr=_arr.map(item=>+item);\nconsole.log(newArr)\n\n\n1\n2\n3\n4\n\n\n\n# 数组去重\n\nindexof、includes、filter/forEach\n\nfunction unique(arr){\n    let res=arr.filter(function(item,index,array){\n        return array.indexOf(item)===index\n    })\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nSet+Array.from()\n\nlet unique=arr=>[...new Set(arr)];\nlet res=Array.from(new Set(arr));\n\n\n1\n2\n\n\nMap\n\nconst unique=(arr)=>{\n    const map=new Map();\n    const res=[];\n    for(let item of arr){\n        if(!map.has(item)){\n            map.set(item,true);\n            res.push(item);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreduce+indexOf\n\nconst newNums3 = nums.reduce((pre, cur, index, arr) => {\n    return [].concat(pre, nums.indexOf(cur) === index ? cur : []);\n})\n\n\n1\n2\n3\n\n\n双重for循环\n\n\n# 🔥判断类型\n\n\n# typeof\n\n返回字符串： string、boolean、number、Object、Function、undefined、symbol(ES6)\n\ntypeof null === '' //object\nconsole.log(typeof {}); // object\ntypeof undefined === '' //undefined\ntypeof function() {} ===‘’ //function\ntypeof NaN; // \"number\"\n\n\n1\n2\n3\n4\n5\n\n\nNaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”\n\nNaN 和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true\n\nvar a = function b() {}\nconsole.log(typeof b)\n\n\n1\n2\n\n\n\n# 区分null和Object\n\n\n# instanceof\n\n原理：判断构造函数的prototype属性是否出现在对象的原型链上\n\n优点\n\n弥补 Object. prototype. toString. call()不能判断自定义实例化对象的缺点\n\n缺点\n\ninstanceof 只能判断对象类型\n\nconsole.log(2 instanceof Number);   // false\nconsole.log(true instanceof Boolean); // false \nconsole.log([] instanceof Array);   // true\nconsole.log(function(){} instanceof Function); // true\nconsole.log({} instanceof Object); //true\n\n\n1\n2\n3\n4\n5\n\n\n实现\n\n// 利用原型链向上查找 能找到这个类的prototype的话，就为true\nfunction myInstanceof(left, right) {\n    if (left === null || typeof right !== 'function') {\n        return false;\n    }\n    let proto = Object.getPrototypeOf(left);// 获取对象的原型\n    // let proto=left.__proto__;\n    let prototype = right.prototype; // 获取构造函数的 prototype 对象\n    // 判断构造函数的 prototype 对象是否在对象的原型链上\n    while (true) {\n        if (proto === null) {\n            return false;\n        }\n        if (proto === prototype) {\n            return true;\n        }\n        proto = Object.getPrototypeOf(proto);\n    }\n}\n\nconst Person = function () {\n}\nconst p1 = new Person()\nconsole.log(myInstanceof(p1, Person));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Object.prototype.toString.call()\n\n使用Object的原型方法toString判读数据类型\n\n优点：能判断所有基本数据类型，即使 是 null 和 undefined\n\n缺点：不能精准判断自定义对象，对于自定义对象返回[object Object]\n\nconst handleType=Object.prototype.toString;\nconsole.log(handleType.call(true));//'[object Boolean]'\nconsole.log(handleType.call([]));//'[object Array]'\nconsole.log(handleType.call(function(){}));//'[object Function]'\nconsole.log(handleType.call({}));//'[object Object]'\nconsole.log(handleType.call(undefined));//'[object Undefined]'\nconsole.log(handleType.call(null));//'[object null]'\n\nObject.prototype.toString.call(new RegExp()); // [object RegExp]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n为啥obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样？\n\n因为toString是Object的原型方法，Array，Function作为Object的实例，重写了toString方法。不同对象类型调用toString时，调用的是对应重写后的toString方法(function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串...)，不会去调用Object上原型toString方法(返回对象具体类型)，因此需要使用Object原型上的toString方法才能得到想要对象的具体类型\n\n\n# constructor\n\n每一个对象实例都可以通过 constrcutor 对象访问它的构造函数 ，JS 中内置了一些构造函数：Object、Array、Function、Date、RegExp、String等。可以根据数据的 constrcutor 是否与其构造函数相等判断\n\n注意：若创建一个对象改变它的原型，constructor就不能用来判断数据类型了\n\nvar arr = [];\nvar obj = {};\nvar date = new Date();\nvar num = 110;\nvar str = 'Hello';\nvar getName = function() {};\nvar sym = Symbol();\nvar set = new Set();\nvar map = new Map();\n\narr.constructor === Array; // true\nobj.constructor === Object; // true\ndate.constructor === Date; // true\nstr.constructor === String; // true\ngetName.constructor === Function; // true\nsym.constructor === Symbol; // true\nset.constructor === Set; // true\nmap.constructor === Map // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n对于null和undefined无效，constructor不太稳定，prototype可被重写导致原有constructor丢失，Object被覆盖也会影响判断结果\n\n\n# 判断数组类型？\n\n 1. instanceof 判断对象在其原型链上是否存在构造函数的prototype属性\n 2. Array.isArray(arr) 静态方法，Array.prototype也是一个数组\n    * 优点：检测 Array 实例时，Array. isArray 优于 instanceof\n    * 缺点：只能判别数组\n 3. Object.prototype.toString.call() （最靠谱）输出格式[object 对象数据类型]\n 4. arr.proto===Array.prototype\n\n\n# typeof、instanceof\n\ntypeof 返回字符串，表示未经计算的操作数的类型\n\ninstanceof 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n\n原理——顺着原型链找，直到找到相同的原型对象，返回true，否则为false\n\n区别如下：\n\n * typeof返回变量的基本类型，instanceof返回布尔值\n * instanceof 可准确判断复杂引用数据类型，但不能正确判断基础数据类型\n * typeof 可以判断基础数据类型（null 除外），但引用数据类型中，除了function 类型以外，其他的无法判断\n\n上述两种方法都有弊端，并不能满足所有场景的需求\n\n如果需要通用检测数据类型，可以采用Object.prototype.toString，统一返回格式“[object Xxx]”的字符串\n\n\n# 🌰 深浅拷贝\n\n浅拷贝只能拷贝一层对象\n\n深拷贝能解决无限极对象嵌套问题\n\n\n# 浅拷贝\n\n新的对象对原始对象的属性精确拷贝，如拷贝的基本类型，拷贝的就是基本数据类型的值；如拷贝的引用类型，拷贝内存地址\n\n如果其中一个对象的引用内存地址改变，另一个对象也会变化\n\n\n# Object.assing()\n\nES6的object的方法，可用于对象合并\n\nObject.assign(target, ...sources)\n\n\n1\n\n\ntarget是目标对象，sources是源对象\n\nlet target = {a: 1};\nlet object2 = {b: {d : 2}};\nlet object3 = {c: 3};\nObject.assign(target, object2, object3);  \nconsole.log(target);  // {a: 1, b: {d : 2}, c: 3}\nobject2.b.d = 666;\nconsole.log(target); // {a: 1, b: {d: 666}, c: 3}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 若目标和源对象有同名属性，或 多个源对象有同名属性，后面覆盖前面属性\n * 若该只有一个参数，参数为对象时直接返回；不是对象先转为对象返回\n * null和undefined不能转为对象，因此第一参数不能为null/undefined\n * 不会拷贝对象的继承属性，不会拷贝对象的不可枚举属性，可拷贝Symbol属性\n\nObject.assign()循环遍历原对象可枚举属性，copy的方式赋值给目标对象的属性\n\n\n# 扩展运算符\n\nlet obj1 = {a:1,b:{c:1}}\nlet obj2 = {...obj1};\nobj1.a = 2;\nconsole.log(obj1); //{a:2,b:{c:1}}\nconsole.log(obj2); //{a:1,b:{c:1}}\nobj1.b.c = 2;\nconsole.log(obj1); //{a:2,b:{c:2}}\nconsole.log(obj2); //{a:1,b:{c:2}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n若属性都是基本类型，使用扩展运算符更方便\n\n\n# 数组浅拷贝\n\n# Array.prototype.slice()\n\nslice的2个参数都不写，不修改原数组\n\nlet arr = [1,2,3,4];\nconsole.log(arr.slice()); // [1,2,3,4]\nconsole.log(arr.slice() === arr); //false\n\n\n1\n2\n3\n\n * 若该对象是个对象引用，slice会拷贝这个对象引用。2个对象都引用了同一个对象。若引用的对象改变，新旧数组中的这个元素也会改变\n * 对字符串、数字和布尔值说，slice会拷贝这些值。在别的数组中修改这些值不会影响另一个数组\n\n若向2个数组任一个添加新元素，另一个不受影响\n\n# Array.prototype.concat()\n\n若省略了concat所有参数，会返回调用此方法的现存数组的浅拷贝\n\nlet arr = [1,2,3,4];\nconsole.log(arr.concat()); // [1,2,3,4]\nconsole.log(arr.concat() === arr); //false\n\n\n1\n2\n3\n\n\nconcat不改变this或任何作为参数提供的数组，而是返回一个浅拷贝，是原始数组的副本\n\n * 对象引用：concat将对象引用copy到新数组，原始/新数组都引用相同对象\n * 数据类型如字符串、数字和boolean：concat将字符串和数字的值copy到新数组\n\n\n# 应用场景\n\n对于一层结构的Array和Object想要拷贝一个副本时使用\n\n\n# 手撕\n\n * 对基础类型做最基本拷贝\n * 对引用类型开辟新的存储，拷贝一层对象属性\n\n// 浅拷贝的实现;\nfunction shallowCopy(object) {\n  // 只拷贝对象\n  if (!object || typeof object !== \"object\") return;\n  // 根据 object 的类型判断是新建一个数组还是对象\n  let newObject = Array.isArray(object) ? [] : {};\n  // 遍历 object，并且判断是 object 的属性才拷贝\n  for (let key in object) {\n    if (object.hasOwnProperty(key)) {\n      newObject[key] = object[key];\n    }\n  }\n  return newObject;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n所有的浅拷贝只能拷贝一层。如果存在对象嵌套，浅拷贝无能为力。深拷贝就是为了解决这个问题而生，它能解决多层对象嵌套问题，彻底实现拷贝\n\n\n# 深拷贝\n\n简单数据类型直接拷贝值，引用数据类型，在堆内存开辟内存存放复制的对象，把原有对象类型数据拷贝过来，两个对象相互独立，属于不同内存地址，修改其中一个，另一个不改变\n\n\n# JSON.stringify()\n\nJSON.parse(JSON.stringify())\n\n将对象序列化为JSON字符串，再反序列化，生成对象\n\n使用最多，也最简单\n\nlet obj1 = {  \n  a: 0,\n  b: {\n    c: 0\n  }\n};\nlet obj2 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 1;\nobj1.b.c = 1;\nconsole.log(obj1); // {a: 1, b: {c: 1}}\nconsole.log(obj2); // {a: 0, b: {c: 0}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 无法解决循环引用，对象成环(obj[key]=obj)\n * 无法拷贝特殊对象 RegExp Date Set Map 等\n * 忽略undefined、symbol和function(非安全类型的值)\n * 无法拷贝不可枚举属性\n * 无法拷贝对象原型链\n * NaN、Infinity变成null\n\n\n# lodash库\n\nvar _ = require('lodash');\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = _.cloneDeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f);// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nlodash源代码\n\n/**\n* value：需要拷贝的对象\n* bitmask：位掩码，其中 1 是深拷贝，2 拷贝原型链上的属性，4 是拷贝 Symbols 属性\n* customizer：定制的 clone 函数\n* key：传入 value 值的 key\n* object：传入 value 值的父对象\n* stack：Stack 栈，用来处理循环引用\n*/\n\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n    let result\n \n    // 标志位\n    const isDeep = bitmask & CLONE_DEEP_FLAG  // 深拷贝，true\n    const isFlat = bitmask & CLONE_FLAT_FLAG  // 拷贝原型链，false\n    const isFull = bitmask & CLONE_SYMBOLS_FLAG // 拷贝 Symbol，true\n \n    // 自定义 clone 函数\n    if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value)\n    }\n    if (result !== undefined) {\n        return result\n    }\n \n    // 非对象  \n    if (!isObject(value)) {\n        return value\n    }\n    \n    const isArr = Array.isArray(value)\n    const tag = getTag(value)\n    if (isArr) {\n        // 数组\n        result = initCloneArray(value)\n        if (!isDeep) {\n            return copyArray(value, result)\n        }\n    } else {\n        // 对象\n        const isFunc = typeof value == 'function'\n \n        if (isBuffer(value)) {\n            return cloneBuffer(value, isDeep)\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n            result = (isFlat || isFunc) ? {} : initCloneObject(value)\n            if (!isDeep) {\n                return isFlat\n                    ? copySymbolsIn(value, copyObject(value, keysIn(value), result))\n                 : copySymbols(value, Object.assign(result, value))\n            }\n        } else {\n            if (isFunc || !cloneableTags[tag]) {\n                return object ? value : {}\n            }\n            result = initCloneByTag(value, tag, isDeep)\n        }\n    }\n    // 循环引用\n    stack || (stack = new Stack)\n    const stacked = stack.get(value)\n    if (stacked) {\n        return stacked\n    }\n    stack.set(value, result)\n \n    // Map\n    if (tag == mapTag) {\n        value.forEach((subValue, key) => {\n            result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))\n        })\n        return result\n    }\n \n    // Set\n    if (tag == setTag) {\n        value.forEach((subValue) => {\n            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))\n        })\n        return result\n    }\n \n    // TypedArray\n    if (isTypedArray(value)) {\n        return result\n    }\n \n    // Symbol & 原型链\n    const keysFunc = isFull\n     ? (isFlat ? getAllKeysIn : getAllKeys)\n     : (isFlat ? keysIn : keys)\n \n    const props = isArr ? undefined : keysFunc(value)\n    \n    // 遍历赋值\n    arrayEach(props || value, (subValue, key) => {\n        if (props) {\n            key = subValue\n            subValue = value[key]\n        }\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))\n    })\n    \n    // 返回结果\n    return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n\n\n\n# 应用场景\n\n复制深层次的object数据结构\n\n\n# 手撕\n\n# 基础递归\n\nfor-in遍历属性，基本类型则直接copy，引用类型则递归调用\n\nfunction deepCopy(object) {\n    if (!object || typeof object !== \"object\") {\n        return;\n    }\n    let newObject = Array.isArray(object) ? [] : {};\n\n    for (let key in object) {\n        if (object.hasOwnProperty(key)) {\n            newObject[key] = typeof object[key] === \"object\" ?\n                deepCopy(object[key]) :\n                object[key];\n        }\n    }\n    return newObject;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 不能复制不可枚举属性及 Symbol 类型\n * 只能对普通引用类型值做递归复制，Date、RegExp、Function 等引用类型不能正确拷贝\n * 可能存在循环引用\n\n# 优化递归\n\n# 第一版本\n\n 1. Reflect.ownKeys() 解决不能复制不可枚举属性及 Symbol 问题。返回由目标对象自身属性键组成的数组。返回值等同于: Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))\n 2. 参数为 Date、RegExp 时，直接生成新实例返回\n 3. Object.getOwnPropertyDescriptors() 获得对象所有属性及特性。返回给定对象所有属性的信息，包括有关getter和setter的信息。允许创建对象副本并在复制所有属性（包括getter和setter）时克隆它\n 4. Object.create() 创建新对象，继承传入原对象的原型链。使用现有的对象提供新创建对象的__proto__\n 5. WeakMap 类型作为 Hash 表，是弱引用类型，防止内存泄漏，用来检测循环引用，如存在循环，则引用直接返回 WeakMap 存储的值。WeakMap的特性是，保存在其中的对象不影响垃圾回收，如WeakMap保存节点在其他地方没被引用，即使它还在WeakMap中也会被垃圾回收。深拷贝过程，所有引用对象都是被引用，为解决循环引用，深拷贝过程，希望有个数据结构记录每个引用对象有没有被使用，但深拷贝结束之后这个数据能自动垃圾回收，避免内存泄漏\n\n代码实现：\n\nfunction deepClone (obj, hash = new WeakMap()) {\n  // 日期对象直接返回一个新的日期对象\n  if (obj instanceof Date){\n   return new Date(obj);\n  } \n  //正则对象直接返回一个新的正则对象     \n  if (obj instanceof RegExp){\n   return new RegExp(obj);     \n  }\n  //如果循环引用,就用 weakMap 来解决\n  if (hash.has(obj)){\n   return hash.get(obj);\n  }\n  // 获取对象所有自身属性的描述\n  let allDesc = Object.getOwnPropertyDescriptors(obj);\n  // 遍历传入参数所有键的特性\n  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)\n  \n  hash.set(obj, cloneObj)\n  for (let key of Reflect.ownKeys(obj)) { \n    if(typeof obj[key] === 'object' && obj[key] !== null){\n     cloneObj[key] = deepClone(obj[key], hash);\n    } else {\n     cloneObj[key] = obj[key];\n    }\n  }\n  return cloneObj\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n测试\n\nlet obj = {\n  num: 1,\n  str: 'str',\n  boolean: true,\n  und: undefined,\n  nul: null,\n  obj: { name: '对象', id: 1 },\n  arr: [0, 1, 2],\n  func: function () { console.log('函数') },\n  date: new Date(1),\n  reg: new RegExp('/正则/ig'),\n  [Symbol('1')]: 1,\n};\nObject.defineProperty(obj, 'innumerable', {\n  enumerable: false, value: '不可枚举属性' \n});\nobj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))\nobj.loop = obj    // 将loop设置成循环引用的属性\nlet cloneObj = deepClone(obj)\n\nconsole.log('obj', obj)\nconsole.log('cloneObj', cloneObj)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n缺点——Map和Set无法拷贝\n\n# 第二版本\n\n/**\n * 深拷贝 避免循环引用\n */\nconst deepCopy2 = (target, hash = new WeakMap()) => {\n    if (target === null) {\n        return target;\n    }\n    if (target instanceof Date) {\n        return new Date(target);\n    }\n    if(target instanceof RegExp){\n        return new RegExp(target);\n    }\n    if(typeof target!=='object'){\n        return target;\n    }\n    if (hash.get(target)) {\n        //   避免循环引用\n        return target;\n    }\n    let cloneObj=new target.constructor();\n    hash.set(target, true);\n    const cloneTarget = Array.isArray(target) ? [] : {};\n    for (let prop in target) {\n        if (target.hasOwnProperty(prop)) {\n            cloneTarget[prop] = deepCopy2(target[prop], hash);\n        }\n    }\n    return cloneTarget;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 第三版本\n\nfunction deepClone(source, map = new WeakMap()) { // 传入一个WeakMap对象用于记录拷贝前和拷贝后的映射关系\n        if (typeof source !== \"object\") { // 非对象类型(undefined、boolean、number、string、symbol)，直接返回原值即可\n            return source;\n        }\n        if (source === null) { // 为null类型的时候\n            return source;\n        }\n        if (source instanceof Date) { // Date类型\n            return new Date(source);\n        }\n        if (source instanceof RegExp) { // RegExp正则类型\n            return new RegExp(source);\n        }\n        if (map.get(source)) { // 如果存在相互引用，则从map中取出之前拷贝的结果对象并返回以便形成相互引用关系\n            return map.get(source);\n        }\n        let result;\n        if (Array.isArray(source)) { // 数组\n            result = [];\n            map.set(source, result); // 数组也会存在相互引用\n            source.forEach((item) => {\n                result.push(deepClone(item, map)); // 必须传入第一次调用deepClone时候创建的map对象\n            });\n            return result;\n        } else { // 为对象的时候\n            result = {};\n            map.set(source, result); // 保存已拷贝的对象\n            const keys = [...Object.getOwnPropertyNames(source), ...Object.getOwnPropertySymbols(source)]; // 取出对象的key以及symbol类型的key\n            keys.forEach(key => {\n                let item = source[key];\n                result[key] = deepClone(item, map); // 必须传入第一次调用deepClone时候创建的map对象\n            });\n            return result;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 操作符\n\n\n\n> +和 - 一样，会将其操作数转化为数值，返回转化后的值\n\n * 若操作数是数值，它啥都不做\n * 若操作数不能转化为数组，返回NaN\n * 不可用于BigInt，BigInt不能转化为数值\n\n按位与&\n\n * 判断奇偶，最末位是0/1，是0就是偶数，1就是奇数，用if ((i & 1) === 0)代替if (i % 2 === 0)来判断a是不是偶数\n * 清零\n\n>  * \n\n1 + {}            // \"1[object Object]\"\ntrue + false      // 1  布尔值会先转为数字，再进行运算\n1 + null          // 1 null会转化为0，再进行计算\n1 + undefined     // NaN undefined转化为数字是NaN\n\n\n1\n2\n3\n4\n\n\n> 逻辑非 !\n\n首先将操作数转化为布尔值，再对其取反\n\n * 对象，返回false\n * 空字符串，返回true\n * 非空字符串，返回false\n * 数值0，返回true\n * 非0数值，返回false\n * null，返回true\n * NaN，返回true\n * undefined，返回true\n\n可用户将任何值转化为布尔值，使用2个!，相当于调用了Boolean()\n\n!!\"blue\" // true\n!!0;     // false\n!!NaN    // false\n!!\"\"     // false\n!!12345  // true\n\n\n1\n2\n3\n4\n5\n\n\n> 关系操作符\n\n遵循规则\n\n * 2个操作数都是数值，进行数值比较\n * 2个操作数都是字符串，比较字符串对应的字符编码值\n * 若一个操作数是数值，则将另一个操作数转换为数值，执行数值比较\n * 若一个操作数是对象，调用对象的valueOf()，根据前面的规则比较\n * 若一个操作数是布尔值，先将其转换为数值，再比较\n\n\n# 💙 类型转换\n\n6种基本类型 null undefined number stringify boolean symbol\n\n1种引用类型 object\n\n\n# 对象转换为基本类型\n\n * 对象转换为字符串\n\n优先调用toString\n\n// 模拟 toString 返回的不是基本类型值，valueOf 返回的基本类型值\nvar obj = {\n    toString: function() {\n        return {}\n    },\n    valueOf:function(){\n        return null\n    }\n}\n\nString(obj)   // \"null\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 对象转换为数字\n\n先判断valueOf方法，再判断toString方法\n\n\n\n// valueOf 和 toString 返回的都不是基本类型值\nvar obj = {\n    valueOf:function(){\n        return {}\n    },\n    toString:function(){\n        return {}\n    }\n}\n\nNumber(obj)  // Uncaught TypeError: Cannot convert object to primitive value\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nObject.create(null)创建的对象没有valueOf和toString方法，因此转换报错\n\n一般，我们不会重写valueOf和toString，大部分对象valueOf返回的仍然是对象，因此对象转换为基本类型值可以直接看toString返回的值\n\n * 转换为对象\n\n优先调用toString，若没有重写toString 则调用valueOf，若2者均没有被重写，按toString输出\n\n\n# 显式强制类型转换\n\n * 转换为字符串\n\n如果对象有自定义toString方法，则返回toString方法的结果，若是toString返回的结果不是基本类型值，报错TypeError\n\nvar obj = {\n    toString:function(){\n        return {}\n    }\n}\n\nString(obj) // Uncaught TypeError: Cannot convert object to primitive value\n\nobj + \"\"   // Uncaught TypeError: Cannot convert object to primitive value\n\nobj.toString()  // {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 转换为布尔类型\n\nnull undefined false +0 -0 NaN \"\"\n\n其他情况都是true\n\n * 转换为数字类型\n\nNumber('')    // 0\nNumber(null)  // 0\nNumber(undefined)  // NaN\nNumber(true)  // 1\nNumber(false)  // 0\n\n\n1\n2\n3\n4\n5\n\n\n对象 先被转换为相应基本类型值，再转换\n\nNumber([])  // 0\n// [] valueOf 返回的是 []，因此继续调用 toString 得到基本类型值 \"\"，转换为数字为 0\n\n\n1\n2\n\n\n\n# 隐式强制类型转换\n\n          被比较值 B                                                                                                                                      \n                      Undefined   Null                  Number                        String                          Boolean                         Object\n被比较值 A    Undefined   true        true                  false                         false                           false                           IsFalsy(B)\nNull      true        true        false                 false                         false                           IsFalsy(B)                      \nNumber    false       false       A === B               A === ToNumber(B)             A=== ToNumber(B)                A== ToPrimitive(B)              \nString    false       false       ToNumber(A) === B     A === B                       ToNumber(A) === ToNumber(B)     ToPrimitive(B) == A             \nBoolean   false       false       ToNumber(A) === B     ToNumber(A) === ToNumber(B)   A === B                         ToNumber(A) == ToPrimitive(B)   \nObject    false       false       ToPrimitive(A) == B   ToPrimitive(A) == B           ToPrimitive(A) == ToNumber(B)   A === B                         \n\nToNumber(A) 在比较前将A 转换为数字，与 +A（单目运算符 +）效果相同。ToPrimitive(A)尝试调用 A 的A.toString() 和 A.valueOf() ，将 A 转换为原始值（Primitive）\n\n * 转换为字符串\n\nx+\"\"，将x转换为字符串，+ 运算符其中一个操作数是字符串，执行字符串拼接操作\n\n对象和字符串拼接时，**对象转为基本类型，再转为数字，**先判断valueOf，再判断toString\n\nvar obj = {\n    valueOf: function() {\n        return 1\n    },\n    toString: function() {\n        return 2\n    }\n}\n\nobj + ''  // '1'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 转换为布尔值\n\n发生布尔值隐式强制类型转换的情况\n\n 1. if (..)语句中的条件判断表达式\n 2. for ( .. ; .. ; .. )语句中的条件判断表达式（第二个）\n 3. while (..)和do..while(..)循环中的条件判断表达式\n 4. ? :中的条件判断表达式\n 5. 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）\n\n> alert(3>5 || 'a' && 'b')\n\n * 转换为数字类型\n\n+ '2'  // 2\n'2' - 0  // 2\n'2' / 1   // 2\n'2' * 1   // 2\n\n\n+ 'x'  // NaN\n'x' - 0 // NaN\n'x' / 1 // NaN\n'x' * 1  // NaN\n\n1 + '2'  // '12'\n1 + + '2'  // 3    即：1 + (+ '2')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# ==、===\n\n== 允许在比较中强制类型转换， === 不允许\n\n== 比较时 ，2个操作符都会进行强制类型转换，再确定是否相等\n\n比较规则\n\n 1. 判断二者类型是否相同，相同则比较大小\n 2. 类型不同，进行类型转换\n 3. null和undefined，返回true，其**他类型和 null 均不相等**，undefined 也是\n 4. String和number，将字符串转换为number\n 5. 若其中一方是boolean，将boolean转为number再判断\n 6. 若其中一方是object，另一方是string、number或Symbol，将object转为原始类型再判断，对象转换优先级最高\n\n\n\n注意！\n\n若一个是NaN，相等运算符返回false，不相等运算符返回true\n\n对于(!=)，只有在强制类型转换后不相等才返回 false\n\n对于(===)，只有当2个操作数 数据类型和值都相等时，返回true，它不会转化数据类型\n\n对于(!==)，只有2个操作数在不进行类型转化的情况下是不相等的，才返回true\n\nnull+1=1\nundefined+1=NaN\n1 + {} = \"1[object Object]\"//一个操作数是对象,调用对象的 valueOf 转成原始值,如果没有该方法或调用后仍是原始值,则调用 toString 方法\n\n\n1\n2\n3\n\n\nnull转换为number=0\n\nundefined转换为number=NaN\n\n其它运算只要其中一方是数字,另一方就转为数字\n\n'a' + + 'b' // -> \"aNaN\"\n// 因为 + 'b' -> NaN\n// 你也许在一些代码中看到过 + '1' -> 1\n\n\n1\n2\n3\n\n\n![]=='' //true\n[]=='' //true\n[]==![] //true\n{}=={} \n\n\n1\n2\n3\n4\n\n\n5、特殊情况\n\nNaN == NaN  // false\n-0  == +0   // true\n!NaN //true\n\n\n1\n2\n3\n\n\n两个对象比较，判断两个对象是否是同一个引用\n\n\"0\" == false // true\n// false 转换为数字  0，等式变为 \"0\" == 0\n// 类型不一致继续转换，\"0\" 转换为数字 0，变为 0 == 0\n\nfalse == [] // true\n// [] 转换基本类型值 [].toString() 为 \"\"，变为 \"\" == false\n// 类型不一致，继续转换，false 转换为数字为 0，变为 \"\" == 0\n// 类型不一致，继续转换，第1条规则，\"\" 转换为数字，结果为 0，变为 0 == 0\n\n0 == []    // true\n// [] 转换基本类型值，[].toString()，结果为 \"\"，等式变为 0 == \"\"\n// 类型不一致，继续转换，\"\" 转换为数字，结果为 0，等式变为 0 == 0\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n参考文档https://dorey.github.io/JavaScript-Equality-Table/\n\n\n# 优先级\n\n左结合（左到右）——把左边的子表达式加上小括号 (a OP b) OP c\n\n右结合（右到左）—— a OP (b OP c)\n\n赋值运算符是右结合\n\na=b=5 相当于 a=(b=5)\n\n只有幂运算符是右结合的，其他算术运算符都是左结合\n\n6 / 3 / 2 与 (6 / 3) / 2 相同，除法左结合。幂运算符右结合，所以 2 ** 3 ** 2 与 2 ** (3 ** 2) 相同\n\n判断执行顺序时，优先级在结合性之前，混合求除法和幂，求幂先于除法\n\n2 ** 3 / 3 ** 2 的结果是 0.8888888888888888，相当于 (2 ** 3) / (3 ** 2)\n\n\n\n逻辑非!的优先级比全等===高\n\n点运算符（.）优先级高于new(无参数列表)\n\n[] 、函数调用 优先级和new(带参数列表)一样高\n\nnew Foo()优先级大于 new Foo\n\nnew Foo().getName相当于 (new Foo()).getName()\n\nnew Foo.getName()相当于 new (Foo.getName)()\n\n展开语法不是运算符，因此没有优先级\n\n\n# 🌰 0.1+0.2 === 0.3?\n\nJS数字存储采用IEEE754双精度存储，小数使用64位固定长度表示，其中1位表示符号位，11位表示指数位，剩下52尾数位\n\n总结\n\n 1. 精度损失 0.1和0.2转换为二进制出现无限循环情况，JS 最大可存储53位有效数字，超过此长度会被截取掉，造成精度损失\n 2. 对2个64位双精度格式数据计算时，先对阶(将阶码对齐，将小数点位置对齐)，小阶数在对齐时，有效数字向右移动，超过有效位数的位被截取掉\n 3. 两个数据阶码对齐后加运算，结果可能超过53位有效数字，超过的位被截取掉\n\n相加后因浮点数小数位限制截断的二进制数字转换为十进制时变成0.30000000000000004(15个0)\n\n\n# 让其相等？\n\n * 转换为整数，结果转换为对应小数\n\n * 设置误差范围(将结果与右边相减，若结果小于一个极小数，则正确)\n   \n   * 极小数可以是 ES6 的 Number.EPSILON，实质是一个可接受的最小误差范围, 一般为 Math.pow(2, -52)\n\nfunction isEqual(a, b) {\n  return Math.abs(a - b) < Number.EPSILON;\n}\nconsole.log(isEqual(0.1 + 0.2, 0.3)); // true\n\n\n1\n2\n3\n4\n\n * 转成字符串,对字符串做加法运算\n\nparseFloat((0.1 + 0.2).toFixed(10))\n//toFixed四舍五入\n\n\n1\n2\n\n * toPrecision转换成数字，以指定精度返回该数值对象的字符串表示，四舍五入到参数指定的数字位数\n\nfunction strip(num, precision = 12) {\n  return parseFloat(num.toPrecision(precision));\n}\nlet x=strip(0.30000000000000004,18)\nconsole.log(x)\n//默认去掉最低位的0\n\n\n1\n2\n3\n4\n5\n6\n\n * 将计算数字提升10的N次方\n\n(0.1*1000+0.2*1000)/1000==0.3\n//true\n\n\n1\n2\n\n\n+(0.1+0.2).toFixed(2)\n//一元加号强制转换为数字\n\n\n1\n2\n\n * Math.js\n\n\n# bind、call、apply\n\n\n# call、apply\n\n改变函数体内部this指向\n\n第一个参数都是 this 的指向对象，第二个参数差别：\n\ncall 参数按顺序传递， obj.myFun.call(db,'成都', ... ,'string' )\n\napply参数为数组，obj.myFun.apply(db,['成都', ..., 'string' ])\n\n> 用法\n\n数组追加\n\nvar array1 = [12 , \"foo\" , {name :\"Joe\"} , -2458]; \nvar array2 = [\"Doe\" , 555 , 100]; \nArray.prototype.push.apply(array1, array2); \n/* array1  [12 , \"foo\" , {name \"Joe\"} , -2458 , \"Doe\" , 555 , 100] */\n\n\n1\n2\n3\n4\n\n\n获取数组最大/小值\n\nvar a=[1,2,3,4];\nlet ans=Math.max.apply(null, a);\n\n\n1\n2\n\n\n验证是否为数组(前提是toString()未被重写)\n\nObject.prototype.toString.call(obj)==='[object Array]';\n\n\n1\n\n\n类数组转换为数组\n\nlet arr=Array.prototype.slice.call(arguments);\n\n\n1\n\n\n每个function实例都有call、apply属性？？是的！\n\n\n# bind\n\nbind 除了返回一个新函数以外，参数和 call 一样\n\n注意：将null undefined 作为第一参数时，被忽略\n\n严格模式下 this为undefined\n\n多次调用bind()无效\n\n当 bind 返回的函数作为构造函数 时，bind 指定的this失效，但传入的参数有效\n\nvar value = 2;\n\nvar foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    this.habit = 'shopping';\n    console.log(this.value);\n    console.log(name);\n    console.log(age);\n}\n\nbar.prototype.friend = 'kevin';\n\nvar bindFoo = bar.bind(foo, 'daisy');\n\nvar obj = new bindFoo('18');\n// undefined 绑定的value失效！！\n// daisy\n// 18\nconsole.log(obj.habit);\nconsole.log(obj.friend);\n// shopping\n// kevin\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 实现\n\nFunction.prototype.bind2 = function (context) {\n    if (typeof this !== \"function\") {\n      throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var self = this;\n    //获取bind2函数从第二个到最后一个参数\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var fNOP = function () {};\n\n    var fBound = function () {\n        //bind返回的函数传入的参数\n        var bindArgs = Array.prototype.slice.call(arguments);\n        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));\n    }\n//直接修改fBound.prototype时，也会直接修改 绑定函数的 prototype？？？\n    //fBound.prototype=this.prototype 为了fBound构造的实例能继承绑定函数原型中的值\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n    return fBound;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 为啥fBound.prototype直接修改也会修改 绑定函数的 prototype？\n\nFunction.prototype.bind2 = function (context) {\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var fBound = function () {\n        var bindArgs = Array.prototype.slice.call(arguments);\n        self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));\n    }\n  \n    fBound.prototype = this.prototype;\n    return fBound;\n}\nfunction bar() {}\nvar bindFoo = bar.bind2(null);\nbindFoo.prototype.value = 1;\nconsole.log(bar.prototype.value) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n相当于 用原型式继承 包了一层，实现2个实例间原型的数据共享，但又能 避免return的函数原型直接修改原型，导致绑定函数的原型也被修改\n\n\n# VO、AO\n\nVariable Object\nActivation Object\n\n\n1\n2\n\n\nAO和VO其实是同一个东西，处于不同 生命周期 罢了\n\n只是VO是规范上/引擎实现的，不可在JS环境中访问，只有进入 执行上下文 中，VO被激活，所以才叫AO呐\n\n变量对象是与执行上下文相关的数据作用域，存储 在上下文中定义的 变量和函数声明\n\n只有处于函数调用栈 栈顶的执行上下文中的VO，才会变成AO\n\n\n# ✅this\n\n调用函数时 创建一个执行环境，this在运行时根据函数的执行环境绑定，它允许函数在内部引用上下文中的执行变量，使函数更加优雅简洁\n\n> new>显示>隐式>默认\n\nthis指向在 执行上下文被创建时确定，函数执行过程中，一旦this指向被确定就不可更改\n\n在一个函数上下文中，this由调用者提供。如果调用者函数，被某一个对象所拥有，该函数在调用时，this指向该对象。如果函数独立调用，该函数内部的this指向undefined，在非严格模式中，this自动指向全局对象\n\n// demo03\nvar a = 20;\nvar obj = {\n  a: 10,\n  c: this.a + 20,\n  fn: function () {\n    return this.a;\n  }\n}\n\nconsole.log(obj.c); //40\nconsole.log(obj.fn()); //10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n**单独的{}不形成新的作用域，**这里的this.a，并没有作用域的限制，仍然处于全局作用域之中\n\n定义对象的大括号{}不是一个单独的执行环境，依旧处于全局环境\n\n\n# 绑定规则\n\n1、默认\n\n2、隐式\n\n考虑 调用位置是否上下文对象\n\n若函数调用当前存在多个对象，this指向距离自己最近的对象\n\n> 隐式丢失\n\n作为参数传递和变量赋值，会使参数或变量直接指向函数，丢失this指向\n\n如何解决？\n\n使用隐式绑定：将函数绑定至对象属性，调用时通过对象属性直接调用，弱赋值到其他对象，需将正对象赋值过去，不然会丢失 初次绑定的环境\n\n3、显式\n\ncall、bind和apply 改变this\n\n4、new\n\n创建一个新的对象将其绑定到foo()调用的this\n\n5、箭头函数\n\n从自己的作用域链的上一层继承this\n\n\n# 全局上下文\n\n> 全局对象\n\n 1. 可通过this访问\n 2. 是Object实例化的一个对象\n 3. 预定了一堆函数和属性\n 4. 作为全局变量的宿主\n 5. 客户端，this.window==this\n\n全局上下文中的变量对象就是全局对象！！\n\n非严格模式和严格模式中this指向顶层对象\n\n// 在浏览器中，全局对象为 window 对象：\nconsole.log(this === window); // true\n\nthis.a = 37;\nconsole.log(window.a); // 37\n\n\n1\n2\n3\n4\n5\n\n\n\n# 函数上下文\n\n严格模式下 this 为undefined，非严格模式下为 window\n\n活动对象在进入函数上下文时被创建，通过arguments初始化\n\n执行上下文代码分2个阶段\n\n 1. 进入执行上下文\n 2. 执行\n\n\n# 进入执行上下文\n\n变量对象包括\n\n 1. 函数的所有形参\n    1. 键值对形式的变量对象被创建\n    2. 无 实参，值设为 undefined\n 2. 函数声明\n    1. 名称和对应值(函数对象 function-Object)组成变量对象的属性被创建\n    2. 若vo 已存在同名 属性，则完全替换\n 3. 变量声明\n    1. 名称和对应值(undefined)组成vo被创建\n    2. 若变量名称和已声明形参/函数相同，则 变量声明 不会干扰已存在的这类属性———所以 再次声明的var变量不会覆盖掉已变量提升的函数声明！！\n\njs在函数预处理阶段的解析顺序：\n函数参数->内部声明式函数->内部var声明的变量\n\n\n1\n2\n\n\n\n# 代码执行\n\n顺序执行代码并 修改 VO的值\n\n\n# 箭头函数\n\n标准函数中this引用的是 方法调用 时的上下文\n\n箭头函数的this 为定义时所在的 this，不绑定this (因为箭头函数没有Constructor)，捕获其所在上下文的 this 作为自己的 this\n\n若包裹在函数中，就是函数调用时所在的对象，全局就是window，箭头函数的this是外层代码块的this，固定不变\n\n\n# 特点\n\n * 没有自己的this\n * 继承来的this不会变\n * 没有arguments，获得的arguments是外层函数的arguments\n * call apply 和bind无法改变this\n\n\n# 啥时候不能用\n\n * 对象方法不适用 箭头函数\n * 原型方法 不适用\n * 不可用于构造函数，没有new关键字\n * 不用于 动态上下文的回调\n\nconst btn1 = document.getElementById('btn1')\nbtn1.addEventListener('click', () => {\n    this.innerHTML = 'clicked'\n    //此处 this指向 window，而不是 button\n})\n\n\n1\n2\n3\n4\n5\n\n * Vue 生命周期和method不能用\n\nReact可以用\n\n因为 Vue本质是对象，React组件(class)本质是ES6的class\n\n * 不能用于generator函数，没有yield关键字\n\n> 不适用箭头函数如何使其指向实例\n\n函数定义在prototype就能获得this指向\n\n\n# bind 函数\n\n在 Function的原型链上，Function.prototype.bind 通过 bind 函数绑定后，函数将绑定在其第一个参数对象上，除非使用new时被改变，其他情况不会改变，无论在啥情况下被调用\n\n！！多次bind调用，this指向依旧是第一次的\n\n\n# setTimeout、setInterval\n\nfor(var i=0;i<5;i++){\n    ;(function(i){\n        setTimeout(function(){\n            console.log(i)\n        },i*1999)\n    })()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n**延时函数内部回调函数this 指向全局对象window\n\nintroduction() === introduction.call() ，前者是后者的简写！call()中的第一个传参 指定这个函数中的 this 指向！\n\nfunction introduction(name) {\n  console.log('你好,'+ name +' 我是' + this.name);\n}\nvar zhangsan = {\n name:'张三'\n}  \nintroduction.call(zhangsan,\"李四\")   // 你好 李四, 我是 张三   call\nintroduction.apply(zhangsan,[\"李四\"])   // 你好 李四, 我是 张三   apply\nintro = introduction.bind(zhangsan)\nintro(\"李四\")// 你好 李四, 我是 张三   bind\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nbind()返回一个绑定新环境的function，等着被调用\n\n\n# 🌈 函数\n\n\n# new Function\n\nlet func = new Function ([arg1, arg2, …argN], functionBody);\n\n\nlet sum = new Function('a', 'b', 'return a + b');\nconsole.log(sum(1, 2)); \n\n\n1\n2\n3\n4\n5\n\n 1. 无效的 JSON 对象字符串合法化\n 2. 模板字符串作为模板\n 3. 闭包和上下文\n\nnew Function body 参数变量上下文是全局的，不是私有，没有闭包\n\n\nfunction getFunc() {\nlet value = 'yh';\nlet func = new Function('console.log(value)');\nreturn func;\n}\ngetFunc()(); // error: value is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n常规函数语法没有问题\n\n\nfunction getFunc() {\nlet value = 'yh';\nlet func = function () {\nconsole.log(value)\n  };\nreturn func;\n}\ngetFunc()(); // print 'yh'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nnew Function 语 RegExp ，使用字符串作为正则表达式的内容， 适合动态匹配/ 增加代码混淆\n\n\n# 函数声明\n\n使用function的函数声明比函数表达式优先提升\n\n> 函数声明比变量声明 更优先执行顺序\n\n无论在什么位置声明了函数，都可以在同一个执行上下文中直接使用该函数\n\n\n# 函数表达式\n\n也叫匿名函数—— 没有被显式赋值操作的函数。使用场景，多为一个参数传入另一个函数中\n\n函数自执行，其实是匿名函数的一种应用\n\n函数表达式使用 var/let/const声明，确认他是否可正确使用时 必须依照var/let/const的规则判断——变量声明\n\nvar声明，其实进行两步操作\n\n// 变量声明\nvar a = 20;\n\n// 实际执行顺序\nvar a = undefined;  // 变量声明，初始值undefined，变量提升，提升顺序次于function声明\na = 20;  // 变量赋值，该操作不会提升\n\n\n1\n2\n3\n4\n5\n6\n\n\n同样道理，当使用变量声明的方式声明函数时——函数表达式。函数表达的提升方式与变量声明一致\n\nfn(); // 报错\nvar fn = function() {\n    console.log('function');\n}\n//上述例子执行顺序为\nvar fn = undefined;   // 变量声明提升\nfn();    // 执行报错\nfn = function() {   // 赋值操作，将后边函数的引用赋值给fn\n    console.log('function');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 由于声明方式的不同，导致函数声明与函数表达式存在差异，除此，这种形式在使用上并无不同\n\n\n# 函数声明、函数表达式\n\n * 函数声明式 ： function functionName （）{}\n * 函数表达式：let name = function(){}\n\nconsole.log(a) //undefined\nvar a = 1\nconsole.log(getNum)//getNum(){a=3}\nvar getNum = function() { \n  a = 2\n}\nfunction getNum() {\n  a = 3\n}\nconsole.log(a) //1\ngetNum()\nconsole.log(a) //2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n函数声明有提升作用，执行前把函数提升到顶部，执行上下文中生成函数定义，所以第二个 getNum会被最先提升到顶部\n\n然后var 声明 getNum 的本该提升，但 getNum 的函数已经被声明了，所以不需要再声明一个同名变量，只是将已经声明的getNum替换掉了，于是修改变量a=2\n\nvar a = 1\nfunction a(){} //已经声明提升,跳过\nconsole.log(a) //1\n\nvar b\nfunction b(){} \nconsole.log(b) //f b(){}\n\nfunction b(){}\nvar b //已经提升过了,var声明忽略\nconsole.log(b) //f b(){}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n！！函数会优先提升. function声明优先于var声明\n\n> 进入执行上下文时，先 处理函数声明，其次 处理 变量声明，如果变量名称跟已经声明的形参或函数相同，变量声明不会干扰已经存在的这类属性\n\n箭头函数和函数声明区别？？？\n\nsetTimeout(foo, 100)\nfoo = () => {\n    console.log('a')\n}\nfoo()\n\nfunction foo() {\n    console.log('b')\n}\n\nfoo()\n\nfunction foo() {\n    console.log('c')\n}\n\nfoo()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 回调函数？由谁调用？\n\n匿名函数传入另一个函数之后，最终会在另一个函数中执行，称这个匿名函数为回调函数\n\n\n# 高阶函数\n\n> 一个函数可接收另一个函数作为参数或返回另一个函数\n\n 1. map\n 2. reduce\n\n * 参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中四个默认参数，依次为积累值、当前值、当前索引和整个数组\n\n 3. filter 返回新数组\n 4. sort\n\n\n# 普通函数\n\n若是'use strict'，不能将全局对象window作为默认绑定。this=undefined\n\n普通函数：定义时this 指向函数作用域，但定时器之后执行函数时，此时this指向 window\n\n> 普通函数的this，是调用是所在的对象\n\n\n# 自执行函数\n\n[IIFE]Immediately Invoked Function Expression：声明即执行的函数表达式\n\n\n# 函数按值传参\n\n结论仍然是按值传递，当我们期望传递一个引用类型时**，真正传递的，**只是这个引用类型保存在变量对象中的引用而已\n\nvar person = {\n    name: 'Nicholas',\n    age: 20\n}\n\nfunction setName(obj) {  // 传入一个引用\n    obj = {};   // 将传入的引用指向另外的值\n    obj.name = 'Greg';  // 修改引用的name属性\n}\n\nsetName(person);\nconsole.log(person.name);  // Nicholas 未被改变\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 函数式编程\n\n函数式编程的思维建议我们将这种会多次出现的功能封装起来\n\n使用时，只需要关心这个方法能做什么，而不用关心具体是怎么实现的。这也是函数式编程思维与命令式不同的地方之一\n\n> 特征\n\n函数是第一等公民\n\n所谓\"第一等公民\"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值\n\n只用\"表达式\"，不用\"语句\"\n\n\"表达式\"（expression）是一个单纯的运算过程，总是有返回值；\"语句\"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。每一步都是单纯的运算，都有返回值\n\n函数式编程期望一个函数有输入，也有输出\n\n\n# 纯函数\n\n即：只要是同样的参数传入，返回的结果一定是相等的\n\n\n# 自执行函数IIEE\n\nlet obj = {\n    num: 5,\n    func: function () {\n        let that = this;\n        console.log(that)\n        that.num *= 2;\n        (function () {\n            console.log(this)//window\n            this.num *= 3;\n            that.num *= 4;\n            return function () {\n                console.log(this)//window，但是没有IIEE的返回值没有被接收，所以不会执行此语句块\n                this.num *= 5;\n                that.num *= 6;\n            }\n        })()\n    }\n}\nvar num = 2;\nobj.func();\nconsole.log(num);\nconsole.log(obj.num);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nIIEE的this指向？\n\nIIEE的返回值？\n\n\n# 执行上下文\n\n当执行 JS 代码时，会产生三种执行上下文\n\n * 全局执行上下文\n * 函数执行上下文\n * eval 执行上下文\n\n执行上下文创建阶段，vo、作用域链、闭包、this被确定\n\n对每个执行上下文，都有三个重要属性：\n\n * (Variable object，VO) 包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问\n * 作用域链(Scope chain) ，JS 采用词法作用域，变量的作用域在定义时就决定了\n * this\n\nJS属于解释型语言，执行分为：解释和执行两个阶段，这两个阶段所做的事并不一样：\n\n\n# 解释阶段\n\n * 词法分析\n * 语法分析\n * 作用域规则确定\n\n\n# 执行阶段\n\n * 创建执行上下文\n   * 确定this\n   * 创建 词法环境\n   * 创建 变量环境\n * 执行\n   * 变量赋值、代码执行\n * 垃圾回收\n\n执行上下文在函数执行前创建。随时可改变，最明显的就是this的指向在执行时确定。 作用域访问的变量是编写代码的结构确定\n\n词法环境——持有标识符-变量映射的结构\n\n(标识符指的是变量/函数的名字，变量是对实际对象[包含函数类型对象]或原始数据的引用)\n\n其实就是作用域，是一套规则\n\n变量环境也是词法环境\n\n词法环境组件和变量环境的不同是前者被用来存储函数声明和变量（let 和 const）绑定，后者只用来存储 var 变量绑定\n\n同一个作用域下，不同调用产生不同的执行上下文环境，产生不同的变量值\n\nJS引擎创建了**执行上下文栈(调用栈/执行栈)**管理执行上下文\n\n当 JS 开始要解释执行代码的时候，首先创建全局执行上下文 push进栈，用 globalContext 表示它，当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext\n\n遇到函数调用 就为函数 创建新的 函数执行上下文 push进栈\n\n从栈顶依次执行，执行完pop出栈\n\nlet a = 'Hello World!';\nfunction first() {\n  console.log('Inside first function');\n  second();\n  console.log('Again inside first function');\n}\nfunction second() {\n  console.log('Inside second function');\n}\nfirst();\nconsole.log('Inside Global Execution Context');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n简单分析一下流程：\n\n * 创建全局上下文压入执行栈\n * first被调用，创建函数执行上下文并压入栈\n * 执行first过程遇到second，创建一个函数执行上下文并压入栈\n * second执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文first\n * first执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文\n * 所有代码执行完毕，全局上下文pop出栈\n\n\n# 🌰 作用域\n\nScope，变量（变量作用域又称为上下文）和函数存在的范围\n\n作用域就是 变量 和函数的可访问范围，控制着变量和函数的可见性和生命周期\n\n作用域规定了如何查找变量，即确定当前执行代码对变量的访问权限。(最大作用是 隔离变量)，内层作用域可以访问外层作用域的变量，反之不行\n\n块语句（大括号“｛｝”中间的语句）， if/switch 条件语句或 for/while 循环语句，不像函数，它们不会创建新的作用域\n\n\n1\n\n\n\n# 全局作用域\n\n{}外声明的变量\n\n在代码任何地方都能访问到的对象拥有全局作用域\n\n一般以下几种情形有全局作用域链:\n\n 1. 最外层函数和在最外层函数外定义的变量\n 2. 所有末定义直接赋值的变量自动声明为拥有全局作用域\n 3. window对象的属性\n\n\n# 局部作用域\n\n和全局作用域相反，一般只在固定的代码片段内可访问，最常见的例如函数内部\n\n分为 函数和 块级作用域\n\n\n# 函数作用域\n\n声明在函数内部的变量，在函数定义时就决定了\n\n因为函数有内部属性[[scope]]，函数创建时，保存所有父变量对象，理解为 [[scope]]就是所有父变量 对象的层级链，但！[[scope]] 不代表完整的作用域链\n\n> JS不支持函数 重载！ 因为 js 不用对传入的参数的类型进行严格定义。所以，即使我们写同名函数，只会导致后面函数将前面函数覆盖\n\n\n# 块级作用域(ES6增)\n\n> 为啥?ES5只有全局和函数，有不合理场景\n> \n>  * 内层变量覆盖外层变量\n>  * 计数的i变为全局变量\n> \n> 块级作用域一定程度解决问题\n\n块级作用域 通过 let和const声明，声明的变量在指定块的作用域外无法被访问\n\n被创建：\n\n 1. 函数内部\n 2. 代码块（由一对花括号包裹）内部\n\n特点:\n\n * 声明变量不会提升\n * 禁止重复声明\n * 循环中的绑定块作用域的妙用\n\n> 特点\n\n 1. 不存在变量提升\n 2. 禁止重复声明\n 3. 循环中绑定作用域\n\nfor循环还有一个特别之处，设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域\n\n\n * # for循环的setTimeout输出，var和let定义变量区别\n\n它们算是闭包吗？\n\n80% 应聘者都不及格的 JS 面试题\n\nsetTimeout先将回调函数放到等待队列中等待其他主程序执行完毕，按时间顺序先进先出执行回调。本质是作用域的问题\n\n每个setTimeout运行时都将function压入队列，var声明变量在全局环境都会被调用，执行压入下一个function时，会改变上一个已经压入队列的function中的变量i，最后打印五个5\n\n因为 setTimeout 创建了一个可以访问其外部作用域的函数（闭包），该作用域是包含索引 i 的循环。 经过 3 秒后，执行函数并打印 i ，该值在循环结束时为 4，循环经过0,1,2,3,4循环最终停止在 4\n\n某个标识符在当前作用域中没有找到，沿着外层作用域继续查找，直到最顶端，**词法作用域在函数定义时确定，而不是执行时，**b函数在全局作用域中定义，虽然在a函数内调用，但它只能访问到全局的作用域而不能访问到a函数的作用域\n\n> 美团面试题\n\nvar name = 'name';\nvar A = {\n  name: 'A',\n  sayHello: function() {\n      let s = () => console.log(this.name);\n      let s=function(){\n          console.log(this.name)\n      }\n      return s;\n  }\n};\nlet sayHello = A.sayHello();\nsayHello();\nvar B = {\n  name: 'B'\n};\nsayHello.call(B)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 词法作用域\n\n又叫静态作用域，变量被创建时就确定好，而不是执行阶段\n\n\n# 作用域链\n\n查找变量时，先从当前上下文的变量对象中查找，，从当前作用域开始一层层往上找，如果没找到，会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象——即全局对象。这样由多个执行上下文的变量对象构成的链表——作用域链\n\n保证当前执行环境对符合访问权限的变量和函数的有序访问\n\n与其相对的是动态作用域\n\n作用域链规定如何查找变量，确定当前执行代码对变量的访问权限\n\nif(!('a' in window)){\n    var a=1;\n}\nconsole.log(a)//undefined\n\n\n1\n2\n3\n4\n\n\n因为 if语句中的var会变量提升，变成全局变量，于是window中就有a，但不会进入条件语句中，输出 undefined\n\n\n# 🔑 闭包\n\n> 闭包是啥？\n> \n> 为啥JS中所有函数都是闭包的\n> \n> 关于[[Environment]]属性和词法环境原理的细节\n\n\n# 是啥\n\n内部函数 可以访问其外部函数中声明变量，调用 外部函数返回 内部函数后，即使 外部函数执行结束了，但 内部函数引用外部函数的变量依然保存在内存 ，这些变量的集合——闭包\n\n闭包 允许我们从内部函数 访问外部函数的作用域，闭包随着函数的创建同时被创建\n\n每一个函数都会拷贝上级作用域，形成一个作用域链条\n\n闭包：自由变量的查找，在函数定义的地方，向上级作用域查找\n\n闭包数据是对象 存在堆空间，所以函数调用之后为闭包还能引用函数内的变量\n\n形成 的3个条件：\n\n * 闭包在函数被调用执行的时候被确认创建\n * 闭包形成与作用域链的访问顺序有直接关系\n * 只有内部函数访问了上层作用域链中变量对象，才会形成闭包\n\n即使创建函数的上下文 已经销毁，它依然存在；同时引用了自由变量(自由变量：函数中使用，既不是 函数参数 也不是 函数局部变量的变量)\n\n函数存在闭包，其所有内部函数都会拥有指向这个闭包的引用(所有内部函数共享一个闭包)，只要任意内部函数引用外部函数声明变量，这个变量会被纳入闭包，最内部的函数持有所有外部的闭包\n\n\n1\n\n\n闭包不满足链式作用域结构？？\n\n(function(){})()理论上是一个闭包？？\n\n不是，它是立即执行函数\n\n参考文档\n\n\n# 作用\n\n 1. 独立作用域，避免变量污染\n 2. 实现缓存计算结果，延长变量生命周期\n 3. 创建私有变量\n\n\n# 运用\n\n项目中的应用？？\n\n防抖节流\n\n防抖：事件触发高频到最后一次操作，如果规定时间内再次触发，则重新计时\n\nfunction debounce(fn,delay=300){\n    let timer; //闭包引用外界变量\n    return function(){\n        consr args=arguments;\n        if(timer){\n            clearTimeout(timer);\n        }\n        timer=setTimeout(()=>{\n            fn.apply(this,args);\n        },delay);\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n模拟块级作用域\n\nfunction OutPutNum(cnt){\n    (function (){\n        for(let i=0;i<cnt;i++){\n            alert(i);\n        }\n    })();\n    alert(i);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对象中创建私有变量\n\n模拟私有方法\n\n\n# 内存管理GC\n\n栈中JS引擎自动清除\n\nJS单线程机制，GC过程阻碍了主线程 执行\n\n> 堆内存中的变量只有在 所有对它的引用都 结束 时被回收\n\n自动垃圾回收机制：找出不使用的值，释放内存\n\n函数运行结束，没有闭包或引用，局部变量被 标记 清除\n\n全局变量：浏览器卸载页面 被清除\n\n引用：显式引用（对象有对其属性的引用） 和 隐式引用（对象对其原型的引用）\n\n\n# 垃圾回收算法\n\n不论哪个垃圾回收算法，都有一套共同的流程：\n\n 1. 标记内存空间中的活动对象（在使用中的对象）和非活动对象（可以回收的对象）\n 2. 删除非活动对象，释放内存空间\n 3. 整理内存空间，避免频繁回收后产生的大量内存碎片（不连续内存空间）\n\n\n# 引用计数\n\n一个对象是否有被引用（循环引用导致内存泄露）\n\n跟踪每个变量被使用的次数\n\n>  1. 当声明了变量且将引用类型赋值给该变量时，值的引用次数为1\n>  2. 若同一个值又被赋给另一个值，引用数+1\n>  3. 如果该变量的值被其他的值覆盖了，则引用次数减 1\n>  4. 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器在运行的时候清理掉引用次数为 0 的值占用的内存\n\n缺点:\n\n * 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限\n * 解决不了循环引用导致的无法回收问题\n\n\n# 标记清除\n\n将“不再使用的对象”定义为“无法到达的对象”\n\n工作流程：\n\n>  1. 垃圾收集器在运行时给内存变量加上 标记，假设内存中所有对象都是垃圾，全标记为0\n>  2. 根部出发，寻找可到达的变量，将其标记清除，改为1\n>  3. 留有标记的变量就是待删除的，即标记为0，销毁并回收它们占用的内存\n>  4. 把所有内存中对象标记修改为0，等待下一轮垃圾回收\n\n优点:实现简单，一位二进制位就可以为其标记\n\n缺点:\n\n * 内存碎片化，空闲内存块不连续，可能出现分配所需内存过大的对象时找不到合适的块\n * 分配速度慢，即使使用first-fit策略，操作仍是一个O(n)的操作，最坏情况是每次都要遍历到最后，因为碎片化，大对象的分配速率会更慢\n\n\n# 复制算法\n\n为了解决上述问题，复制算法出现了\n\n 1. 将整个空间平均分成 from 和 to 两部分。\n 2. 先在 from 空间进行内存分配，当空间被占满时，标记活动对象，将其复制到 to 空间\n 3. 复制完成后，将 from 和 to 空间互换\n\n由于直接将活动对象复制到另一半空间，没有了清除阶段的开销，所以能在较短时间内完成回收操作，并且每次复制的时候，对象都会集中到一起，相当于同时做了整理操作，避免了内存碎片\n\n复制算法 吞吐量高、没有碎片；但 复制操作需要时间成本，若堆空间很大且活动对象很多，每次清理时间会很久。其次，将空间二等分的操作，让可用的内存空间直接减少了一半\n\n\n# 标记整理\n\n也叫做 标记-压缩算法。结合了标记-清除和复制算法的优点\n\n 1. 从一个 GC root 集合出发，标记所有活动对象\n 2. 将所有活动对象移到内存的一端，集中到一起\n 3. 直接清理掉边界以外的内存，释放连续空间\n\n既避免了标记-清除法产生内存碎片的问题，又避免了复制算法导致可用内存空间减少的问题。其清除和整理的操作很麻烦，需要对整个堆做多次搜索，故而堆越大，耗时越多\n\n必须暂停JS脚本执行等待——全停顿，全停顿对性能影响大，所以出现了 增量标记的策略进行老生代垃圾回收\n\n\n# 💛 V8 对GC优化\n\n> 代际假说\n\n * 栈中数据回收：执行状态指针 ESP 在执行栈中移动，移过某执行上下文，被销毁\n * 堆中数据回收：V8 引擎采用标记-清除算法\n * V8 堆分为新生代和老生代 2个区域，分别使用副、主垃圾回收器\n * 副垃圾回收器负责新生代垃圾回收，小对象（1 ～ 8M）被分配到该区域处理\n * 新生代采用 scavenge 算法处理：空间分为一半空闲，一半存对象，对象区域做标记，存活对象复制到空闲区域，没有内存碎片，完成后，清理对象区域，角色反转\n * 新生代区域两次垃圾回收还存活的对象晋升至老生代区域\n * 主垃圾回收器负责老生区垃圾回收，大对象，存活时间长\n * 新生代区域采用标记-清除算法回收垃圾\n * 为了不造成卡顿，标记过程被切分为一个个子标记，交替进行\n\n分代式垃圾回收\n\n以上垃圾清理算法每次都要检查内存中所有对象，对一些大、老、存活时间长的对象来说，同新、小、存活时间短的对象一个频率的检查很不好，因为前者不需要频繁清理，后者相反，如何优化？\n\n\n# 分代式\n\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，此机制的出现很大程度提高了垃圾回收机制的效率\n\n\n# 新老生代\n\nV 8 将堆内存分为新生代和老生代两区域，采用不同的垃圾回收策略\n\n新生代的对象是存活时间较短的对象\n\n老生代的对象为存活时间较长或常驻内存的对象\n\n\n# 新生代\n\n新生代中对象一般存活时间较短，采用 scavenge 算法，主要采用一种复制式的方法\n\n> scavenge 是典型的以时间换空间的算法，新生代大部分对象生命周期较短，时间效率上表现可观，所以 比较适合这种算法\n> \n> scavenge主要采用Cheney算法\n\n新生代空间对半分 from-space 和 to-space 两个区域\n\nfrom空间为激活状态区域\nto空间为 未激活 区域\n\n\n1\n2\n\n\n新创建的对象存放到 from-space，空间快被写满时触发垃圾回收。***先对 from-space 中的对象标记，完成后将标记对象复制到 to-space*** ，非存活对象被回收，copy后，from和to 空间 角色反转，完成回收操作\n\n> 为啥要角色反转？？\n\n因为需要使用 活跃区啊——from\n\nscavenge主要 将存活的对象在from和to空间赋值，完成2个空间的角色互换\n\n缺点——浪费一般内存用于复制\n\n每次执行清理操作都需要复制对象，复制对象需要时间成本，所以新生代空间设置得比较小（1~8M）\n\n当一个对象经过多次复制后依然存活，是生命周期较长的对象，被移动到老生代，采用老生代垃圾回收策略 管理\n\n晋升的条件\n\n * 对象经历过一次scavenge算法\n * to空间内存占比超过25%\n\n复制一个对象到空闲区时，空闲区空间占用超过 25%，这个对象被直接晋升到老生代空间中，设置为 25% 的比例是因为完成 Scavenge 回收后，to区将翻转成from区，继续进行对象内存的分配，占比过大影响后续内存分配\n\n\n# 老生代\n\n老生代管理大量 存活对象，scavenge算法浪费内存\n\n老生代中对象一般存活时间长且数量多，使用 标记清除(Mark-sweep) 和标记压缩(Mark-Compact) 算法\n\n晋升条件：\n\n * 对象是否经历过一次 Scavenge 算法\n * To 空间对象占比大小超过 25 %\n\n首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素为非活动对象\n\n> 具体步骤\n\n * 内部创建根列表，从根节点 出发寻找可被访问的变量，比如window可看成根节点\n * 垃圾回收器从所有根节点出发，遍历可访问的子节点，标记为 活动的；不能到达的 被视为 垃圾\n * 释放所有非活动内存块\n\n1、全局对象2、本地函数局部变量和参数 3、当前嵌套调用链上其他函数的变量和参数 均可被视作 根节点\n\n前面我们也提过，标记清除算法在清除后产生大量不连续内存碎片，过多碎片导致大对象无法分配到足够的连续内存——标记整理算法 解决这一问题\n\n整理过程中，将活动对象往 堆内存 的一端移动，移动完成后再清理掉外边界的全部内存\n\n以下情况先启动标记清除算法：\n\n * 某一个空间没有分块\n * 空间中被对象超过一定限制\n * 空间不能保证新生代中的对象移动到老生代中\n\n> JS 单线程运行，垃圾回收算法和脚本任务在同一线程内运行，执行垃圾回收逻辑时，后续脚本任务需要等垃圾回收完成后才能执行。若堆中数据量非常大，一次完整垃圾回收的时间会非常长，将导致应用的性能和响应能力都下降\n> \n> 为了避免垃圾回收影响性能，V8 将标记的过程拆分成多个子标记，让垃圾回收标记和应用逻辑交替执行(以前是 全停顿，现在改为 增量标记) ，避免脚本任务等太久\n\n增量标记 和Fiber相似，只有空闲时去遍历Fiber Tree执行对应任务\n\n基于增量标记，V8后续引入 延迟清理和增量式整理，充分利用CPU性能\n\n\n# 🔥 内存泄漏\n\n\n# 识别\n\n如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏\n\n这就要求实时查看内存的占用情况\n\n在 Chrome 浏览器中，我们可以这样查看内存占用情况\n\n1.打开开发者工具，选择 Performance 面板\n2.在顶部勾选 Memory\n3.点击左上角的 record 按钮\n4.在页面上进行各种操作，模拟用户的使用情况\n5.一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况\n\n\n1\n2\n3\n4\n5\n\n\n\n# 造成内存泄露\n\n 1. 意外的全局变量\n 2. 被遗忘的定时器和回调函数\n 3. 事件监听没有移除\n 4. 没有清理的DOM 引用\n 5. 闭包\n 6. 控制台打印\n\n\n# 🔥 柯里化\n\n是高阶函数的一种特殊用法\n\n接收函数A作为参数，返回新的函数，这个新的函数能够处理函数A的剩余参数\n\n柯里化函数的运行过程是一个参数的收集过程，我们将每一次传入的参数收集起来，并在最里层里面处理\n\n> 用 闭包 把参数保存起来，当参数的数量足够执行函数了，就开始执行\n\nvar add = function (m) {\n  var temp = function (n) {\n    return add(m + n);\n  }\n  temp.toString = function () {\n    return m;\n  }\n  return temp;\n};\nconsole.log(add(3)(4)(5)); // 12\nconsole.log(add(3)(6)(9)(25)); // 43\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n对于add(3)(4)(5)，其执行过程如下：\n\n 1. 执行add(3)，此时m=3，返回temp函数\n 2. 执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)=add(3+4)=add(7)，此时m=7，返回temp函数\n 3. 执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)=add(7+5)=add(12)，此时m=12，返回temp函数\n 4. 后面没有传入参数，等于返回的temp函数不被执行而是打印，对象的toString修改对象转换字符串，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m=12，所以返回值是12\n\n> fn.length 表示fn函数的参数个数\n\nlet addCurry = curry1((a, b) => a + b);\n\nconsole.log(addCurry()(11)(1));\n\nfunction curry1(fn) {\n    let judge = (...args) => {\n        if (args.length === fn.length) {\n            return fn.call(this, ...args);\n        }\n        //获取偏函数，返回包装器，重新组装参数并传入\n        return (...arg) => judge(...arg, ...args)\n    }\n    return judge;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ✅let var const\n\n在ES5中，顶层对象的属性和全局变量等价，var声明的变量是全局也是顶层变量\n\nvar没有块级作用域，只有函数作用域。var只有在function{ }内部才有作用域的概念，其他地方没有。意味着函数以外用var定义的变量是同一个，我们所有的修改都是针对他的\n\n 1. let和const增加块级作用域（JS没有块级作用域）\n\n 2. let和const存在暂时性死区，不存在变量提升，不能在初始化前引用，调用 返回 uninitialized\n\n 3. let和const禁止重复声明，不能重新声明\n\n 4. let和const不会成为全局对象属性，var声明的变量自动成为全局对象属性\n    \n    var a = 123\n    if (true) {\n        a = 'abc' // ReferenceError\n        let a;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    > const实际保证的并不是变量的值，而是变量指向的内存地址\n\n 5. var 存在变量提升（执行前，编译器对代码预编译，当前作用域的变量/函数提升到作用域顶部），let约束变量提升。let和var都发生了变量提升，只是es6进行了约束，在我们看来，就像let禁止了变量提升\n\n 6. 使用var，我们能对变量多次声明，后面声明的变量会覆盖前面的声明\n\n\n# 作用域\n\n在函数中声明了var，整个函数有效，比如for循环内定义var变量，实际在for循环以外也可以访问\n\nfor循环每次执行都是一个全新独立块作用域，let声明的变量传入for循环体的作用域后，不会发生改变，不受外界影响\n\n常考面试题：\n\nfor (var i = 0; i <10; i++) {  \n  setTimeout(function() {  // 同步注册回调函数到 异步的 宏任务队列\n    console.log(i);        // 执行此代码时，同步代码for循环已经执行完成\n  }, 0);\n}\n// 输出结果\n10   共10个\n// 这里面的知识点： JS的事件循环机制，setTimeout的机制等\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰\nfor (let i = 0; i < 10; i++) { \n  setTimeout(function() {\n    console.log(i);    //  i 是循环体内局部作用域，不受外界影响\n  }, 0);\n}\n// 输出结果：\n0  1  2  3  4  5  6  7  8 9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nlet必须先声明再使用。var先使用后声明也行，只不过直接使用没定义 是undefined。var 变量提升，整个函数作用域被创建时，实际上var定义的变量都会被创建，如果没有初始化，默认undefined\n\nJS只有函数和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围\n\n(function () {\n    var x = y = 1\n})();\nvar z;\nconsole.log(y)\nconsole.log(z)\nconsole.log(x)\n//var x=y=1 等价于 var x=1;y=1 ,y被提升至全局作用域\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 💜 事件流？\n\nJS和HTML的交互 通过 事件 实现，使用侦听器 预定事件，便于事件发生时执行相应代码\n\n手指放在一组同心圆的圆心上，手指指向不是一个圆 ，而是纸上的所有圆，单击按钮时 单击事件不止发生在按钮上，同时 也单击了按钮的容器元素，甚至也单击了整个页面\n\n事件流描述 从页面接收事件的顺序\n\n事件发生时会在元素节点和根节点之间按照特定的顺序传播，路径所经过的节点都会收到该事件——DOM事件流\n\n 1. 捕获：不太具体的节点应该更早接收到事件，而最具体的节点最后收到事件。目的是在事件到达预定目标之前捕获它\n\n 2. 冒泡：事件开始由最具体的元素接收，逐级向上传播到不具体的节点，document对象首先收到click事件，事件沿着DOM树依次往下，传播到事件的具体目标\n\n 3. DOM标准规定事件流包括3个阶段：事件捕获、处于目标阶段和事件冒泡\n\n * 事件捕获——为截获事件提供机会\n * 处于目标阶：事件在div上发生并处理\n * 冒泡阶段：事件又传播回文档\n\n\n\n所有事件都要经过捕获阶段和处于目标阶段\n\n**focus(获得输入焦点)和失去焦点blur事件没有冒泡，**无法委托\n\n\n# 原始事件模型\n\n<input type=\"button\" onclick=\"fun()\">\nvar btn = document.getElementById('.btn');\nbtn.onclick = fun;\n\n\n1\n2\n3\n\n * 绑定速度快\n\n页面还未完全加载，事件可能无法正常运行\n\n * 只支持冒泡，不支持捕获\n * 同一个类型的事件只能绑定一次\n\n<input type=\"button\" id=\"btn\" onclick=\"fun1()\">\n\nvar btn = document.getElementById('.btn');\nbtn.onclick = fun2;\n//出错 后绑定的事件会覆盖掉之前的事件\n\n\n1\n2\n3\n4\n5\n\n\n删除事件处理程序 将对应事件属性置为null\n\nbtn.onclick = null;\n\n\n1\n\n\n\n# 标准事件模型\n\n * 事件捕获：从document一直向下传播到目标元素， 依次检查经过节点是否绑定了事件监听函数，有则执行\n * 事件处理：到达目标元素， 触发目标元素的监听函数\n * 事件冒泡：从目标元素冒泡到document， 依次检查经过节点是否绑定了事件监听函数，如果有则执行\n\n事件绑定监听函数\n\naddEventListener(eventType, handler, useCapture)\n\n\n1\n\n\n事件移除监听函数\n\nremoveEventListener(eventType, handler, useCapture)\n\n\n1\n\n * eventType事件类型(不要加on)\n * handler事件处理函数\n * useCapture，是否在捕获阶段处理，默认false\n\n举个例子：\n\n    var btn = document.getElementById('.btn');\n    btn.addEventListener('click', showMessage, false);\n    btn.removeEventListener('click', showMessage, false);\n\n\n1\n2\n3\n\n\n> 一个DOM上绑定多个事件处理器，不会冲突\n\nbtn.addEventListener(‘click’, showMessage1, false);\nbtn.addEventListener(‘click’, showMessage2, false);\nbtn.addEventListener(‘click’, showMessage3, false);\n\n\n1\n2\n3\n\n\n第三个参数(useCapture)为true在捕获过程执行，反之在冒泡过程执行\n\n\n# IE事件模型\n\n因为IE8及更早版本只支持事件冒泡，因此通过attachEvent添加的事件都会被添加到冒泡阶段\n\n * 事件处理：事件到达目标元素， 触发目标元素的监听函数\n\n * 事件冒泡：事件从目标元素冒泡到document\n\n * 事件绑定监听函数的方式\n   \n   attachEvent(eventType, handler)\n   \n   \n   1\n   \n   \n   事件移除监听函数的方式\n   \n   detachEvent(eventType, handler)\n   \n   \n   1\n   \n   \n   举个例子：\n   \n   var btn = document.getElementById('.btn');\n   btn.attachEvent(‘onclick’, showMessage);\n   btn.detachEvent(‘onclick’, showMessage);\n   \n   \n   1\n   2\n   3\n   \n\n\n# 事件代理\n\n\n# 原理\n\n事件委托，把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，不是目标元素\n\n只指定一个事件处理程序，管理某一类型 所有事件\n\n把一个元素响应事件（click、keydown......）的函数委托到另一个元素，冒泡阶段完成\n\n对“事件处理程序过多”问题的解决方案就是事件委托\n\n使用事件委托，只需在DOM树中尽量高的一层添加一个事件处理程序\n\n> 举例\n\n代 取快递\n\n优点\n\n * 节省内存，减少dom操作\n * 不需要给子节点注销事件\n * 动态绑定事件\n * 提高性能\n * 新添加的元素还会有之前的事件\n\n> 为啥用\n\n**事件冒泡过程中上传到父节点，**父节点通过事件对象获取到目标节点，把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理子元素的事件\n\n比如100个li，每个都有click，如果使用for遍历 添加事件，关系页面整体性能，需要不断交互 访问dom次数过多，引起重排，延长交互时间\n\n事件委托的话，将操作放进JS，只需要和dom交互一次，提高性能，还节约内存\n\n\n# 实现\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<ul id=\"ul1\">\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n    <li>444</li>\n</ul>\n<script>\n    /* window.onload = function () {\n         var oUl = document.getElementById(\"ul1\");\n         var aLi = oUl.getElementsByTagName('li');\n         for (var i = 0; i < aLi.length; i++) {\n             aLi[i].onclick = function () {\n                 alert(123);\n             }\n         }\n     }*/\n    window.onload = function () {\n        var oUl = document.getElementById(\"ul1\");\n        oUl.onclick = function () {\n            alert(123);\n        }\n    }\n<\/script>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nEvent对象提供属性target，返回事件的目标节点——事件源\n\ntarget表示当前事件操作的dom，但不是真正操作dom\n\n通过target.id获得操作的具体dom\n\n新增的节点怎么办，即 新来员工的快递咋整？\n\n事件委托也能解决\n\n> (鼠标事件、键盘事件和点击事件)支持冒泡\n> \n> 聚焦、失焦、UI、鼠标移入移除事件不支持冒泡\n\n * 适合事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress\n * mouseover 和 mouseout 也有事件冒泡，但需要经常计算它们的位置，处理不太容易\n * 不适合的，mousemove，每次都要计算它的位置，不好把控， focus，blur 等本身就没有冒泡的特性，自然就不用事件委托\n\n\n# 阻止冒泡\n\n * 阻止冒泡：非 IE stopPropagation()，IE 则event.cancelBubble = true\n * 阻止默认行为：非 IE preventDefault()，IE则event.returnValue = false\n\n\n# e.target、e.currentTarget\n\n * e.target：触发事件的元素，是点击的元素\n * e.currentTarget：绑定事件的元素，是途径的元素，执行捕获的顺序\n\nMDN Event\n\n> event还有哪些属性？\n\nevent.bubbles 返回 布尔值，表明当前事件是否会向 DOM 树上层元素冒泡\n\nevent.defaultPrevented 返回 布尔值，表明当前事件是否调用了 event.preventDefault()\n\n\n# addEventListener、onClick()\n\naddEventListener为元素绑定事件，接收三个参数：\n\n * 第一个参数：绑定的事件名\n\n * 第二个参数：执行的函数\n\n * 第三个参数：\n   \n   * false：默认，代表冒泡时绑定\n   * true：代表捕获时绑定\n\n> onclick和addEventListener\n\nonclick事件会被覆盖，同一个元素只能绑定一个事件\n\naddEventListener可先后运行不会被覆盖，可监听多个事件，执行顺序从上到下依次执行\n\naddEventListener对任何DOM元素有效\n\n注册addEventListener不需写on，onClick需要加on\n\n移除事件，onClick使用指针指向null，document.onClick=null，addEventListener使用独有移除方法removeListener\n\naddEventListener为DOM2级事件绑定，onclick为DOM0级事件绑定\n\n不适用内联onClick作为HTML属性，混淆JS和HTML，降低维护性\n\n\n# 事件劫持？\n\n\n# 🌰 JSON.stringify()\n\n序列化，忽略值为undefined的字段\n\n若某个字段为undefined，将其修改为空串\n\n1、若目标对象存在toJSON()方法，它负责定义哪些数据被序列化\n\nlet obj={\n    x:1,\n    y:2,\n    toJSON:function(){\n        return 'a string create by toJSON'\n    }\n}\nconsole.log(JSON.stringify(obj));\n//'a string create by toJSON'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2、Boolean、Number、String对象被装换为对应原始值\n\nconst obj={\n    a:new Number(11),\n    b:new String('aaa'),\n    c:new Boolean(true)\n}\nconsole.log(JSON.stringify(obj));\n//{\"a\":11,\"b\":\"aaa\",\"c\":true}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n3、undefined、Function和Symbol不是有效的JSON值，要么被忽略(在对象中找着)，要么被更改为null(在数组中找着)\n\nconst obj={\n    name:Symbol('aaa'),\n    age:undefined,\n    isHigh:function(){}\n}\nconsole.log(JSON.stringify(obj));\n//{}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    const arr=[Symbol('aaa'),undefined,function(){},'fighting'];\n    console.log(JSON.stringify(arr));\n//[null,null,null,\"fighting\"]\n\n\n1\n2\n3\n\n\n4、所有Symbol-keyed属性被忽略\n\nconst obj={\n    \n}\nobj[Symbol('a')]='aa';\nobj[Symbol('b')]='bb';\nconsole.log(obj);\nconsole.log(JSON.stringify(obj));\n//{Symbol(a): 'aa', Symbol(b): 'bb'}\n//{}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n5、Date的实例返回一个字符串实现toJSON()方法(和date.toISOString()——使用 ISO 标准返回 Date 对象的字符串格式相同)\n\nJSON.stringify(new Date());\n//'\"2022-06-16T23:36:38.943Z\"'\n\n\n1\n2\n\n\n6、Infinity、NaN和null都被认为是null\n\nconst obj={\n    a:Infinity,\n    b:NaN,\n    c:null,\n    val:20\n};\nconsole.log(JSON.stringify(obj));\n//{\"a\":null,\"b\":null,\"c\":null,\"val\":20}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n7、所有其他Object实例(包括Map、Weakmap、Set和WeakSet)序列化为其可枚举的属性\n\nlet enumObj={};\n//直接在一个对象上定义新的属性或修改现有属性，并返回该对象\nObject.defineProperties(enumObj,{\n    'name':{\n        value:'a',\n        enumerable:true\n    },\n    'age':{\n        value:99,\n        enumerable:false\n    },\n});\nconsole.log(JSON.stringify(enumObj));\n//{\"name\":\"a\"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n8、遇到循环抛出TypeError(循环对象值)异常\n\nconst obj={\n    a:'aa'\n};\nobj.subObj=obj;\nconsole.log(JSON.stringify(obj));\n//VM357:5 Uncaught TypeError: Converting circular structure to JSON\n\n\n1\n2\n3\n4\n5\n6\n\n\n9、对BigInt值字符串化时抛出TypeError(BigInt值无法在JSON中序列化)\n\nconst obj={\n    a:BigInt(999999999999999999999)\n};\nconsole.log(JSON.stringify(obj));\n//VM362:4 Uncaught TypeError: Do not know how to serialize a BigInt\n\n\n1\n2\n3\n4\n5\n\n\n\n# Promise\n\n简单说就是一个容器，保存某个未来才会结束的事件的结果。语法上Promise 是对象，可以获取异步操作的消息。Promise 提供统一 API，各种异步操作都可以用同样方法处理，让开发者不用关注时序和底层结果。Promise的状态不受外界影响，不可逆\n\n是异步编程的一种解决方案，更合理 强大\n\n> 出现的原因\n\n基于回调的异步风格——异步执行某项功能的函数提供一个callback在相应事件完成时调用\n\n**回调中回调！**单一的callback处理error报告和传递返回结果\n\n可行的异步编程方式？？对1/2个嵌套调用看起来不错\n\nbut，一个接一个的异步行为……\n\n调用嵌套增加，代码层次更深，维护难度大，尤其是 很多循环和条件语句的代码……——回调地狱/厄运金字塔\n\n造成 代码失控！！\n\n> Promise\n\n链式调用\n\n * 链式写法\n * 改善可读性\n * 多层嵌套更友好\n\nPromise 是对象也是构造函数，接收一个函数作为参数，该函数的2个参数分别是resolve reject\n\n所有异步任务都返回promise实例，promise有一个then方法，指定下一步回调\n\n成功则调用resolve，失败调用reject\n\n由new Promise返回的Promise的内部属性\n\n * state：pending、fulfilled、rejected\n * result：undefined——value/error\n\nPromise——承诺，一旦承诺 便不可更改\n\nPromise.reject(2)\n    //.catch(err=>console.log(\"err1,\",err))\n    .then(null,err=>console.log(\"err1,\",err)) //rejected状态，执行then的第二个callback，改变状态为fulfilled\n\n    .then(res=>{console.log(\"then1\",res)},null)//fulfilled，执行第一个回调,不会去到下一步catch\n    \n    .then(res=>console.log('end'),err=>console.log(\"err2,\",err))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> .then\n\n可将多个.then添加到一个Promise上，但不是一个promise链\n\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000);\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\npromise的几个处理程序，彼此 独立运行！！\n\n\n\nPromise的错误“冒泡”会一直向后传递，直到被捕获\n\n每个Promise都会经历生命周期：\n\n * 进行中（pending）代码执行尚未结束，也叫未处理的（unsettled）\n * 已处理（settled） 代码执行结束 已处理的代码进入两种状态中的一种：\n\n已完成（fulfilled）代码执行成功，resolve()触发\n\n已拒绝（rejected）遇到错误，代码执行失败 ，reject()触发\n\n// 如果触发reject()，但是没有 捕获 reject的结果，代码抛出异常并停止执行\nasync function async1() {\n    await async2();\n    console.log('async1');\n    return 'async1 success'\n}\nasync function async2() {\n    return new Promise((resolve, reject) => {\n        console.log('async2')\n        reject('error')\n    })\n        // .then(res => {console.log(res)}, res => console.log((res)))\n}\nasync1().then(res => console.log(res))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 实例方法\n\n * then()\n\n.then(handler)中的handler 创建返回 新的Promise，确切说 返回不完全是promise，而是 对象\"thenable\"——具有方法.then的对象，被当做promise\n\n所以，then会修改Promise状态吗？\n\nrejected——>fulfilled？？？？\n\n * catch()\n\n建议使用catch()，而不是then()的第二个参数\n\n * finally\n\n返回 Promise 。 promise 结束时，无论结果 fulfilled / rejected，都会执行指定回调\n\n\n# 构造函数方法\n\n\n# all()\n\n将多个 Promise 实例，包装成一个新的 Promise 实例\n\n接收一个数组(可迭代对象)作为参数，数组成员都应为Promise实例\n\n提供并行执行异步操作的能力\n\nconst p = Promise.all([p1, p2, p3]);\n\n\n1\n\n * 只有状态都变成fulfilled，p才会变成fulfilled，此时p1 p2 p3的返回值组成一个数组，传递给回调\n * 只要有一个被rejected，p就变成rejected，此时第一个被reject的实例返回值传递给回调\n\n若Promise参数实例自己定义catch()，它被rejected不会触发Promise.all()的catch()\n\n因此可在单个catch中对失败promise请求做处理，使请求正常返回\n\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", Error: 报错了]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n若p2没有自己的catch()，就调用Promise.all()的catch()\n\nconst p1 = new Promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new Promise((resolve, reject) => {\n  throw new Error('报错了');\n})\n.then(result => result);\n\nPromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// Error: 报错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n出现错误后不进行reject，继续resolve(error)，交给promise.all()处理\n\n> promise 数组顺序直接影响结果顺序，和 promise 执行完成先后无关\n\n快速失败——如果数组至少一个被 rejected ，那返回的 promise 也被拒绝。如果数组中所有都被 rejected ，那返回的promise 被拒绝的原因是先rejected的那一个\n\nPromise.all()是并行执行异步操作获取所有 resolve 值的最佳方法，适合需要同时获取异步操作结果进行下一步运算场合\n\n\n# allSettled\n\n数组作为参数，每个成员都是 Promise 对象，返回新的 Promise 实例\n\n只有等到数组的所有 Promise 都状态变更（不管是fulfilled/rejected） 返回的 Promise 才状态变更，带有对象数组，每个对象表示对应promise结果\n\n当有多个彼此不依赖的异步任务完成时，或想知道每个promise的结果时，可以使用\n\n相比，all更适合彼此依赖或其中任何一个reject时马上结束\n\nvar promise1 = new Promise(function(resolve,reject){\n  setTimeout(function(){\n    reject('promise1')\n  },2000)\n})\n            \nvar promise2 = new Promise(function(resolve,reject){\n  setTimeout(function(){\n    resolve('promise2')\n  },3000)\n})\n \nvar promise3 = Promise.resolve('promise3')\n \nvar promise4 = Promise.reject('promise4')\n \nPromise.allSettled([promise1,promise2,promise3,promise4]).then(function(args){\n  console.log(args);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# any\n\n一个成功就成功，所有失败才失败！\n\n接受一组 Promise 可迭代实例作为参数，返回一个新的 Promise\n\n只要参数实例有一个fulfilled，包装实例变成fulfilled；如果所有参数实例都rejected，包装实例变成rejected\n\nPromise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变状态才结束\n\n\n# race\n\n简言之，看谁跑得快呗，注重时序\n\n和all一样，但是 返回执行最快的Promise的结果\n\n将多个 Promise 实例，包装成一个新的 Promise 实例 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变 率先改变的 Promise 实例返回值 传递给p的回调\n\nconst p = Promise.race([p1, p2, p3]);\n\n\n1\n\n\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * resolve()\n * reject()\n\n\n# 场景\n\n * Ajax请求\n * 文件读取\n * 图片加载\n * 函数封装\n\n\n# 实现Promise\n\n\n# 实现Promise.then()\n\n\n# 栗子\n\nJS不会允许看不到尽头的微任务一直待在队列，以下代码执行可能差强人意\n\nPromise.resolve().then(() => {\n    console.log(0);\n    return Promise.resolve(4);\n}).then((res) => {\n    console.log(res)\n})\n\nPromise.resolve().then(() => {\n    console.log(1);\n}).then(() => {\n    console.log(2);\n}).then(() => {\n    console.log(3);\n}).then(() => {\n    console.log(5);\n}).then(() =>{\n    console.log(6);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n因为promise1处于pending状态，所以promise1.then()的回调函数还不会加入到微任务队列中\n\ntimer2是一个延时2s的计时器，1s后，timer1完成，promise1状态变化，又过了1s，timer2完成，执行回调函数\n\nconst promise1 = new Promise((resolve, reject) => {\n  const timer1 = setTimeout(() => {\n    resolve('success')\n  }, 1000)\n})\nconst promise2 = promise1.then(() => {\n  throw new Error('error!!!')\n})\n\nconsole.log('promise1', promise1)\nconsole.log('promise2', promise2)\n\nconst timer2 = setTimeout(() => {\n  console.log('promise1', promise1);\n  console.log('promise2', promise2);\n}, 2000)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nresolve会马上执行，a=2，就resolve了，实际上a的循环会走完 变成1002\n\nvar a = 1;\nsetTimeout(function () {\n    console.log(a++)\n}, 0)\nnew Promise(function executor(resolve) {\n    console.log(a++)\n    for (var i = 0; i < 1000; i++) {\n        resolve(a++)\n    }\n    console.log(a++)\n}).then(function (a) {\n    console.log(a++)\n})\nconsole.log(a++)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 🌰 异步解决方案\n\n同步操作：顺序执行，同一时间只能做一件事情。会阻塞后面代码的执行\n\n异步：当前代码的执行作为任务放进任务队列。当程序执行到异步的代码时，将该异步的代码作为任务放进任务队列，而不是推入主线程的调用栈。等主线程执行完之后，再去任务队列里执行对应的任务。不会阻塞后续代码的运行\n\n\n# 异步场景?\n\n * 定时任务：setTimeout、setInterval\n * 网络请求：ajax请求、动态创建img标签的加载\n * 事件监听器：addEventListener\n\n\n# 回调\n\n回调函数就是我们请求成功后需要执行的函数\n\n实现了异步，但是带来一个非常严重的问题——回调地狱，即 我们表达异步操作的执行顺序的唯一方法是 将一个回调嵌套在另一个回调中\n\n\n# 发布/订阅\n\nNode.js EventEmitter 中的 on 和 emit\n\n当一个对象的状态改变时，所有依赖于它的对象都得到状态改变的通知\n\n比如公众号推送\n\n> 手写 发布-订阅模式\n\n * 创建对象\n * 创建缓存列表\n * on 将handler 加到缓存列表中(订阅者注册事件)\n * emit 根据event值执行函数\n * off根据event取消订阅\n * once监听一次，调用完毕后删除\n\nlet eventEmitter = {\n    // 缓存列表\n    list: {},\n    on(event, fn) {\n        let _this = this;\n        // 如果对象中没有对应的 event 值，也就是说明没有订阅过，就给 event 创建个缓存列表\n        // 如有对象中有相应的 event 值，把 fn 添加到对应 event 的缓存列表里\n        (_this.list[event] || (_this.list[event] = [])).push(fn);\n        return _this;\n    },\n    once(event, fn) {\n        // 先绑定，调用后删除\n        let _this = this;\n        function on() {\n            _this.off(event, on);\n            fn.apply(_this, arguments);\n        }\n        on.fn = fn;\n        _this.on(event, on);\n        return _this;\n    },\n    off(event, fn) {\n        let _this = this;\n        let fns = _this.list[event];\n        // 如果缓存列表中没有相应的 fn，返回false\n        if (!fns) return false;\n        if (!fn) {\n            // 如果没有传 fn 的话，就会将 event 值对应缓存列表中的 fn 都清空\n            fns && (fns.length = 0);\n        } else {\n            // 若有 fn，遍历缓存列表，看看传入的 fn 与哪个函数相同，如果相同就直接从缓存列表中删掉即可\n            let cb;\n            for (let i = 0, cbLen = fns.length; i < cbLen; i++) {\n                cb = fns[i];\n                if (cb === fn || cb.fn === fn) {\n                    fns.splice(i, 1);\n                    break\n                }\n            }\n        }\n        return _this;\n    },\n    emit() {\n        let _this = this;\n        // 第一个参数是对应的 event 值，直接用数组的 shift 方法取出\n        let event = [].shift.call(arguments),\n            fns = [..._this.list[event]];\n        // 如果缓存列表里没有 fn 就返回 false\n        if (!fns || fns.length === 0) {\n            return false;\n        }\n        // 遍历 event 值对应的缓存列表，依次执行 fn\n        fns.forEach(fn => {\n            fn.apply(_this, arguments);\n        });\n        return _this;\n    }\n};\nfunction user1(content) {\n    console.log('用户1订阅了:', content);\n}\nfunction user2(content) {\n    console.log('用户2订阅了:', content);\n}\nfunction user3(content) {\n    console.log('用户3订阅了:', content);\n}\nfunction user4(content) {\n    console.log('用户4订阅了:', content);\n}\n\n// 订阅\neventEmitter.on('article1', user1);\neventEmitter.on('article1', user2);\neventEmitter.on('article1', user3);\n\n// 取消user2方法的订阅\neventEmitter.off('article1', user2);\n\neventEmitter.once('article2', user4)\n\n// 发布\neventEmitter.emit('article1', 'Javascript 发布-订阅模式');\neventEmitter.emit('article1', 'Javascript 发布-订阅模式');\neventEmitter.emit('article2', 'Javascript 观察者模式');\neventEmitter.emit('article2', 'Javascript 观察者模式');\n\neventEmitter.on('article1', user3).emit('article1', 'test111');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\nclass myEventEmitter {\n  constructor() {\n    this.eventMap = {};  // 存储事件和监听函数之间的关系\n  }\n  \n  // type:事件名称; handler:事件处理函数\n  on(type, handler) {\n    // hanlder 必须是一个函数\n    if (!(handler instanceof Function)) {\n      throw new Error(\"hanler必须是函数\");\n    }\n    // 判断 type 事件对应的队列是否存在\n    if (!this.eventMap[type]) {\n      // 若不存在，新建该队列\n      this.eventMap[type] = [];\n    }\n    // 若存在，直接往队列里推入 handler\n    this.eventMap[type].push(handler);\n  }\n  \n  // type:事件名称; params:支持传参\n  emit(type, params) {\n    // 假设该事件是有订阅的（对应的事件队列存在）\n    if (this.eventMap[type]) {\n      // 将事件队列里的 handler 依次执行出队\n      this.eventMap[type].forEach((handler, index) => {\n        handler(params); // 别忘了读取 params\n      });\n    }\n  }\n  \n  off(type, handler) {\n    if (this.eventMap[type]) {\n      this.eventMap[type].splice(this.eventMap[type].indexOf(handler) >>> 0, 1);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# Promise\n\n\n# 事件循环\n\n\n# Generator\n\n\n# iterator\n\nES6推出，方便创建iterator，Generator是一个返回``iterator`对象的函数\n\n> iterator——迭代器\n> \n> 为各种数据结构(Array、Set、Map)提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作\n\n作用：\n\n * 使得数据结构的成员能够按某种次序排列\n * ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of\n\niterator的结构： 有next方法，该方法返回一个包含value和done两个属性的对象（我们假设叫result）\n\nvalue是迭代的值，后者是表明迭代是否完成的标志\n\niterator内部有指向迭代位置的指针，每次调用next，自动移动指针并返回相应的result\n\n原生具备iterator接口的数据结构如下：\n\n * Array\n * Map\n * Set\n * String\n * TypedArray\n * 函数里的arguments对象\n * NodeList对象\n\n这些数据结构都有一个Symbol.iterator属性，可以直接通过这个属性创建迭代器\n\nlet arr = ['a','b','c'];\n\nlet iter = arr[Symbol.iterator]();\n\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor ... of首先调用被遍历集合对象的 Symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象是可以拥有.next()方法的任何对象，每次循环，调用该迭代器对象上的 .next 方法\n\n对于不具备iterator接口的数据结构，比如Object，我们可以采用自定义的方式来创建一个遍历器\n\n\n# Generator\n\nfunction* createIterator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\n//generators像正常函数一样被调用，返回iterator\nlet iterator = createIterator();\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\nconsole.log(iterator.next().value); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nGenerator 是一个普通函数，两个特征:\n\n * function关键字与函数名之间有一个星号\n * 函数体内部使用yield语句，定义不同的内部状态\n\nGenerator函数的调用方法与普通函数一样，在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象——遍历器对象（Iterator Object）\n\nfunction* generator(){\n    yield 1;\n}\nconsole.dir(generator);\n\n\n1\n2\n3\n4\n\n\ngenerator函数的返回值的原型链上有iterator对象该有的next，说明generator的返回值是一个iterator。除此之外还有函数该有的return方法和throw方法。\n\ngenerator和普通的函数完全不同。当以function*的方式声明一个Generator生成器时，内部可以有许多状态，以yield进行断点间隔。期间我们执行调用这个生成的Generator，他返回一个遍历器对象，用这个对象上的方法，实现获得yield后面输出的结果\n\nyield和return的区别\n\n * 都能返回紧跟在语句后面的那个表达式的值\n * yield更像是一个断点。遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能\n * 一个函数里面，只能执行一个return语句，但可以执行多次yield表达式\n * 正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield\n\n语法注意点：\n\n * yield表达式只能用在 Generator 函数里面\n * yield表达式如果用在另一个表达式之中，必须放在圆括号里面\n * yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号\n * 如果 return 语句后面还有 yield 表达式，后面的 yield 完全不生效\n\n使用Generator的其余注意事项：\n\n * yield 不能跨函数，需要和*配套使用，别处使用无效\n\nfunction* createIterator(items) {\n  items.forEach(function (item) {\n    // 语法错误\n    yield item + 1;\n  });\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 箭头函数不能用做 generator\n\nGenerator到底有什么用呢？\n\n * Generator可以在执行过程中多次返回，它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator可以实现需要用面向对象才能实现的功能\n * Generator还有另一个巨大的好处——把异步回调代码变成“同步”代码\n\n> 原理\n\n采用 编译 转换思路，运用 状态机 模型，同时 利用闭包保存 函数上下文信息，最终实现新的语言特性\n\n\n# async/await\n\nJS单线程语言，异步防止用户界面被阻塞\n\n> 特点\n\n * 异步变成同步，代码更具 表现力和可读性\n * 统一异步编程；提供更好的错误堆栈跟踪\n\nES7提出的关于异步的终极解决方案\n\n * 一说async/await是Generator的语法糖\n * 二 说async/await是Promise的语法糖\n\n> async/await是Generator的语法糖：\n\nGenerator语法糖，表明 aysnc/await实现的就是generator实现的功能。但async/await比generator要好用。因为generator执行yield设下的断点就是不断调用iterator方法，这是个手动调用的过程。针对generator的这个缺点，后面提出了co这个库函数自动执行next，相比之前的方案，这种方式有了进步，但是仍然麻烦。async配合await得到的就是断点执行后的结果。async/await比generator使用更普遍\n\nasync函数对 Generator函数的改进，主要体现\n\n * 内置执行器：Generator函数的执行必须靠执行器，不能一次执行完成，所以之后才有了开源的 co函数库。但async和正常的函数一样执行，不用 co函数库，不用 next方法，async函数自带执行器，自动执行\n * 适用性更好：co函数库有条件约束，yield命令后面只能是 Thunk函数或 Promise对象，但async函数的 await关键词后面，不受约束\n * 可读性更好：async和 await，比起使用 *号和 yield，语义清晰明了\n\n> async/await是Promise的语法糖：\n\n如果不使用async/await的话，Promise需要通过链式调用执行then之后的代码\n\nPromise搭配async/await的使用才是正解！\n\nasync/await基于Promise。async把promise包装了一下，async函数更简洁，不需要像promise一样需要写then，不需要写匿名函数处理promise的resolve值，也不需要定义多余的data，避免嵌套代码\n\nasync是Generator函数的语法糖，async函数返回值promise对象，比generator函数返回值 iterator对象更方便，可使用 await 代替then 指定下一步操作(await==promise.then)\n\nfunction f() {\n    return Promise.resolve('TEST');\n}\n\n// asyncF is equivalent to f!\nasync function asyncF() {\n    return 'TEST';\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> async方法执行时，遇到await会立即执行，然后把表达式后面的代码放到微任务队列，让出执行栈让同步代码先执行\n\nconst one=()=>Promise.resolve('one');\nasync function myFunc(){\n    console.log('in function');\n    const res=await one();\n    console.log(res);\n}\n\nconsole.log('before function');\nmyFunc();\nconsole.log('after function');\n\n//before fucntion\n//in function\n//after funciton\n//one\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 定时器原理\n\n * var id=setTimeout(fn,delay); 初始化一个只执行一次的定时器，这个定时器会在指定的时间延迟 delay 之后调用函数 fn ，该 setTimeout 函数返回定时器的唯一 id ，可以通过这个 id 取消定时器的执行\n * var id=setInvertal(fn,delay); 与 setTimeout 类似，它会以 delay 为周期，反复调用函数 fn ，直到我们通过id取消该定时器\n * clearInterval(id),clearTimeout(id); 这两个函数接受定时器的 id，并停止对定时器中指定函数的调用\n\n> 定时器指定的延迟时间不能得到保证\n\n所有的JS代码都运行在单一线程中，异步事件只有在被触发时，其回调才会执行\n\n这个图是一维的，垂直方向是时间，以毫秒为单位。蓝色的盒子代表正在执行的JS代码所占时间片段\n\n因为单线程在同一时间只能执行一条 代码，每一个代码块（蓝色盒子）都会阻塞其他异步事件的执行\n\n这就意味着，当一个异步事件发生时（例如鼠标点击，定时器触发，一个 XMLHttpRequest 请求完成），它进入了代码的执行队列，执行线程空闲时会依照该执行队列中顺序依次执行代码\n\n总结：\n\n * JS 引擎是单线程的，会迫使异步事件进入执行队列，等待执行\n * setTimeout 和 setInterval 在执行异步代码时从根本上有所不同\n * 如果一个定时器事件被阻塞，使得它不能立即执行，它会被延迟，直到下一个可能的时间点，才被执行（可能比指定的 delay 时间要长）\n * Interval 回调有可能‘背靠背’无间隔执行，interval的回调函数的执行时间比指定的 delay 时间还要长\n\nJS中定时器的工作原理\n\n\n# 💙 原型\n\n\n# 原型\n\n每个实例对象有有私有属性（proto）指向它构造函数的原型对象。该原型对象有自己的原型对象（proto）,层层向上直到对象的原型为null。null没有原型，作为原型链终点\n\n> 实例是类的具象化产品\n> \n> 对象是一个具有多种属性的内容结构\n> \n> 实例都是对象，对象不一定是实例（Object.prototype是对象但不是实例），构造函数也是对象\n> \n> prototype是构造函数的属性\n> \n> __proto__是对象的属性\n\n试图访问对象属性时，它不仅在该对象搜寻，还会搜寻该对象原型，以及该对象的原型的原型，层层向上搜索，直到找到名字匹配的属性或到达原型链的末尾\n\n每个对象都有__proto__属性，指向它的prototype原型对象\n\n每个构造函数都有prototype原型对象\n\nprototype原型对象的constructor指向构造函数本身\n\n有默认constructor属性，记录实例由哪个构造函数创建\n\n\n\n对象都具有的属性，叫_proto_，指向该对象的原型，原型有两个属性，constructor和proto\n\n\n\n实例对象和构造函数都可以指向原型，原型有属性指向构造函数或实例吗?\n\nproto与其说是一个属性，不如说是个getter/setter，使用obj._proto_时，可理解为返回Object.getPrototypeOf(obj)\n\n原型都有constructor属性指向关联的构造函数\n\n\n\nfunction Person() {\n\n}\n\nvar person = new Person();\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true 原型对象的constructor指向构造函数本身\n// 顺便学习一个ES5的方法,可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n\nconsole.log(Object.getPrototypeOf(person))\nperson.__proto__\nPerson.prototype//constructor\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n读取实例属性时，若找不到，会查找与对象关联原型中的属性，若还查不到，就去找原型的原型，一直找到最顶层为止\n\n实例的proto指向构造函数的prototype\n\n\n\n\n# 原型链\n\n每个构造函数都有原型对象（prototype），原型上有属性（constructor）指回构造函数，实例有内部指针指向原型。原型本身也有内部指针指向另一个原型，相应的这个另一个原型也会有个属性指向另一个构造函数，在实例与原型之间形成链式关系\n\nfoo.__proto__ => Function.prototype => Function.prototype.__proto__ => Object.prototype => Object.prototype.__proto__ => null\n\n\n1\n\n\nconsole.log(Object.prototype.__proto__ === null) // true\n\n\n1\n\n\n意思就是Object.prototype没得原型\n\n\n\n> 图中由相互关联的原型组成的练状结构就是原型链(蓝色线)\n\n\n# 创建没有原型的对象\n\nlet obj=Object.create(null)\nobj.name='merry'\nconsole.log(obj)\n\n\n1\n2\n3\n\n\n参考文档https://zh.javascript.info/prototype-methods\n\n\n# proto、prototype\n\n\n\nprototype是原型对象\n\n__ proto __ 将对象和该对象的原型相连\n\n特殊的 Function 对象，Function 的 __proto__ 指向自身的 prototype\n\n构造函数 prototype 的 __proto__ 指向构造函数的构造函数的 prototype\n\n> 构造函数是一个函数对象，通过Function构造器产生\n> \n> 原型对象本身是一个普通对象，普通对象的构造函数是Object\n\n\n\n> 除了Object的原型对象（Object.prototype）的__proto__指向null，其他内置函数对象的原型对象（例如：Array.prototype）和自定义构造函数的 __proto__都指向Object.prototype， 因为原型对象本身是普通对象\n\nObject.prototype.__proto__ = null;\nArray.prototype.__proto__ = Object.prototype;\nFoo.prototype.__proto__  = Object.prototype;\n\n\n1\n2\n3\n\n * 一切对象都继承Object对象，Object 对象直接继承根源对象null\n * 一切函数对象（包括 Object 对象），都继承自 Function 对象\n * Object 对象直接继承自 Function 对象\n * Function对象的__proto__指向自己的原型对象，最终还是继承自Object对象\n\n\n# 原型、原型链\n\n\n\n需要new关键字，成为“构造器constructor或构造函数”\n\n通过prototype定义的属性，再被多个实例化后，引用地址是同一个\n\n继承链 从祖父——到爷爷——到爸爸——到自己\n\n * constructor指向构造函数，每个对象的__proto__指向创建它的构造函数的prototype，构造函数的prototype也有__proto__，指向他的父辈或者是Object，当查找一个对象中不存在的属性时，会去它的__proto__、__proto__中的__proto__中寻找，直到找到或是null为止\n * instanceof判断对象的__proto__和构造函数的prototype是不是同一个地址\n * Object.setPrototypeOf改变对象的__proto__\n\n原型(prototype)：一个对象，实现对象的属性继承，简单理解为对象的爹\n\nprototype可通过Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器访问\n\n当继承的函数被调用时，this 指向当前继承的对象，而不是继承的函数所在原型对象\n\n不是所有对象都有原型\n\nclass A{}\nclass B extends A{}\nconst a = new A()\nconst b = new B()\na.__proto__\nb.__proto__\nB. __proto__\nB. prototype.__proto__\nb.__proto__.__proto__\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Object是Function实例，那Function是谁的实例\n\nFunction.__proto__=== Function.prototype;\n//true\n\n\n1\n2\n\n\nFunction构造函数的prototype和__proto__属性指向同一个原型，说明Function对象是Function构造函数创建的一个实例？\n\nYes and No\n\n> Yes ：\n\n按照JS中“实例”定义，a 是 b 的实例即 a instanceof b 为 true，默认是 b.prototype 在 a 的原型链上。而 Function instanceof Function 为 true，本质上即 Object.getPrototypeOf(Function) === Function.prototype，符合定义\n\n> No ：\n\nFunction 是 built-in 的对象，不存在“Function对象由Function构造函数创建”会造成鸡生蛋蛋生鸡问题。实际上 直接写一个函数时（如 function f() {} 或 x => x），不存在调用 Function 构造器，只有显式调用 Function 构造器时（如 new Function('x', 'return x') ）才有\n\n本质上，a instanceof b 只是运算，满足条件返回 true/false，我们说 a 是 b 的实例时，只是表示他们符合某种关系。JS 是强大的动态语言，你甚至可在运行时改变这种关系，如修改对象原型改变instanceof 运算的结果。ES6+ 已允许通过 Symbol.hasInstance 自定义 instanceof 运算\n\n Function.prototype//\"function\"\n\n\n1\n\n\n后来意见：\n\n> 先有Object.prototype， Object.prototype构造Function.prototype，Function.prototype构造Object和Function\n> \n> Object.prototype是鸡，Object和Function都是蛋\n\n\n# 栗子\n\n不是没有，只是是undefined，所以不会继续往上找\n\nfunction A(x) {\n    this.x = x\n}\n\nA.prototype.x = 1\n\nfunction B(x) {\n    this.x = x\n}\n\nB.prototype = new A()\nvar a = new A(2), b = new B(3)\ndelete b.x\nconsole.log(a.x)\nconsole.log(b.x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n此题涉及的知识点 包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等\n\n\nfunction Foo () {\n    getName = function () { console.log(1) }\n    /*\n    是函数赋值语句，没有var声明，先向当前Foo函数作用域寻找getName变量，没有，再向当前函数作用域上层寻找是否有getName变量，找到了，即console.log(4)函数，将此变量赋值为console.log(1)\n    */\n    return this;//指向window\n}\nFoo.getName = function () { console.log(2) }\n\nFoo.prototype.getName = function () { console.log(3) }\n\nvar getName = function () { console.log(4) }\n\nfunction getName () { console.log(5) }\n\nFoo.getName();//2\ngetName();//4\n/*\n所有声明变量或声明函数都会被提升到当前函数顶部\n函数提升优先级高于变量提升，不会被变量声明覆盖，但会被变量赋值之后覆盖\n*/\nFoo().getName();//1\ngetName();//1\nnew Foo.getName();//2\n/*\n相当于 new (Foo.getName)()，将getName作为了构造函数执行\n*/\nnew Foo().getName();//3\n/*\n相当于(new Foo()).getName()，先执行Foo函数，有返回值\nthis本就代表当前实例化对象，调用this的getName函数，prototype中寻找getName\n*/\nnew new Foo().getName();//\n/*\nnew ((new Foo()).getName)()\n先初始化Foo的对象，将原型上的getName作为构造函数再次new\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n构造函数的返回值\n\n传统中，构造函数不该有返回值，实际执行的返回值就是实例化对象\n\nJS中构造函数可有可不有返回值\n\n 1. 没有返回值就返回实例化对象\n 2. 有返回值就检查返回值是否为引用类型，非引用类型则返回实例化对象\n 3. 若返回值是引用类型，则返回这个引用类型\n\n\n# 继承\n\n构造函数会在每一个实例上都创建一遍！\n\n使用原型模式定义的属性和方法由所有实例共享！\n\n\n# 原型链\n\n原型链向上查找的机制实现继承，子类prototype原本指向 子类构造函数本身，改变子类原型指向，把子类的原型指向父类实例，酱紫可在子类的实例上，既能继承父类属性和方法，也能继承父类原型属性和方法\n\nfunction Animal() { // 父类\n    this.name = '父类name -> Animal';\n    this.arr = [1,2,3]\n}\nAnimal.prototype.speak = function () { // 父类原型上的方法\n    return '父类原型的方法 speak ---\x3e'\n};\nfunction Dog(type) {\n    this.type = type\n}\nconsole.log('----\x3e>', Dog.prototype); // 未改变指向之前的原型 指向子类函数本身: Dog{}\n\nDog.prototype = new Animal(); #// 子类原型指向父类实例\n\nlet dog1 = new Dog('dog1');\nlet dog2 = new Dog('dog2');\nconsole.log(dog1.name); // 父类name -> Animal\ndog1.arr.push('又push了一个元素');\nconsole.log(dog1.speak()); // 父类原型的方法 speak ---\x3e\nconsole.log(dog2.name); // 父类name -> Animal\nconsole.log(dog2.arr); // [ 1, 2, 3, '又push了一个元素' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n缺点\n\n 1. 引用类型的属性被所有实例共享，我们通常不希望2个子类实例相互影响\n 2. 创建Child实例时，不能向Parent传参\n\n\n# 构造函数(经典继承)\n\ncall实现继承，本质是改变this的指向，父类的this指向当前子类的上下文，这样在父类中通过this设置的属性/方法被写到子类上\n\nfunction Animal() {\n    console.log('父类里的 this ------',this);\n    this.name = 'Animal'\n}\nAnimal.prototype.speak = function () {\n    console.log('speak --\x3e');\n};\nfunction Dog() {\n    console.log('子类里的 this ---\x3e>>',this);\n    Animal.call(this); // 这时父类里的this是 Dog{}\n    this.type = 'dog'\n}\nvar dog = new Dog(); // new 的时候执行 Obj 构造函数, 调用父类\nconsole.log(dog.name); // Fun\nconsole.log(dog.speak); // undefined\n\nfunction Cat() {\n    Animal.call(this) // 这时父类里的this是 Cat{}\n}\nvar cat = new Cat(); // new 的时候执行 Obj2 构造函数, 调用父类\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 1. 避免了 引用类型的属性被所有实例共享\n 2. 可以在 Child 中向 Parent 传参\n\n缺点\n\n * 方法都在构造函数中 定义，每次创建实例都会创建一遍方法\n * 只能继承父类构造函数上的属性和方法，不能继承父类原型上的属性和方法\n\n\n# 组合继承\n\n原型链继承+经典继承 双剑合璧\n\n子类中执行Parent.call(this) 改变当前子类Child的父类中this，等于 将父类构造函数在子类中调用执行了一遍， 将父类构造函数本身 的属性和方法设置到了子类，让子类单独维护一套从父类构造函数继承来的属性和方法，避免其沿着原型链向上查找共同的父类 属性和方法，保持了相互独立\n\n然后 再次通过改变子类的原型指向父类的实例，实现继承父类原型的属性和方法\n\nfunction Parent() {\n    this.name = 'I am Parent';\n    this.arr = [1,2,3]\n}\n\nParent.prototype.speak = function () {\n    console.log('我是父类原型上的方法 speak --\x3e ');\n};\nfunction Child() {\n    Parent.call(this); // 构造函数继承的 call 方法\n    this.type = 'child'\n}\nChild.prototype = new Parent(); // 子类的原型指向父类的实例\n\nlet child1 = new Child();\nlet child2 = new Child();\nchild1.arr.push('child1 push一个元素');\nconsole.log(child1.arr); // [ 1, 2, 3, 'child1 push一个元素' ]\nconsole.log(child2.arr); // [ 1, 2, 3 ]\nconsole.log(child1.speak); // [Function] 可以访问父类原型的熟悉和方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n融合 原型链 继承和构造函数的优点，JS最常用继承模式\n\n缺点\n\n * 父类构造函数被执行两遍，分别是 Parent.call(this) 和Child.prototype=new Parent()\n * 父类构造函数的属性在子类自身和子类原型上都存在，若delete child.arr时，只是删除了child1上的arr属性，其原型上的arr属性依然存在，原型链上依旧可以查找到\n\n优化: 把之前 子类原型指向父类实例, 改为 子类原型指向父类原型来只继承父类原型属性和方法, 避免重复继承父类本身属性方法\n\n同样有缺点:\n\nChild.prototype == Parent.prototype, 父类和子类的实例无法区分\n\n\n# 原型式继承\n\nfunction createObj(o) {\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n\n\n1\n2\n3\n4\n5\n\n\nES5 Object.create的模拟实现，将传入对象 作为 创建的对象的原型\n\ncreate创建中间对象，将2个对象区分开\n\nObject.assign 实现同时继承多个对象, 如Object.assign(对象1, 对象2, ...对象N) 实现同时继承多个对象\n\n包含引用类型的属性值都会共享相应的值——和原型链 继承一样\n\nfunction Parent() {\n    this.name = 'I am Parent';\n    this.arr = [1,2,3]\n}\n\nParent.prototype.speak = function () {\n    console.log('我是父类原型上的方法 speak --\x3e ');\n};\nfunction Child() {\n    Parent.call(this); // 构造函数继承的 call 方法\n    this.type = 'child'\n}\n\n// 子类原型指向一个新创建的对象,这个对象依据父类原型创建\nChild.prototype = Object.create(Parent.prototype);\nChild.prototype.constructor = Child; // 让子类原型的构造函数 重新指回 子类本身构造函数\n\nlet child1 = new Parent();\nlet child2 = new Child();\n\nconsole.log(child1 instanceof Parent); // true\nconsole.log(child1 instanceof Child); // false 区分出其不是子类的实例,而是父类的实例\nconsole.log(child2 instanceof Child); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 寄生式继承\n\n创建一个仅用于封装继承过程的函数，该函数在内部以某种形式 做增强对象，再返回对象\n\nfunction createObj (o) {\n    var clone = Object.create(o);\n    clone.sayName = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n缺点\n\n和借用构造函数一样，每次创建对象都会创建一遍方法\n\n\n# 寄生组合式继承\n\n组合继承 最大缺点——调用2次 父构造方法\n\n 1. 设置子实例的原型时\n 2. 创建子类型的实例时\n\n如何 避免 重复调用？\n\n如果我们不使用Child.prototype=new Parent()，而是间接让 Child.prototype访问Parent.prototype呢？\n\n// 精简版\nclass Child {\n  constructor() {\n    // 调用父类的构造函数\n    Parent.call(this);\n    // 利用Object.create生成一个对象，新生成对象的原型是父类的原型，并将该对象作为子类构造函数的原型，继承了父类原型上的属性和方法\n    Child.prototype = Object.create(Parent.prototype);\n    // 原型对象的constructor指向子类的构造函数\n    Child.prototype.constructor = Child;\n  }\n}\n\n// 通用版\nfunction Parent(name) {\n  this.name = name;\n}\nParent.prototype.getName = function() {\n  console.log(this.name);\n};\nfunction Child(name, age) {\n  // 调用父类的构造函数\n  Parent.call(this, name); \n  this.age = age;\n}\nfunction createObj(o) {\n  // 目的是为了继承父类原型上的属性和方法，在不需要实例化父类构造函数的情况下，避免生成父类的实例，如new Parent()\n  function F() {}\n  F.prototype = o;\n  // 创建一个空对象，该对象原型指向父类的原型对象\n  return new F(); \n}\n\n// 等同于 Child.prototype = Object.create(Parent.prototype)\nChild.prototype = createObj(Parent.prototype); \nChild.prototype.constructor = Child;\n\nlet child = new Child(\"tom\", 12);\nchild.getName(); // tom\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n优点——引用类型最理想的继承方式\n\n只调用一次Parent 构造函数，避免了在Parent.prototype上面创建不必要的、多余的属性\n\n同时，原型链能保持不变，能正常使用instanceof和isPrototypeOf\n\n\n# class\n\n基于寄生组合式继承，是目前最理想的继承方式\n\nES6的extends实现(底层 寄生组合式继承)\n\n是原型系统上的语法糖\n\n\nclass Game{\n  constructor(name){\n    this.name = name;\n  }\n}\nconst game = new Game('Fornite');\nconsole.log(game.__proto__ === Game.prototype);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# class原理\n\n手撕class\n\n// Child 为子类的构造函数， Parent为父类的构造函数\nfunction selfClass(Child, Parent) {\n  // Object.create 第二个参数，给生成的对象定义属性和属性描述符/访问器描述符\n  Child.prototype = Object.create(Parent.prototype, {\n    // 子类继承父类原型上的属性和方法\n    constructor: {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value: Child\n    }\n  });\n  // 继承父类的静态属性和静态方法\n  Object.setPrototypeOf(Child, Parent);\n}\n\n// 测试\nfunction Child() {\n  this.name = 123;\n}\nfunction Parent() {}\n// 设置父类的静态方法getInfo\nParent.getInfo = function() {\n  console.log(\"info\");\n};\nParent.prototype.getName = function() {\n  console.log(this.name);\n};\nselfClass(Child, Parent);\nChild.getInfo(); // info\nlet tom = new Child();\ntom.getName(); // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nlet a=5\nclass A{\n    a=10\n    fn(){\n        console.log(this)\n        console.log(this.a)\n    }\n}\nconst b=new A().fn\nb()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# super\n\n> 用作函数\n\nsuper作为函数调用时 代表父类 构造函数，子类构造函数必须执行 super()，super()只能用在子类的构造函数中\n\n作为函数调用时，this指的是子类实例\n\n> 用作对象\n\n1、super在普通方法及this\n\nsuper作为对象时，在普通方法中，指向父类 原型对象(所以若父类的方法/属性 定义在实例上，无法通过super调用)；静态方法中 指向父类\n\n子类普通方法通过super调用父类方法时，方法内部this指向当前子类实例\n\n2、super在静态方法中及this\n\nsuper作为对象，用在静态方法中，super直接指向父类，而不是父类 原型对象\n\n子类静态方法中通过super调用父类方法时，方法内部this指向当前子类，而不是子类实例\n\n\n# ✅创建对象\n\n\n# 工厂方法\n\n\n# 构造函数\n\n\n# 原型模式\n\n\n# 构造函数+原型模式\n\n\n# 动态原型\n\n判断实例上是否有函数\n\n没有的话，就在原型上定义一个函数\n\n\n# 寄生构造函数\n\n\n# 稳妥构造函数\n\n安全\n\n不用this和new\n\n\n# ❤️ proxy？\n\nES6新增功能\n\n在目标对象前设一层\"拦截\"，外界对该对象的访问，必须先通过这层拦截，可过滤和更改外界访问\n\n代理是一种很有用的抽象机制，能够通过API只公开部分信息，同时还能对数据源进行全面控制\n\n在需要公开API，同时又要避免使用者直接操作底层数据时，可使用代理\n\n比如，实现一个传统的栈数据类型，数组可以作为栈使用，但要保证人们只使用push pop 和length，我们可以基于数组创建一个代理对象，只对外公开这个三个对象成员\n\nVue3.0中使用Proxy替换原本的Object.defineProperty实现数据响应式\n\nlet p = new Proxy(target, handler)\n\n\n1\n\n\ntarget 表示需要添加代理的对象，handler表示自定义对象中的操作，可以用来自定义set或get函数\n\n使用Proxy实现数据响应式：\n\nlet onWatch = (obj, setBind, getLogger) => {\n  let handler = {\n    get(target, property, receiver) {\n      getLogger(target, property)\n      return Reflect.get(target, property, receiver)\n    },\n    set(target, property, value, receiver) {\n      setBind(value, property)\n      return Reflect.set(target, property, value)\n    }\n  }\n  return new Proxy(obj, handler)\n}\nlet obj = { a: 1 }\nlet p = onWatch(\n  obj,\n  (v, property) => {\n    console.log(`监听到属性${property}改变为${v}`)\n  },\n  (target, property) => {\n    console.log(`'${property}' = ${target[property]}`)\n  }\n)\np.a = 2 // 监听到属性a改变\np.a // 'a' = 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n自定义set和get函数，在原本逻辑中插入函数逻辑，实现 在对 对象任何属性进行读写时 发出通知\n\n如果 是实现Vue中的响应式，需要在get中收集依赖，在set派发更新，Vue3.0使用Proxy代替原来API的原因在于 Proxy无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能更好，Proxy可以完美监听到任何方式的数据改变，兼容性 不太好\n\nconst obj = {\n   name: '徐小夕',\n   age: '120'\n }\n const proxy = new Proxy(obj, {\n   get(target, propKey, receiver) {\n    console.log('get:' + propKey)\n    return Reflect.get(target, propKey, receiver)\n   },\n   set(target, propKey, value, receiver) {\n    console.log('set:' + propKey)\n    return Reflect.set(target, propKey, value, receiver)\n   }\n })\n console.log(proxy.name) // get:name 徐小夕\n proxy.work = 'frontend' // set:work frontend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# Reflect\n\n配合proxy使用，将对象的一些明显属于语言内部的方法放到Reflect对象上，并修改某些对象方法的返回结果\n\n\n# 🔥 new\n\n> 创建给定构造函数的实例，可以访问构造函数的属性方法，同时实例和构造函数通过原型链接起来\n\nnew做了如下工作：\n\n 1. 创建新对象\n 2. 将对象和构造函数通过原型链连接\n 3. 将构造函数中的this绑定到新建的对象\n 4. 根据构造函数返回类型判断，若是原始值则忽略，若是对象则返回\n\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n}\nconst person1 = new Person('Tom', 20)\nconsole.log(person1)  // Person {name: \"Tom\", age: 20}\n\n\n1\n2\n3\n4\n5\n6\n\n\n实现\n\nfunction myNew2(Func, ...args) {\n    const obj = {};\n    obj.__proto__ = Func.prototype;\n    let res = Func.apply(obj, args);\n    return res instanceof Object ? res : obj;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 第二版的代码\nfunction objectFactory() {\n    var obj = new Object(),\n    Constructor = [].shift.call(arguments);\n    obj.__proto__ = Constructor.prototype;\n    var ret = Constructor.apply(obj, arguments);\n    return typeof ret === 'object' ? ret : obj;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n构造函数中 不要显示返回任何值！！\n\n因为返回 原始值不生效，返回对象会导致new失效！\n\n> 为啥\n\n构造函数不是由我们的代码直接调用，是由运行时的内存分配和对象初始化代码调用。它的返回值(编译为机器码时实际上有一个)对用户来说不透明——所以，我们不能指定它\n\nlet a=[]//let a=new Array()\nfunction(){} //let a=new Function(){}\n\n\n1\n2\n\n\n\n# 🍉 懒加载\n\n过度使用的弊端\n\n * 减慢快速滚动的速度\n * 页面缓冲\n * 内容变化导致延迟\n\n何时使用\n\n * 懒加载不妨碍网页使用的内容\n\n\n# lazy\n\n<img src=\"./example.jpg\" loading=\"lazy\">\n\n\n1\n\n * loading\n * 判断元素是否在视口\n * 递归获取滚动容器\n * 添加滚动事件\n * 元素出现在视口中 展示真正内容，取消监控事件\n\n判断元素是否出现在视口\n\n 1. offsetTop计算body到元素距离(繁琐)\n 2. getBoundingClientRect计算\n\n\n# offsetTop\n\nclientHeight 包括元素的内容 和内边距，不包括边框\n\noffsetTop 元素的偏移量，获取元素到有定位的父盒子顶部距离\n\n先给图片一个占位资源:\n\n<img src=\"default.jpg\" data-src=\"http://www.xxx.com/target.jpg\" />\n\n\n1\n\n\n监听 scroll 判断图片是否到达视口:\n\nlet img = document.getElementsByTagName(\"img\");\nlet num = img.length;\nlet count = 0;//计数器，从第一张图片开始计\n\nlazyload();//首次加载别忘了显示图片\n\nwindow.addEventListener('scroll', lazyload);\n\nfunction lazyload() {\n  let viewHeight = document.documentElement.clientHeight;//视口高度\n  let scrollTop = document.documentElement.scrollTop || document.body.scrollTop;//滚动条卷去的高度\n  for(let i = count; i <num; i++) {\n    // 元素现在已经出现在视口中\n    if(img[i].offsetTop < scrollHeight + viewHeight) {\n      if(img[i].getAttribute(\"src\") !== \"default.jpg\") continue;\n      img[i].src = img[i].getAttribute(\"data-src\");\n      count ++;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n最好对 scroll 事件做节流处理，以免频繁触发:\n\n节流就是一段时间内执行一次\n\n// throttle函数我们上节已经实现\nwindow.addEventListener('scroll', throttle(lazyload, 200));\nfunction throttle(fn,wait){\n    let pre=0;\n    return function(){\n        let now=Date now();\n        if(now-pre>=wait){\n            pre=now;\n            fn.apply(this,arguments);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# getBoundingClientRect\n\n判断图片是否出现在当前视口，返回 DOMRect对象，有left， top， right， bottom， x， y， width，height属性\n\nconst target = document.querySelector('.target');\nconst clientRect = target.getBoundingClientRect();\nconsole.log(clientRect);\n\n// {\n//   bottom: 556.21875,\n//   height: 393.59375,\n//   left: 333,\n//   right: 1017,\n//   top: 162.625, 元素到视窗顶部的距离\n//   width: 684\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n图片不可以看见，说明图片到窗口顶部距离＞窗口显示区高度\n\n图片可以看见，说明图片距离视窗顶部距离＜窗口显示区高度\n\n上述的 lazyload 函数改成下面这样:\n\nfunction lazyload() {\n  for(let i = count; i <num; i++) {\n    // 元素现在已经出现在视口中\n    if(img[i].getBoundingClientRect().top < document.documentElement.clientHeight) {\n      if(img[i].getAttribute(\"src\") !== \"default.jpg\") continue;\n      img[i].src = img[i].getAttribute(\"data-src\");\n      count ++;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n缺点：即使图片加载完成，监听到滚动事件，还是会触发函数\n\n多2个处理\n\n * 图片全部加载后移除事件监听\n * 加载完的图片从imgList移除\n\nlet imgList = [...document.querySelectorAll('img')]\nlet length = imgList.length\n\nconst imgLazyLoad = (function() {\n    let count = 0\n    return function() {\n        let deleteIndexList = []\n        imgList.forEach((img, index) => {\n            let rect = img.getBoundingClientRect()\n            if (rect.top < window.innerHeight) {\n                img.src = img.dataset.src\n                deleteIndexList.push(index)\n                count++\n                if (count === length) {\n                    document.removeEventListener('scroll', imgLazyLoad)\n                }\n            }\n        })\n        imgList = imgList.filter((img, index) => !deleteIndexList.includes(index))\n    }\n})()\n\n// 这里最好加上防抖处理\ndocument.addEventListener('scroll', imgLazyLoad)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n防抖指的是 n s 后执行一次，重复触发则重新计时\n\n\n# Intersection Observer\n\n重叠观察者，判断两个元素是否重叠，不用事件监听，性能比getBoundingClientRect好 浏览器内置API，实现监听window的scroll事件、判断是否在视口中、节流三大功能\n\nlet img = document.getElementsByTagName(\"img\");\n\nconst observer = new IntersectionObserver(changes => {\n  //changes 是被观察的元素集合\n  for(let i = 0, len = changes.length; i < len; i++) {\n    let change = changes[i];\n    // 通过这个属性判断是否在视口中\n    if(change.isIntersecting) {\n      const imgElement = change.target;\n      imgElement.src = imgElement.getAttribute(\"data-src\");\n      observer.unobserve(imgElement);\n    }\n  }\n})\nArray.from(img).forEach(item => observer.observe(item));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 💚 防抖、节流\n\n浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，不断调用事件回调，浪费资源\n\n防抖（debounce） 和 节流（throttle） 减少调用频率\n\n设置事件频率为500ms，2s内，频繁触发函数\n\n节流——每隔500ms执行一次( 隔一段时间 再执行)\n\n防抖——不管调用多少次，在2s后只会执行一次 (一段时间之后执行)\n\n\n# 防抖\n\n控制次数\n\nn 秒后再执行，若在 n 秒内重复触发，会重新计时\n\n高频到最后一次操作，这事儿需要等待，如果你反复操作，我就重新计时\n\n函数被连续触发，只执行最后一次\n\n原理：维护一个定时器，延迟计时以最后一次触发为计时起点，到达延迟时间后触发函数执行\n\n\n# 普通版\n\n支持this 和 event 对象\n\nfunction debounce(fn, wait) {\n        // 4、创建一个标记用来存放定时器的返回值\n        let timer = null;\n        // 返回闭包函数 ，闭包保存timer，保证其不被销毁，重复点击会清理上一次的定时器\n        return function () {\n            let that = this;\n            // 5、每次当用户点击/输入的时候，把前一个定时器清除\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            // 6、创建一个新的 setTimeout，保证点击按钮后的 interval 间隔\n            // 如果用户还点击了的话，不会执行 fn 函数\n            timer = setTimeout(() => {\n                fn.call(that, arguments);\n            }, wait);\n        };\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n使用\n\nvar node = document.getElementById('layout')\nfunction getUserAction(e) {\n    console.log(this, e)  // 分别打印：node 这个节点 和 MouseEvent\n    node.innerHTML = count++;\n};\nnode.onmousemove = debounce(getUserAction, 1000)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 非立即执行版\n\n感觉 和普通版 是一个道理？？\n\n<body>\n<button id=\"debounce\">点击</button>\n<script>\n  window.onload = function () {\n    var mydebounce = document.getElementById(\"debounce\")\n    mydebounce.addEventListener(\"click\", debounce(sayDebounce, 1000))\n  }\n\n  //防抖函数\n  function debounce(fn, time) {\n    let timer = null;\n    return function () {\n      let context = this;\n      if (timer) clearTimeout(timer);  //清除前一个定时器\n      timer = setTimeout(() => {  //在时间间隙内再次点击不会执行fn函数\n        fn.apply(context, arguments);\n      }, time || 500)\n    }\n  }\n\n  //要防抖的事件处理\n  function sayDebounce() {\n    console.log(\"处理防抖的事件写在这里,比如发送请求\");\n  }\n<\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 立即执行版\n\n如果timer不存在的话，设置flag标志立即调用\n\n function debounce(fn,time) {\n    let timer = null\n    return function () {\n      let context = this\n      if(timer) clearTimeout(timer)  //清除前一个定时器\n      let callNow = !timer\n      timer = setTimeout(()=>{\n        timer = null\n      },time || 500)\n      if (callNow) fn.apply(context,arguments)\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 双剑合璧版\n\n如果需要立即执行，可加入第三个参数判断\n\n  window.onload = function () {\n    var mydebounce = document.getElementById(\"debounce\")\n    mydebounce.addEventListener(\"click\", debounce(sayDebounce, 1000, true))\n  }\n\n  //immediate 为true表 立即执行\n  function debounce(func, wait, immediate) {\n    let timer;\n    return function () {\n      let context = this;\n      if (timer) clearTimeout(timer);\n      if (immediate) {\n        var callNow = !timer;//第一次会立即执行，后面每次触发时执行\n        timer = setTimeout(() => {\n          timer = null;\n        }, wait)\n        if (callNow) func.apply(context, arguments)\n      } else {\n        timer = setTimeout(function () {\n          func.apply(context, arguments)\n        }, wait);\n      }\n    }\n  }\n  function sayDebounce() {\n    console.log(\"处理防抖的事件写在这里,比如发送请求\");\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 加强版\n\n触发过于频繁导致一次响应都没有，希望到了固定时间必须给用户一个响应\n\n function debounce(fn, await) {\n        let last = 0;\n        let timer = null;\n        return function () {\n            let that = this;\n            let now = new Date();\n            if (now - last < await) {\n                clearTimeout(timer);\n                setTimeout(() => {\n                    last = now;\n                    fn.apply(that, arguments);\n                }, await);\n            } else {\n                // 时间到了，必须给响应\n                last = now;\n                fn.apply(that, arguments);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 取消debounce（终极版）\n\n\n\n\n1\n\n\n\n# 节流\n\n用户反复触发一些操作，如 鼠标移动，需要一个\"巡视\"的间隔时间，不管用户期间触发多少次，只会在间隔点上执行给定的回调\n\n> 水龙头的水一直往下流，浪费水，我们可以把龙头关小，让水一滴一滴流，每隔一段时间掉下来一滴水\n\nn 秒内只运行一次，若在 n 秒内重复触发，只有一次生效\n\n稀释函数的执行频率\n\nfunction throttle(fn) {\n        // 4、通过闭包保存一个标记\n        let canRun = true;\n        return function () {\n            // 5、判断标志是否为 true，不为 true 则中断\n            if (!canRun) {\n                return;\n            }\n            // 6、将 canRun 设置为 false，防止执行之前再被执行\n            canRun = false;\n            // 7\n            setTimeout(() => {\n                fn.call(this, arguments);\n                // 8、执行完事件后，重新将这个标志设置为 true\n                canRun = true;\n            }, 1000);\n        };\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 时间戳 首节流\n\n立即执行，每wait执行一次，停止触发后不再执行\n\n时间戳\n\n  function throttle(fn, wait) {\n    //记录第一次调用时间\n    let preTime = 0;\n    return function () {\n      const that = this;\n      let nowTime = Date.now();\n      // 如果两次时间间隔 超过了指定时间，则执行函数\n      if (nowTime - preTime >= wait) {\n        //将现在的时间设置为上一次执行时间\n        preTime = nowTime;\n        return fn.apply(that, arguments);\n      }\n    };\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 定时器 尾节流\n\n不会立即执行，每wait执行一次，停止触发后，再执行一次\n\n定时器\n\n  function throttle(fn, wait = 500) {\n    let timer = null;\n    return function () {\n      if (!timer) {\n        timer = setTimeout(() => {\n          fn.apply(this, arguments);\n          //执行完毕后重置定时器\n          timer = null;\n        }, wait);\n      }\n    };\n  };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 双剑合璧版\n\n立刻执行，停止触发后还能再执行一次\n\n时间戳+定时器\n\nfunction throttle(fn, await) {\n    // 初始化定时器\n    let timer = null;\n    // 上一次调用时间\n    let prev = null;\n    return function () {\n      // 现在触发事件时间\n      let now = Date.now();\n      // 触发间隔是否大于await\n      let remaining = await - (now - prev);\n      clearTimeout(timer);\n      // 如果间隔时间满足await\n      if (remaining <= 0) {\n        fn.apply(this, arguments);\n        prev = Date.now();\n      } else {\n        // 否则，过了剩余时间执行最后一次fn\n        timer = setTimeout(() => {\n          fn.apply(this, arguments)\n        }, await);\n      }\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 应用场景\n\n防抖在连续的事件只触发一次：\n\n * 鼠标滑动\n * 登录注册等表达提交操作用户单击过快触发多次请求\n * 编辑器内容实时保存\n * iinput.change实时输入校验(输入实时查询，不可能摁一个字就查一次，肯定是输一串，统一查询一次)\n * window.resize(窗口缩放完成后，才会重新计算部分 DOM 尺寸)\n\n节流在间隔一段时间执行一次回调的场景：\n\n * 搜索框，搜索联想功能\n * 滑动定时/滑动高度，埋点请求\n * 运维系统查看日志，n秒刷新\n * 进度条位置计算\n * 监听 mousemove、 鼠标滚动等事件，常用于：拖拽动画、下拉加载、滚动加载、加载更多或滚到底部监听\n\n> 节流常用在比防抖刷新更频繁的场景，大部分需要涉及动画操作\n\n\n# 🍉 模块化\n\n指定规范约束我们按照规范写代码\n\n规范包括模板可暴露的属性 和 可导入自己所需的属性\n\n\n# 特点\n\n 1. 解决命名污染，全局污染，变量冲突等\n 2. 内聚私有，变量不能被外部访问\n 3. 更好的分离，按需加载\n 4. 引入其他模块可能存在循环引用\n 5. 代码抽象，封装，复用\n 6. 避免通过script标签从上至下加载资源\n 7. 大型项目资源难以维护\n\n\n# CommonJS\n\n服务端解决方案。加载速度快(因为模块·文件一般存在本地硬盘)\n\n * Node中 **每个文件是一个模块，**有自己的作用域。在一个文件里面定义的变量、函数 都是私有的，对其他文件不可见\n\n * 运行时加载，只能在运行时才能确定一些东西\n\n * 同步加载，加载完成后，才能执行后续操作。 文件都在本地，同步导入即使卡住主线程影响也不大\n\n * 导出时是值拷贝，想更新值，必须重新导入\n\n * 模块在首次执行后会缓存，再次加载只返回缓存结果，若想再次执行，可清除缓存\n\n * 模块加载的顺序就是代码出现的顺序\n\n\n# 基本语法\n\n核心变量——exports，module.exports，require\n\n * 暴露模块：module.exports = value或exports.xxx = value\n * 引入模块：require(xxx)，xxx为模块 名/文件路径\n\nCommonJS规范规定，每个模块内部，module变量代表当前模块，它是一个对象，它的exports属性是对外的接口。加载某个模块，其实是加载该模块的module.exports属性\n\n// 加载模块\nvar example = require('./example.js');\nvar config = require('config.js');\nvar http = require('http');\n// 对外暴露模块\nmodule.exports.example = function () {\n  ...\n}\nmodule.exports = function(x){  \n    console.log(x)\n}\nexports.xxx=value;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\nrequire 读入并执行一个JS文件，返回该模块的exports对象。如果没有发现指定模块，报错\n\nnodejs主要用于服务器编程，模块文件一般存在本地硬盘，所以加载比较快，不用考虑异步加载——使用CommonJS规范\n\n浏览器环境，要从服务器端加载模块，用CommonJS需要等模块下载完并运行后才能使用，将阻塞后面代码执行，这时必须采用非同步模式，浏览器端一般采用AMD规范，解决异步加载\n\n 1. exports 记录当前模块导出的变量\n 2. module 记录当前模块的详细信息\n 3. require 进行模块的导入\n\n\n# exports、module.exports\n\n两者指向同一块内存\n\n 1. 绑定同一属性时，2者相等\n 2. 不能直接赋值给exports，即不能直接使用exports={}\n 3. 只要最后直接给module.exports赋值了，之前绑定的属性都会被覆盖掉\n\n\n\n和exports对象没有任何关系了，exports 你自己随便玩吧\n\nmodule.exports 现在导出一个自己的对象，不带你玩了\n\n新的对象 取代了 exports 的导出，即 require 导入的对象 是新的对象\n\n\n\n\n# 循环引入\n\n//index.js\nvar a = require('./a')\nconsole.log('入口模块引用a模块：',a)\n\n// a.js\nexports.a = '原始值-a模块内变量'\nvar b = require('./b')\nconsole.log('a模块引用b模块：',b)\nexports.a = '修改值-a模块内变量'\n\n// b.js\nexports.b ='原始值-b模块内变量'\nvar a = require('./a')\nconsole.log('b模块引用a模块',a)\nexports.b = '修改值-b模块内变量'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\nCommonJS做了处理——模块缓存\n\n每一个模块都会先加入缓存再执行，每次遇到require都先检查缓存，这样不会出现死循环；借助缓存，就能找到输出的值\n\n\n# 多次引入\n\n//index.js\nvar a = require('./a')\nvar b= require('./b')\n\n// a.js\nmodule.exports.a = '原始值-a模块内变量'\nconsole.log('a模块执行')\nvar c = require('./c')\n\n// b.js\nmodule.exports.b = '原始值-b模块内变量'\nconsole.log('b模块执行')\nvar c = require('./c')\n\n// c.js\nmodule.exports.c = '原始值-c模块内变量'\nconsole.log('c模块执行')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nc模块只执行一次，第二次读取时，发现有缓存，直接读取缓存\n\n\n# 路径解析\n\n> 为什么简单写一个'React'就能找到包的位置\n\n路径分类\n\n 1. 内置核心模块，node已将其编译为二进制代码，直接书写标识符fs、http就可\n 2. 本地文件模块，自己书写的文件模块，需要使用'./' \"../\"开头，require将其转化为真实路径\n 3. 第三方模块，npm下载的包，用到paths变量，依次查找当前路径下的node_modules->父级目录的node_modules->根目录为止\n\n\n# AMD\n\nAsynchronous Module Definition（异步模块定义）\n\n编译成 require/exports 来执行\n\n浏览器一般使用AMD规范，异步加载\n\nRequireJS是一个工具库。用于客户端的模块管理。可以让客户端的代码分成一个个模块，实现异步或动态加载，提高代码的性能和可维护性。遵守AMD规范\n\nRequire.js的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载\n\n> 基本语法\n\n定义暴露模块:\n\n//定义没有依赖的模块\ndefine(function(){\n   return 模块\n})\n//定义有依赖的模块\ndefine(['module1', 'module2'], function(m1, m2){\n   return 模块\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n引入使用模块:\n\nrequire(['module1', 'module2'], function(m1, m2){\n   使用m1/m2\n})\n\n\n1\n2\n3\n\n * 采用异步加载的方式来加载模块，模块的加载不影响后面语句执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调；也可以根据需要动态加载模块\n * AMD模块定义的方法清晰，不会污染全局环境，可清楚地显示依赖关系\n\n\n# CMD\n\nCommon Module Definition（通用模块定义）\n\nCMD规范用于浏览器端，异步加载，使用模块时才会加载执行\n\n整合了CommonJS和AMD规范的特点\n\nSea.js中，所有JS模块都遵循CMD模块定义规范\n\n> 基本语法\n\n定义暴露模块：\n\n//定义没有依赖的模块\ndefine(function(require, exports, module){\n  exports.xxx = value\n  module.exports = value\n})\n//定义有依赖的模块\ndefine(function(require, exports, module){\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  //引入依赖模块(异步)\n    require.async('./module3', function (m3) {\n    })\n  //暴露模块\n  exports.xxx = value\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n引入使用模块：\n\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# ES6\n\nimport 和 export 的形式导入导出模块。这种方案和上面三种方案都不同\n\n尽量静态化，保证在编译时就能确定模块的依赖关系和输入输出的变量\n\n异步导入，用于浏览器，需要下载文件，同步导入对渲染有很大影响\n\n实时绑定，导入导出的值都指向同一个内存地址，导入值跟随导出值变化\n\n编译成 require/exports 来执行\n\n * 使用export命令定义了模块的对外接口以后，其他 JS 文件可以通过import命令加载这个模块\n\n一个模块是一个独立的文件，该文件内部的所有变量，外部无法获取。如果希望外部读取模块内部的某个变量，必须使用export关键字输出该变量\n\n编译阶段，import会提升到整个模块的头部，首先执行\n\n如果不需要知道变量名或函数就完成加载，用export default命令，为模块指定默认输出\n\nexport default指定模块的默认输出。一个模块只能有一个默认输出，export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令\n\n\n# 基本语法\n\nexport\n\n1.如果不想对外暴露内部变量真实名称，可使用as关键字设置别名，同一个属性可设置多个别名\n\n外部引入时，可通过name2这个变量访问king值\n\nconst name='king';\nexport {name as name2};\n\n\n1\n2\n\n\n2.同一文件中，同一变量名只能export一次，否则抛出异常\n\nconst name='king';\nconst _name='king';\nexport {name as _name};\nexport {_name};//抛出异常，_name作为对外输出的变量，只能export一次\n\n\n1\n2\n3\n4\n\n\nimport\n\nimport {标识符列表} from '模块'\n{}不是对象，里面知识存放导入的标识符\n\n\n1\n2\n\n\n1.import和export的变量名相同\n\n2.相同变量名的值只能import一次\n\n3.import命令具有提升的效果\n\n//export.js\nexport const name='king';\n\n//import.js\nconsole.log(name);//king\nimport {name} from './export.js'\n\n\n1\n2\n3\n4\n5\n6\n\n\n本质：import在编译期间运行，执行console语句之前就已经执行了import语句。因此能够打印出 name的值，即，King\n\n4.多次import时，只会加载一次\n\n以下代码，我们import了两次export.js文件，最终只输出一次“start”，可推断出import导入的模块是单例模式\n\n//export.js\nconsole.log('start');\nexport const name='king';\nexport const age=19;\n\n//import.js\nimport {name} from './export.js\nimport {age} from './export.js''\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n5.允许在需要的时候动态加载模块，而不是一开始就加载所有模块，提高性能\n\n这个新功能允许我们将import()作为函数调用，将其作为参数传递给模块的路径。 它返回 promise，用一个模块对象实现，可以访问该对象的导出\n\nimport('/modules/myModule.mjs')\n  .then((module) => {\n    // Do something with the module.\n  });\n\n\n1\n2\n3\n4\n\n\n\n# 循环引入\n\n> 模块地图和模块记录\n\n模块记录类似模块的身份证，记录关键信息——模块导出值的内存地址，加载状态，其他模块导入时，做一个\"连接\"——根据模块记录，把导入的变量指向同一块内存，实现动态绑定\n\n模块地图，标记进入过的模块为\"获取中\"，所以循环引用时不会再次进入，地图中每个节点是一个模块记录，上面有导出变量的内存地址\n\n// index.mjs\nimport * as a from './a.mjs'\nconsole.log('入口模块引用a模块：',a)\n\n// a.mjs\nlet a = \"原始值-a模块内变量\"\nexport { a }\nimport * as b from \"./b.mjs\"\nconsole.log(\"a模块引用b模块：\", b)\na = \"修改值-a模块内变量\"\n\n// b.mjs\nlet b = \"原始值-b模块内变量\"\nexport { b }\nimport * as a from \"./a.mjs\"\nconsole.log(\"b模块引用a模块：\", a)\nb = \"修改值-b模块内变量\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n\n# 对比总结\n\nCommonJS输出值的浅拷贝（加载一个对象，及module.exports属性，该对象只有在脚本运行时生成），同步的，运行时加载\n\nES6 编译时加载，且是异步的，输出值的引用\n\n\n\n 1. CommonJS规范用于服务端编程，同步加载，不适合浏览器，同步意味阻塞，而浏览器资源异步加载，因此诞生AMD 和 CMD\n 2. AMD规范在浏览器环境中异步加载，可以并行加载。开发成本高，代码阅读困难，模块定义语义不顺畅\n 3. CMD和AMD相似，依赖就近，延迟执行，易在nodejs运行。但是，依赖SPM打包，模块加载逻辑偏重\n 4. ES6实现模块功能且实现简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用模块解决方案的宠儿\n\n\n * # 为什么模块循环依赖不会死循环？CommonJS和ES Module的处理不同？\n\n 1. CommonJS和ES Module都对循环引入做了处理，不会进入死循环，但方式不同：\n\n 2. * CommonJS借助模块缓存，遇到require函数会先检查是否有缓存，已经有的则不会进入执行，在模块缓存中还记录着导出的变量的拷贝值\n    * ES Module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——指向同一块内存\n\n 3. CommonJS的export和module.export指向同一块内存，由于最后导出的是module.export，不能直接给export赋值，会导致指向丢失\n\n 4. 查找模块时，核心模块和文件模块的查找都比较简单，对于react/vue这种第三方模块，会从当前目录下的node_module文件下开始，递归往上找，找到该包后，根据package.json的main字段找到入口文件\n\n\n# 💛 DOM\n\n\n# 操作\n\n（1）创建新节点\n\nconst fragment = document.createDocumentFragment();\nconst divEl = document.createElement(\"div\");\nconst textEl = document.createTextNode(\"content\");\n\n\n1\n2\n3\n\n\n（2）添加、移除、替换、插入\n\nappendChild(node)\nremoveChild(node)\nreplaceChild(new,old)\ninsertBefore(new,old)\n\n\n1\n2\n3\n4\n\n\n（3）查找\n\ndocument.getElementById('id属性值');返回拥有指定id的对象的引用\ndocument.getElementsByClassName('class属性值');返回拥有指定class的对象集合\ndocument.getElementsByTagName('标签名');返回拥有指定标签名的对象集合\ndocument.getElementsByName('name属性值'); 返回拥有指定名称的对象结合\ndocument/element.querySelector('CSS选择器');  仅返回第一个匹配的元素\ndocument/element.querySelectorAll('CSS选择器');   返回所有匹配的元素\ndocument.documentElement;  获取页面中的HTML标签\ndocument.body; 获取页面中的BODY标签\ndocument.all[''];  获取页面中的所有元素节点的对象集合型\ndocument.querySelector('.element')\ndocument.querySelector('#element')\ndocument.querySelector('div')\ndocument.querySelector('[name=\"username\"]')\ndocument.querySelector('div + p > span')\nconst notLive = document.querySelectorAll(\"p\");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nHTMLCollection 是动态集合， DOM 树变化时， HTMLCollection 随之改变。 NodeList 是静态集合， NodeList 不受 DOM 树变化影响\n\n（4）属性操作\n\ngetAttribute(key);\nsetAttribute(key,value);\nhasAttribute(key);\nremoveAttribute(key);\nconst dataAttribute = document.createAttribute('custom');\nconsle.log(dataAttribute);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# DOM事件\n\nonerror()\n\nonconfirm()应该是在表单提交前触发，确认\n\n\n# location\n\n包含有关当前URL的信息\n\n是window的一部分，通过window.location访问\n\n属性\n\n属性         描述\nhash       从井号 (#) 开始的 URL（锚）\nhost       主机名和当前 URL 的端口号\nhostname   当前 URL 的主机名\nhref       完整的 URL\npathname   当前 URL 的路径部分\nport       当前 URL 的端口号\nprotocol   当前 URL 的协议\nsearch     从问号 (?) 开始的 URL（查询部分）\norigin     URL 来源的 Unicode 序列化，包括协议\n\n方法\n\n属性          描述\nassign()    加载新的文档\nreload()    重新加载当前文档\nreplace()   用新的文档替换当前文档\n\n> document、window\n\nwindow代表浏览器窗口，是JS在浏览器中的全局对象\n\ndocument代表文档对象，window的一个属性\n\n> Element、Node\n\nNode是基类，Element、Text都继承于它\n\nElement、Text分别叫做ELEMENT_NODE，TEXT_NODE\n\nhtml上的元素，即element，是类型为ELEMENT_NODE的Node\n\nNode表示DOM树的结构，html中节间可以插入文本，这个插入的空隙就是TEXT_NODE\n\n可使用childNodes得到NodeList，如何获取ElementList？\n\ngetElementByXXX返回ElementList，它的真名是 ElementCollection\n\n就像NodeList是Node的集合一样，ElementCollection也是Element的集合\n\n他们都不是真正的数组\n\n\n# HTMLCollection、NodeList\n\n\n# HTMLCollection\n\n类数组对象， 包含元素（元素顺序为文档流中的接口）的通用集合，提供从该集合中选择元素的属性和方法\n\nlive——即时更新\n\n因此，最好创建副本后再迭代 以 add 、delete 或是 move节点\n\ngetElementByTagName()返回HTMLCollection对象\n\nHTMLCollection有namedITem方法，其他和NodeList保持一致\n\nHTMLCollection只包含元素节点（ElementNode）\n\n属性和方法\n\n * item(index) —— 返回 HTMLCollection 指定索引元素，不存在则返回 null\n * length —— 返回 HTMLCollection 元素的数量\n\n\n# NodeList\n\n节点的集合\n\n不是数组，是类数组对象\n\n可以使用forEach迭代，使用Array.from()转换为数组\n\n一些情况下，NodeList动态变化，如果文档节点树变化，NodeList会随之而变，Node.childNodes是实时的\n\n其他情况，NodeLIst是静态集合，document.querySelectorAll返回静态NodeList\n\n可使用for循环 或 for-of 遍历，不要使用 for-in 遍历NodeList，因为NodeList对象的length和item属性会被遍历出来，可能导致错误，且for-in无法保证属性顺序\n\nNodeList可包含任何节点类型\n\n通过以下方法，可 获取 NodeList\n\n①**一些旧版本浏览器 getElementsClassName() 返回 NodeList ，而不是 HTMLCollection **\n\n②**所有浏览器的Node.childNodes 返回 NodeList **\n\n③大部分浏览器 document.querySelectorAll() 返回NodeList\n\nNodeList 属性和方法\n\n * item() —— 返回元素索引\n * length() —— 返回 NodeList 节点数量\n * NodeList.forEach() —— 遍历 NodeList 所有成员。接收回调函数作为参数，遍历一回就要执行这个回调，与数组 forEach 完全一致\n * NodeList.keys()/values()/entries() —— 都返回 ES6 遍历器对象，通过 for…of… 循环遍历，获取每一个成员\n\n\n# 总结\n\n         HTMLCOLLECTION                                                 NODELIST\n集合       元素集合                                                           节点集合\n静态和动态    动态集合。DOM 树变化，随之变化，其节点的增删敏感                                     静态集合，不受 DOM 树元素变化影响；相当于是 DOM 树、节点数量和类型的快照，对节点增删时，NodeList\n                                                                        感觉不到。但是对节点内部内容修改，可以感觉到，修改 innerHTML\n节点       不包含属性节点和文本节点                                                   只有 NodeList 对象有包含属性节点和文本节点\n元素获取方式   元素可以通过 name，id / index 索引获取                                    只能通过 index 索引获取\n伪数组      HTMLCollection 和 NodeList 都是类数组。所以使用数组方法，pop()，push()/join()   与 HTMLCollection 一样\n\n\n# 获取DOM大小\n\ngetBoundingClientRect()\n\n获取 元素 大小及 相对于视窗的位置，返回 包含left, top, right, bottom, x, y, width, 和 height 参数对象，除 width 和 height 以外 属性 相对于视图窗口的左上角 计算\n\n\n# 💛 Ajax、Fetch、Axios\n\n\n# Ajax\n\nAjax（Asynchronous JavaScript and XML，异步JS与XML技术），实现网页异步更新，不重新加载网页对网页部分进行更新\n\n不是一种新技术，而是2005年被提出的新术语\n\nXMLHttpRequest的API实现\n\n\n * # axios洋葱模型\n\n\n * # 请求步骤\n\n//创建 XMLHttpRequest 对象\nconst ajax = new XMLHttpRequest();\n//规定请求类型、URL 以及是否异步处理请求,open() 方法与服务端建立连接\najax.open('GET',url,true);\n//为对象添加一些信息和监听函数\najax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); \n//发送请求\najax.send(null);  \n//监听服务端的通信状态\najax.onreadystatechange = function () {\n    if (ajax.readyState == 4 && (ajax.status == 200 || ajax.status == 304)) { \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nXMLHttpRequest对象有5个状态，状态变化触发onreadystatechange事件，可设置监听函数处理请求结果\n\n当对象的 readystate 变为 4时，代表服务器返回的数据接收完毕， 可对 请求状态进行判断\n\n\n * # Promise封装Ajax请求\n\nfunction getJSON(url){\n    let promise=new Promise((resolve,reject)=>{\n        let xhr=new XMLHttpRequest();\n        xhr.open('GET',url,true);\n        xhr.onreadystatechange=()=>{\n            if(this.readystate!==4) return;\n            if(this.status===200){\n                resolve(this.response);\n            }else{\n                reject(new Error(this.statusText));\n            }\n        };\n        xhr.onerror=()=>{\n            reject(new Error(this.statusText));\n        };\n        xhr.responseType='json';\n        xhr.setRequestHeader('Accept','application/json');\n        xhr.send(null);\n    });\n    return promise;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n特点：\n\n * 局部刷新页面\n * 基于原生XHR开发，而XHR本身架构不清晰\n * 对基于异步的事件不友好\n\n\n# Ajax底层实现？\n\n\n# Fetch\n\n获取资源的接口，**替换笨重繁琐XMLHttpRequest。**有Request 、Response 、Headers 概念，与后端语言请求资源更接近\n\n> 会创建微任务，因为返回 Promise\n\n * 使用 Promise，支持async/await\n * 模块化设计，Response Request 和 Header对象\n * 不携带cookie，需要手动配置\n\nfetch是底层API，真实存在\n\n\n# fetch能监听网络请求超时吗\n\nXMLHttpRequest可设置请求超时时间，Fetch不能监听网络请求超时\n\n\n# Axios\n\nAxios ——基于 promise 的HTTP网络请求库，用于浏览器和Nodejs\n\n体积小，提供简单易用的库，接口易于扩展\n\n本质是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本\n\n特点：\n\n * 从浏览器中创建 XMLHttpRequests\n * 支持浏览器和nodejs环境\n * 支持 Promise API\n * 转换请求数据和响应数据\n * 取消请求\n * 客户端支持防御 XSRF\n\naxios({        \n  url:'xxx',    // 设置请求的地址\n  method:\"GET\", // 设置请求方法\n  params:{      // get请求使用params进行参数凭借,如果是post请求用data\n    type: '',\n    page: 1\n  }\n}).then(res => {  \n  // res为后端返回的数据\n  console.log(res);   \n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n * # 设置接口请求前缀\n\n利用node环境变量判断，区分开发、测试、生产环境\n\nif (process.env.NODE_ENV === 'development') {\n  axios.defaults.baseURL = 'http://dev.xxx.com'\n} else if (process.env.NODE_ENV === 'production') {\n  axios.defaults.baseURL = 'http://prod.xxx.com'\n}\n\n\n1\n2\n3\n4\n5\n\n\n本地调试时，在config.js中配置proxy实现代理转发\n\n\n * # 设置请求头和超时时间\n\nconst service = axios.create({\n    ...\n    timeout: 30000,  // 请求 30s 超时\n      headers: {\n        get: {\n          'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        },\n        post: {\n          'Content-Type': 'application/json;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        }\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n * # 封装请求方法\n\n// get 请求\nexport function httpGet({\n  url,\n  params = {}\n}) {\n  return new Promise((resolve, reject) => {\n    axios.get(url, {\n      params\n    }).then((res) => {\n      resolve(res.data)\n    }).catch(err => {\n      reject(err)\n    })\n  })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 请求拦截器\n\n在每个请求里加上token，统一处理维护方便\n\n> 响应拦截器\n\n在接收到响应后先做一层判断，比如状态码判断登录状态、授权\n\n\n# axios和fetch\n\n就个人体验， Axios优于Fetch\n\nFetch的优势仅在于浏览器原生支持\n\n不像Axios需引入包，需要即时测试接口直接在Chrome浏览器中使用Fetch请求，尤其是编写爬虫/脚本\n\nAxios是对XMLHttpRequest的封装，Fetch是新的获取资源的接口方式，不是对XMLHttpRequest的封装\n\n最大的不同点在于Fetch浏览器原生支持，Axios需要引入Axios库\n\nAxios兼容IE，Fetch在IE和一些老版浏览器没有支持，但有库可让老版浏览器支持Fetch，很多网站为了减少成本而选择不再兼容IE浏览器\n\n在旧的浏览器上可能还需要使用promise兼容库\n\nAxios可设置 超时，直接设置timeout属性，fetch不行\n\nAxios 自动对数据转化，Fetch 需要 手动转化\n\nAxios 提供拦截器，统一对请求或响应处理，可为请求附加token、增加时间戳防止请求缓存、拦截响应，状态码不符合预期直接将响应消息通过弹框的形式展示在界面，密码错误、服务器内部错误、表单验证不通过\n\nFetch没有拦截器功能，重写全局Fetch方法就可办到\n\n\n# CDN\n\nContent Delivery Network，内容分发网络\n\n我们访问一个页面的时候，会请求很多资源，包括各种图片、声音、影片、文字等信息。这和我们要购买多种货物一样\n\n网站可以预先把内容分发至全国各地的加速节点。用户可以就近获取内容，避免网络拥堵、地域、运营商等因素带来的访问延迟问题\n\n\"内容分发网络\"像前面提到的\"全国仓配网络\"，解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景\n\n用户可就近取得所需内容，解决 Internet网络拥挤的状况\n\n> CDN本质 是一大堆遍布在全球各个 角落 的缓存服务器。通过与DNS的配合，找到最靠近用户的一台CDN缓存服务器，将数据快速 分发 给用户\n> \n> 减少对整体骨干网的流量负担，提高用户体验\n\nDNS解析之后，浏览器向服务器请求内容后发生\n\n\n\n长途骨干网的传输最耗时，需经过网站服务器所在的机房、骨干网、用户所在城局域网、用户所在接入网等，物理传输距离遥远\n\n1亿人同时请求12306上一张一模一样的图片，对国家的互联网基础设施是一个灾难\n\nCDN 提前把数据存在离用户最近的数据节点，避免长途跋涉经过长途骨干网，最终 减少骨干网负担、提高访问速度\n\n\n\n请求图片数据，先去CDN缓存服务器获取，若获取到数据直接返回，否则才 经过 长途骨干网，最终达到 网站服务器 获取数据\n\nCDN其实还缩短了请求数据的距离\n\n用户分布全国各地，一般会在 离用户在 较近的地方设置 CDN 缓存服务器，酱紫各个 地区的用户能直接请求对应的CDN服务器，不需要来回跑 大半个 中国！\n\n\n# 过程\n\n 1.  发起请求，本地 DNS 解析，将域名解析权交给域名 CNAME 指向的 CDN 专用 DNS 服务器\n 2.  CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回浏览器\n 3.  浏览器向 CDN 全局负载均衡设备发起 URL 请求\n 4.  CDN 全局负载均衡设备根据用户 IP ，以及URL，选择一台用户所属区域的区域负载均衡设备，向其发请求\n 5.  区域负载均衡设备为用户选最合适的 CDN 缓存服务器（考虑的依据包括：服务器负载情况，距离用户的距离等），返回给全局负载均衡设备\n 6.  全局负载均衡设备将选中的 CDN 缓存服务器 IP 返回给用户\n 7.  根据用户IP，判断最近边缘节点\n 8.  根据用户请求URL中内容，判断有用户所需内容的边缘节点\n 9.  查询边缘节点负载情况，判断有服务能力的边缘节点\n 10. 全局负载均衡设备将服务器IP返回给用户\n 11. 用户向 CDN 缓存服务器发起请求，缓存服务器响应用户请求，最终将内容返回\n\n\n# 组成\n\n（CDN）由多个节点组成。一般，CDN网络主要由中心节点、边缘节点两部分构成\n\n> 中心节点\n\n中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理\n\n> 边缘节点\n\nCDN边缘节点主要指异地分发节点，有负载均衡设备、高速缓存服务器两部分\n\n负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点 工作效率；同时负责收集节点与周围环境的信息，保持与全局负载均衡DNS的通信，实现整个系统的负载均衡\n\n高速缓存服务器（Cache）负责存储客户网站信息，像一个靠近用户的网站服务器一样响应本地用户的请求\n\n通过全局负载均衡DNS的控制，用户的请求被透明 指向离他最近的节点，节点中Cache服务器像网站的原始服务器一样，响应终端用户的请求\n\n中心节点像仓配网络中负责货物调配的总仓，边缘节点就是负责存储货物的各个城市的本地仓库\n\n\n# 前端路由\n\n\n# location.replace/ href\n\nhref会写入 浏览器 window.history 对象中\n\nreplace不会，replace将当前URL替换，而非跳转，不会保存记录\n\nlocation.href=\"http://www.baidu.com\"\nlocation.replace(\"http://www.baidu.com\")\n\n\n1\n2\n\n\n\n# 前端路由\n\n * 路由是根据不同的 url 地址展示不同的内容或页面\n * 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。\n\n前端路由实现原理很简略，实质上就是检测 URL 的变动，截获 URL 地址，通过解析、匹配路由规定实现 UI 更新\n\n\n# SPA路由跳转实现\n\n不是真正的页面跳转，另一个角度来说，其实就是组件的挂载和卸载罢了。通过监听知道某一个组件的状态并对其进行渲染\n\n单页面应用中的路由分为两种: hash模式和history模式\n\n\n# hash模式\n\n监听浏览器地址hash值变化，执行事件\n\nhash会在浏览器URL后增加 # 号\n\n一个完整的的 URL 包含：协定、域名、端口、虚拟目录、文件名、参数、锚\n\n比如 https://www.google.com/#abc中的hash值为abc 特点：hash的变化不会刷新页面，也不会发送给服务器\n\n但hash的变化会被浏览器记录下来，用来指导浏览器中的前进和后退\n\n使用window.location.hash变化触发窗口的onhashchange事件，监听hash变化\n\n触发路由时视图容器更新——多数前端框架哈希路由的实现原理\n\n# 触发hashchange\n\n * URL变化(包括浏览器的前进、后退)修改window.location.hash的值\n * 浏览器发送http://www.baidu.com/ 至服务器，请求完毕后设置散列值为#/home，触发onhashchange\n * 只修改hash部分，不发请求，但触发onhashchange\n * a标签可设置页面hash，浏览器自动设置hash属性，触发onhashchange\n\nwindow.location.hash='abc';\nlet {hash}=window.location\nwindow.addEventListener('hashchange',function(){\n    //监听hash变化\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 特点\n\n * 不需要后端配合\n\n * 兼容性好\n\n * 路径在#后面，不好看\n\n\n# history模式\n\nH5新特性，允许我直接修改前端路由，更新URL但不重新发请求，history可自定义地址\n\nwindow.history属性指向 History 对象，它表示当前窗口的浏览历史，保存了当前窗口访问过的所有页面网址\n\n由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航\n\n// 后退到前一个网址\nhistory.back()\n\n// 等同于\nhistory.go(-1)\n\n\n1\n2\n3\n4\n5\n\n\n浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作\n\nHistory 对象主要有两个属性。\n\n * History.length：当前窗口访问过的网址数量（包括当前网页）\n * History.state：History 堆栈最上层的状态值（详见下文）\n\n// 当前窗口访问过多少个网页\nwindow.history.length // 1\n\n// History 对象的当前状态\n// 通常是 undefined，即未设置\nwindow.history.state // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n# history.back()、history.forward()、history.go()\n\n用于在历史之中移动\n\n * History.back()：移动到上一个网址，等于点击浏览器后退键。对于第一个访问的网址，该方法无效\n * History.forward()：移动到下一个网址，等于点击浏览器前进键。对于最后一个访问的网址，该方法无效果\n * History.go()：跳转到指定记录页，go(1)相当于forward()，go(-1)相当于back()。如果参数超过实际存在的网址范围，该方法无效；如果不指定参数，默认0，相当于刷新当前页面\n\n# history.pushState()\n\n在历史中添加一条记录，不会导致页面刷新\n\nwindow.history.pushState(state, title, url)\n\n\n1\n\n\n * state：对象，触发popstate事件将该对象传递到新页面。不需要可以填null\n\n * title：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串\n\n * url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址\n\n假定当前网址是example.com/1.html，使用pushState()方法在浏览记录（History 对象）中添加一个新记录\n\nvar stateObj = { foo: 'bar' };\nhistory.pushState(stateObj, 'page 2', '2.html');\n\n\n1\n2\n\n\n添加新记录后，浏览器地址栏立刻显示example.com/2.html，但并不会跳转到2.html，甚至也不会检查2.html是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问google.com)，然后点击了倒退按钮，页面的 URL 将显示2.html；再点击一次倒退按钮，URL 将显示1.html\n\npushState()不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应\n\n使用该方法之后，可以用History.state读出状态对象\n\nvar stateObj = { foo: 'bar' };\nhistory.pushState(stateObj, 'page 2', '2.html');\nhistory.state // {foo: \"bar\"}\n\n\n1\n2\n3\n\n\n如果pushState的 URL 参数设置了一个新的锚点值（即hash），不会触发hashchange事件。反过来，如果 URL 的锚点值变了，会在 History 对象创建一条浏览记录\n\n如果pushState()方法设置了一个跨域网址，报错\n\n// 报错\n// 当前网址为 http://example.com\nhistory.pushState(null, '', 'https://twitter.com/hello');\n\n\n1\n2\n3\n\n\npushState想要插入一个跨域的网址，导致报错。防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转\n\n# history.replaceState()\n\n修改 History 当前记录，其他与pushState()一模一样\n\n假定当前网页是example.com/example.html\n\nhistory.pushState({page: 1}, 'title 1', '?page=1')\n// URL 显示为 http://example.com/example.html?page=1\n\nhistory.pushState({page: 2}, 'title 2', '?page=2');\n// URL 显示为 http://example.com/example.html?page=2\n\nhistory.replaceState({page: 3}, 'title 3', '?page=3');\n// URL 显示为 http://example.com/example.html?page=3\n\nhistory.back()\n// URL 显示为 http://example.com/example.html?page=1\n\nhistory.back()\n// URL 显示为 http://example.com/example.html\n\nhistory.go(2)\n// URL 显示为 http://example.com/example.html?page=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# popstate事件\n\n当同一个文档的浏览历史变化触发popstate\n\n注意\n\n * 调用pushState()/replaceState() ，不会触发该事件\n\n * 只有点击浏览器倒退/前进，或调用History.back()、History.forward()、History.go()才会触发\n\n * 只针对同一个文档，如果浏览历史切换，导致加载不同文档，不会触发\n\npopstate指定回调函数\n\nwindow.onpopstate = function (event) {\n  console.log('location: ' + document.location);\n  console.log('state: ' + JSON.stringify(event.state));\n};\n\n// 或者\nwindow.addEventListener('popstate', function(event) {\n  console.log('location: ' + document.location);\n  console.log('state: ' + JSON.stringify(event.state));\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n回调函数参数event事件对象，state指向当前状态对象，这个state也可以通过history对象读取\n\nvar currentState = history.state;\n\n\n1\n\n\n页面第一次加载不会触发popstate事件\n\n# 特点\n\n路径正规\n\n兼容性不比hash，需服务端支持\n\n对于一个应用而言，url 的改变(不包括 hash 值得改变)只能由下面三种情况引起：\n\n * 点击浏览器的前进或后退按钮 => 可以监听popstate事件\n * 点击 a 标签\n * 在 JS 代码中触发 history.pushState()、history.replaceState()\n\nhistory router的实现思路是：监听页面中和路由有关的a标签点击事件，阻止默认的跳转行为，然后调用history.pushState()方法，让浏览器记住路由，手动更新相应视图。为了监听用户手点击浏览器的前进后退按钮，还需要监听popstate事件，动态的修改相应视图\n\n\n# ✅ 页面生命周期\n\n\n\n包含三个重要事件：\n\n * DOMContentLoaded —— 已完全加载 HTML，并构建了 DOM 树，像 <img> 和样式表之类的外部资源可能尚未加载完成\n * load —— 浏览器不仅加载完成了 HTML，还加载完了所有外部资源：图片，样式等\n * beforeunload/unload —— 用户正在离开页面时\n\n每个事件都有用：\n\n * DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口\n * load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知\n * beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开\n * unload 事件 —— 用户几乎已经离开，但是我们仍然可以启动一些操作，例如发送统计数据\n\n\n# DOMContentLoaded\n\n遇到script标签，会在DOM构建之前运行它，因为脚本可能修改DOM，所以DOMContentLoaded必须等待脚本执行结束\n\n外部样式表不影响DOM，因为DOMContenLoaded不会等待他们\n\n但是，如果在样式后面有一个脚本，该脚本必须等待样式表加载完成：\n\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n<script>\n  // 在样式表加载完成之前，脚本都不会执行\n  alert(getComputedStyle(document.body).marginTop);\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n原因是，脚本可能想要获取元素的坐标或其他与样式相关的属性，如上例所示。必须等待样式加载完成\n\n当 DOMContentLoaded 等待脚本时，它也在等待脚本前面的样式\n\n\n# 不会阻塞 DOMContentLoaded 的脚本\n\n 1. 具有 async 特性的脚本不会阻塞 DOMContentLoaded\n 2. 使用 document.createElement('script') 动态生成并添加到网页的脚本也不会阻塞 DOMContentLoaded\n\n\n# onload\n\n当整个页面，包括样式、图片和其他资源被加载完成时，触发 window 对象上的 load 事件\n\n\n# onunload\n\n当访问者离开页面时，window 对象上的 unload 事件就会被触发。我们可以做一些不涉及延迟的操作，例如关闭相关的弹出窗口\n\n> 和onpagehide事件相互替换的是\n> \n> onunload\n> \n> 用户离开网页执行onpagehide，但onunload无法缓存页面\n\n\n# onbeforeunload\n\n如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，beforeunload 处理程序将进行更多确认\n\n如果我们要取消事件，浏览器会询问用户是否确定\n\n\n# readyState\n\n如果我们在文档加载完成之后设置 DOMContentLoaded 事件处理程序，会发生什么？\n\n> 它永远不会运行\n\n在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后\n\ndocument.readyState 属性可以为我们提供当前加载状态的信息\n\n它有 3 个可能值：\n\n * loading —— 文档正在被加载\n * interactive —— 文档被全部读取\n * complete —— 文档被全部读取，所有资源（例如图片等）都已加载完成\n\n所以，我们可以检查 document.readyState 并设置一个处理程序，或在代码准备就绪时立即执行它\n\n\n# 🌰CSS、JS位置问题\n\n渲染引擎判断脚本时，HTML解析器暂停DOM解析，JS引擎介入，因为JS脚本可能修改当前已生成DOM\n\n如果JS脚本通过文件加载，需先下载JS代码，JS文件下载会阻塞DOM解析，下载耗时，受到 网络、文件大小 因素影响\n\n如果脚本内嵌，则 直接执行，阻塞DOM构建\n\n如果JS脚本修改 DOM内容，执行脚本后，div被修改，HTML解析器恢复解析过程\n\n如果JS代码出现修改CSS的语句，操纵 CSSDOM，执行JS前，先解析JS语句之上所有CSS样式，如果引用外部CSS文件，执行JS前，需等待外部CSS文件下载完成，解析生成CSSOM后，才执行 JS 脚本\n\n解析JS前，不知道JS是否操纵CSSOM，所以渲染引擎遇到JS脚本时，不管该脚本是否操纵了CSSOM，都会执行CSS文件下载，解析，再执行JS脚本，构建DOM，生成布局树\n\n所以JS脚本依赖样式表\n\n> JS文件下载会阻塞DOM解析\n> \n> 样式文件会阻塞JS执行\n\n> JS阻塞了啥\n\nJS文件放在head中，构建DOM树遇到JS文件加载会阻塞，直到JS加载执行完页面都是空白！\n\nscript标签最好放在body，浏览器为了用户体验 渲染引擎尝试尽快显示，不会等到所有DOM解析完成 才布局渲染树，JS阻塞发生时，将已经构建的DOM元素渲染，减少白屏——这就是为啥将script标签放body标签底部的原因，不影响前面页面渲染\n\n有了async和defer，script标签位置不再那么重要\n\n> CSS阻塞了啥\n\n解析HTML遇到link/style标签 会计算样式，构建CSSOM\n\nCSS不会阻塞DOM树构建，但会阻塞页面显示，因为 构建CSSOM过程中，不渲染任何内容，即便DOM解析完毕，只要CSSOM没构建好，不显示\n\n如果link标签前有DOM元素，加载CSS阻塞时，浏览器会将前面已经构建好的DOM元素渲染到屏幕上，减少白屏时间\n\n但是，会出现 页面闪烁！**因此将CSS标签放在head中，如果放在body标签前面，因为CSS不阻塞DOM构建，**DOM树构建完成 render树渲染，渲染树构建完成，浏览器不得不re-render，造成资源浪费，在head中，边构建边渲染，效率更高\n\n放在head尽早加载，减少请求阻塞时间\n\n> script放head和body\n\nhead中，代表的function只加载不执行\n\nbody中，加载并执行\n\n\n# 🍉 defer、async\n\nDOMContentLoaded触发时间：HTML文档被加载解析完成\n\n\n\n\n\n\n# sync 同步\n\n\n\n\n# async 异步\n\n 1. HTML未被解析完，async脚本已经加载完，HTML停止解析去执行脚本\n\n\n\n 2. HTML解析完，async脚本才加载完，再执行脚本\n\n\n\n\n# defer 延迟\n\n不影响HTML解析，HTML解析完才执行，阻止 DOMContentLoaded，直到脚本被加载且解析完成\n\n 1. HTML未解析完，defer脚本加载完毕，defer等HTML解析完再执行\n\n\n\n 2. HTML解析完，defer脚本还没加载完毕，defer脚本继续加载，加载完直接执行\n\n\n\n\n# 总结\n\nscript标签属性\n\n脚本下载执行和文档解析同步，会阻塞文档解析，若控制不好，会造成页面卡顿\n\n可以在script声明defer和async （仅适用外部脚本）\n\ndefer：HTML解析完成后按照脚本出现次序 顺序执行，构建DOM树和JS文件的加载 并行 执行，JS文件执行在DOM树构建完成之后\n\nasync：H5新增，下载完成立即执行，阻塞页面解析，**谁先下载好谁执行 **\n\nasync脚本和DOMContentLoaded不会彼此等待\n\n\n\n推荐与主业务无关的JS脚本使用async，例如 监控、广告 脚本，它们都是独立的文件，没有外部依赖，无需访问DOM，使用async有效避免 非核心功能的加载影响页面解析速度\n\n\n# 💚 排序\n\n\n# 数组、链表\n\n数据的物理存储结构：连续存储（数组）离散存储（链表）\n\n区别：\n\n对数组，查找方便，连续存储，增删改效率低；事先申请好连续的内存空间小，太大浪费内存，太小越界\n\n对链表，动态申请内存空间，不需要提前申请好内存的大小，只需在用的时候申请就可以，根据需要动态申请或者删除内存空间，对数据增加和删除以及插入比数组灵活\n\n应用场景：\n\n数组：数据量固定，频繁查询，较少增删的场景\n\n链表：数据量不固定，频繁增删，较少查询的场景\n\n * 单向链表：线型数据结构，指针指向下一个节点，终点指向null\n * 双向链表：可以往前或者往后添加节点，指针指向前一个节点和后一个节点\n\n\n# 链表在JS的应用\n\n原型链\n\nhooks state存储\n\nfiber架构的fiber数据结构本身是链表结构\n\n\n# 选择排序\n\n> 买苹果每次都选择最大的\n\n找到数组最小的元素，将其和数组第一个元素交换位置\n\n在剩下的元素中找到最小的元素，将其与数组第二个元素交换位置\n\n如此往复，直到整个数组排序\n\nfunction selectSort(arr) {\n    let len = arr.length;\n    let minIndex;\n    for (let i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (let j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return arr;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 1. 无论什么数据进去都是 O(n²) 的时间复杂度\n 2. 空间复杂度O(1)\n 3. 非稳定排序\n 4. 原地排序\n\n\n# 冒泡\n\n第一个元素和第二个元素比较，如果第一个比第二个大，则交换\n\n继续比较第二个和第三个元素，若第二个比第三个大，则交换……\n\n对每一个相邻元素做同样工作，从第一对开始到最后一对结尾，一趟比较下来后，排在最后的元素是最大元素\n\nfunction bubbleSort(arr) {\n    if (arr.length < 2) {\n        return arr;\n    }\n    const len = arr.length;\n    for (let i = 0; i < len - 1; i++) {\n        for (let j = 0; j < len - i - 1; j++) {\n            if (arr[j + 1] < arr[j]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 1. 时间复杂度O(n²)\n 2. 空间复杂度O(1)\n 3. 稳定排序\n 4. 原地排序\n\n\n# 优化\n\n如果从第一队到最后一对，相邻元素间没有交换，意味着右边的元素总是≥左边元素，此时数组有序，无需再对剩下元素重复比较\n\nfunction bubbleSortPerformance(arr) {\n    if (arr.length < 2) {\n        return arr;\n    }\n    const len = arr.length;\n    for (let i = 0; i < len - 1; i++) {\n        let flag = true;\n        for (let j = 0; j < len - i - 1; j++) {\n            if (arr[j + 1] < arr[j]) {\n                flag = false;\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n        if (flag) {\n            break;\n        }\n    }\n    return arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n如何优化？\n\n优化后时间复杂度？\n\n与快排相比？\n\n快排思路？\n\n相比冒泡，快排每次交换是跳跃式。每次排序设置基准点，将≤基准点的数放到基准点左边，将大≥基准点的数放到基准点右边。这样每次交换不会像冒泡每次只在相邻数间交换，交换距离大的多。因此总比较和交换次数少，速度提高。最坏的情况仍可能是相邻两数交换\n\n\n# ❤️ 插入排序\n\n适合处理数据量少或部分有序的数据(移动少)\n\n 1. 从第二个元素开始抽取\n 2. 把它和左边第一个元素比较，若左边第一个元素比它大，则继续与左边第二个元素比较，直到遇到比它小的元素，然后插入到这个元素的右边\n 3. 继续选取第 3 4 ...n个元素，重复步骤2，选择适当位置插入\n\nfunction insertSort(arr) {\n    let preIndex = 0;\n    let curVal = 0;\n    for (let i = 1; i < arr.length; i++) {\n        preIndex = i - 1;\n        curVal = arr[i];\n        while (preIndex >= 0 && arr[preIndex] > curVal) {\n            //腾出位置插入\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex--;\n        }\n        //插入元素\n        arr[preIndex + 1] = curVal;\n    }\n    return arr;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 1. 时间复杂度O(n)，最坏时间复杂度为O(n²)\n 2. 空间复杂度O(1)\n 3. 稳定排序\n 4. 原地排序\n\n\n# ❤️ 希尔排序\n\nlet arr=[16,9,49,7,1,45,23,13]\ngap=4\n一趟排序后 数组为\n\n\n1\n2\n3\n\n\n对大规模且无序数据有效率\n\n对 数组 进行 多次 间隔的 插入排序\n\n加速简单改进了插入排序，交换不相邻元素对数组局部排序\n\n先让数组中任意间隔为h的元素有序，刚开始h可以为n/2，接着使h=n/4，h一直缩小，当h=1时，即，此时数组中任意间隔为1的元素有序\n\nfunction shellSort2(arr) {\n    const len = arr.length;\n    let gap = Math.floor(len);\n    while (gap) {\n        for (let i = gap; i < len; i++) {\n            const tmp = arr[i];\n            let j;\n            for (j = i - gap; j >= 0 && tmp < arr[j]; j -= gap) {\n                arr[j + gap] = arr[j];\n            }\n            arr[j + gap] = tmp;\n        }\n        gap = Math.floor(gap / 2);\n    }\n    return arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n对各个分组插入时并不是先对一个组排序完成后再对另一个组排序，而是轮流对每个组排序\n\n 1. 时间复杂度O(nlogn)\n 2. 空间复杂度O(1)\n 3. 非稳定排序\n 4. 原地排序\n\n\n# 💙 归并(讲过)\n\n分治法\n\n大的数组一分为二，分别对2个数组排序，然后将其合并一个有序数组\n\n递归，分割数组，直到数组大小为1，然后\n\n把2个数组大小为1的合并为一个大小为2的，再把大小为2的合并为大小为4的，直到全部小数组都合并\n\nlet arr = [2, 11, 10, 6, 12, 3, 4, 8, 9, 5, 1, 15, 13, 7, 14];\n\nfunction mergeSort(arr) {\n//    自上而下递归法\n    let len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n    let mid = Math.floor(len / 2);\n    let left = arr.slice(0, mid);\n    let right = arr.slice(mid);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n    let res = [];\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            res.push(left.shift());\n        } else {\n            res.push(right.shift());\n        }\n    }\n    while (left.length) {\n        res.push(left.shift());\n    }\n    while (right.length) {\n        res.push(right.shift());\n    }\n    return res;\n}\n\nconsole.log(mergeSort(arr));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n 1. 时间复杂度O(nlogn)，切logn次，合并一个大的有序数组为O(n)\n 2. 空间复杂度O(n)\n 3. 稳定排序\n 4. 非原地排序\n\n\n# 💙 快排\n\n分治法\n\n选取一个元素作为中轴元素，把所有小于中轴的元素放在左边，所有≥中轴的元素放在右边，此时，中轴所处位置有序\n\n从中轴开始将大树组切割为2个小数组，递归让中轴左边数组和右边数组执行同样操作，直到数组大小为1\n\nfunction quickSort1(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    let pivotIndex = Math.floor(arr.length / 2);\n    //返回删除的元素\n    let tmp=arr.splice(pivotIndex, 1);\n    let pivot = tmp[0];\n    let left = [];\n    let right = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return quickSort1(left).concat([pivot], quickSort1(right));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 1. 时间复杂度O(nlogn)\n 2. 空间复杂度O(logn)\n 3. 非稳定排序\n 4. 原地排序\n\n不像归并，还需要辅助数组\n\n不像归并，需要把2部分有序子数组汇总到临时数组，还要copy回原数组\n\n\n# 堆排序\n\n堆顶元素是最值，将堆顶元素和最后一个元素交换，交换后破坏堆的特性，再把剩下元素再次构成一个大顶堆，把堆顶元素和最后第二个元素交换\n\n往复……\n\n\n\n\n\n\n\n删除包括3个步骤\n\n 1. 交换堆顶与堆最后一个元素\n 2. 堆大小-1\n 3. 调整堆\n\n\n\n\n1\n\n\n\n# 计数排序\n\n适用于最大值和最小值差值不大的排序\n\n数组元素作为数组下表，临时数组统计该元素出现次数，最后汇总\n\nfunction cntSort(arr) {\n    const maxVal = Math.max.apply(null, arr);\n    //元素出现的次数\n    const count = Array(maxVal + 1).fill(0);\n    arr.forEach(item => {\n        count[item]++;\n    })\n    let ans = [];\n    for (let i = 0; i < count.length; i++) {\n        while (count[i]--) {\n            ans.push(i);\n        }\n    }\n    return ans;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n 1. 时间复杂度O()\n 2. 空间复杂度O(ans.length)\n 3. 稳定排序\n 4. 非原地排序\n\n\n# 优化\n\n偏移量，min=1000，max=1005，临时数组大小为(max-min+1)即可\n\n\n# 桶排序\n\n计数排序不适用时，可以使用桶排序\n\n把最大值和最小值间的数瓜分，例如分成10个区间，对应10个桶，把元素放到对应区间的桶，在对每个桶中数进行排序，合并汇总\n\n\n\n\n# 基数排序\n\n先以个位数大小对数据排序，接着以十位数大小排序，接着是百位……\n\n以某位数排序时，用 桶 排序\n\n将相同数值元素放进同一个桶，再把桶里的数按照0-9的顺序取出来，一趟下来，按照某位数的排序就完成了\n\n\n\n\n1\n\n\n不建议以最高位排序，致命问题——对各部分 单独排序，每一部分类似于原问题的子问题，采用递归处理，每个小部分 排序中，需要10个桶将它们排序 ，导致空间花费大\n\n\n# 总结\n\n\n\n\n# others\n\n\n# UTF-8、UTF-16、Unicode\n\nASCII 可以表示的编码有限，想表示其他语言的编码，需要使用 Unicode，Unicode可以说是 ASCII的超集\n\nUnicode是字符集，为每种语言的每个字符设定 **统一且唯一 的二进制编码 **\n\nUnicode的编码方式有很多，常见的是 UTF-8、UTF-16\n\nUTF-8判断每个字节中的开头标志信息，如果某个字节在传送过程出错，会导致后面的字节解析出错；UTF-16不会判断开头标志，即使错只会错一个字符，容错能力较强\n\n字符内容 英文占大多数，UTF-8比UTF-16更节省空间；如果中文占多数，UTF-16占优势\n\n\n# JS二进制\n\n谈谈JS二进制：File、Blob、FileReader、ArrayBuffer、Base64\n\nJS提供API处理文件或原始文件数据\n\nFile、Blob、FileReader、ArrayBuffer、base64\n\n\n\nBlob及binary large object，二进制大对象，表示原始类似文件的数据\n\nblob对象是包含只读原始数组的类文件对象，就是一个不可修改的二进制文件\n\n\n# base64\n\n把不可见字符转换为可见字符\n\n1、字符三三分组，不够0补齐\n\n> 为啥是三三分组？\n> \n> 因为ASCII码每个字符时8位二进制，3*8=24，正好可以被第三步拆分为4个6位二进制\n\n2、把字符转换为二进制ASCII编码，再转换为二进制\n\n3、二进制，六位分隔开\n\n4、6位二进制能代表0-63\n\n\n\n补位产生的0，使用=表示\n\nabcd->YWJjZA==\n\n\n1\n\n\n> 图片base64、URL\n\n前端传给后端的是base64编码的字符串，后端将解码的图片存起来\n\n后端返回图片数据流，前端解析？\n\n将图片转换blob，通过 blob 创建 URL\n\n\n# 位运算\n\n运算符   描述   运算规则\n&     与    两个位都为1时，结果才为1\n|     或    两个位都为0时，结果才为0\n^     异或   两个位相同为0，相异为1\n~     取反   0变1，1变0\n<<    左移   各二进制位全部左移若干位，高位丢弃，低位补0\n>>    右移   各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃\n\n&\n\n判断奇偶，最末位是0就是偶数，为1就是奇数\n\nif ((i & 1) == 0)\n    //等价\nif (i % 2 == 0 )\n\n\n1\n2\n3\n\n\n> 原码 补码 反码\n\n符号位和数值位，符号位 0 表示 正，1 表示 负\n\n原码\n\n数的 二进制\n\n反码\n\n * 正数的反码和原码相等\n * 负数的反码为 除符号位，按位取反\n\n-10\n原码 1000 1010\n反码 1111 0101\n\n\n1\n2\n3\n\n\n补码\n\n * 正数的补码 与 原码 相同\n * 负数的补码 是原码 除符号位外的所有位 取反，再加1（即 反码+1）\n\n-10\n原码 1000 1010\n反码 1111 0101\n补码 1111 0110\n\n\n1\n2\n3\n4\n\n\n\n# 点击事件延迟\n\n移动端点击有 300ms 的延迟，因为移动端有双击缩放操作，浏览器在 click 之后要等待 300ms（JS捕获click事件的回调处理），看用户有没有下一次点击，判断这次操作是不是双击\n\n有三种办法解决这个问题：\n\n * meta 标签禁用网页的缩放\n\n<meta name=\"viewport\" content=\"width=device-width user-scalable= 'no'\">\n\n\n1\n\n * 更改默认视口宽度\n\n<meta name=\"viewport\" content=\"width=device-width\">\n\n\n1\n\n\n如果能识别网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并去掉300ms的点击延迟\n\n * 调用 js 库，比如 FastClick\n\nclick 延时问题可能引起点击穿透，如在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件\n\n\n# 滚动穿透\n\n若页面超过一屏高度出现滚动条时，fixed定位的弹窗遮罩层上下滑动，下面的内容也会一起滑动——滚动穿透\n\n1、默认情况，平移（滚动）和缩放手势由浏览器专门处理，但可通过 CSS 特性 touch-action 改变触摸手势的行为\n\n2、\n\nStep 1、监听弹窗最外层元素（popup）的 touchmove 事件并阻止默认行为来禁用所有滚动（包括弹窗内部的滚动元素） Step 2、释放弹窗内的滚动元素，允许其滚动：同样监听 touchmove 事件，但是阻止该滚动元素的冒泡行为（stopPropagation），使得在滚动的时候最外层元素（popup）无法接收到 touchmove 事件\n\n\n# 滚动溢出\n\n弹窗内也含有滚动元素，在滚动元素滚到底部或顶部时，再往下或往上滚动，也会触发页面的滚动，这种现象称之为滚动链（scroll chaining）， 也称为滚动溢出（overscroll）\n\n借用 event.preventDefault 的能力，当组件滚动到底部或顶部时，通过调用 event.preventDefault 阻止所有滚动，从而页面滚动也不会触发了，而在滚动之间则不做处理\n\n\n# with\n\n> 警告：混淆错误和兼容性的问题\n\n扩展一个语句的作用域链\n\n\n# if内的函数？\n\nlet phrase = \"Hello\";\nif (true) {\n  let user = \"John\";\n  function sayHi() {\n    alert(`${phrase}, ${user}`);\n  }\n}\n\nsayHi();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * https://zh.javascript.info/closure这里说因为if内声明的函数，所以报错\n * 实际运行，能够正常输出值\n\n\n# polyfills\n\n补丁\n\n例如浏览器太老，不支持Promise，我们可以自己定制实现现代语言功能\n\nif (!window.Promise) {\n  window.Promise = ... // 定制实现现代语言功能\n}\n\n\n1\n2\n3\n\n\n\n# use strict\n\nECMAscript5 添加的（严格）运行模式，使 JS 在更严格的条件下运行\n\n * 消除 JS 语法的一些不合理、不严谨之处，减少一些怪异行为\n * 消除代码运行的一些不安全之处，保证代码运行的安全\n * 提高编译器效率，增加运行速度\n * 为未来新版本的 JS 做好铺垫\n\n区别：\n\n * 1.禁止使用 with 语句\n * 2.禁止 this 关键字指向全局对象\n * 3.对象不能有重名的属性\n\n只要函数参数使用了默认值、解构赋值、或者扩展运算符，函数内部就不能显式设定为严格模式，否则会报错\n\nvar num = 117\n\nfunction func1() {\n    console.log(this.num)\n}\n\n(function () {\n    \"use strict\";\n    func1()\n})()\n\"use strict\"\n\nfunction func2() {\n    console.log(this.num)\n}\n\nsetTimeout(function () {\n    func2.call(this)\n}, 0)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 定时刷新\n\nsetInterval不行，5s一刷新，万一请求10s返回数据，不久轮询了，直接卡死\n\nsetTimeout\n\nrequestAnimationFrame\n\n<meta http-equiv=\"refresh\" content=\"20\">\n \n// 注释：其中20指每隔20秒刷新一次页面\n\n\n1\n2\n3\n\n\n\n# 切面编程\n\n/*实现在function的原型链新增before(fn),after(fn)两个函数*/\n\nFunction.prototype.before = function (beforeFn) {\n    let _this = this;\n    return function () {\n        beforeFn.apply(this, arguments);\n        return _this.apply(this, arguments)\n    }\n}\nFunction.prototype.after = function (afterFn) {\n    var _self = this;\n    return function () {\n        var ret = _self.apply(this, arguments);\n        afterFn.apply(this, arguments);\n        return ret;\n    }\n}\nlet func1 = () => console.log('func1');\nfunc1 = func1.before(() => {\n    console.log('==before==');\n}).after(() => {\n    console.log('==after');\n});\nlet func2 = () => console.log('func2');\nfunc2 = func2.before(() => {\n    console.log('==before==');\n}).after(() => {\n    console.log('==after');\n});\n\nfunction main() {\n    func1();\n    func2();\n}\n\nmain()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n面向切面编程(AOP) 和面向对象编程(OOP)一样，是编程范式\n\nAOP主要应用在 与核心业务无关但又在多个模块使用的功能比如权限控制、日志记录、数据校验、异常处理等领域\n\n\n# 尾递归\n\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n]递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误\n\n> 为啥尾递归优化\n\n\n# 解构赋值\n\n是ES6提供的语法糖，针对可迭代对象的Iterator接口，按顺序获取对应的值赋值\n\nfor...of...也是遍历器，遍历数据结构时，寻找Iterator接口\n\nIterator——为各种数据解构提供统一访问接口，使数据结构能按次序排列处理\n\n> 解构赋值，是浅拷贝！\n\n解构的不定参数只能出现在 最后一个位置！\n\n> 解构多层对象嵌套\n\n使用 可选链 或 判断空值 解决\n\n\n# ES2022\n\n以前定义实例的默认值，只能通过constructor定义\n\n现在\n\nclass Counter {\n  num = 0;\n}\n\n\n1\n2\n3\n\n\nstatic声明静态字段和方法，静态类字段和方法属于整个类，并非某一具体的实例\n\nclass Counter {\n  // 静态字段\n  static NUM = 1\n  // 静态方法\n  static getNUM() {\n    return this.NUM\n  }\n}\n\n//只能通过类来直接访问类的静态字段和静态方法\nconsole.log(Counter.NUM) //1\nconsole.log(Counter.getNUM()) // 1\n\n// 无法通过实例访问类的静态字段和静态方法\nconst counter = new Counter()\nconsole.log(counter.NUM) // undefined\nconsole.log(counter.getNUM()) // TypeError: counter.getNUM is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n以前await只能和async用，限制一些场景，如在全局作用域使用import的异步加载方式\n\n可以使用.at()取数组的倒数元素\n\n\n# 拖拽\n\n * dragstart 元素被拖拽时触发【拖拽元素上绑定】\n * dragend 被拖拽元素结束拖拽时触发【拖拽元素上绑定】\n * dragover 被拖拽元素拖入目标区域后 触发 【目标区域绑定事件】\n * drop 被拖拽元素拖入目标区域结束 触发 【在目标区域绑定】",normalizedContent:"# ❤️ 全局属性/函数\n\n属性          描述\ninfinity    正无穷大\nnan         某个值是不是数字值\nundefined   未定义\n\n函数                     描述\ndecodeuri()            解码某个编码的 uri\ndecodeuricomponent()   解码一个编码的 uri 组件\nencodeuri()            把字符串编码为 uri\nencodeuricomponent()   把字符串编码为 uri 组件\nescape()               对字符串进行编码\neval()                 计算 js 字符串，把它作为脚本代码执行\nisfinite()             检查某个值是否为有穷大的数\nisnan()                检查某个值是否是数字\nnumber()               把对象的值转换为数字\nparsefloat()           解析一个字符串返回一个浮点数\nparseint()             解析一个字符串返回一个整数\nstring()               把对象的值转换为字符串\nunescape()             对由 escape() 编码的字符串解码\n\n\n# isnan、number.isnan\n\nisnan 尝试将参数转换为数值，任何不能被转换为数值的的值都返回 true，因此非数字值传入也返回 true ，会影响 nan 的判断\n\nnumber.isnan 先判断参数是否为数字，如果是数字继续判断是否为 nan ，对于 nan 的判断更为准确\n\nfunction typeofnan(x) {\n  if (number.isnan(x)) {\n    return 'number nan';\n  }\n  if (isnan(x)) {\n    return 'nan';\n  }\n}\n\nconsole.log(typeofnan('100f'));\n// expected output: \"nan\"\n\nconsole.log(typeofnan(nan));\n// expected output: \"number nan\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# isfinite、isnan\n\n * infinity和-infinity是特殊数值\n\n * nan代表一个error\n\n都是number类型，但不是\"普通\"数字\n\nisnan(val)，将val转换为数字，再测试是否为nan\n\nisnan(nan);//true\nisnan('merry');//true\n\n\n1\n2\n\n\nnan独一无二，不等于任何东西，包括自身\n\nnan===nan;//false\n\n\n1\n\n\nisfinite(val)将val转换为数字，若是常规数字而不是nan/infinity/-infinity，则返回true\n\nisfinite(11);//true\nisfinite(\"merry\");//false 因为是nan\nisfinite(infinity);//false 因为是infinity\n\n\n1\n2\n3\n\n\n> 在所有数字函数中，包括isfinite，空字符串或只有空格的字符串都被视为0\n\n\n# parseint、parsefloat\n\n> +'le'==parseint('le')//false\n> \n> 因为nan不等于nan\n\n+和number()转换数字是严格的，若一个值不完全是数字，会失败\n\nconsole.log(+\"100px\");//nan\nconsole.log(+\" \");//0\n\n\n1\n2\n\n\n从\"100px\"，\"12pt\"中将数值提取出来，parseint和parsefloat派上用场，它们可以从字符串中读取数字，直到无法读取位置，若出现error，则返回收集到的数字\n\nparseint(\"100px\");//100\nparseint(\"11.22px\");//11\n\nparsefloat(\"12.33px\");//12.33\nparsefloat(\"12.3.4\");//12.3\n\n\n1\n2\n3\n4\n5\n\n\n没有数字可读取时，返回nan\n\nparseint(\"a123\");//nan\n\n\n1\n\n\n> parseint(str,radix)\n\nalert( parseint('0xff', 16) ); // 255\nalert( parseint('ff', 16) ); // 255，没有 0x 仍然有效\n\nalert( parseint('2n9c', 36) ); // 123456\n\n\n1\n2\n3\n4\n\n\n\n# escape、encodeuri、encodeuricomponent\n\nescapeuri(已废弃)，16进制转义序列。当该值小于等于 0xff 时，用一个 2 位转义序列: %xx 表示。大于则使用 4 位序列：%uxxxx 表示\n\n对整个 uri 转义，将非法字符转换为合法字符，一些特殊意义的字符不会转义\n\nescape和encodeuri作用相同，对unicode编码为0xff之外字符有区别\n\n * escape直接在字符unicode编码前加上%u\n * encodeuri将字符转换为utf-8格式，再在每个字符前加上%\n\nencodeuricomponent 对uri 的组成部分转义，一些特殊字符也会转义\n\nencodeuricomponent和encodeuri异同？\n\nvar set1 = \";,/?:@&=+$\";  // 保留字符\nvar set2 = \"-_.!~*'()\";   // 不转义字符\nvar set3 = \"#\";           // 数字标志\nvar set4 = \"abc abc 123\"; // 字母数字字符和空格\n\nconsole.log(encodeuri(set1)); // ;,/?:@&=+$\nconsole.log(encodeuri(set2)); // -_.!~*'()\nconsole.log(encodeuri(set3)); // #\nconsole.log(encodeuri(set4)); // abc%20abc%20123 (空格被编码为 %20)\n\nconsole.log(encodeuricomponent(set1)); // %3b%2c%2f%3f%3a%40%26%3d%2b%24\nconsole.log(encodeuricomponent(set2)); // -_.!~*'()\nconsole.log(encodeuricomponent(set3)); // %23\nconsole.log(encodeuricomponent(set4)); // abc%20abc%20123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n为避免服务器收到不可预知的请求，对用户输入的任何作为uri的部分都应使用encodeuricomponent转义\n\n\n# es6特性\n\n 1. const、let\n\n 2. 模板字符串\n\n 3. 箭头函数\n\n 4. 函数参数默认值\n\n 5. 对象、解构赋值\n\n 6. for...of 用于数组，for...in用于对象\n\n 7. promise\n\n 8. 展开运算符(...)\n\n 9. 对象字面量、class(原型链的语法糖)\n    \n    // es5\n    // 构造函数\n    function person(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n    // 原型方法\n    person.prototype.getname = function() {\n      return this.name\n    }\n    // es6\n    class person {\n      constructor(name, age) {  // 构造函数\n        this.name = name;\n        this.age = age;\n      }\n      getname() {   // 这种写法表示将方法添加到原型中\n        return this.name\n      }\n      static a = 20;  // 等同于 person.a = 20\n      c = 20;   // 表示在构造函数中添加属性 构造函数中等同于 this.c = 20\n    // 箭头函数的写法表示在构造函数中添加方法，构造函数中等同于this.getage = function() {}\n      getage = () => this.age   \n    \n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n\n\n# 🌈 内存空间\n\n\n# 栈\n\n一块连续内存区域，容量小 ，基本用完就回收，相对 存取速度更快，为先进先出结构，自动分配 固定大小的内存空间，系统自动释放\n\n基本数据类型按值存在栈内存中，占用内存空间由 系统自动分配和释放，内存可及时回收，容易管理内存空间\n\n栈空间就是js的调用栈，存储执行上下文及执行上下文中基本类型的小数据\n\n> 变量环境：存放var和函数声明的变量，编译时确定，不受块级作用域影响\n> \n> 词法缓存：存放let和const声明的变量空间，编译时不能完全确定，受块级作用域影响\n\nv8把数字分成 ：smi 和 heapnumber\n\nsmi是 -2³¹ 到 2³¹-1的整数，栈中直接存值；其余数字类型都是heapnumber，另外开辟堆空间储存，变量保存引用\n\n\n# 堆\n\n不连续内存区域，容量大，存储大数据，堆中对象不会随方法结束而销毁，没有被引用时被回收掉 ，动态分配内存，内存大小不固定，不会自动释放，无序的树状结构\n\n\n# ⭐️数据类型\n\n引用数据类型包括对象、数组和函数等\n\n> 原始类型\n\nundefined ,null ,boolean,number,string\n\nes6新增symbol和bigint\n\n * symbol 代表独一无二的值，用法是为对象定义唯一属性名\n * bigint 表示任意大小的整数， 指安全存储、操作大整数\n\n> 引用类型\n\n\n# null、undefined\n\n * 两个基本数据类型\n * undefined 未定义，null 空对象。一般变量声明了但没有定义返回 undefined，null 主要给一些可能返回对象的变量赋值，作为初始化\n * undefined 在 js 中不是一个保留字，我们可以使用 undefined 作为一个变量名，这样非常危险，它会影响我们对 undefined 的判断。但我们可以获得安全的 undefined 值，比如说 void 0(此运算符优先级较高)\n\n> let undefiend = 'test' 覆盖 js自身undefined？\n\njs为全局创建一个只读的undefined，但没有彻底禁止局部undefined变量的定义\n\n * 使用 typeof ，null 返回 “object”，历史遗留问题。当我们使用==比较两种类型 时返回 true，使用===返回 false\n\n> typeof null=\"object\"?\n\n在第一版js中，变量的值被设计保存在一个32位内存单元中。在变量的机器码的低位 1-3 位存储其 类型信息\n\n 1. 000：对象\n\n 2. 1：int\n\n 3. 010：double\n\n 4. 100：string\n\n 5. 110：boolean\n\n特殊情况：\n\n * undefined -2^30（超出当时整型取值范围的一个数）\n * null 空指针，所有机器码均为 0\n\nnull 被误判为object\n\n\n# 数字处理\n\n * parseint(5.4) 只保留整数部分，有基模式\n * parsefloat() 值转换成浮点数，没有基模式\n * number() 转换成数字（可以是整数或浮点数），number()的强制类型转换与parseint()和parsefloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值\n * math.floor(4.33) 向下取整\n * math.ceil(6.7) 向上取整\n * math.round(6.19) 四舍五入的 整数\n * math.random() [0,1)，生成随机数\n * math.abs(-1) 绝对值\n * string() 把给定的值转换成字符串\n\n\n# tofixed(n)\n\n数字舍入到小数点后n位(四舍五入)，以字符串形式返回\n\n为啥？\n\n6.35.tofixed(1);//6.3\n\n\n1\n\n\n6.35的小数部分是一个无限的二进制，存储造成精度损失\n\nalert( 6.35.tofixed(20) ); // 6.34999999999999964473\n\n\n1\n\n\n酱紫，数字就变小一点\n\n解决办法——舍入之前，使其更接近整数\n\nalert( (6.35 * 10).tofixed(20) ); // 63.50000000000000000000\nalert( math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(rounded) -> 6.4\n\n\n1\n2\n\n\n乘除法，将数字舍入到固定n位\n\nlet num=1.23456\nmath.round(num*100)/100;\n//1.23456->123.456->123->1.23\n\n\n1\n2\n3\n\n\n\n# parseint()\n\n解析一个字符串，返回整数。parseint相比number，没那么严格，parseint逐个解析字符，遇到不能转换的字符就停下来\n\nparseint(string, radix)\n\n\n1\n\n\nstring 必需。要被解析的字符串\n\nradix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间\n\n如果省略该参数或其值为 ‘0‘，则数字将以 10 为基础解析，如果以 ‘”0x”‘ 或 ‘”0x”‘ 开头，将以 16 为基数\n\n如果该参数小于 2 或者大于 36，则 parseint()返回 nan\n\n# ['1', '2', '3'].map(parseint)\n\n 1. parseint('1', 0) //radix为0，string参数不以“0x”/“0”开头，按10为基数处理。返回1\n 2. parseint('2', 1) //基数为1表示的数最大值小于2，无法解析，返回nan\n 3. parseint('3', 2) //基数为2表示的数最大值小于3，无法解析，返回nan\n\nmap返回数组，结果为[1, nan, nan]\n\n\n# toprecision()\n\n把数字格式化为指定的长度:\n\nvar num = new number(13.3714); \nvar n=num.toprecision(2);\nconsole.log(n)\n\n\n1\n2\n3\n\n\n\n# 🔥 symbol\n\n表示唯一标识符\n\n只有两种原始类型可作为对象属性键\n\n 1. 字符串\n 2. symbol\n\n> 应用\n\n * 属性名(避免冲突)\n * 定义私有\n * 唯一值\n\n> 特点\n\n * 不能使用new\n * 不能使用 .\n * 不能使用for-in\n\n使用其他类型，会被转换为字符串\n\nobj[1]===obj[\"1\"]\nobj[true]===obj[\"true\"]\n\n\n1\n2\n\n\nlet id1=symbol(\"id1\");\nlet id2=symbol(\"id2\");\nid1===id2;//false\n//描述只是一个标签，不影响任何东西\n\n\n1\n2\n3\n4\n\n\nsymbol不会被自动转换为字符串——防止“混乱”的语言保护，字符串和symbol有着本质的不同\n\nsymbol属性不参加for-in循环、object.keys()\n\n因为symbol是“隐藏的属性部分”\n\n但是，object.assign()会同时复制字符串和symbol属性\n\nlet id = symbol(\"id\");\nlet user = {\n  [id]: 123\n};\n\nlet clone = object.assign({}, user);\n\nalert( clone[id] ); // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n因为合并对象时，肯定希望一个不落合并所有属性啊！！\n\n全局symbol——可随处访问\n\n// 从全局注册表中读取\nlet id = symbol.for(\"id\"); // 如果该 symbol 不存在，则创建它\n\n// 再次读取（可能是在代码中的另一个位置）\nlet idagain = symbol.for(\"id\");\n\n// 相同的 symbol\nalert( id === idagain ); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n//通过 name 获取 symbol \nsymbol.for('a') === symbol.for('a')  //true\n symbol('a') === symbol('a')  //false\n\n\n1\n2\n3\n\n\n> “隐藏 ”属性\n\nsymbol可创建对象的“隐藏”属性，其他地方不能访问或修改\n\nlet user = { // 属于另一个代码\n  name: \"john\"\n};\n\nlet id = symbol(\"id\");\n\nuser[id] = 1;\nalert( user[id] ); // 我们可以使用 symbol 作为键来访问数据\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n使用“id”和symbol(\"id\")作为对象的键有啥区别？\n\n防止意外重写属性\n\n尽管symbol的description一样，但是symbol总是不同\n\n而且我们添加的symbol属性不会被意外访问到\n\njs 使用了许多系统 symbol，这些 symbol 可以作为 symbol.* 访问。可以使用它们改变一些内建行为。例如，使用 symbol.iterator 进行 迭代 操作，用symbol.toprimitive 设置 对象原始值的转换 等\n\n\n# 💛 array方法\n\n\n# 创建数组\n\n * new array()\n\nlet arr=new array(\"merry\",\"aa\");\n\n\n1\n\n\n单个数字参数调用new array，创建一个指定长度没有项的数组\n\n * array.from() 浅拷贝\n\nconst dp=array(5).fill();\nconst dp = array.from(array(m+1), () => array(n+1).fill(0));\n let res = new array(n).fill(0).map(() => new array(n).fill(0));\n\n\n1\n2\n3\n\n\n类数组对象或者可迭代对象中创建新的数组实例\n\narray.from 可接受第二个参数，类似于数组的map方法，处理每个元素，处理后的值放入返回的数组\n\n * array.of()\n\n根据一组参数创建新的数组实例，支持任意参数数量和类型，没有参数时返回 []，参数只有一个的时候，实际上是指定数组的长度\n\n> 注意\n\n数组没有symbol.toprimitive，也没有valueof，它们只能执行tostring转换\n\nalert( [] + 1 ); // \"1\"\nalert( [1] + 1 ); // \"11\"\nalert( [1,2] + 1 ); // \"1,21\"\n\n\n1\n2\n3\n\n\n当+运算符把一些项加到字符串后时，加号后面的项也会被转换为字符串\n\n\n\n\n# 改变原数组\n\n * push\n\n返回数组最新长度\n\n\n * # 数组内存不够了，但还是要继续push元素咋办？\n\n内存都不够了，还push，直接报错 栈溢出\n\n扩容机制？？\n\n * pop()\n\n为啥作用于数组末端比首端快呢？\n\n * shift需要做3件事：\n\n1、移除索引为0的元素\n\n2、把所有元素向左移动，并重新编号\n\n3、更新length属性\n\n * unshift()\n\n返回新数组长度\n\n * splice\n\ndelete obj.key通过key移除对应的值3\n\nlet arr = [\"i\", \"go\", \"home\"];\n\ndelete arr[1]; // remove \"go\"\n\nalert( arr[1] ); // undefined\n\n// now arr = [\"i\",  , \"home\"];\nalert( arr.length ); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nsplice删除或替换现有元素或原地添加新元素修改数组，返回被修改数组\n\n***会改变原数组！！***\n\n返回值由被删除元素组成的数组，若只删除一个元素，则返回只包含一个元素的数组，若没有删除元素，则返回 []\n\n[2, 3, 4].splice(0, 1); // 0位置删除一个，返回[2]\n[2, 3, 4].splice(0, 1, 5); // 0位置删除1个，插入5，原数组是[5, 3, 4]，返回[2]\narrayobject.splice(start,deletecount,item1,.....,itemx)\nstart 必需。添加/删除项目位置，负数可从数组结尾处规定位置\ndeletecount 必需。删除项目数量。设置为 0，则不会删除项目\nitem1, ..., itemx 可选。向数组添加新项目\n\n\n1\n2\n3\n4\n5\n6\n\n\n * shift()\n\n * sort()\n\n默认 将元素转为字符串，比较utf-16代码单元值序列\n\n无法保证排序的时间/空间复杂性\n\na-b 是正数，根据规则，b会被移到a的前面\n\na-b 是负数，根据规则，a会排列到b的前面\n\n//升序\nfunction comparenumbers(a, b) {\n  return a - b;\n}\n\n\n1\n2\n3\n4\n\n\nfunction comparenumeric(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\n\nlet arr = [ 1, 2, 15 ];\n\narr.sort(comparenumeric);\n\nalert(arr);  // 1, 2, 15\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * reverse()\n\n\n# 不改变原数组\n\n * concat()\n\n返回新数组\n\n * slice(start,end)左闭右开，可以为负数\n\n返回一个包含原有数组中一个或多个元素的新数组\n\n * filter\n\n判断所有元素，将满足条件的元素作为一个新的数组返回\n\n * join()\n * find()\n * findindex()\n * indexof()\n * includes()\n\n\n# 其他\n\n * copywithin()\n\n将指定位置的成员复制到其他位置（会覆盖原有成员），返回当前数组\n\n 1. target（必需）：从该位置开始替换数据。负值表示倒数\n 2. start（可选）：从该位置开始读取数据，默认 0。负值表示从末尾开始计算\n 3. end（可选）：到该位置前停止读取数据，默认等于数组长度。负值，表示从末尾开始计算\n\n[1, 2, 3, 4, 5].copywithin(0, 3);\n// 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2\n// [4, 5, 3, 4, 5] \n\n\n1\n2\n3\n\n * fill()\n\n可以接受第二个和第三个参数，指定填充的起始位置和结束位置\n\n如果填充的类型为对象，则是浅拷贝\n\n实现\n\nfunction fill (n, m) {\n    n--\n    if(n) {\n        return [m].concat(fill(n, m))\n    } else {\n        return m\n    }\n}\n\nconsole.log(fill(3,4))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * reduce\n\n不改变原始数组\n\n每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值\n\nvar numbers = [65, 44, 12, 4];\n \nfunction getsum(total, num) {\n    return total + num;\n}\nlet sum = numbers.reduce(getsum);\n//语法\nlet val=arr.reduce((pre,cur,index,arr)=>{\n    //...\n},[initial]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n应用\n\n>  1. 累加器\n>  2. 求数组最大/小值\n>  3. 提取url参数\n>  4. 二维数组转为一维\n>  5. 数组拍平\n>  6. 字符统计\n>  7. 反转串\n\n * reduceright\n\n和reduce功能一样，遍历顺序从右到左\n\n * some(不用遍历整个数组，就能得到结果)\n\n判断所有元素，若存在元素满足条件，返回 true，若所有元素都不满足条件，返回 false\n\n> 类似的api？\n> \n> find?\n> \n> findindex?\n\n * every\n\n判断 所有元素返回一个布尔值，如果所有元素都满足条件，则返回 true，否则为 false\n\n * flat()，flatmap()\n\n数组扁平化，返回新数组，对原数据没有影响\n\nflat()默认“拉平”一层，如果想要“拉平”多层嵌套数组，参数为整数，表示想要拉平的层数，默认为1\n\nflatmap()对原数组的每个成员执行一个函数相当于执行array.prototype.map()，对返回值组成的数组执行flat()。返回新数组，不改变原数组\n\nflatmap()`方法还可以有第二个参数，绑定遍历函数里面的`this\n\n\n1\n\n * arr.at(i)\n\n> 若i>=0，就和arr[i]完全相同\n> \n> 若i<0，倒数\n\nlet fruits = [\"apple\", \"orange\", \"plum\"];\n\n// 与 fruits[fruits.length-1] 相同\nalert( fruits.at(-1) ); // plum\n\n\n1\n2\n3\n4\n\n * delete\n\n删除对象的属性/数组元素，删除对象属性本身，不会删除属性指向的对象\n\n若 delete 数组某位元素，数组长度不变，只是元素为 empty item\n\n原型中声明的属性/对象自带属性无法被删除\n\nvar声明的变量和通过function声明的函数拥有dontdelete属性，不能被删除\n\n * map\n\nmap() 返回新数组，数组中元素为原始数组元素调用函数处理后的值\n\nmap() 按照原始数组元素顺序依次处理元素\n\n * foreach\n\n基本数据类型——>死都改不动原数组！拷贝值\n\n引用类型——>类似对象数组可以改变，拷贝地址\n\nforeach原理是for循环，使用arr[index]赋值改变\n\n> 总结\n\n几乎所有调用函数的数组方法都支持可选附加参数'thisarg'，除了sort\n\nlet army={\n    a:1,\n    canjoin:function(user){\n        if(user!=='c'){\n            console.log(user)\n        }\n    }\n}\nlet users=['a','b','c']\nconst ans=users.filter(user => army.canjoin(user))\nconsole.log(ans)\nconst ans1=users.filter(army.canjoin, army)\nconsole.log(ans1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 不用全部遍历数组就能得出结果的api，比如some，除此之外 还有哪些？\n\n\n# 🌱 set集合\n\nset 允许存储任何类型的唯一值\n\nset 是值的集合，可以存储任意类型的值，set 可以按照插入顺序遍历输出，插入的值会自动去重\n\n\n# 特殊情况\n\n * 0 和 -0 不会去重\n * nan 不等于 nan，但是 nan 和 nan 会去重，只能存储一个\n\nlet myset = new set();\n\nmyset.add(1); // set [ 1 ]\nmyset.add(5); // set [ 1, 5 ]\nmyset.add(5); // set [ 1, 5 ]\nmyset.add(\"some text\"); // set [ 1, 5, \"some text\" ]\nlet o = {a: 1, b: 2};\nmyset.add(o);\n\nmyset.add({a: 1, b: 2}); // o 指向的是不同的对象，所以没问题\n\nmyset.has(1); // true\nmyset.has(3); // false\nmyset.has(5);              // true\nmyset.has(math.sqrt(25));  // true\nmyset.has(\"some text\".tolowercase()); // true\nmyset.has(o); // true\n\nmyset.size; // 5\n\nmyset.delete(5);  // true,  从set中移除5\nmyset.has(5);     // false, 5已经被移除\n\nmyset.size; // 4, 刚刚移除一个值\n\nconsole.log(myset);\n// logs set(4) [ 1, \"some text\", {…}, {…} ] in firefox\n// logs set(4) { 1, \"some text\", {…}, {…} } in chrome\nmyset.clear()//清楚所有成员，没有返回值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 遍历\n\n * keys()：返回键名的遍历器\n * values()：返回键值的遍历器\n * entries()：返回键值对的遍历器\n * foreach()：使用回调函数遍历每个成员\n\nset的遍历顺序就是插入顺序\n\nkeys方法、values方法、entries方法 都是 返回 遍历器对象\n\n实现并集、交集、和差集:\n\nlet a = new set([1, 2, 3]);\nlet b = new set([4, 3, 2]);\n\n// 并集\nlet union = new set([...a, ...b]);\n// set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// （a 相对于 b 的）差集\nlet difference = new set([...a].filter(x => !b.has(x)));\n// set {1}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 集合转换为数组\n\narray.from(arraylike object)\n\n扩展运算符(...)\n\nforeach\n\nlet ans=array.prototype.slice.apply(set)？？？待考究\n\n\n# map字典\n\nkey值不能重复！\n\nmap.size // 属性返回 map 结构的成员总数\nconst m = new map().set('key1', 'val1')\n\nmap.prototype.set(key, value) // 方法设置键名key对应的键值为value，返回整个 map 。如果key已经有值，键值会被更新，否则就新生成该键\n// set方法返回的是当前的map对象，因此可以采用链式写法\n\nmap.prototype.get(key) // 读取key对应的键值，如果找不到key，返回undefined\n\nmap.prototype.has(key) // 返回一个布尔值，表示某个键是否在当前 map 对象之中\n\nmap.prototype.delete(key) // 删除某个键，返回true。如果删除失败，返回false\n\nmap.prototype.clear() // 清除所有成员，没有返回值\n\nmap.prototype.keys()：// 返回键名的遍历器\nmap.prototype.values()：// 返回键值的遍历器\nmap.prototype.entries()：// 返回所有成员的遍历器\nmap.prototype.foreach()：// 遍历 map 的所有成员\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 判断是否存在某个值\n\n * array.indexof(item,from) //return 下标或-1\n\n * array.lastindexof(item,from)\n\n * array.includes(item,from)\n\n判断字符串/数组是否包含另一个字符，返回 true/false，第二个参数表示搜索的起始位置，默认0，为负数表示倒数\n\n以上3种方法和字符串操作具有相同的语法！！使用===比较！\n\n * array.find() 返回满足条件的第一个元素的值\n\nlet res=arr.find((item,index,arr)=>{\n   //返回true，则返回item并停止迭代\n    //返回false，则返回undefined\n});\n\n\n1\n2\n3\n4\n\n * array.findindex() 返回满足条件的第一个元素下标，没有找到返回-1\n\n> find和findindex都可以接受第二个参数，绑定回调函数的this\n\n\n# 遍历语法比较\n\n\n\n（for、foreach、map、 for...in、for...of的区别）\n\n数组遍历各个方法的速度：传统的for循环最快，for-in最慢\n\n> for-in > for > for-of > foreach > map > for-in\n\n\n# for\n\n速度最快，兼容旧版本浏览器\n\n优化一下\n\nlet arr=[1,2,3,4,5];\nfor(let i=0,len=arr.length;i<len;i++){\n    \n}\n\n\n1\n2\n3\n4\n\n\n临时变量存储len，避免重复获取数组长度，只有len较大时优化才明显\n\n\n# for in (es5)\n\n * 枚举对象属性包括继承属性，除symbol\n * 不建议使用 for in 遍历数组\n\n因为输出属性名的顺序不可预测，效率低\n\n是第一个能迭代对象键的js语句，循环对象键与在数组上循环不同，引擎会执行额外的工作跟踪已迭代的属性\n\n * 如果迭代对象的变量值是 null 或 undefined, for in 不执行，建议使用 for in 循环之前，先检查\n * 遍历数组索引，得到对象的key或数组，字符串下标\n * 遍历数组的话，类数组有length和索引属性，也可能有其它非数字的属性和方法，for-in会全部列出来\n\n\n# for of (es6)\n\n * for…of 语句在可迭代对象上创建一个迭代循环，调用自定义迭代钩子，为每个不同属性的值执行语句\n * 得到对象的value或数组、字符串的值，还可以遍历map和set\n * for of 循环数组时怎么拿到数组索引？\n\nes6之前的遍历方法都会跳过数组未赋值过的位置，即空位，但是es6新增的for of 不会跳过\n\n 1. 可使用break\n 2. 避开了for-in所有缺陷\n 3. 可正确响应break、continue和return\n 4. 支持字符串遍历\n\n> object没有iterator属性，因此它不是可迭代对象，没有for-of方法，不过我们可以自定义方法实现遍历\n\n性能优于for-in\n\n\n# every/some\n\n返回布尔值\n\nevery判断数组每一项，some当某一项满足条件返回\n\n\n# fliter\n\n过滤数组成员，满足条件的成员组成一个新数组返回，否则返回[]\n\n不改变原数组\n\n\n# foreach()\n\n> foreach不是es6的方法，是es3的\n\n修改原数组，遍历可迭代对象，不返回执行结果，而是undefined，return无法终止 有continue效果\n\n中断foreach\n\n 1. 使用try监视代码块，中断地方抛出异常\n 2. 替换：every和some碰到return false时，中止循环\n\nfunction log(msg, time) {\n    return new promise((resolve) => {\n        settimeout(() => {\n            console.log(msg);\n            resolve();\n        }, time);\n    });\n};\n(async () => {\n    [1, 2, 3, 4].foreach(async (i,index,array) => {\n        await log(i, 1000);\n    });\n})();\n// 1s 后依次输出1 2 3 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n对于异步代码，foreach不能保证按顺序执行\n\nfor...of /in可解决问题，不像foreach简单粗暴遍历执行，而是采用迭代器遍历\n\n\n# map()\n\n遍历可迭代对象\n\n分配内存并返回新数组，不改变原数组\n\n不能break，否则引发异常\n\n可使用for循环/for-in/for-of中断循环\n\n> 关于map和foreach的性能对比问题，我也没有找到答案，网络上众说纷纭，其实也不用太纠结它们的速度快慢\n\n\n# [\"1\", \"2\", \"3\"].map(parseint)\n\n[1, nan, nan]\n\n\n1\n\n\nparseint() 解析字符串，返回整数，两个参数 (val, radix)，radix 表要解析数字的基数\n\n（该值介于 2 ~ 36 之间，且字符串中的数字不能大于 radix 才能正确返回结果）\n\n此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 \"1-0\", \"2-1\", \"3-2\"\n\n因为字符串的值不能大于基数，后面两次调用均失败，返回 nan ，第一次基数为 0 ，按十进制解析返回 1\n\n> 同理\n\nlet res=['1','2','100'].map(parseint);//[1,nan,4]\n\n\n1\n\n\n\n# 对比\n\nfor、foreach\n\n * 都是遍历数组\n * foreach永远返回undefined\n * map是映射，返回新数组\n * map()效率更高不用太过纠结速度快慢，因为我也没找着答案\n * 二者均不能中断\n * 可以使用简单的for循环或for-of/for-in中断循环\n * 遍历可迭代对象\n * 当只想遍历数据而修改时，使用foreach\n * 建议用map转换数组元素\n * for不创建函数\n * foreach创建每次调用的函数\n * 函数单独作用，产生额外开销\n * 开发不考虑性能，foreach更具可读性\n * 都可以接受第二个参数，绑定回调内的 this ，将回调内部的 this指向第二个参数，间接操作这个参数\n * map()和filter()都会跳过空位，for 和 while 不会\n\n\n# 🍅string方法\n\n * charat(index) 返回指定索引处的字符串，没找着返回空串\n * charcodeat(index) 返回指定索引处的字符的 unicode值\n\n// tolowercase()转换成小写 touppercase()转换成大写\nvar x = \"a\".tolowercase().charcodeat(0)\n//x = 97\n\n\n1\n2\n3\n\n * concat(str1, str2, ... ) 连接多个字符串，返回连接后串的副本，纯函数\n * fromcharcode() 将 unicode 值转换成实际的字符串\n\nstring.fromcharcode(97)\n// 返回\"a\"\n\n\n1\n2\n\n * indexof(str) 返回 str 在父串中第一次出现的位置，若没有则返回-1\n * lastindexof(str) 返回 str 在父串中最后一次出现的位置，若没有返回-1\n * match(regex) 搜索字符串，返回正则表达式的所有匹配\n * search(regex) 基于正则表达式搜索字符串，返回第一个匹配的位置\n * slice(start, end) 返回字符索引在 start 和 end（不含）间的子串\n * split(sep，limit) 将字符串分割为字符数组，limit 为从头开始执行分割的最大数量\n * substr(start，length) 从字符索引 start 的位置开始，返回长度为 length 的子串\n * substring(from, to) 返回字符索引在 from 和 to（不含）之间的子串，和slice几乎相同，但它允许from>to，不支持负参数，slice支持负参数\n * tolowercase() 将字符串转换为小写\n * touppercase() 将字符串转换为大写\n * valueof() 返回原始字符串值\n * tostring() 把 number 对象转换为字符串，返回结果\n\n{} 的 valueof 结果为 {} ，tostring 的结果为 \"[object object]\"\n\n[] 的 valueof 结果为 [] ，tostring 的结果为 \"\"\n\n\n1\n2\n3\n\n * str.codepointat(pos) 返回在pos位置的字符编码\n\n// 不同的字母有不同的代码\nalert( \"z\".codepointat(0) ); // 122\nalert( \"z\".codepointat(0) ); // 90\n\n\n1\n2\n3\n\n * string.fromcodepoint(code) 通过code创建字符\n\nalert( string.fromcodepoint(90) ); // z\n\n//\\u后跟十六进制代码，通过代码添加unicode字符\n// 在十六进制系统中 90 为 5a\nalert( '\\u005a' ); // z\n\n\n1\n2\n3\n4\n5\n\n\n> 'a'>'z'\n> \n> 因为字符通过数字代码比较，a(97)>z(90)\n\n// 英文是否大写\nfunction uppercase(num) {\n\tvar reg = /^[a-z]+$/;\n\treturn reg.test(num);\n}\n\n\n1\n2\n3\n4\n5\n\n * repeat() 返回新的字符串 =重复了指定次数的原始字符串\n\n\n# replace\n\n不会修改原字符串！\n\n第二个参数可传入要替换的目标串，这种用法中replace只会匹配一次\n\n第二个参数也可以传入一个函数，若原始字符串中有n个我们查找的字符串，函数就会执行n次，且这个函数返回一个字符串，用来替换每次匹配到的字符串\n\n\n# 参数\n\n> $&\n\n匹配的字符串\n\nvar sstr='讨论一下正则表达式中的replace的用法';\nsstr.replace(/正则表达式/,'《$&》');\n// \"讨论一下《正则表达式》中的replace的用法\"\n\n\n1\n2\n3\n\n\n> $`\n\n匹配字符串左边的所有字符\n\nvar sstr='讨论一下正则表达式中的replace的用法';\nsstr.replace(/正则表达式/,'《$`》');\n// \"讨论一下《讨论一下》中的replace的用法\"\n\n\n1\n2\n3\n\n\n> $'\n\n匹配字符串右边的所有字符，既然有单引号，外面的引号必须双引号，如果不可以双引号，只能把单引号转义\n\nvar sstr='讨论一下正则表达式中的replace的用法';\nsstr.replace(/正则表达式/,\"《$'》\");\n// \"讨论一下《中的replace的用法》中的replace的用法\"\n\n\n1\n2\n3\n\n\n> 1,2,3,4……n\n\n依次匹配子表达式\n\nvar sstr='讨论一下正则表达式中的replace的用法';\nsstr.replace(/(正则)(.+?)(式)/,\"《$1》$2<$3>\");\n//\"讨论一下《正则》表达<式>中的replace的用法\"\n\n\n1\n2\n3\n\n\n\n# 函数\n\nvar sstr='讨论一下正则表达式中的replace的用法';\nsstr.replace(/(正则).+?(式)/,function() {\n    console.log(arguments);\n});\n// [\"正则表达式\", \"正则\", \"式\", 4, \"讨论一下正则表达式中的replace的用法\"]\n\n\n1\n2\n3\n4\n5\n\n\n参数：\n\n * 匹配到的字符串\n * 若正则使用了分组匹配就是多个，否则无此参数\n * 匹配字符串的索引位置\n * 原始字符串\n\n或者使用命名形参：\n\nvar sstr='讨论一下正则表达式中的replace的正则表达式用法';\nsstr.replace(/(正则).+?(式)/g,function($1) {\n    console.log($1);\n    return $1 + 'a';\n});\n\n\n1\n2\n3\n4\n5\n\n\n\n# 用法\n\n\\s匹配任何空白字符（空格，制表符，换行符）\n\nstr = str.replace(/\\s*/g); //去除所有空格 \nstr = str.replace(/^\\s*|\\s*$/g, \"\");//去除首尾空格\nstr = str.replace(/^\\s*/, \"\");\nstr = str.replace(/\\s*&/, \"\");\n\n\n1\n2\n3\n4\n\n\n\\w 匹配任何单词字符，包括 字母 数字 下划线\n\nname = \"doe, john\";\nlet a=name.replace(/(\\w+)\\s*, \\s*(\\w+)/, \"$2 $1\");\nconsole.log(a)\n//john doe\n\n\n1\n2\n3\n4\n\n\n\\b 匹配单词字符和非单词字符的边界位置\n\n//首字母大写\nlet name = 'aaa bbb ccc';\nlet uw=name.replace(/\\b\\w+\\b/g, function(word){\n    return word.substring(0,1).touppercase()+word.substring(1);}\n);\n\n\n1\n2\n3\n4\n5\n\n\n\n# str. trim()\n\n删除串两端空白字符并返回**，不影响原来字符串，返回新串**\n\n> 只能去除字符串两端空格\n\n\n# 截取字符串\n\n\n# substring()\n\n左闭右开，提取串中介于两个指定下标间的字符\n\nsubstring(start,stop)\n\n\n1\n\n\n * start：非负整数，提取子串的第一个字符索引，必写\n\n * stop：非负整数，比要提取子串的最后一个字符在字符串上的位置多 1，可写可不写，如果不写则返回子串会一直到字符串的结尾\n\n该字符串的长度为stop-start\n\n如果参数 start 与 stop 相等，返回空串，如果 start 比 stop 大，该方法在提取之前会先交换这两个参数\n\n\n# substr()\n\n抽取从 start 下标开始的指定数目的字符\n\nsubstr(start,length)\n\n\n1\n\n * start：要截取的子串的起始下标，必须是数值。如果是负数，该参数从字符串的尾部开始算。-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推，必需写\n * length：子串中的字符数，必须是数值。如果不填，返回字符串的开始位置到结尾的字符。如果length 为0 或者负数，返回一个空串\n\n\n# split()\n\n把一个字符串分割成字符串数组\n\nstringobject.split(separator,howmany)\n\n\n1\n\n\n * separator：字符串或正则表达式，从该参数指定的地方分割字符串。必须写\n\n * howmany：指返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。可选\n\n\n# string.prototype.padstart()\n\n用另一个串填充当前字符串 (如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串左侧开始填充\n\n\n# ✅ 正则\n\nregular expression\n\n\n# 方法\n\n方法         描述\nexec       执行查找匹配的regexp方法，返回数组（未匹配到则返回 null）\ntest       字符串中测试是否匹配，返回 true 或 false\nmatch      执行查找匹配字符串，返回数组，未匹配时返回 null\nmatchall   执行查找所有匹配的string方法，返回迭代器（iterator）\nsearch     测试匹配的string方法，返回匹配到的位置索引，失败返回-1\nreplace    执行查找匹配的string方法，使用替换字符串替换掉匹配到的子字符串\nsplit      使用正则表达式或固定字符串分隔字符串，将分隔后的子字符串存储到数组中\n\n\n# exec()\n\n检索字符串中指定值，返回结果数组，若没有，则返回null\n\n\n\n\n# compile()\n\n改变regexp，可改变检索模式也可add或delete第二个参数\n\n\n# match()\n\n\n\n\n# new regexp()、字面量\n\n使用字面量效率更高\n\n//正则表达字面量\nvar re = /\\\\/gm;\n\n//正则构造函数\nvar reg = new regexp(\"\\\\\\\\\", \"gm\");\n\nvar foo = \"abc\\\\123\"; // foo的值为\"abc\\123\"\nconsole.log(re.test(foo)); //true\nconsole.log(reg.test(foo)); //true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用构造函数时，要使用四个反斜杠才能匹配单个反斜杠。使得正则表达式模式更长，难以阅读。当使用 regexp()构造函数时，不仅要转义引号（即\"表示\"），通常还需要双反斜杠（即\\表示一个\\）\n\n\n# 校验规则\n\n规则        描述\n\\         转义\n.         默认匹配除换行符之外的任何单个字符\nx(?=y)    匹配'x'仅仅当'x'后面跟着'y'——先行断言\n(?<=y)x   匹配'x'仅当'x'前面是'y'——后行断言\nx(?!y)    仅当'x'后面不跟着'y'时匹配'x'——正向否定查找\n(?<!y)x   仅当'x'前面不是'y'时匹配'x'——反向否定查找\nx|y       匹配‘x’或者‘y’\n{n}       n 是正整数，匹配前面一个字符刚好出现了 n 次\n{n,}      n是正整数，匹配前一个字符至少出现了n次\n{n,m}     n 和 m 都是整数。匹配前面的字符至少n次，最多m次\n[xyz]     一个字符集合。匹配方括号中的任意字符\n[^xyz]    匹配任何没有包含在方括号中的字符\n\\b        匹配一个词的边界，例如在字母和空格之间\n\\b        匹配一个非单词边界\n\\d        匹配一个数字\n\\d        匹配一个非数字字符\n\\f        匹配一个换页符\n\\n        匹配一个换行符\n\\r        匹配一个回车符\n\\s        匹配一个空白字符，包括空格、制表符、换页符和换行符\n\\s        匹配一个非空白字符\n\\w        匹配一个单字字符**（字母、数字或者下划线）**\n\\w        匹配一个非单字字符\n\n> 先行断言 从左往右看\n> \n> 后行断言 从右往左看\n\nx(?=y)`匹配x`仅当x后面跟着y，不会将y包含在结果中正向先行断言\nx(?!y) 仅当x后面不是y时`匹配x` ，负向先行断言\n(?<=y)x `匹配x`仅当x前面是y ，正向后行断言\n(?<!y)x 仅当x前面不是y时`匹配x `,反向否定查找（负向后行断言）\n\n\n1\n2\n3\n4\n\n\n\n# 捕获、非捕获\n\n\n\n捕获——可通过序号/名称使用这些匹配结果\n\n非捕获——标识不需要捕获的分组\n\n\n# 标记\n\n标志   描述\ng    全局搜索\ni    不区分大小写搜索\nm    多行搜索\ns    允许 . 匹配换行符\nu    使用unicode码的模式匹配\ny    执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始\n\n\n# 千分位分隔\n\n正则+replace\n\nfunction format(num) {\n    const reg = /(\\d)(?=(\\d{3})+\\.)/g;\n    return num && num.tostring().replace(reg, function (s2) {\n        return s2 + ',';\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nfunction numformat(num){\n    const reg=/(\\d)(?=(\\d{3})+$)/g;\n    const res=num.tostring().replace(/\\d+/, function(n){ // 先提取整数部分\n        return n.replace(reg,function(s1){\n            return s1+\",\";\n        });\n    })\n    return res;\n}\n//就它最正宗，不报错，点名表扬！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nx(?=y) 仅当x后面为y时，匹配x\n\nfunction numberwithcommas(x) {\n    var parts = x.tostring().split(\".\");\n    parts[0] = parts[0].replace(/\\b(?=(\\d{3})+(?!\\d))/g, \",\");\n    return parts.join(\".\");\n}\nnumberwithcommas(33333333333.3333333333)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nx(?=y) 仅当x后面是y时匹配x\n\n(?<!y)x 仅当x前面不是y时匹配x\n\nx(?!y) 仅当x后面不是y时匹配x\n\nfunction numberwithcommas(x) {\n    return x.tostring().replace(/\\b(?<!\\.\\d*)(?=(\\d{3})+(?!\\d))/g, \",\");\n}\nnumberwithcommas(1111111111.1111111111)\n\n\n1\n2\n3\n4\n\n\n利用 正则 + 循环\n\nfunction numberwithcommas(x) {\n    x = x.tostring();\n    var pattern = /(-?\\d+)(\\d{3})/;\n    while (pattern.test(x)){\n        x = x.replace(pattern, \"$1,$2\");   \n    }\n    return x;\n}\nnumberwithcommas(12312124545);//'12,312,124,545'\nnumberwithcommas(123121245.45);//'123,121,245.45'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n将数字转换为字符串，循环整个数组，每三位增加分隔逗号，最后合并成字符串，分隔符从后往前添加\n\nfunction format2(num) {\n    num = num.tostring().split(\".\");\n    let arr = num[0].split(\"\").reverse();\n    let res = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n        if (i % 3 === 0 && i !== 0) {\n            res.push(\",\");\n        }\n        res.push(arr[i]);\n    }\n    res.reverse();\n    if (num[1]) {\n        res = res.join(\"\").concat(\".\" + num[1]);\n    } else {\n        res = res.join(\"\");\n    }\n    return res;\n}\nformat2(12345678.987654)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n调用api\n\nfunction format1(number) {\n    return intl.numberformat().format(number)\n}\n//intl 对象是 ecmascript 国际化 api 的一个命名空间，提供了精确的字符串对比、数字格式化，和日期时间格式化\n// intl.numberformat.prototype.format 属性返回一个根据numberformat对象的语言环境和格式化选项，来格式化一个数字的getter函数\n\n\n1\n2\n3\n4\n5\n\n\nfunction format2(number) {\n    return number.tolocalestring('en')\n}\n//tolocalestring() 方法返回这个数字在特定语言环境下的表示字符串\n\n\n1\n2\n3\n4\n\n\n\n# 应用场景\n\n// 匹配 16 进制颜色值\nvar regex = /#([0-9a-fa-f]{6}|[0-9a-fa-f]{3})/g;\n\n// 匹配日期，如 yyyy-mm-dd 格式\nvar regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;\n\n//匹配 qq 号\nvar regex = /^[1-9][0-9]{4,10}$/g;\n\n// 手机号码正则\nvar regex = /^1[34578]\\d{9}$/g;\n\n//用户名正则\nvar regex = /^[a-za-z\\$][a-za-z0-9_\\$]{4,16}$/;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 初始化对象\n\nobject.create()、字面量、new\n\n创建一个对象，推荐字面量方式（无论性能上还是可读性）\n\nnew object() 创建对象要通过作用域链一层层找到 object，但使用字面量方式就没这个问题\n\nvar person = {}; //相当于 var person = new object();\nvar person = {\n    name: 'nike';\n    age: 29;\n}\n\n\n1\n2\n3\n4\n5\n\n\nes5新增object.create——内部定义对象，接受一个原型对象并创建指向它的新对象\n\n\n * # 实现object.create()\n\nf.prototype对象赋值为 引进对象/函数o，return新对象\n\nobject.create =  function (o) {\n    var f = function () {};\n    f.prototype = o;\n    return new f();\n};\n\n\n1\n2\n3\n4\n5\n\n\nnew 是新建对象o1，让o1的 __proto__ 指向 base.prototype 对象，使用call 强转作用环境，实现对象创建\n\nvar o1 = new object();\no1.[[prototype]] = base.prototype;\nbase.call(o1);\n\n\n1\n2\n3\n\n\n> 区别\n\nvar base = function () {\n    this.a = 2\n}\nvar o1 = new base();\nvar o2 = object.create(base);\nconsole.log(o1.a); // 2\nconsole.log(o2.a); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nobject.create 失去了原来对象属性的访问\n\n比较     new                object.create\n构造函数   保留原构造函数属性          丢失原构造函数属性\n原型链    原构造函数prototype属性   原构造函数/（对象）本身\n作用对象   function           function、object\n\nlet o=new object()\nlet o={}\nlet o=new object\n\nlet o=object (×)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 💜 对象方法\n\n> 可选链\n\nlet user = {}; // user 没有 address 属性\nalert( user?.address?.street ); // undefined（不报错）\n\n\n1\n2\n\n\nobject.is()\n\n严格判断两个值是否相等，与严格比较运算符（===）基本一致，不同之处\n\n+0 === -0 //true\nnan === nan // false\n\nobject.is(+0, -0) // false\nobject.is(nan, nan) // true\n\n\n1\n2\n3\n4\n5\n\n\nobject.assign()\n\n * 用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target\n * 第一个参数是目标对象，后面的参数都是源对象\n\nconsole.log(object.assign([1, 2, 3], [4, 5])); //4,5,3\n\n\n1\n\n\n数组视为对象，目标数组视为属性为0、1、2的对象，所以源数组的0、1属性的值覆盖了目标对象的值\n\nobject.getownpropertydescriptors()\n\n * 返回指定对象所有自身属性（非继承属性）的描述对象\n\nobject.setprototypeof()\n\n * 设置一个对象的原型对象\n\nobject.getprototypeof()\n\n * 读取一个对象的原型对象\n\nobject.fromentries()\n\n * 将一个键值对数组转为对象\n\nobject.fromentries([\n  ['foo', 'bar'],\n  ['baz', 42]\n])\n// { foo: \"bar\", baz: 42 }\n\n\n1\n2\n3\n4\n5\n\n\nobject.defineproperty()\n\n直接在对象上定义新的属性，修改一个已经存在的属性\n\nobject.defineproperty(obj, props, desc):\n\n * obj: 需要定义属性的当前对象\n * props: 当前准备定义的属性名\n * desc: 对定义属性的描述\n\nisprototypeof() 测试对象是否存在于另一对象的原型链上\n\n> 哪些属性是函数function a(){}独有，对象const b = new object()没有的?\n> \n>  * constructor\n>  * [proto]\n>  * isprototypeof\n>  * prototype(√)\n\n判断对象是否为空？(没有任何属性可以用什么方法)\n\n\n# 判断对象是否有属性\n\n. / []+undefined\n\n判断对象自身属性和继承属性\n\n属性名存在 但 值为undefined时，不能返回想要的结果——in 解决\n\n1、in\n\n如果属性来自对象的原型，仍然返回true\n\nlet obj={name:'aa'};\n'name' in obj;//true\n'tostring' in obj;//true\n\n\n1\n2\n3\n\n\n2、reflect.has()\n\n检查属性是否在对象中，和in一样作为函数工作\n\nconst obj={name:111};\nreflect.has(obj,'name');//true\nreflect.has(obj,'tostring');//true\n\n\n1\n2\n3\n\n\n3、hasownproperty()\n\n返回布尔值，对象是否具有指定属性作为它**自己的属性**(不是继承)\n\n可正确区分对象本身属性和其原型的属性\n\nconst obj={a:1};\nobj.hasownproperty('a');//true\nobj.hasownproperty('tostring');//false\n\n\n1\n2\n3\n\n\n缺点：如果对象用object.create(null)创建，不能使用这个方法\n\nconst obj=object.create(null);\nobj.name='merry';\nobj.hasownproperty('name');\n//uncaught typeerror: obj.hasownproperty is not a function\n\n\n1\n2\n3\n4\n\n\n4、object.prototype.hasownproperty()\n\n可解决3的问题，直接调用内置有效函数，跳过原型链\n\nconst obj=object.create(null);\nobj.name='merry';\nobject.prototype.hasownproperty.call(obj,'name');//true\nobject.prototype.haspwnproperty.call(obj,'tostring');//false\n\n\n1\n2\n3\n4\n\n\nobject.propertyisenumerable() 判断对象是否包含某个属性，且这个属性是否可枚举（通过原型继承的属性除外）\n\n5、object.hasown()\n\n若指定对象具有指定属性作为自己的属性，object.hasown()静态方法返回true，若属性被继承或不存在，返回false\n\nconst obj=object.create(null);\nobj.name='merry';\nobject.hasown(obj,'name');//true\nobject.hasown(obj,'tostring');//false\n\n\n1\n2\n3\n4\n\n\n6、object.keys()\n\n返回对象本身可枚举类型(不含 继承 和symbol 属性)的数组\n\nobject.freeze() 冻结对象。一个被冻结的对象不能被修改，不能添加新的属性，不能删除已有属性，不能修改已有属性的任何属性 包括 值。冻结对象后该对象的原型也不能被修改\n\n\n# 🙋‍♂ 对象遍历\n\n                                 可枚举属性   不可枚举属性   继承属性   symbol\nfor-in                           √       ×        √      ×\nobject.keys()                    √       ×        ×      ×\nobject.getownpropertynames()     √       √        ×      ×\nobject.getownpropertysymbols()   ×       √        ×      √\nreflect.ownkeys()                √       √        ×      √\n\n\n# . 和[]？\n\n[]语法 通过变量访问属性\n\n如果属性包含空格，就不能通过 . 访问它。属性名可以包含非字母非数字，使用[]访问它\n\n除非必须使用变量访问属性，否则我们使用点表示法\n\n注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object object]\n\nconst keya = {a: 1};\nconst keyb = {b: 2};\n\nconst myobject = {\n  [keya]: 'valuea',\n  [keyb]: 'valueb'\n};\n\nmyobject // object {[object object]: \"valueb\"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# for-in\n\n遍历自身和继承的可枚举属性（不含 symbol ）\n\n对象属性没有顺序，for-in输出的顺序不可预测\n\nlet obj = {\n    name: 'scarlett',\n    age: 37,\n    [symbol()]: 'johansson'\n}\nfor (let key in obj) {\n    console.log(key) // name age\n}\n// 在原型上添加一个可枚举属性\nobject.prototype.nationality = 'america'\n// 在obj对象上添加一个不可枚举属性\nobject.defineproperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\nfor (let key in obj) {\n    console.log(key, obj[key])\n}\n/* 输出结果：包含对象自身的可枚举属性和原型上的可枚举属性\nname scarlett\nage 37\nnationality america\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# object.keys()\n\n返回对象key组成的数组\n\n数组成员是对象本身的 (不含继承)所有可枚举属性(不含 symbol )的键名\n\nlet obj = {\n    name: 'scarlett',\n    age: 37,\n    [symbol()]: 'johansson'\n}\n\n// 在原型上添加一个可枚举属性\nobject.prototype.nationality = 'america'\n\n// 在obj对象上添加一个不可枚举属性\nobject.defineproperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\n// 获取对象自有的可枚举属性\nobject.keys(obj).map(key => {\n    console.log(key);   // name  age\n})\n\nconsole.log(object.entries(obj)); // [[\"name\", \"scarlett\"], [\"age\", 37]]\nconsole.log(object.values(obj)); // [\"scarlett\", 37]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# object.getownpropertynames()\n\n对象自身所有属性（不含 symbol，但包括不可枚举属性）的键名\n\nlet obj = {\n    name: 'scarlett',\n    age: 37,\n    [symbol()]: 'johansson'\n}\n\n// 在原型上添加一个可枚举属性\nobject.prototype.nationality = 'america'\n\n// 在obj对象上添加一个不可枚举属性\nobject.defineproperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\nconsole.log(object.getownpropertynames(obj))  // [\"name\", \"age\", \"occupation\"]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nlet obj = {\n    name: 'scarlett',\n    age: 37,\n    [symbol()]: 'johansson'\n}\n\n// 在原型上添加一个可枚举属性\nobject.prototype.nationality = 'america'\n\n// 在obj对象上添加一个不可枚举属性\nobject.defineproperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\nconst getallpropertynames = (obj) => {\n    let props = object.assign([], object.getownpropertynames(obj))\n    // 得到所有的可枚举属性（自有的和继承的属性）\n    for (let key in obj) {\n        // 过滤自有的不可枚举属性\n        if (!object.getownpropertynames(obj).includes(key)) {\n            props.push(key)\n        }\n    }\n    return props;\n};\ngetallpropertynames(obj);  // [\"name\", \"age\", \"occupation\", \"nationality\"] \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# object.getownpropertysymbols()\n\n对象自身的所有 symbol 属性键名\n\nlet obj = {\n    name: 'scarlett',\n    age: 37,\n    [symbol()]: 'johansson'\n}\n\n// 在原型上添加一个可枚举属性\nobject.prototype.nationality = 'america'\n\n// 在obj对象上添加一个不可枚举属性\nobject.defineproperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\nvar symbolsarr = object.getownpropertysymbols(obj);\nfor( let sym of symbolsarr){\n    console.log(sym, obj[sym]); // symbol() \"johansson\"\n}\n\n// 给对象添加一个不可枚举的symbol属性\nobject.defineproperties(obj, {\n    [symbol('aa')]: {\n          value: 'localsymbol',\n          enumerable: false\n     }\n})\nobject.getownpropertysymbols(obj).map(key => {\n    console.log(key, obj[key]); // symbol() \"johansson\", symbol(aa) \"localsymbol\"\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# reflect.ownkeys()\n\n对象自身（不含继承的）所有键名，不管键名是 symbol /字符串，也不管是否可枚举\n\nlet obj = {\n    name: 'scarlett',\n    age: 37,\n    [symbol()]: 'johansson'\n}\n\n// 在原型上添加一个可枚举属性\nobject.prototype.nationality = 'america'\n\n// 在obj对象上添加一个不可枚举属性\nobject.defineproperty(obj, 'occupation', {\n    value: 'actress',\n    enumerable: false\n})\n\nreflect.ownkeys(obj).map(key => {\n    console.log(key, obj[key])\n})\n\n/* 输出结果：\nname scarlett\nage 37\noccupation actress\nsymbol() \"johansson\"\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# object.values\n\n返回对象value组成的数组\n\n数组成员是对象本身的 (不含继承)所有可枚举属性的键值\n\n\n# object.entries\n\n返回对象key-value组成的数组\n\n数组成员是对象本身的 (不含继承)所有可枚举属性的键值对数组\n\n\n# object转换\n\n\n# toprimitive\n\njs中，若想要将对象转换成基本类型 ，再从基本类型转换为对应的string或number，实质 是调用valueof和tosting——拆箱转换\n\ntoprimitive(input,preferedtype)\n//参数是要转换的对象，期望转换的基本类型(字符串、数字，选填，默认为number)\n\n\n1\n2\n\n\n\n# tostring、valueof\n\n对于string优先调用tostring，若不存在，调用valueof方法\n\ntostring返回字符串\"[object object]\"\n\nvalueof返回对象自身(历史原因，别问我为啥，可假设它根本不存在)\n\n\n# tostring()\n\nobject.prototype.tostring()返回表示该对象的字符串\n\n每个对象都有tostring()方法\n\n数字转换为二进制\n\n * 是正数\n * 可能有小数\n * 小数部分最多保留8位\n\nfunction translate(num){\n    let a=num.tostring(2);\n    let b=a.split('.');\n    let c='';\n    if(b[1].length>8){\n        c=b[1].slice(0,8);\n        return b[0]+'.'+c;\n    }\n    return a;\n}\nconsole.log(translate(1.0))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# '1'.tostring()为啥可以调用？\n\n进行以下几步\n\n 1. 创建实例\n 2. 调用实例方法\n 3. 销毁实例\n\nvar s=new object('1');\ns.tostring();\ns=null;\n\n\n1\n2\n3\n\n\n\n# 123['tostring'].length+123\n\nfunction的length——第一个具有默认值之前的参数个数！\n\n剩余参数不算进length的计算中\n\n\n# 对象、map\n\n对象和 map 可以枚举\n\nobject本质是哈希结构的键值对的集合，只能用字符串、数字或者symbol等简单数据类型当作键，有限制；map 的 key 可以是任意值\n\nmap继承object，对object做拓展，map键可以是任意数据类型\n\n对象 在堆开辟一块内存，map的键存的就是这块内存的地址。只要地址不一样，就是不同键，解决同名属性碰撞问题，传统的object做不到这一点\n\n对象键值对无序\n\nmap 能记住键的原始插入顺序\n\n         map                    object\n意外的键     默认情况不包含任何键。只包含显式插入的键   有原型，原型链上的键名可能和自己设置的键名冲突。可以用 object.create(null) 创建没有原型的对象\n键的类型     键可以是任意值                的键必须是string/symbol\n键的顺序     键有序。迭代时，map对象以插入顺序返回   目前有序，但不总是这样，而且这个顺序复杂\nsize     键值个数可通过 size 获取        键值对个数只能手动计算\n迭代       可迭代的                   没有 迭代协议，使用 js的 for...of 不能直接迭代\n性能       频繁增删键值对的场景下表现更好        在频繁添加和删除键值对的场景下未优化\n序列化和解析   没有元素的序列化和解析的           使用 json.stringify()\n\n\n# weakset、weakmap\n\nweakmap、weakset 的 key 是弱引用，相应对象被回收时，key 被回收，因为不可控，所以不可枚举\n\nweakset 只能存储对象的集合\n\nweakset 可检测循环引用，递归调用自身的函数需要一种方式 ，跟踪哪些对象已被处理\n\nweakmap 的 key 只能是对象（null 除外）\n\nweakmap 无属性读取键值的个数\n\n\n# ... 与rest？\n\n... 扩展运算符可用于 扩展 数组对象和字符串，将可迭代对象转为用 逗号 分隔的参数序列\n\n> 应用\n\n * 展开数组、对象、字符串\n * 类数组对象转为数组\n * 函数传参\n * 用于具有iterator接口的对象\n\nrest为解决传入的参数数量不一定；不会为每个变量给一个单独的名称，参数对象包含所有参数传递给函数；arguments不是真正的数组，rest参数是真实的数组\n\n剩余参数只包含那些没有对应形参的实参，arguments包含传给函数的所有实参\n\n\n# ... 应用\n\nes6通过扩展元素符...，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\n\n函数调用的时候，将一个数组变为参数序列\n\n将某些数据结构转为数组\n\n合并数组\n\n**注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组\n\n\n# rest特点\n\n减少代码\n\n//以前函数\nfunction f(a, b) {\nvar args = array.prototype.slice.call(arguments, f.length);\n}\n// 等效于\nfunction f(a, b, ...args) {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nrest参数可以被解构\n\n\n# arguments\n\n另一种对象类型，也叫类对象数组（类数组）\n\njs的每个函数都会有一个arguments对象实例，它引用函数的实参，有length和callee属性\n\ncallee引用函数本身（返回正被执行的function对象），实现匿名的递归函数\n\nvar sum = function (n) {\n        if (1 == n) {\n            return 1;\n        } else {\n            return n + arguments.callee(n - 1);\n        }\n   }\n   alert(sum(6));输出结果：21\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 转换为数组\n\n 1. array.prototype.slice.call()\n\nfunction sum(a, b) {\n  let args = array.prototype.slice.call(arguments);\n  console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦\n}\nsum(1, 2);//3\n\n\n1\n2\n3\n4\n5\n\n\nfunction exam(a, b, c, d, e) {\n\n  // 先看看函数的自带属性 arguments 什么是样子的\n  console.log(arguments);\n\n  // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变\n  var arg = [].slice.call(arguments);\n\n  console.log(arg);\n}\n\nexam(2, 8, 9, 10, 3);\n\n// result:\n// { '0': 2, '1': 8, '2': 9, '3': 10, '4': 3 }\n// [ 2, 8, 9, 10, 3 ]\n//\n// 也常常使用该方法将dom中的nodelist转换为数组\n// [].slice.call( document.getelementsbytagname('li') );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n 2. array.prototype.splice.call(arraylike,0)\n\n 3. array.form\n\n对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例\n\nfunction sum(a,b){\n    let args=array.from(arguments);\n    console.log(args.reduce((sum,cur)=>sum+cur));\n}\nsum(1,2);\n\n\n1\n2\n3\n4\n5\n\n 3. es6扩展运算符\n\nfunction sum(a,b){\n    let args=[...arguments];\n    console.log(args.reduce((sum,cur)=>sum+cur));\n}\nsum(1,2);\n\n\n1\n2\n3\n4\n5\n\n 4. concat+apply or apply\n\nfunction sum(a,b){\n    let args=array.prototype.concat.apply([],arguments); //apply会把第二个参数展开\n    console.log(args.reduce((sum,cur)=>sum+cur));\n}\n\n\n1\n2\n3\n4\n\n\n古老for循环\n\n\n# 💜 数组拍平\n\n * es6的语法，arr.flat([depth])，depth默认不填，数值为1，参数可以是infinity，表示全部展开\n * tostring+replace+split\n\nlet arr = [1, [2, [3, [4, 5]]], 6];\nfunction flatten(arr) {\n  let str = json.stringify(arr);\n   str=str.replace(/(\\[|\\])/g,'')\n  str = '[' + str + ']';\n  return json.parse(str); \n}\nconsole.log(flatten(arr));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * replace+json.parse\n * 递归\n\nfunction flatten(arr,n){\n    if(n<2){\n        return arr;\n    }\n    let res=[];\n    const dfs=(arr,n)=>{\n        if(n<2){\n            res.push(arr);\n            return res;\n        }\n        for(let item of arr){\n            if(array.isarray(item) && n){\n                dfs(item,n-1);\n            }else{\n                res.push(item);\n            }\n        }\n    }\n    dfs(arr,n);\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 利用reduce函数迭代\n\nconst arr3 = [\n\t[1, 2],\n\t[3, 4],\n\t[5, [7, [9, 10], 8], 6],\n];\nconsole.log(flatten(arr3,2)); \nfunction flatten(_arr, depth = 1) {\n    if (depth === 0) {\n        return _arr;\n    }\n    return _arr.reduce((pre, cur) =>\n        pre.concat(array.isarray(cur) && depth>1 ?\n            flatten(cur, depth - 1) :\n            cur),[])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nfunction flatten(_arr, depth = 1) {\n    if (depth === 0) {\n        return _arr;\n    }\n    return _arr.reduce((pre,cur)=>{\n        return array.isarray(cur) && depth>1 ?\n            [...pre,...flatten(cur,depth-1)]:\n        [...pre,cur];\n    },[])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 扩展运算符\n\nwhile(arr.some(array.isarray)){\n    arr=[].concat(...arr);\n}\n\n\n1\n2\n3\n\n * tostring+split+map\n\nconst str=[1,2,3,[5,6,[7,8]]].tostring();\nconst _arr=str.split(\",\");\nconst newarr=_arr.map(item=>+item);\nconsole.log(newarr)\n\n\n1\n2\n3\n4\n\n\n\n# 数组去重\n\nindexof、includes、filter/foreach\n\nfunction unique(arr){\n    let res=arr.filter(function(item,index,array){\n        return array.indexof(item)===index\n    })\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nset+array.from()\n\nlet unique=arr=>[...new set(arr)];\nlet res=array.from(new set(arr));\n\n\n1\n2\n\n\nmap\n\nconst unique=(arr)=>{\n    const map=new map();\n    const res=[];\n    for(let item of arr){\n        if(!map.has(item)){\n            map.set(item,true);\n            res.push(item);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreduce+indexof\n\nconst newnums3 = nums.reduce((pre, cur, index, arr) => {\n    return [].concat(pre, nums.indexof(cur) === index ? cur : []);\n})\n\n\n1\n2\n3\n\n\n双重for循环\n\n\n# 🔥判断类型\n\n\n# typeof\n\n返回字符串： string、boolean、number、object、function、undefined、symbol(es6)\n\ntypeof null === '' //object\nconsole.log(typeof {}); // object\ntypeof undefined === '' //undefined\ntypeof function() {} ===‘’ //function\ntypeof nan; // \"number\"\n\n\n1\n2\n3\n4\n5\n\n\nnan 指“不是一个数字”（not a number），nan 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”\n\nnan 和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 nan != nan为 true\n\nvar a = function b() {}\nconsole.log(typeof b)\n\n\n1\n2\n\n\n\n# 区分null和object\n\n\n# instanceof\n\n原理：判断构造函数的prototype属性是否出现在对象的原型链上\n\n优点\n\n弥补 object. prototype. tostring. call()不能判断自定义实例化对象的缺点\n\n缺点\n\ninstanceof 只能判断对象类型\n\nconsole.log(2 instanceof number);   // false\nconsole.log(true instanceof boolean); // false \nconsole.log([] instanceof array);   // true\nconsole.log(function(){} instanceof function); // true\nconsole.log({} instanceof object); //true\n\n\n1\n2\n3\n4\n5\n\n\n实现\n\n// 利用原型链向上查找 能找到这个类的prototype的话，就为true\nfunction myinstanceof(left, right) {\n    if (left === null || typeof right !== 'function') {\n        return false;\n    }\n    let proto = object.getprototypeof(left);// 获取对象的原型\n    // let proto=left.__proto__;\n    let prototype = right.prototype; // 获取构造函数的 prototype 对象\n    // 判断构造函数的 prototype 对象是否在对象的原型链上\n    while (true) {\n        if (proto === null) {\n            return false;\n        }\n        if (proto === prototype) {\n            return true;\n        }\n        proto = object.getprototypeof(proto);\n    }\n}\n\nconst person = function () {\n}\nconst p1 = new person()\nconsole.log(myinstanceof(p1, person));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# object.prototype.tostring.call()\n\n使用object的原型方法tostring判读数据类型\n\n优点：能判断所有基本数据类型，即使 是 null 和 undefined\n\n缺点：不能精准判断自定义对象，对于自定义对象返回[object object]\n\nconst handletype=object.prototype.tostring;\nconsole.log(handletype.call(true));//'[object boolean]'\nconsole.log(handletype.call([]));//'[object array]'\nconsole.log(handletype.call(function(){}));//'[object function]'\nconsole.log(handletype.call({}));//'[object object]'\nconsole.log(handletype.call(undefined));//'[object undefined]'\nconsole.log(handletype.call(null));//'[object null]'\n\nobject.prototype.tostring.call(new regexp()); // [object regexp]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n为啥obj.tostring()的结果和object.prototype.tostring.call(obj)的结果不一样？\n\n因为tostring是object的原型方法，array，function作为object的实例，重写了tostring方法。不同对象类型调用tostring时，调用的是对应重写后的tostring方法(function类型返回内容为函数体的字符串，array类型返回元素组成的字符串...)，不会去调用object上原型tostring方法(返回对象具体类型)，因此需要使用object原型上的tostring方法才能得到想要对象的具体类型\n\n\n# constructor\n\n每一个对象实例都可以通过 constrcutor 对象访问它的构造函数 ，js 中内置了一些构造函数：object、array、function、date、regexp、string等。可以根据数据的 constrcutor 是否与其构造函数相等判断\n\n注意：若创建一个对象改变它的原型，constructor就不能用来判断数据类型了\n\nvar arr = [];\nvar obj = {};\nvar date = new date();\nvar num = 110;\nvar str = 'hello';\nvar getname = function() {};\nvar sym = symbol();\nvar set = new set();\nvar map = new map();\n\narr.constructor === array; // true\nobj.constructor === object; // true\ndate.constructor === date; // true\nstr.constructor === string; // true\ngetname.constructor === function; // true\nsym.constructor === symbol; // true\nset.constructor === set; // true\nmap.constructor === map // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n对于null和undefined无效，constructor不太稳定，prototype可被重写导致原有constructor丢失，object被覆盖也会影响判断结果\n\n\n# 判断数组类型？\n\n 1. instanceof 判断对象在其原型链上是否存在构造函数的prototype属性\n 2. array.isarray(arr) 静态方法，array.prototype也是一个数组\n    * 优点：检测 array 实例时，array. isarray 优于 instanceof\n    * 缺点：只能判别数组\n 3. object.prototype.tostring.call() （最靠谱）输出格式[object 对象数据类型]\n 4. arr.proto===array.prototype\n\n\n# typeof、instanceof\n\ntypeof 返回字符串，表示未经计算的操作数的类型\n\ninstanceof 检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n\n原理——顺着原型链找，直到找到相同的原型对象，返回true，否则为false\n\n区别如下：\n\n * typeof返回变量的基本类型，instanceof返回布尔值\n * instanceof 可准确判断复杂引用数据类型，但不能正确判断基础数据类型\n * typeof 可以判断基础数据类型（null 除外），但引用数据类型中，除了function 类型以外，其他的无法判断\n\n上述两种方法都有弊端，并不能满足所有场景的需求\n\n如果需要通用检测数据类型，可以采用object.prototype.tostring，统一返回格式“[object xxx]”的字符串\n\n\n# 🌰 深浅拷贝\n\n浅拷贝只能拷贝一层对象\n\n深拷贝能解决无限极对象嵌套问题\n\n\n# 浅拷贝\n\n新的对象对原始对象的属性精确拷贝，如拷贝的基本类型，拷贝的就是基本数据类型的值；如拷贝的引用类型，拷贝内存地址\n\n如果其中一个对象的引用内存地址改变，另一个对象也会变化\n\n\n# object.assing()\n\nes6的object的方法，可用于对象合并\n\nobject.assign(target, ...sources)\n\n\n1\n\n\ntarget是目标对象，sources是源对象\n\nlet target = {a: 1};\nlet object2 = {b: {d : 2}};\nlet object3 = {c: 3};\nobject.assign(target, object2, object3);  \nconsole.log(target);  // {a: 1, b: {d : 2}, c: 3}\nobject2.b.d = 666;\nconsole.log(target); // {a: 1, b: {d: 666}, c: 3}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 若目标和源对象有同名属性，或 多个源对象有同名属性，后面覆盖前面属性\n * 若该只有一个参数，参数为对象时直接返回；不是对象先转为对象返回\n * null和undefined不能转为对象，因此第一参数不能为null/undefined\n * 不会拷贝对象的继承属性，不会拷贝对象的不可枚举属性，可拷贝symbol属性\n\nobject.assign()循环遍历原对象可枚举属性，copy的方式赋值给目标对象的属性\n\n\n# 扩展运算符\n\nlet obj1 = {a:1,b:{c:1}}\nlet obj2 = {...obj1};\nobj1.a = 2;\nconsole.log(obj1); //{a:2,b:{c:1}}\nconsole.log(obj2); //{a:1,b:{c:1}}\nobj1.b.c = 2;\nconsole.log(obj1); //{a:2,b:{c:2}}\nconsole.log(obj2); //{a:1,b:{c:2}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n若属性都是基本类型，使用扩展运算符更方便\n\n\n# 数组浅拷贝\n\n# array.prototype.slice()\n\nslice的2个参数都不写，不修改原数组\n\nlet arr = [1,2,3,4];\nconsole.log(arr.slice()); // [1,2,3,4]\nconsole.log(arr.slice() === arr); //false\n\n\n1\n2\n3\n\n * 若该对象是个对象引用，slice会拷贝这个对象引用。2个对象都引用了同一个对象。若引用的对象改变，新旧数组中的这个元素也会改变\n * 对字符串、数字和布尔值说，slice会拷贝这些值。在别的数组中修改这些值不会影响另一个数组\n\n若向2个数组任一个添加新元素，另一个不受影响\n\n# array.prototype.concat()\n\n若省略了concat所有参数，会返回调用此方法的现存数组的浅拷贝\n\nlet arr = [1,2,3,4];\nconsole.log(arr.concat()); // [1,2,3,4]\nconsole.log(arr.concat() === arr); //false\n\n\n1\n2\n3\n\n\nconcat不改变this或任何作为参数提供的数组，而是返回一个浅拷贝，是原始数组的副本\n\n * 对象引用：concat将对象引用copy到新数组，原始/新数组都引用相同对象\n * 数据类型如字符串、数字和boolean：concat将字符串和数字的值copy到新数组\n\n\n# 应用场景\n\n对于一层结构的array和object想要拷贝一个副本时使用\n\n\n# 手撕\n\n * 对基础类型做最基本拷贝\n * 对引用类型开辟新的存储，拷贝一层对象属性\n\n// 浅拷贝的实现;\nfunction shallowcopy(object) {\n  // 只拷贝对象\n  if (!object || typeof object !== \"object\") return;\n  // 根据 object 的类型判断是新建一个数组还是对象\n  let newobject = array.isarray(object) ? [] : {};\n  // 遍历 object，并且判断是 object 的属性才拷贝\n  for (let key in object) {\n    if (object.hasownproperty(key)) {\n      newobject[key] = object[key];\n    }\n  }\n  return newobject;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n所有的浅拷贝只能拷贝一层。如果存在对象嵌套，浅拷贝无能为力。深拷贝就是为了解决这个问题而生，它能解决多层对象嵌套问题，彻底实现拷贝\n\n\n# 深拷贝\n\n简单数据类型直接拷贝值，引用数据类型，在堆内存开辟内存存放复制的对象，把原有对象类型数据拷贝过来，两个对象相互独立，属于不同内存地址，修改其中一个，另一个不改变\n\n\n# json.stringify()\n\njson.parse(json.stringify())\n\n将对象序列化为json字符串，再反序列化，生成对象\n\n使用最多，也最简单\n\nlet obj1 = {  \n  a: 0,\n  b: {\n    c: 0\n  }\n};\nlet obj2 = json.parse(json.stringify(obj1));\nobj1.a = 1;\nobj1.b.c = 1;\nconsole.log(obj1); // {a: 1, b: {c: 1}}\nconsole.log(obj2); // {a: 0, b: {c: 0}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 无法解决循环引用，对象成环(obj[key]=obj)\n * 无法拷贝特殊对象 regexp date set map 等\n * 忽略undefined、symbol和function(非安全类型的值)\n * 无法拷贝不可枚举属性\n * 无法拷贝对象原型链\n * nan、infinity变成null\n\n\n# lodash库\n\nvar _ = require('lodash');\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = _.clonedeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f);// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nlodash源代码\n\n/**\n* value：需要拷贝的对象\n* bitmask：位掩码，其中 1 是深拷贝，2 拷贝原型链上的属性，4 是拷贝 symbols 属性\n* customizer：定制的 clone 函数\n* key：传入 value 值的 key\n* object：传入 value 值的父对象\n* stack：stack 栈，用来处理循环引用\n*/\n\nfunction baseclone(value, bitmask, customizer, key, object, stack) {\n    let result\n \n    // 标志位\n    const isdeep = bitmask & clone_deep_flag  // 深拷贝，true\n    const isflat = bitmask & clone_flat_flag  // 拷贝原型链，false\n    const isfull = bitmask & clone_symbols_flag // 拷贝 symbol，true\n \n    // 自定义 clone 函数\n    if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value)\n    }\n    if (result !== undefined) {\n        return result\n    }\n \n    // 非对象  \n    if (!isobject(value)) {\n        return value\n    }\n    \n    const isarr = array.isarray(value)\n    const tag = gettag(value)\n    if (isarr) {\n        // 数组\n        result = initclonearray(value)\n        if (!isdeep) {\n            return copyarray(value, result)\n        }\n    } else {\n        // 对象\n        const isfunc = typeof value == 'function'\n \n        if (isbuffer(value)) {\n            return clonebuffer(value, isdeep)\n        }\n        if (tag == objecttag || tag == argstag || (isfunc && !object)) {\n            result = (isflat || isfunc) ? {} : initcloneobject(value)\n            if (!isdeep) {\n                return isflat\n                    ? copysymbolsin(value, copyobject(value, keysin(value), result))\n                 : copysymbols(value, object.assign(result, value))\n            }\n        } else {\n            if (isfunc || !cloneabletags[tag]) {\n                return object ? value : {}\n            }\n            result = initclonebytag(value, tag, isdeep)\n        }\n    }\n    // 循环引用\n    stack || (stack = new stack)\n    const stacked = stack.get(value)\n    if (stacked) {\n        return stacked\n    }\n    stack.set(value, result)\n \n    // map\n    if (tag == maptag) {\n        value.foreach((subvalue, key) => {\n            result.set(key, baseclone(subvalue, bitmask, customizer, key, value, stack))\n        })\n        return result\n    }\n \n    // set\n    if (tag == settag) {\n        value.foreach((subvalue) => {\n            result.add(baseclone(subvalue, bitmask, customizer, subvalue, value, stack))\n        })\n        return result\n    }\n \n    // typedarray\n    if (istypedarray(value)) {\n        return result\n    }\n \n    // symbol & 原型链\n    const keysfunc = isfull\n     ? (isflat ? getallkeysin : getallkeys)\n     : (isflat ? keysin : keys)\n \n    const props = isarr ? undefined : keysfunc(value)\n    \n    // 遍历赋值\n    arrayeach(props || value, (subvalue, key) => {\n        if (props) {\n            key = subvalue\n            subvalue = value[key]\n        }\n        assignvalue(result, key, baseclone(subvalue, bitmask, customizer, key, value, stack))\n    })\n    \n    // 返回结果\n    return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n\n\n\n# 应用场景\n\n复制深层次的object数据结构\n\n\n# 手撕\n\n# 基础递归\n\nfor-in遍历属性，基本类型则直接copy，引用类型则递归调用\n\nfunction deepcopy(object) {\n    if (!object || typeof object !== \"object\") {\n        return;\n    }\n    let newobject = array.isarray(object) ? [] : {};\n\n    for (let key in object) {\n        if (object.hasownproperty(key)) {\n            newobject[key] = typeof object[key] === \"object\" ?\n                deepcopy(object[key]) :\n                object[key];\n        }\n    }\n    return newobject;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 不能复制不可枚举属性及 symbol 类型\n * 只能对普通引用类型值做递归复制，date、regexp、function 等引用类型不能正确拷贝\n * 可能存在循环引用\n\n# 优化递归\n\n# 第一版本\n\n 1. reflect.ownkeys() 解决不能复制不可枚举属性及 symbol 问题。返回由目标对象自身属性键组成的数组。返回值等同于: object.getownpropertynames(target).concat(object.getownpropertysymbols(target))\n 2. 参数为 date、regexp 时，直接生成新实例返回\n 3. object.getownpropertydescriptors() 获得对象所有属性及特性。返回给定对象所有属性的信息，包括有关getter和setter的信息。允许创建对象副本并在复制所有属性（包括getter和setter）时克隆它\n 4. object.create() 创建新对象，继承传入原对象的原型链。使用现有的对象提供新创建对象的__proto__\n 5. weakmap 类型作为 hash 表，是弱引用类型，防止内存泄漏，用来检测循环引用，如存在循环，则引用直接返回 weakmap 存储的值。weakmap的特性是，保存在其中的对象不影响垃圾回收，如weakmap保存节点在其他地方没被引用，即使它还在weakmap中也会被垃圾回收。深拷贝过程，所有引用对象都是被引用，为解决循环引用，深拷贝过程，希望有个数据结构记录每个引用对象有没有被使用，但深拷贝结束之后这个数据能自动垃圾回收，避免内存泄漏\n\n代码实现：\n\nfunction deepclone (obj, hash = new weakmap()) {\n  // 日期对象直接返回一个新的日期对象\n  if (obj instanceof date){\n   return new date(obj);\n  } \n  //正则对象直接返回一个新的正则对象     \n  if (obj instanceof regexp){\n   return new regexp(obj);     \n  }\n  //如果循环引用,就用 weakmap 来解决\n  if (hash.has(obj)){\n   return hash.get(obj);\n  }\n  // 获取对象所有自身属性的描述\n  let alldesc = object.getownpropertydescriptors(obj);\n  // 遍历传入参数所有键的特性\n  let cloneobj = object.create(object.getprototypeof(obj), alldesc)\n  \n  hash.set(obj, cloneobj)\n  for (let key of reflect.ownkeys(obj)) { \n    if(typeof obj[key] === 'object' && obj[key] !== null){\n     cloneobj[key] = deepclone(obj[key], hash);\n    } else {\n     cloneobj[key] = obj[key];\n    }\n  }\n  return cloneobj\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n测试\n\nlet obj = {\n  num: 1,\n  str: 'str',\n  boolean: true,\n  und: undefined,\n  nul: null,\n  obj: { name: '对象', id: 1 },\n  arr: [0, 1, 2],\n  func: function () { console.log('函数') },\n  date: new date(1),\n  reg: new regexp('/正则/ig'),\n  [symbol('1')]: 1,\n};\nobject.defineproperty(obj, 'innumerable', {\n  enumerable: false, value: '不可枚举属性' \n});\nobj = object.create(obj, object.getownpropertydescriptors(obj))\nobj.loop = obj    // 将loop设置成循环引用的属性\nlet cloneobj = deepclone(obj)\n\nconsole.log('obj', obj)\nconsole.log('cloneobj', cloneobj)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n缺点——map和set无法拷贝\n\n# 第二版本\n\n/**\n * 深拷贝 避免循环引用\n */\nconst deepcopy2 = (target, hash = new weakmap()) => {\n    if (target === null) {\n        return target;\n    }\n    if (target instanceof date) {\n        return new date(target);\n    }\n    if(target instanceof regexp){\n        return new regexp(target);\n    }\n    if(typeof target!=='object'){\n        return target;\n    }\n    if (hash.get(target)) {\n        //   避免循环引用\n        return target;\n    }\n    let cloneobj=new target.constructor();\n    hash.set(target, true);\n    const clonetarget = array.isarray(target) ? [] : {};\n    for (let prop in target) {\n        if (target.hasownproperty(prop)) {\n            clonetarget[prop] = deepcopy2(target[prop], hash);\n        }\n    }\n    return clonetarget;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n# 第三版本\n\nfunction deepclone(source, map = new weakmap()) { // 传入一个weakmap对象用于记录拷贝前和拷贝后的映射关系\n        if (typeof source !== \"object\") { // 非对象类型(undefined、boolean、number、string、symbol)，直接返回原值即可\n            return source;\n        }\n        if (source === null) { // 为null类型的时候\n            return source;\n        }\n        if (source instanceof date) { // date类型\n            return new date(source);\n        }\n        if (source instanceof regexp) { // regexp正则类型\n            return new regexp(source);\n        }\n        if (map.get(source)) { // 如果存在相互引用，则从map中取出之前拷贝的结果对象并返回以便形成相互引用关系\n            return map.get(source);\n        }\n        let result;\n        if (array.isarray(source)) { // 数组\n            result = [];\n            map.set(source, result); // 数组也会存在相互引用\n            source.foreach((item) => {\n                result.push(deepclone(item, map)); // 必须传入第一次调用deepclone时候创建的map对象\n            });\n            return result;\n        } else { // 为对象的时候\n            result = {};\n            map.set(source, result); // 保存已拷贝的对象\n            const keys = [...object.getownpropertynames(source), ...object.getownpropertysymbols(source)]; // 取出对象的key以及symbol类型的key\n            keys.foreach(key => {\n                let item = source[key];\n                result[key] = deepclone(item, map); // 必须传入第一次调用deepclone时候创建的map对象\n            });\n            return result;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 操作符\n\n\n\n> +和 - 一样，会将其操作数转化为数值，返回转化后的值\n\n * 若操作数是数值，它啥都不做\n * 若操作数不能转化为数组，返回nan\n * 不可用于bigint，bigint不能转化为数值\n\n按位与&\n\n * 判断奇偶，最末位是0/1，是0就是偶数，1就是奇数，用if ((i & 1) === 0)代替if (i % 2 === 0)来判断a是不是偶数\n * 清零\n\n>  * \n\n1 + {}            // \"1[object object]\"\ntrue + false      // 1  布尔值会先转为数字，再进行运算\n1 + null          // 1 null会转化为0，再进行计算\n1 + undefined     // nan undefined转化为数字是nan\n\n\n1\n2\n3\n4\n\n\n> 逻辑非 !\n\n首先将操作数转化为布尔值，再对其取反\n\n * 对象，返回false\n * 空字符串，返回true\n * 非空字符串，返回false\n * 数值0，返回true\n * 非0数值，返回false\n * null，返回true\n * nan，返回true\n * undefined，返回true\n\n可用户将任何值转化为布尔值，使用2个!，相当于调用了boolean()\n\n!!\"blue\" // true\n!!0;     // false\n!!nan    // false\n!!\"\"     // false\n!!12345  // true\n\n\n1\n2\n3\n4\n5\n\n\n> 关系操作符\n\n遵循规则\n\n * 2个操作数都是数值，进行数值比较\n * 2个操作数都是字符串，比较字符串对应的字符编码值\n * 若一个操作数是数值，则将另一个操作数转换为数值，执行数值比较\n * 若一个操作数是对象，调用对象的valueof()，根据前面的规则比较\n * 若一个操作数是布尔值，先将其转换为数值，再比较\n\n\n# 💙 类型转换\n\n6种基本类型 null undefined number stringify boolean symbol\n\n1种引用类型 object\n\n\n# 对象转换为基本类型\n\n * 对象转换为字符串\n\n优先调用tostring\n\n// 模拟 tostring 返回的不是基本类型值，valueof 返回的基本类型值\nvar obj = {\n    tostring: function() {\n        return {}\n    },\n    valueof:function(){\n        return null\n    }\n}\n\nstring(obj)   // \"null\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 对象转换为数字\n\n先判断valueof方法，再判断tostring方法\n\n\n\n// valueof 和 tostring 返回的都不是基本类型值\nvar obj = {\n    valueof:function(){\n        return {}\n    },\n    tostring:function(){\n        return {}\n    }\n}\n\nnumber(obj)  // uncaught typeerror: cannot convert object to primitive value\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nobject.create(null)创建的对象没有valueof和tostring方法，因此转换报错\n\n一般，我们不会重写valueof和tostring，大部分对象valueof返回的仍然是对象，因此对象转换为基本类型值可以直接看tostring返回的值\n\n * 转换为对象\n\n优先调用tostring，若没有重写tostring 则调用valueof，若2者均没有被重写，按tostring输出\n\n\n# 显式强制类型转换\n\n * 转换为字符串\n\n如果对象有自定义tostring方法，则返回tostring方法的结果，若是tostring返回的结果不是基本类型值，报错typeerror\n\nvar obj = {\n    tostring:function(){\n        return {}\n    }\n}\n\nstring(obj) // uncaught typeerror: cannot convert object to primitive value\n\nobj + \"\"   // uncaught typeerror: cannot convert object to primitive value\n\nobj.tostring()  // {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 转换为布尔类型\n\nnull undefined false +0 -0 nan \"\"\n\n其他情况都是true\n\n * 转换为数字类型\n\nnumber('')    // 0\nnumber(null)  // 0\nnumber(undefined)  // nan\nnumber(true)  // 1\nnumber(false)  // 0\n\n\n1\n2\n3\n4\n5\n\n\n对象 先被转换为相应基本类型值，再转换\n\nnumber([])  // 0\n// [] valueof 返回的是 []，因此继续调用 tostring 得到基本类型值 \"\"，转换为数字为 0\n\n\n1\n2\n\n\n\n# 隐式强制类型转换\n\n          被比较值 b                                                                                                                                      \n                      undefined   null                  number                        string                          boolean                         object\n被比较值 a    undefined   true        true                  false                         false                           false                           isfalsy(b)\nnull      true        true        false                 false                         false                           isfalsy(b)                      \nnumber    false       false       a === b               a === tonumber(b)             a=== tonumber(b)                a== toprimitive(b)              \nstring    false       false       tonumber(a) === b     a === b                       tonumber(a) === tonumber(b)     toprimitive(b) == a             \nboolean   false       false       tonumber(a) === b     tonumber(a) === tonumber(b)   a === b                         tonumber(a) == toprimitive(b)   \nobject    false       false       toprimitive(a) == b   toprimitive(a) == b           toprimitive(a) == tonumber(b)   a === b                         \n\ntonumber(a) 在比较前将a 转换为数字，与 +a（单目运算符 +）效果相同。toprimitive(a)尝试调用 a 的a.tostring() 和 a.valueof() ，将 a 转换为原始值（primitive）\n\n * 转换为字符串\n\nx+\"\"，将x转换为字符串，+ 运算符其中一个操作数是字符串，执行字符串拼接操作\n\n对象和字符串拼接时，**对象转为基本类型，再转为数字，**先判断valueof，再判断tostring\n\nvar obj = {\n    valueof: function() {\n        return 1\n    },\n    tostring: function() {\n        return 2\n    }\n}\n\nobj + ''  // '1'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 转换为布尔值\n\n发生布尔值隐式强制类型转换的情况\n\n 1. if (..)语句中的条件判断表达式\n 2. for ( .. ; .. ; .. )语句中的条件判断表达式（第二个）\n 3. while (..)和do..while(..)循环中的条件判断表达式\n 4. ? :中的条件判断表达式\n 5. 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）\n\n> alert(3>5 || 'a' && 'b')\n\n * 转换为数字类型\n\n+ '2'  // 2\n'2' - 0  // 2\n'2' / 1   // 2\n'2' * 1   // 2\n\n\n+ 'x'  // nan\n'x' - 0 // nan\n'x' / 1 // nan\n'x' * 1  // nan\n\n1 + '2'  // '12'\n1 + + '2'  // 3    即：1 + (+ '2')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# ==、===\n\n== 允许在比较中强制类型转换， === 不允许\n\n== 比较时 ，2个操作符都会进行强制类型转换，再确定是否相等\n\n比较规则\n\n 1. 判断二者类型是否相同，相同则比较大小\n 2. 类型不同，进行类型转换\n 3. null和undefined，返回true，其**他类型和 null 均不相等**，undefined 也是\n 4. string和number，将字符串转换为number\n 5. 若其中一方是boolean，将boolean转为number再判断\n 6. 若其中一方是object，另一方是string、number或symbol，将object转为原始类型再判断，对象转换优先级最高\n\n\n\n注意！\n\n若一个是nan，相等运算符返回false，不相等运算符返回true\n\n对于(!=)，只有在强制类型转换后不相等才返回 false\n\n对于(===)，只有当2个操作数 数据类型和值都相等时，返回true，它不会转化数据类型\n\n对于(!==)，只有2个操作数在不进行类型转化的情况下是不相等的，才返回true\n\nnull+1=1\nundefined+1=nan\n1 + {} = \"1[object object]\"//一个操作数是对象,调用对象的 valueof 转成原始值,如果没有该方法或调用后仍是原始值,则调用 tostring 方法\n\n\n1\n2\n3\n\n\nnull转换为number=0\n\nundefined转换为number=nan\n\n其它运算只要其中一方是数字,另一方就转为数字\n\n'a' + + 'b' // -> \"anan\"\n// 因为 + 'b' -> nan\n// 你也许在一些代码中看到过 + '1' -> 1\n\n\n1\n2\n3\n\n\n![]=='' //true\n[]=='' //true\n[]==![] //true\n{}=={} \n\n\n1\n2\n3\n4\n\n\n5、特殊情况\n\nnan == nan  // false\n-0  == +0   // true\n!nan //true\n\n\n1\n2\n3\n\n\n两个对象比较，判断两个对象是否是同一个引用\n\n\"0\" == false // true\n// false 转换为数字  0，等式变为 \"0\" == 0\n// 类型不一致继续转换，\"0\" 转换为数字 0，变为 0 == 0\n\nfalse == [] // true\n// [] 转换基本类型值 [].tostring() 为 \"\"，变为 \"\" == false\n// 类型不一致，继续转换，false 转换为数字为 0，变为 \"\" == 0\n// 类型不一致，继续转换，第1条规则，\"\" 转换为数字，结果为 0，变为 0 == 0\n\n0 == []    // true\n// [] 转换基本类型值，[].tostring()，结果为 \"\"，等式变为 0 == \"\"\n// 类型不一致，继续转换，\"\" 转换为数字，结果为 0，等式变为 0 == 0\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n参考文档https://dorey.github.io/javascript-equality-table/\n\n\n# 优先级\n\n左结合（左到右）——把左边的子表达式加上小括号 (a op b) op c\n\n右结合（右到左）—— a op (b op c)\n\n赋值运算符是右结合\n\na=b=5 相当于 a=(b=5)\n\n只有幂运算符是右结合的，其他算术运算符都是左结合\n\n6 / 3 / 2 与 (6 / 3) / 2 相同，除法左结合。幂运算符右结合，所以 2 ** 3 ** 2 与 2 ** (3 ** 2) 相同\n\n判断执行顺序时，优先级在结合性之前，混合求除法和幂，求幂先于除法\n\n2 ** 3 / 3 ** 2 的结果是 0.8888888888888888，相当于 (2 ** 3) / (3 ** 2)\n\n\n\n逻辑非!的优先级比全等===高\n\n点运算符（.）优先级高于new(无参数列表)\n\n[] 、函数调用 优先级和new(带参数列表)一样高\n\nnew foo()优先级大于 new foo\n\nnew foo().getname相当于 (new foo()).getname()\n\nnew foo.getname()相当于 new (foo.getname)()\n\n展开语法不是运算符，因此没有优先级\n\n\n# 🌰 0.1+0.2 === 0.3?\n\njs数字存储采用ieee754双精度存储，小数使用64位固定长度表示，其中1位表示符号位，11位表示指数位，剩下52尾数位\n\n总结\n\n 1. 精度损失 0.1和0.2转换为二进制出现无限循环情况，js 最大可存储53位有效数字，超过此长度会被截取掉，造成精度损失\n 2. 对2个64位双精度格式数据计算时，先对阶(将阶码对齐，将小数点位置对齐)，小阶数在对齐时，有效数字向右移动，超过有效位数的位被截取掉\n 3. 两个数据阶码对齐后加运算，结果可能超过53位有效数字，超过的位被截取掉\n\n相加后因浮点数小数位限制截断的二进制数字转换为十进制时变成0.30000000000000004(15个0)\n\n\n# 让其相等？\n\n * 转换为整数，结果转换为对应小数\n\n * 设置误差范围(将结果与右边相减，若结果小于一个极小数，则正确)\n   \n   * 极小数可以是 es6 的 number.epsilon，实质是一个可接受的最小误差范围, 一般为 math.pow(2, -52)\n\nfunction isequal(a, b) {\n  return math.abs(a - b) < number.epsilon;\n}\nconsole.log(isequal(0.1 + 0.2, 0.3)); // true\n\n\n1\n2\n3\n4\n\n * 转成字符串,对字符串做加法运算\n\nparsefloat((0.1 + 0.2).tofixed(10))\n//tofixed四舍五入\n\n\n1\n2\n\n * toprecision转换成数字，以指定精度返回该数值对象的字符串表示，四舍五入到参数指定的数字位数\n\nfunction strip(num, precision = 12) {\n  return parsefloat(num.toprecision(precision));\n}\nlet x=strip(0.30000000000000004,18)\nconsole.log(x)\n//默认去掉最低位的0\n\n\n1\n2\n3\n4\n5\n6\n\n * 将计算数字提升10的n次方\n\n(0.1*1000+0.2*1000)/1000==0.3\n//true\n\n\n1\n2\n\n\n+(0.1+0.2).tofixed(2)\n//一元加号强制转换为数字\n\n\n1\n2\n\n * math.js\n\n\n# bind、call、apply\n\n\n# call、apply\n\n改变函数体内部this指向\n\n第一个参数都是 this 的指向对象，第二个参数差别：\n\ncall 参数按顺序传递， obj.myfun.call(db,'成都', ... ,'string' )\n\napply参数为数组，obj.myfun.apply(db,['成都', ..., 'string' ])\n\n> 用法\n\n数组追加\n\nvar array1 = [12 , \"foo\" , {name :\"joe\"} , -2458]; \nvar array2 = [\"doe\" , 555 , 100]; \narray.prototype.push.apply(array1, array2); \n/* array1  [12 , \"foo\" , {name \"joe\"} , -2458 , \"doe\" , 555 , 100] */\n\n\n1\n2\n3\n4\n\n\n获取数组最大/小值\n\nvar a=[1,2,3,4];\nlet ans=math.max.apply(null, a);\n\n\n1\n2\n\n\n验证是否为数组(前提是tostring()未被重写)\n\nobject.prototype.tostring.call(obj)==='[object array]';\n\n\n1\n\n\n类数组转换为数组\n\nlet arr=array.prototype.slice.call(arguments);\n\n\n1\n\n\n每个function实例都有call、apply属性？？是的！\n\n\n# bind\n\nbind 除了返回一个新函数以外，参数和 call 一样\n\n注意：将null undefined 作为第一参数时，被忽略\n\n严格模式下 this为undefined\n\n多次调用bind()无效\n\n当 bind 返回的函数作为构造函数 时，bind 指定的this失效，但传入的参数有效\n\nvar value = 2;\n\nvar foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    this.habit = 'shopping';\n    console.log(this.value);\n    console.log(name);\n    console.log(age);\n}\n\nbar.prototype.friend = 'kevin';\n\nvar bindfoo = bar.bind(foo, 'daisy');\n\nvar obj = new bindfoo('18');\n// undefined 绑定的value失效！！\n// daisy\n// 18\nconsole.log(obj.habit);\nconsole.log(obj.friend);\n// shopping\n// kevin\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n> 实现\n\nfunction.prototype.bind2 = function (context) {\n    if (typeof this !== \"function\") {\n      throw new error(\"function.prototype.bind - what is trying to be bound is not callable\");\n    }\n\n    var self = this;\n    //获取bind2函数从第二个到最后一个参数\n    var args = array.prototype.slice.call(arguments, 1);\n\n    var fnop = function () {};\n\n    var fbound = function () {\n        //bind返回的函数传入的参数\n        var bindargs = array.prototype.slice.call(arguments);\n        return self.apply(this instanceof fbound ? this : context, args.concat(bindargs));\n    }\n//直接修改fbound.prototype时，也会直接修改 绑定函数的 prototype？？？\n    //fbound.prototype=this.prototype 为了fbound构造的实例能继承绑定函数原型中的值\n    fnop.prototype = this.prototype;\n    fbound.prototype = new fnop();\n    return fbound;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 为啥fbound.prototype直接修改也会修改 绑定函数的 prototype？\n\nfunction.prototype.bind2 = function (context) {\n    var self = this;\n    var args = array.prototype.slice.call(arguments, 1);\n\n    var fbound = function () {\n        var bindargs = array.prototype.slice.call(arguments);\n        self.apply(this instanceof fbound ? this : context, args.concat(bindargs));\n    }\n  \n    fbound.prototype = this.prototype;\n    return fbound;\n}\nfunction bar() {}\nvar bindfoo = bar.bind2(null);\nbindfoo.prototype.value = 1;\nconsole.log(bar.prototype.value) // 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n相当于 用原型式继承 包了一层，实现2个实例间原型的数据共享，但又能 避免return的函数原型直接修改原型，导致绑定函数的原型也被修改\n\n\n# vo、ao\n\nvariable object\nactivation object\n\n\n1\n2\n\n\nao和vo其实是同一个东西，处于不同 生命周期 罢了\n\n只是vo是规范上/引擎实现的，不可在js环境中访问，只有进入 执行上下文 中，vo被激活，所以才叫ao呐\n\n变量对象是与执行上下文相关的数据作用域，存储 在上下文中定义的 变量和函数声明\n\n只有处于函数调用栈 栈顶的执行上下文中的vo，才会变成ao\n\n\n# ✅this\n\n调用函数时 创建一个执行环境，this在运行时根据函数的执行环境绑定，它允许函数在内部引用上下文中的执行变量，使函数更加优雅简洁\n\n> new>显示>隐式>默认\n\nthis指向在 执行上下文被创建时确定，函数执行过程中，一旦this指向被确定就不可更改\n\n在一个函数上下文中，this由调用者提供。如果调用者函数，被某一个对象所拥有，该函数在调用时，this指向该对象。如果函数独立调用，该函数内部的this指向undefined，在非严格模式中，this自动指向全局对象\n\n// demo03\nvar a = 20;\nvar obj = {\n  a: 10,\n  c: this.a + 20,\n  fn: function () {\n    return this.a;\n  }\n}\n\nconsole.log(obj.c); //40\nconsole.log(obj.fn()); //10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n**单独的{}不形成新的作用域，**这里的this.a，并没有作用域的限制，仍然处于全局作用域之中\n\n定义对象的大括号{}不是一个单独的执行环境，依旧处于全局环境\n\n\n# 绑定规则\n\n1、默认\n\n2、隐式\n\n考虑 调用位置是否上下文对象\n\n若函数调用当前存在多个对象，this指向距离自己最近的对象\n\n> 隐式丢失\n\n作为参数传递和变量赋值，会使参数或变量直接指向函数，丢失this指向\n\n如何解决？\n\n使用隐式绑定：将函数绑定至对象属性，调用时通过对象属性直接调用，弱赋值到其他对象，需将正对象赋值过去，不然会丢失 初次绑定的环境\n\n3、显式\n\ncall、bind和apply 改变this\n\n4、new\n\n创建一个新的对象将其绑定到foo()调用的this\n\n5、箭头函数\n\n从自己的作用域链的上一层继承this\n\n\n# 全局上下文\n\n> 全局对象\n\n 1. 可通过this访问\n 2. 是object实例化的一个对象\n 3. 预定了一堆函数和属性\n 4. 作为全局变量的宿主\n 5. 客户端，this.window==this\n\n全局上下文中的变量对象就是全局对象！！\n\n非严格模式和严格模式中this指向顶层对象\n\n// 在浏览器中，全局对象为 window 对象：\nconsole.log(this === window); // true\n\nthis.a = 37;\nconsole.log(window.a); // 37\n\n\n1\n2\n3\n4\n5\n\n\n\n# 函数上下文\n\n严格模式下 this 为undefined，非严格模式下为 window\n\n活动对象在进入函数上下文时被创建，通过arguments初始化\n\n执行上下文代码分2个阶段\n\n 1. 进入执行上下文\n 2. 执行\n\n\n# 进入执行上下文\n\n变量对象包括\n\n 1. 函数的所有形参\n    1. 键值对形式的变量对象被创建\n    2. 无 实参，值设为 undefined\n 2. 函数声明\n    1. 名称和对应值(函数对象 function-object)组成变量对象的属性被创建\n    2. 若vo 已存在同名 属性，则完全替换\n 3. 变量声明\n    1. 名称和对应值(undefined)组成vo被创建\n    2. 若变量名称和已声明形参/函数相同，则 变量声明 不会干扰已存在的这类属性———所以 再次声明的var变量不会覆盖掉已变量提升的函数声明！！\n\njs在函数预处理阶段的解析顺序：\n函数参数->内部声明式函数->内部var声明的变量\n\n\n1\n2\n\n\n\n# 代码执行\n\n顺序执行代码并 修改 vo的值\n\n\n# 箭头函数\n\n标准函数中this引用的是 方法调用 时的上下文\n\n箭头函数的this 为定义时所在的 this，不绑定this (因为箭头函数没有constructor)，捕获其所在上下文的 this 作为自己的 this\n\n若包裹在函数中，就是函数调用时所在的对象，全局就是window，箭头函数的this是外层代码块的this，固定不变\n\n\n# 特点\n\n * 没有自己的this\n * 继承来的this不会变\n * 没有arguments，获得的arguments是外层函数的arguments\n * call apply 和bind无法改变this\n\n\n# 啥时候不能用\n\n * 对象方法不适用 箭头函数\n * 原型方法 不适用\n * 不可用于构造函数，没有new关键字\n * 不用于 动态上下文的回调\n\nconst btn1 = document.getelementbyid('btn1')\nbtn1.addeventlistener('click', () => {\n    this.innerhtml = 'clicked'\n    //此处 this指向 window，而不是 button\n})\n\n\n1\n2\n3\n4\n5\n\n * vue 生命周期和method不能用\n\nreact可以用\n\n因为 vue本质是对象，react组件(class)本质是es6的class\n\n * 不能用于generator函数，没有yield关键字\n\n> 不适用箭头函数如何使其指向实例\n\n函数定义在prototype就能获得this指向\n\n\n# bind 函数\n\n在 function的原型链上，function.prototype.bind 通过 bind 函数绑定后，函数将绑定在其第一个参数对象上，除非使用new时被改变，其他情况不会改变，无论在啥情况下被调用\n\n！！多次bind调用，this指向依旧是第一次的\n\n\n# settimeout、setinterval\n\nfor(var i=0;i<5;i++){\n    ;(function(i){\n        settimeout(function(){\n            console.log(i)\n        },i*1999)\n    })()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n**延时函数内部回调函数this 指向全局对象window\n\nintroduction() === introduction.call() ，前者是后者的简写！call()中的第一个传参 指定这个函数中的 this 指向！\n\nfunction introduction(name) {\n  console.log('你好,'+ name +' 我是' + this.name);\n}\nvar zhangsan = {\n name:'张三'\n}  \nintroduction.call(zhangsan,\"李四\")   // 你好 李四, 我是 张三   call\nintroduction.apply(zhangsan,[\"李四\"])   // 你好 李四, 我是 张三   apply\nintro = introduction.bind(zhangsan)\nintro(\"李四\")// 你好 李四, 我是 张三   bind\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nbind()返回一个绑定新环境的function，等着被调用\n\n\n# 🌈 函数\n\n\n# new function\n\nlet func = new function ([arg1, arg2, …argn], functionbody);\n\n\nlet sum = new function('a', 'b', 'return a + b');\nconsole.log(sum(1, 2)); \n\n\n1\n2\n3\n4\n5\n\n 1. 无效的 json 对象字符串合法化\n 2. 模板字符串作为模板\n 3. 闭包和上下文\n\nnew function body 参数变量上下文是全局的，不是私有，没有闭包\n\n\nfunction getfunc() {\nlet value = 'yh';\nlet func = new function('console.log(value)');\nreturn func;\n}\ngetfunc()(); // error: value is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n常规函数语法没有问题\n\n\nfunction getfunc() {\nlet value = 'yh';\nlet func = function () {\nconsole.log(value)\n  };\nreturn func;\n}\ngetfunc()(); // print 'yh'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nnew function 语 regexp ，使用字符串作为正则表达式的内容， 适合动态匹配/ 增加代码混淆\n\n\n# 函数声明\n\n使用function的函数声明比函数表达式优先提升\n\n> 函数声明比变量声明 更优先执行顺序\n\n无论在什么位置声明了函数，都可以在同一个执行上下文中直接使用该函数\n\n\n# 函数表达式\n\n也叫匿名函数—— 没有被显式赋值操作的函数。使用场景，多为一个参数传入另一个函数中\n\n函数自执行，其实是匿名函数的一种应用\n\n函数表达式使用 var/let/const声明，确认他是否可正确使用时 必须依照var/let/const的规则判断——变量声明\n\nvar声明，其实进行两步操作\n\n// 变量声明\nvar a = 20;\n\n// 实际执行顺序\nvar a = undefined;  // 变量声明，初始值undefined，变量提升，提升顺序次于function声明\na = 20;  // 变量赋值，该操作不会提升\n\n\n1\n2\n3\n4\n5\n6\n\n\n同样道理，当使用变量声明的方式声明函数时——函数表达式。函数表达的提升方式与变量声明一致\n\nfn(); // 报错\nvar fn = function() {\n    console.log('function');\n}\n//上述例子执行顺序为\nvar fn = undefined;   // 变量声明提升\nfn();    // 执行报错\nfn = function() {   // 赋值操作，将后边函数的引用赋值给fn\n    console.log('function');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 由于声明方式的不同，导致函数声明与函数表达式存在差异，除此，这种形式在使用上并无不同\n\n\n# 函数声明、函数表达式\n\n * 函数声明式 ： function functionname （）{}\n * 函数表达式：let name = function(){}\n\nconsole.log(a) //undefined\nvar a = 1\nconsole.log(getnum)//getnum(){a=3}\nvar getnum = function() { \n  a = 2\n}\nfunction getnum() {\n  a = 3\n}\nconsole.log(a) //1\ngetnum()\nconsole.log(a) //2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n函数声明有提升作用，执行前把函数提升到顶部，执行上下文中生成函数定义，所以第二个 getnum会被最先提升到顶部\n\n然后var 声明 getnum 的本该提升，但 getnum 的函数已经被声明了，所以不需要再声明一个同名变量，只是将已经声明的getnum替换掉了，于是修改变量a=2\n\nvar a = 1\nfunction a(){} //已经声明提升,跳过\nconsole.log(a) //1\n\nvar b\nfunction b(){} \nconsole.log(b) //f b(){}\n\nfunction b(){}\nvar b //已经提升过了,var声明忽略\nconsole.log(b) //f b(){}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n！！函数会优先提升. function声明优先于var声明\n\n> 进入执行上下文时，先 处理函数声明，其次 处理 变量声明，如果变量名称跟已经声明的形参或函数相同，变量声明不会干扰已经存在的这类属性\n\n箭头函数和函数声明区别？？？\n\nsettimeout(foo, 100)\nfoo = () => {\n    console.log('a')\n}\nfoo()\n\nfunction foo() {\n    console.log('b')\n}\n\nfoo()\n\nfunction foo() {\n    console.log('c')\n}\n\nfoo()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n> 回调函数？由谁调用？\n\n匿名函数传入另一个函数之后，最终会在另一个函数中执行，称这个匿名函数为回调函数\n\n\n# 高阶函数\n\n> 一个函数可接收另一个函数作为参数或返回另一个函数\n\n 1. map\n 2. reduce\n\n * 参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中四个默认参数，依次为积累值、当前值、当前索引和整个数组\n\n 3. filter 返回新数组\n 4. sort\n\n\n# 普通函数\n\n若是'use strict'，不能将全局对象window作为默认绑定。this=undefined\n\n普通函数：定义时this 指向函数作用域，但定时器之后执行函数时，此时this指向 window\n\n> 普通函数的this，是调用是所在的对象\n\n\n# 自执行函数\n\n[iife]immediately invoked function expression：声明即执行的函数表达式\n\n\n# 函数按值传参\n\n结论仍然是按值传递，当我们期望传递一个引用类型时**，真正传递的，**只是这个引用类型保存在变量对象中的引用而已\n\nvar person = {\n    name: 'nicholas',\n    age: 20\n}\n\nfunction setname(obj) {  // 传入一个引用\n    obj = {};   // 将传入的引用指向另外的值\n    obj.name = 'greg';  // 修改引用的name属性\n}\n\nsetname(person);\nconsole.log(person.name);  // nicholas 未被改变\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 函数式编程\n\n函数式编程的思维建议我们将这种会多次出现的功能封装起来\n\n使用时，只需要关心这个方法能做什么，而不用关心具体是怎么实现的。这也是函数式编程思维与命令式不同的地方之一\n\n> 特征\n\n函数是第一等公民\n\n所谓\"第一等公民\"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值\n\n只用\"表达式\"，不用\"语句\"\n\n\"表达式\"（expression）是一个单纯的运算过程，总是有返回值；\"语句\"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。每一步都是单纯的运算，都有返回值\n\n函数式编程期望一个函数有输入，也有输出\n\n\n# 纯函数\n\n即：只要是同样的参数传入，返回的结果一定是相等的\n\n\n# 自执行函数iiee\n\nlet obj = {\n    num: 5,\n    func: function () {\n        let that = this;\n        console.log(that)\n        that.num *= 2;\n        (function () {\n            console.log(this)//window\n            this.num *= 3;\n            that.num *= 4;\n            return function () {\n                console.log(this)//window，但是没有iiee的返回值没有被接收，所以不会执行此语句块\n                this.num *= 5;\n                that.num *= 6;\n            }\n        })()\n    }\n}\nvar num = 2;\nobj.func();\nconsole.log(num);\nconsole.log(obj.num);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\niiee的this指向？\n\niiee的返回值？\n\n\n# 执行上下文\n\n当执行 js 代码时，会产生三种执行上下文\n\n * 全局执行上下文\n * 函数执行上下文\n * eval 执行上下文\n\n执行上下文创建阶段，vo、作用域链、闭包、this被确定\n\n对每个执行上下文，都有三个重要属性：\n\n * (variable object，vo) 包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问\n * 作用域链(scope chain) ，js 采用词法作用域，变量的作用域在定义时就决定了\n * this\n\njs属于解释型语言，执行分为：解释和执行两个阶段，这两个阶段所做的事并不一样：\n\n\n# 解释阶段\n\n * 词法分析\n * 语法分析\n * 作用域规则确定\n\n\n# 执行阶段\n\n * 创建执行上下文\n   * 确定this\n   * 创建 词法环境\n   * 创建 变量环境\n * 执行\n   * 变量赋值、代码执行\n * 垃圾回收\n\n执行上下文在函数执行前创建。随时可改变，最明显的就是this的指向在执行时确定。 作用域访问的变量是编写代码的结构确定\n\n词法环境——持有标识符-变量映射的结构\n\n(标识符指的是变量/函数的名字，变量是对实际对象[包含函数类型对象]或原始数据的引用)\n\n其实就是作用域，是一套规则\n\n变量环境也是词法环境\n\n词法环境组件和变量环境的不同是前者被用来存储函数声明和变量（let 和 const）绑定，后者只用来存储 var 变量绑定\n\n同一个作用域下，不同调用产生不同的执行上下文环境，产生不同的变量值\n\njs引擎创建了**执行上下文栈(调用栈/执行栈)**管理执行上下文\n\n当 js 开始要解释执行代码的时候，首先创建全局执行上下文 push进栈，用 globalcontext 表示它，当整个应用程序结束的时候，ecstack 才会被清空，所以程序结束之前， ecstack 最底部永远有个 globalcontext\n\n遇到函数调用 就为函数 创建新的 函数执行上下文 push进栈\n\n从栈顶依次执行，执行完pop出栈\n\nlet a = 'hello world!';\nfunction first() {\n  console.log('inside first function');\n  second();\n  console.log('again inside first function');\n}\nfunction second() {\n  console.log('inside second function');\n}\nfirst();\nconsole.log('inside global execution context');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n简单分析一下流程：\n\n * 创建全局上下文压入执行栈\n * first被调用，创建函数执行上下文并压入栈\n * 执行first过程遇到second，创建一个函数执行上下文并压入栈\n * second执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文first\n * first执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文\n * 所有代码执行完毕，全局上下文pop出栈\n\n\n# 🌰 作用域\n\nscope，变量（变量作用域又称为上下文）和函数存在的范围\n\n作用域就是 变量 和函数的可访问范围，控制着变量和函数的可见性和生命周期\n\n作用域规定了如何查找变量，即确定当前执行代码对变量的访问权限。(最大作用是 隔离变量)，内层作用域可以访问外层作用域的变量，反之不行\n\n块语句（大括号“｛｝”中间的语句）， if/switch 条件语句或 for/while 循环语句，不像函数，它们不会创建新的作用域\n\n\n1\n\n\n\n# 全局作用域\n\n{}外声明的变量\n\n在代码任何地方都能访问到的对象拥有全局作用域\n\n一般以下几种情形有全局作用域链:\n\n 1. 最外层函数和在最外层函数外定义的变量\n 2. 所有末定义直接赋值的变量自动声明为拥有全局作用域\n 3. window对象的属性\n\n\n# 局部作用域\n\n和全局作用域相反，一般只在固定的代码片段内可访问，最常见的例如函数内部\n\n分为 函数和 块级作用域\n\n\n# 函数作用域\n\n声明在函数内部的变量，在函数定义时就决定了\n\n因为函数有内部属性[[scope]]，函数创建时，保存所有父变量对象，理解为 [[scope]]就是所有父变量 对象的层级链，但！[[scope]] 不代表完整的作用域链\n\n> js不支持函数 重载！ 因为 js 不用对传入的参数的类型进行严格定义。所以，即使我们写同名函数，只会导致后面函数将前面函数覆盖\n\n\n# 块级作用域(es6增)\n\n> 为啥?es5只有全局和函数，有不合理场景\n> \n>  * 内层变量覆盖外层变量\n>  * 计数的i变为全局变量\n> \n> 块级作用域一定程度解决问题\n\n块级作用域 通过 let和const声明，声明的变量在指定块的作用域外无法被访问\n\n被创建：\n\n 1. 函数内部\n 2. 代码块（由一对花括号包裹）内部\n\n特点:\n\n * 声明变量不会提升\n * 禁止重复声明\n * 循环中的绑定块作用域的妙用\n\n> 特点\n\n 1. 不存在变量提升\n 2. 禁止重复声明\n 3. 循环中绑定作用域\n\nfor循环还有一个特别之处，设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域\n\n\n * # for循环的settimeout输出，var和let定义变量区别\n\n它们算是闭包吗？\n\n80% 应聘者都不及格的 js 面试题\n\nsettimeout先将回调函数放到等待队列中等待其他主程序执行完毕，按时间顺序先进先出执行回调。本质是作用域的问题\n\n每个settimeout运行时都将function压入队列，var声明变量在全局环境都会被调用，执行压入下一个function时，会改变上一个已经压入队列的function中的变量i，最后打印五个5\n\n因为 settimeout 创建了一个可以访问其外部作用域的函数（闭包），该作用域是包含索引 i 的循环。 经过 3 秒后，执行函数并打印 i ，该值在循环结束时为 4，循环经过0,1,2,3,4循环最终停止在 4\n\n某个标识符在当前作用域中没有找到，沿着外层作用域继续查找，直到最顶端，**词法作用域在函数定义时确定，而不是执行时，**b函数在全局作用域中定义，虽然在a函数内调用，但它只能访问到全局的作用域而不能访问到a函数的作用域\n\n> 美团面试题\n\nvar name = 'name';\nvar a = {\n  name: 'a',\n  sayhello: function() {\n      let s = () => console.log(this.name);\n      let s=function(){\n          console.log(this.name)\n      }\n      return s;\n  }\n};\nlet sayhello = a.sayhello();\nsayhello();\nvar b = {\n  name: 'b'\n};\nsayhello.call(b)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 词法作用域\n\n又叫静态作用域，变量被创建时就确定好，而不是执行阶段\n\n\n# 作用域链\n\n查找变量时，先从当前上下文的变量对象中查找，，从当前作用域开始一层层往上找，如果没找到，会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象——即全局对象。这样由多个执行上下文的变量对象构成的链表——作用域链\n\n保证当前执行环境对符合访问权限的变量和函数的有序访问\n\n与其相对的是动态作用域\n\n作用域链规定如何查找变量，确定当前执行代码对变量的访问权限\n\nif(!('a' in window)){\n    var a=1;\n}\nconsole.log(a)//undefined\n\n\n1\n2\n3\n4\n\n\n因为 if语句中的var会变量提升，变成全局变量，于是window中就有a，但不会进入条件语句中，输出 undefined\n\n\n# 🔑 闭包\n\n> 闭包是啥？\n> \n> 为啥js中所有函数都是闭包的\n> \n> 关于[[environment]]属性和词法环境原理的细节\n\n\n# 是啥\n\n内部函数 可以访问其外部函数中声明变量，调用 外部函数返回 内部函数后，即使 外部函数执行结束了，但 内部函数引用外部函数的变量依然保存在内存 ，这些变量的集合——闭包\n\n闭包 允许我们从内部函数 访问外部函数的作用域，闭包随着函数的创建同时被创建\n\n每一个函数都会拷贝上级作用域，形成一个作用域链条\n\n闭包：自由变量的查找，在函数定义的地方，向上级作用域查找\n\n闭包数据是对象 存在堆空间，所以函数调用之后为闭包还能引用函数内的变量\n\n形成 的3个条件：\n\n * 闭包在函数被调用执行的时候被确认创建\n * 闭包形成与作用域链的访问顺序有直接关系\n * 只有内部函数访问了上层作用域链中变量对象，才会形成闭包\n\n即使创建函数的上下文 已经销毁，它依然存在；同时引用了自由变量(自由变量：函数中使用，既不是 函数参数 也不是 函数局部变量的变量)\n\n函数存在闭包，其所有内部函数都会拥有指向这个闭包的引用(所有内部函数共享一个闭包)，只要任意内部函数引用外部函数声明变量，这个变量会被纳入闭包，最内部的函数持有所有外部的闭包\n\n\n1\n\n\n闭包不满足链式作用域结构？？\n\n(function(){})()理论上是一个闭包？？\n\n不是，它是立即执行函数\n\n参考文档\n\n\n# 作用\n\n 1. 独立作用域，避免变量污染\n 2. 实现缓存计算结果，延长变量生命周期\n 3. 创建私有变量\n\n\n# 运用\n\n项目中的应用？？\n\n防抖节流\n\n防抖：事件触发高频到最后一次操作，如果规定时间内再次触发，则重新计时\n\nfunction debounce(fn,delay=300){\n    let timer; //闭包引用外界变量\n    return function(){\n        consr args=arguments;\n        if(timer){\n            cleartimeout(timer);\n        }\n        timer=settimeout(()=>{\n            fn.apply(this,args);\n        },delay);\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n模拟块级作用域\n\nfunction outputnum(cnt){\n    (function (){\n        for(let i=0;i<cnt;i++){\n            alert(i);\n        }\n    })();\n    alert(i);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对象中创建私有变量\n\n模拟私有方法\n\n\n# 内存管理gc\n\n栈中js引擎自动清除\n\njs单线程机制，gc过程阻碍了主线程 执行\n\n> 堆内存中的变量只有在 所有对它的引用都 结束 时被回收\n\n自动垃圾回收机制：找出不使用的值，释放内存\n\n函数运行结束，没有闭包或引用，局部变量被 标记 清除\n\n全局变量：浏览器卸载页面 被清除\n\n引用：显式引用（对象有对其属性的引用） 和 隐式引用（对象对其原型的引用）\n\n\n# 垃圾回收算法\n\n不论哪个垃圾回收算法，都有一套共同的流程：\n\n 1. 标记内存空间中的活动对象（在使用中的对象）和非活动对象（可以回收的对象）\n 2. 删除非活动对象，释放内存空间\n 3. 整理内存空间，避免频繁回收后产生的大量内存碎片（不连续内存空间）\n\n\n# 引用计数\n\n一个对象是否有被引用（循环引用导致内存泄露）\n\n跟踪每个变量被使用的次数\n\n>  1. 当声明了变量且将引用类型赋值给该变量时，值的引用次数为1\n>  2. 若同一个值又被赋给另一个值，引用数+1\n>  3. 如果该变量的值被其他的值覆盖了，则引用次数减 1\n>  4. 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器在运行的时候清理掉引用次数为 0 的值占用的内存\n\n缺点:\n\n * 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限\n * 解决不了循环引用导致的无法回收问题\n\n\n# 标记清除\n\n将“不再使用的对象”定义为“无法到达的对象”\n\n工作流程：\n\n>  1. 垃圾收集器在运行时给内存变量加上 标记，假设内存中所有对象都是垃圾，全标记为0\n>  2. 根部出发，寻找可到达的变量，将其标记清除，改为1\n>  3. 留有标记的变量就是待删除的，即标记为0，销毁并回收它们占用的内存\n>  4. 把所有内存中对象标记修改为0，等待下一轮垃圾回收\n\n优点:实现简单，一位二进制位就可以为其标记\n\n缺点:\n\n * 内存碎片化，空闲内存块不连续，可能出现分配所需内存过大的对象时找不到合适的块\n * 分配速度慢，即使使用first-fit策略，操作仍是一个o(n)的操作，最坏情况是每次都要遍历到最后，因为碎片化，大对象的分配速率会更慢\n\n\n# 复制算法\n\n为了解决上述问题，复制算法出现了\n\n 1. 将整个空间平均分成 from 和 to 两部分。\n 2. 先在 from 空间进行内存分配，当空间被占满时，标记活动对象，将其复制到 to 空间\n 3. 复制完成后，将 from 和 to 空间互换\n\n由于直接将活动对象复制到另一半空间，没有了清除阶段的开销，所以能在较短时间内完成回收操作，并且每次复制的时候，对象都会集中到一起，相当于同时做了整理操作，避免了内存碎片\n\n复制算法 吞吐量高、没有碎片；但 复制操作需要时间成本，若堆空间很大且活动对象很多，每次清理时间会很久。其次，将空间二等分的操作，让可用的内存空间直接减少了一半\n\n\n# 标记整理\n\n也叫做 标记-压缩算法。结合了标记-清除和复制算法的优点\n\n 1. 从一个 gc root 集合出发，标记所有活动对象\n 2. 将所有活动对象移到内存的一端，集中到一起\n 3. 直接清理掉边界以外的内存，释放连续空间\n\n既避免了标记-清除法产生内存碎片的问题，又避免了复制算法导致可用内存空间减少的问题。其清除和整理的操作很麻烦，需要对整个堆做多次搜索，故而堆越大，耗时越多\n\n必须暂停js脚本执行等待——全停顿，全停顿对性能影响大，所以出现了 增量标记的策略进行老生代垃圾回收\n\n\n# 💛 v8 对gc优化\n\n> 代际假说\n\n * 栈中数据回收：执行状态指针 esp 在执行栈中移动，移过某执行上下文，被销毁\n * 堆中数据回收：v8 引擎采用标记-清除算法\n * v8 堆分为新生代和老生代 2个区域，分别使用副、主垃圾回收器\n * 副垃圾回收器负责新生代垃圾回收，小对象（1 ～ 8m）被分配到该区域处理\n * 新生代采用 scavenge 算法处理：空间分为一半空闲，一半存对象，对象区域做标记，存活对象复制到空闲区域，没有内存碎片，完成后，清理对象区域，角色反转\n * 新生代区域两次垃圾回收还存活的对象晋升至老生代区域\n * 主垃圾回收器负责老生区垃圾回收，大对象，存活时间长\n * 新生代区域采用标记-清除算法回收垃圾\n * 为了不造成卡顿，标记过程被切分为一个个子标记，交替进行\n\n分代式垃圾回收\n\n以上垃圾清理算法每次都要检查内存中所有对象，对一些大、老、存活时间长的对象来说，同新、小、存活时间短的对象一个频率的检查很不好，因为前者不需要频繁清理，后者相反，如何优化？\n\n\n# 分代式\n\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，此机制的出现很大程度提高了垃圾回收机制的效率\n\n\n# 新老生代\n\nv 8 将堆内存分为新生代和老生代两区域，采用不同的垃圾回收策略\n\n新生代的对象是存活时间较短的对象\n\n老生代的对象为存活时间较长或常驻内存的对象\n\n\n# 新生代\n\n新生代中对象一般存活时间较短，采用 scavenge 算法，主要采用一种复制式的方法\n\n> scavenge 是典型的以时间换空间的算法，新生代大部分对象生命周期较短，时间效率上表现可观，所以 比较适合这种算法\n> \n> scavenge主要采用cheney算法\n\n新生代空间对半分 from-space 和 to-space 两个区域\n\nfrom空间为激活状态区域\nto空间为 未激活 区域\n\n\n1\n2\n\n\n新创建的对象存放到 from-space，空间快被写满时触发垃圾回收。***先对 from-space 中的对象标记，完成后将标记对象复制到 to-space*** ，非存活对象被回收，copy后，from和to 空间 角色反转，完成回收操作\n\n> 为啥要角色反转？？\n\n因为需要使用 活跃区啊——from\n\nscavenge主要 将存活的对象在from和to空间赋值，完成2个空间的角色互换\n\n缺点——浪费一般内存用于复制\n\n每次执行清理操作都需要复制对象，复制对象需要时间成本，所以新生代空间设置得比较小（1~8m）\n\n当一个对象经过多次复制后依然存活，是生命周期较长的对象，被移动到老生代，采用老生代垃圾回收策略 管理\n\n晋升的条件\n\n * 对象经历过一次scavenge算法\n * to空间内存占比超过25%\n\n复制一个对象到空闲区时，空闲区空间占用超过 25%，这个对象被直接晋升到老生代空间中，设置为 25% 的比例是因为完成 scavenge 回收后，to区将翻转成from区，继续进行对象内存的分配，占比过大影响后续内存分配\n\n\n# 老生代\n\n老生代管理大量 存活对象，scavenge算法浪费内存\n\n老生代中对象一般存活时间长且数量多，使用 标记清除(mark-sweep) 和标记压缩(mark-compact) 算法\n\n晋升条件：\n\n * 对象是否经历过一次 scavenge 算法\n * to 空间对象占比大小超过 25 %\n\n首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素为非活动对象\n\n> 具体步骤\n\n * 内部创建根列表，从根节点 出发寻找可被访问的变量，比如window可看成根节点\n * 垃圾回收器从所有根节点出发，遍历可访问的子节点，标记为 活动的；不能到达的 被视为 垃圾\n * 释放所有非活动内存块\n\n1、全局对象2、本地函数局部变量和参数 3、当前嵌套调用链上其他函数的变量和参数 均可被视作 根节点\n\n前面我们也提过，标记清除算法在清除后产生大量不连续内存碎片，过多碎片导致大对象无法分配到足够的连续内存——标记整理算法 解决这一问题\n\n整理过程中，将活动对象往 堆内存 的一端移动，移动完成后再清理掉外边界的全部内存\n\n以下情况先启动标记清除算法：\n\n * 某一个空间没有分块\n * 空间中被对象超过一定限制\n * 空间不能保证新生代中的对象移动到老生代中\n\n> js 单线程运行，垃圾回收算法和脚本任务在同一线程内运行，执行垃圾回收逻辑时，后续脚本任务需要等垃圾回收完成后才能执行。若堆中数据量非常大，一次完整垃圾回收的时间会非常长，将导致应用的性能和响应能力都下降\n> \n> 为了避免垃圾回收影响性能，v8 将标记的过程拆分成多个子标记，让垃圾回收标记和应用逻辑交替执行(以前是 全停顿，现在改为 增量标记) ，避免脚本任务等太久\n\n增量标记 和fiber相似，只有空闲时去遍历fiber tree执行对应任务\n\n基于增量标记，v8后续引入 延迟清理和增量式整理，充分利用cpu性能\n\n\n# 🔥 内存泄漏\n\n\n# 识别\n\n如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏\n\n这就要求实时查看内存的占用情况\n\n在 chrome 浏览器中，我们可以这样查看内存占用情况\n\n1.打开开发者工具，选择 performance 面板\n2.在顶部勾选 memory\n3.点击左上角的 record 按钮\n4.在页面上进行各种操作，模拟用户的使用情况\n5.一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况\n\n\n1\n2\n3\n4\n5\n\n\n\n# 造成内存泄露\n\n 1. 意外的全局变量\n 2. 被遗忘的定时器和回调函数\n 3. 事件监听没有移除\n 4. 没有清理的dom 引用\n 5. 闭包\n 6. 控制台打印\n\n\n# 🔥 柯里化\n\n是高阶函数的一种特殊用法\n\n接收函数a作为参数，返回新的函数，这个新的函数能够处理函数a的剩余参数\n\n柯里化函数的运行过程是一个参数的收集过程，我们将每一次传入的参数收集起来，并在最里层里面处理\n\n> 用 闭包 把参数保存起来，当参数的数量足够执行函数了，就开始执行\n\nvar add = function (m) {\n  var temp = function (n) {\n    return add(m + n);\n  }\n  temp.tostring = function () {\n    return m;\n  }\n  return temp;\n};\nconsole.log(add(3)(4)(5)); // 12\nconsole.log(add(3)(6)(9)(25)); // 43\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n对于add(3)(4)(5)，其执行过程如下：\n\n 1. 执行add(3)，此时m=3，返回temp函数\n 2. 执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)=add(3+4)=add(7)，此时m=7，返回temp函数\n 3. 执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)=add(7+5)=add(12)，此时m=12，返回temp函数\n 4. 后面没有传入参数，等于返回的temp函数不被执行而是打印，对象的tostring修改对象转换字符串，因此代码中temp函数的tostring函数return m值，而m值是最后一步执行函数时的值m=12，所以返回值是12\n\n> fn.length 表示fn函数的参数个数\n\nlet addcurry = curry1((a, b) => a + b);\n\nconsole.log(addcurry()(11)(1));\n\nfunction curry1(fn) {\n    let judge = (...args) => {\n        if (args.length === fn.length) {\n            return fn.call(this, ...args);\n        }\n        //获取偏函数，返回包装器，重新组装参数并传入\n        return (...arg) => judge(...arg, ...args)\n    }\n    return judge;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ✅let var const\n\n在es5中，顶层对象的属性和全局变量等价，var声明的变量是全局也是顶层变量\n\nvar没有块级作用域，只有函数作用域。var只有在function{ }内部才有作用域的概念，其他地方没有。意味着函数以外用var定义的变量是同一个，我们所有的修改都是针对他的\n\n 1. let和const增加块级作用域（js没有块级作用域）\n\n 2. let和const存在暂时性死区，不存在变量提升，不能在初始化前引用，调用 返回 uninitialized\n\n 3. let和const禁止重复声明，不能重新声明\n\n 4. let和const不会成为全局对象属性，var声明的变量自动成为全局对象属性\n    \n    var a = 123\n    if (true) {\n        a = 'abc' // referenceerror\n        let a;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    > const实际保证的并不是变量的值，而是变量指向的内存地址\n\n 5. var 存在变量提升（执行前，编译器对代码预编译，当前作用域的变量/函数提升到作用域顶部），let约束变量提升。let和var都发生了变量提升，只是es6进行了约束，在我们看来，就像let禁止了变量提升\n\n 6. 使用var，我们能对变量多次声明，后面声明的变量会覆盖前面的声明\n\n\n# 作用域\n\n在函数中声明了var，整个函数有效，比如for循环内定义var变量，实际在for循环以外也可以访问\n\nfor循环每次执行都是一个全新独立块作用域，let声明的变量传入for循环体的作用域后，不会发生改变，不受外界影响\n\n常考面试题：\n\nfor (var i = 0; i <10; i++) {  \n  settimeout(function() {  // 同步注册回调函数到 异步的 宏任务队列\n    console.log(i);        // 执行此代码时，同步代码for循环已经执行完成\n  }, 0);\n}\n// 输出结果\n10   共10个\n// 这里面的知识点： js的事件循环机制，settimeout的机制等\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰\nfor (let i = 0; i < 10; i++) { \n  settimeout(function() {\n    console.log(i);    //  i 是循环体内局部作用域，不受外界影响\n  }, 0);\n}\n// 输出结果：\n0  1  2  3  4  5  6  7  8 9\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nlet必须先声明再使用。var先使用后声明也行，只不过直接使用没定义 是undefined。var 变量提升，整个函数作用域被创建时，实际上var定义的变量都会被创建，如果没有初始化，默认undefined\n\njs只有函数和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围\n\n(function () {\n    var x = y = 1\n})();\nvar z;\nconsole.log(y)\nconsole.log(z)\nconsole.log(x)\n//var x=y=1 等价于 var x=1;y=1 ,y被提升至全局作用域\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 💜 事件流？\n\njs和html的交互 通过 事件 实现，使用侦听器 预定事件，便于事件发生时执行相应代码\n\n手指放在一组同心圆的圆心上，手指指向不是一个圆 ，而是纸上的所有圆，单击按钮时 单击事件不止发生在按钮上，同时 也单击了按钮的容器元素，甚至也单击了整个页面\n\n事件流描述 从页面接收事件的顺序\n\n事件发生时会在元素节点和根节点之间按照特定的顺序传播，路径所经过的节点都会收到该事件——dom事件流\n\n 1. 捕获：不太具体的节点应该更早接收到事件，而最具体的节点最后收到事件。目的是在事件到达预定目标之前捕获它\n\n 2. 冒泡：事件开始由最具体的元素接收，逐级向上传播到不具体的节点，document对象首先收到click事件，事件沿着dom树依次往下，传播到事件的具体目标\n\n 3. dom标准规定事件流包括3个阶段：事件捕获、处于目标阶段和事件冒泡\n\n * 事件捕获——为截获事件提供机会\n * 处于目标阶：事件在div上发生并处理\n * 冒泡阶段：事件又传播回文档\n\n\n\n所有事件都要经过捕获阶段和处于目标阶段\n\n**focus(获得输入焦点)和失去焦点blur事件没有冒泡，**无法委托\n\n\n# 原始事件模型\n\n<input type=\"button\" onclick=\"fun()\">\nvar btn = document.getelementbyid('.btn');\nbtn.onclick = fun;\n\n\n1\n2\n3\n\n * 绑定速度快\n\n页面还未完全加载，事件可能无法正常运行\n\n * 只支持冒泡，不支持捕获\n * 同一个类型的事件只能绑定一次\n\n<input type=\"button\" id=\"btn\" onclick=\"fun1()\">\n\nvar btn = document.getelementbyid('.btn');\nbtn.onclick = fun2;\n//出错 后绑定的事件会覆盖掉之前的事件\n\n\n1\n2\n3\n4\n5\n\n\n删除事件处理程序 将对应事件属性置为null\n\nbtn.onclick = null;\n\n\n1\n\n\n\n# 标准事件模型\n\n * 事件捕获：从document一直向下传播到目标元素， 依次检查经过节点是否绑定了事件监听函数，有则执行\n * 事件处理：到达目标元素， 触发目标元素的监听函数\n * 事件冒泡：从目标元素冒泡到document， 依次检查经过节点是否绑定了事件监听函数，如果有则执行\n\n事件绑定监听函数\n\naddeventlistener(eventtype, handler, usecapture)\n\n\n1\n\n\n事件移除监听函数\n\nremoveeventlistener(eventtype, handler, usecapture)\n\n\n1\n\n * eventtype事件类型(不要加on)\n * handler事件处理函数\n * usecapture，是否在捕获阶段处理，默认false\n\n举个例子：\n\n    var btn = document.getelementbyid('.btn');\n    btn.addeventlistener('click', showmessage, false);\n    btn.removeeventlistener('click', showmessage, false);\n\n\n1\n2\n3\n\n\n> 一个dom上绑定多个事件处理器，不会冲突\n\nbtn.addeventlistener(‘click’, showmessage1, false);\nbtn.addeventlistener(‘click’, showmessage2, false);\nbtn.addeventlistener(‘click’, showmessage3, false);\n\n\n1\n2\n3\n\n\n第三个参数(usecapture)为true在捕获过程执行，反之在冒泡过程执行\n\n\n# ie事件模型\n\n因为ie8及更早版本只支持事件冒泡，因此通过attachevent添加的事件都会被添加到冒泡阶段\n\n * 事件处理：事件到达目标元素， 触发目标元素的监听函数\n\n * 事件冒泡：事件从目标元素冒泡到document\n\n * 事件绑定监听函数的方式\n   \n   attachevent(eventtype, handler)\n   \n   \n   1\n   \n   \n   事件移除监听函数的方式\n   \n   detachevent(eventtype, handler)\n   \n   \n   1\n   \n   \n   举个例子：\n   \n   var btn = document.getelementbyid('.btn');\n   btn.attachevent(‘onclick’, showmessage);\n   btn.detachevent(‘onclick’, showmessage);\n   \n   \n   1\n   2\n   3\n   \n\n\n# 事件代理\n\n\n# 原理\n\n事件委托，把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，不是目标元素\n\n只指定一个事件处理程序，管理某一类型 所有事件\n\n把一个元素响应事件（click、keydown......）的函数委托到另一个元素，冒泡阶段完成\n\n对“事件处理程序过多”问题的解决方案就是事件委托\n\n使用事件委托，只需在dom树中尽量高的一层添加一个事件处理程序\n\n> 举例\n\n代 取快递\n\n优点\n\n * 节省内存，减少dom操作\n * 不需要给子节点注销事件\n * 动态绑定事件\n * 提高性能\n * 新添加的元素还会有之前的事件\n\n> 为啥用\n\n**事件冒泡过程中上传到父节点，**父节点通过事件对象获取到目标节点，把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理子元素的事件\n\n比如100个li，每个都有click，如果使用for遍历 添加事件，关系页面整体性能，需要不断交互 访问dom次数过多，引起重排，延长交互时间\n\n事件委托的话，将操作放进js，只需要和dom交互一次，提高性能，还节约内存\n\n\n# 实现\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>title</title>\n</head>\n<body>\n<ul id=\"ul1\">\n    <li>111</li>\n    <li>222</li>\n    <li>333</li>\n    <li>444</li>\n</ul>\n<script>\n    /* window.onload = function () {\n         var oul = document.getelementbyid(\"ul1\");\n         var ali = oul.getelementsbytagname('li');\n         for (var i = 0; i < ali.length; i++) {\n             ali[i].onclick = function () {\n                 alert(123);\n             }\n         }\n     }*/\n    window.onload = function () {\n        var oul = document.getelementbyid(\"ul1\");\n        oul.onclick = function () {\n            alert(123);\n        }\n    }\n<\/script>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nevent对象提供属性target，返回事件的目标节点——事件源\n\ntarget表示当前事件操作的dom，但不是真正操作dom\n\n通过target.id获得操作的具体dom\n\n新增的节点怎么办，即 新来员工的快递咋整？\n\n事件委托也能解决\n\n> (鼠标事件、键盘事件和点击事件)支持冒泡\n> \n> 聚焦、失焦、ui、鼠标移入移除事件不支持冒泡\n\n * 适合事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress\n * mouseover 和 mouseout 也有事件冒泡，但需要经常计算它们的位置，处理不太容易\n * 不适合的，mousemove，每次都要计算它的位置，不好把控， focus，blur 等本身就没有冒泡的特性，自然就不用事件委托\n\n\n# 阻止冒泡\n\n * 阻止冒泡：非 ie stoppropagation()，ie 则event.cancelbubble = true\n * 阻止默认行为：非 ie preventdefault()，ie则event.returnvalue = false\n\n\n# e.target、e.currenttarget\n\n * e.target：触发事件的元素，是点击的元素\n * e.currenttarget：绑定事件的元素，是途径的元素，执行捕获的顺序\n\nmdn event\n\n> event还有哪些属性？\n\nevent.bubbles 返回 布尔值，表明当前事件是否会向 dom 树上层元素冒泡\n\nevent.defaultprevented 返回 布尔值，表明当前事件是否调用了 event.preventdefault()\n\n\n# addeventlistener、onclick()\n\naddeventlistener为元素绑定事件，接收三个参数：\n\n * 第一个参数：绑定的事件名\n\n * 第二个参数：执行的函数\n\n * 第三个参数：\n   \n   * false：默认，代表冒泡时绑定\n   * true：代表捕获时绑定\n\n> onclick和addeventlistener\n\nonclick事件会被覆盖，同一个元素只能绑定一个事件\n\naddeventlistener可先后运行不会被覆盖，可监听多个事件，执行顺序从上到下依次执行\n\naddeventlistener对任何dom元素有效\n\n注册addeventlistener不需写on，onclick需要加on\n\n移除事件，onclick使用指针指向null，document.onclick=null，addeventlistener使用独有移除方法removelistener\n\naddeventlistener为dom2级事件绑定，onclick为dom0级事件绑定\n\n不适用内联onclick作为html属性，混淆js和html，降低维护性\n\n\n# 事件劫持？\n\n\n# 🌰 json.stringify()\n\n序列化，忽略值为undefined的字段\n\n若某个字段为undefined，将其修改为空串\n\n1、若目标对象存在tojson()方法，它负责定义哪些数据被序列化\n\nlet obj={\n    x:1,\n    y:2,\n    tojson:function(){\n        return 'a string create by tojson'\n    }\n}\nconsole.log(json.stringify(obj));\n//'a string create by tojson'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2、boolean、number、string对象被装换为对应原始值\n\nconst obj={\n    a:new number(11),\n    b:new string('aaa'),\n    c:new boolean(true)\n}\nconsole.log(json.stringify(obj));\n//{\"a\":11,\"b\":\"aaa\",\"c\":true}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n3、undefined、function和symbol不是有效的json值，要么被忽略(在对象中找着)，要么被更改为null(在数组中找着)\n\nconst obj={\n    name:symbol('aaa'),\n    age:undefined,\n    ishigh:function(){}\n}\nconsole.log(json.stringify(obj));\n//{}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    const arr=[symbol('aaa'),undefined,function(){},'fighting'];\n    console.log(json.stringify(arr));\n//[null,null,null,\"fighting\"]\n\n\n1\n2\n3\n\n\n4、所有symbol-keyed属性被忽略\n\nconst obj={\n    \n}\nobj[symbol('a')]='aa';\nobj[symbol('b')]='bb';\nconsole.log(obj);\nconsole.log(json.stringify(obj));\n//{symbol(a): 'aa', symbol(b): 'bb'}\n//{}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n5、date的实例返回一个字符串实现tojson()方法(和date.toisostring()——使用 iso 标准返回 date 对象的字符串格式相同)\n\njson.stringify(new date());\n//'\"2022-06-16t23:36:38.943z\"'\n\n\n1\n2\n\n\n6、infinity、nan和null都被认为是null\n\nconst obj={\n    a:infinity,\n    b:nan,\n    c:null,\n    val:20\n};\nconsole.log(json.stringify(obj));\n//{\"a\":null,\"b\":null,\"c\":null,\"val\":20}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n7、所有其他object实例(包括map、weakmap、set和weakset)序列化为其可枚举的属性\n\nlet enumobj={};\n//直接在一个对象上定义新的属性或修改现有属性，并返回该对象\nobject.defineproperties(enumobj,{\n    'name':{\n        value:'a',\n        enumerable:true\n    },\n    'age':{\n        value:99,\n        enumerable:false\n    },\n});\nconsole.log(json.stringify(enumobj));\n//{\"name\":\"a\"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n8、遇到循环抛出typeerror(循环对象值)异常\n\nconst obj={\n    a:'aa'\n};\nobj.subobj=obj;\nconsole.log(json.stringify(obj));\n//vm357:5 uncaught typeerror: converting circular structure to json\n\n\n1\n2\n3\n4\n5\n6\n\n\n9、对bigint值字符串化时抛出typeerror(bigint值无法在json中序列化)\n\nconst obj={\n    a:bigint(999999999999999999999)\n};\nconsole.log(json.stringify(obj));\n//vm362:4 uncaught typeerror: do not know how to serialize a bigint\n\n\n1\n2\n3\n4\n5\n\n\n\n# promise\n\n简单说就是一个容器，保存某个未来才会结束的事件的结果。语法上promise 是对象，可以获取异步操作的消息。promise 提供统一 api，各种异步操作都可以用同样方法处理，让开发者不用关注时序和底层结果。promise的状态不受外界影响，不可逆\n\n是异步编程的一种解决方案，更合理 强大\n\n> 出现的原因\n\n基于回调的异步风格——异步执行某项功能的函数提供一个callback在相应事件完成时调用\n\n**回调中回调！**单一的callback处理error报告和传递返回结果\n\n可行的异步编程方式？？对1/2个嵌套调用看起来不错\n\nbut，一个接一个的异步行为……\n\n调用嵌套增加，代码层次更深，维护难度大，尤其是 很多循环和条件语句的代码……——回调地狱/厄运金字塔\n\n造成 代码失控！！\n\n> promise\n\n链式调用\n\n * 链式写法\n * 改善可读性\n * 多层嵌套更友好\n\npromise 是对象也是构造函数，接收一个函数作为参数，该函数的2个参数分别是resolve reject\n\n所有异步任务都返回promise实例，promise有一个then方法，指定下一步回调\n\n成功则调用resolve，失败调用reject\n\n由new promise返回的promise的内部属性\n\n * state：pending、fulfilled、rejected\n * result：undefined——value/error\n\npromise——承诺，一旦承诺 便不可更改\n\npromise.reject(2)\n    //.catch(err=>console.log(\"err1,\",err))\n    .then(null,err=>console.log(\"err1,\",err)) //rejected状态，执行then的第二个callback，改变状态为fulfilled\n\n    .then(res=>{console.log(\"then1\",res)},null)//fulfilled，执行第一个回调,不会去到下一步catch\n    \n    .then(res=>console.log('end'),err=>console.log(\"err2,\",err))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> .then\n\n可将多个.then添加到一个promise上，但不是一个promise链\n\nlet promise = new promise(function(resolve, reject) {\n  settimeout(() => resolve(1), 1000);\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\npromise的几个处理程序，彼此 独立运行！！\n\n\n\npromise的错误“冒泡”会一直向后传递，直到被捕获\n\n每个promise都会经历生命周期：\n\n * 进行中（pending）代码执行尚未结束，也叫未处理的（unsettled）\n * 已处理（settled） 代码执行结束 已处理的代码进入两种状态中的一种：\n\n已完成（fulfilled）代码执行成功，resolve()触发\n\n已拒绝（rejected）遇到错误，代码执行失败 ，reject()触发\n\n// 如果触发reject()，但是没有 捕获 reject的结果，代码抛出异常并停止执行\nasync function async1() {\n    await async2();\n    console.log('async1');\n    return 'async1 success'\n}\nasync function async2() {\n    return new promise((resolve, reject) => {\n        console.log('async2')\n        reject('error')\n    })\n        // .then(res => {console.log(res)}, res => console.log((res)))\n}\nasync1().then(res => console.log(res))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 实例方法\n\n * then()\n\n.then(handler)中的handler 创建返回 新的promise，确切说 返回不完全是promise，而是 对象\"thenable\"——具有方法.then的对象，被当做promise\n\n所以，then会修改promise状态吗？\n\nrejected——>fulfilled？？？？\n\n * catch()\n\n建议使用catch()，而不是then()的第二个参数\n\n * finally\n\n返回 promise 。 promise 结束时，无论结果 fulfilled / rejected，都会执行指定回调\n\n\n# 构造函数方法\n\n\n# all()\n\n将多个 promise 实例，包装成一个新的 promise 实例\n\n接收一个数组(可迭代对象)作为参数，数组成员都应为promise实例\n\n提供并行执行异步操作的能力\n\nconst p = promise.all([p1, p2, p3]);\n\n\n1\n\n * 只有状态都变成fulfilled，p才会变成fulfilled，此时p1 p2 p3的返回值组成一个数组，传递给回调\n * 只要有一个被rejected，p就变成rejected，此时第一个被reject的实例返回值传递给回调\n\n若promise参数实例自己定义catch()，它被rejected不会触发promise.all()的catch()\n\n因此可在单个catch中对失败promise请求做处理，使请求正常返回\n\nconst p1 = new promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result)\n.catch(e => e);\n\nconst p2 = new promise((resolve, reject) => {\n  throw new error('报错了');\n})\n.then(result => result)\n.catch(e => e);\n\npromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// [\"hello\", error: 报错了]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n若p2没有自己的catch()，就调用promise.all()的catch()\n\nconst p1 = new promise((resolve, reject) => {\n  resolve('hello');\n})\n.then(result => result);\n\nconst p2 = new promise((resolve, reject) => {\n  throw new error('报错了');\n})\n.then(result => result);\n\npromise.all([p1, p2])\n.then(result => console.log(result))\n.catch(e => console.log(e));\n// error: 报错了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n出现错误后不进行reject，继续resolve(error)，交给promise.all()处理\n\n> promise 数组顺序直接影响结果顺序，和 promise 执行完成先后无关\n\n快速失败——如果数组至少一个被 rejected ，那返回的 promise 也被拒绝。如果数组中所有都被 rejected ，那返回的promise 被拒绝的原因是先rejected的那一个\n\npromise.all()是并行执行异步操作获取所有 resolve 值的最佳方法，适合需要同时获取异步操作结果进行下一步运算场合\n\n\n# allsettled\n\n数组作为参数，每个成员都是 promise 对象，返回新的 promise 实例\n\n只有等到数组的所有 promise 都状态变更（不管是fulfilled/rejected） 返回的 promise 才状态变更，带有对象数组，每个对象表示对应promise结果\n\n当有多个彼此不依赖的异步任务完成时，或想知道每个promise的结果时，可以使用\n\n相比，all更适合彼此依赖或其中任何一个reject时马上结束\n\nvar promise1 = new promise(function(resolve,reject){\n  settimeout(function(){\n    reject('promise1')\n  },2000)\n})\n            \nvar promise2 = new promise(function(resolve,reject){\n  settimeout(function(){\n    resolve('promise2')\n  },3000)\n})\n \nvar promise3 = promise.resolve('promise3')\n \nvar promise4 = promise.reject('promise4')\n \npromise.allsettled([promise1,promise2,promise3,promise4]).then(function(args){\n  console.log(args);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# any\n\n一个成功就成功，所有失败才失败！\n\n接受一组 promise 可迭代实例作为参数，返回一个新的 promise\n\n只要参数实例有一个fulfilled，包装实例变成fulfilled；如果所有参数实例都rejected，包装实例变成rejected\n\npromise.any()不会因为某个 promise 变成rejected状态而结束，必须等到所有参数 promise 变状态才结束\n\n\n# race\n\n简言之，看谁跑得快呗，注重时序\n\n和all一样，但是 返回执行最快的promise的结果\n\n将多个 promise 实例，包装成一个新的 promise 实例 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变 率先改变的 promise 实例返回值 传递给p的回调\n\nconst p = promise.race([p1, p2, p3]);\n\n\n1\n\n\nconst p = promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new promise(function (resolve, reject) {\n    settimeout(() => reject(new error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * resolve()\n * reject()\n\n\n# 场景\n\n * ajax请求\n * 文件读取\n * 图片加载\n * 函数封装\n\n\n# 实现promise\n\n\n# 实现promise.then()\n\n\n# 栗子\n\njs不会允许看不到尽头的微任务一直待在队列，以下代码执行可能差强人意\n\npromise.resolve().then(() => {\n    console.log(0);\n    return promise.resolve(4);\n}).then((res) => {\n    console.log(res)\n})\n\npromise.resolve().then(() => {\n    console.log(1);\n}).then(() => {\n    console.log(2);\n}).then(() => {\n    console.log(3);\n}).then(() => {\n    console.log(5);\n}).then(() =>{\n    console.log(6);\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n因为promise1处于pending状态，所以promise1.then()的回调函数还不会加入到微任务队列中\n\ntimer2是一个延时2s的计时器，1s后，timer1完成，promise1状态变化，又过了1s，timer2完成，执行回调函数\n\nconst promise1 = new promise((resolve, reject) => {\n  const timer1 = settimeout(() => {\n    resolve('success')\n  }, 1000)\n})\nconst promise2 = promise1.then(() => {\n  throw new error('error!!!')\n})\n\nconsole.log('promise1', promise1)\nconsole.log('promise2', promise2)\n\nconst timer2 = settimeout(() => {\n  console.log('promise1', promise1);\n  console.log('promise2', promise2);\n}, 2000)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nresolve会马上执行，a=2，就resolve了，实际上a的循环会走完 变成1002\n\nvar a = 1;\nsettimeout(function () {\n    console.log(a++)\n}, 0)\nnew promise(function executor(resolve) {\n    console.log(a++)\n    for (var i = 0; i < 1000; i++) {\n        resolve(a++)\n    }\n    console.log(a++)\n}).then(function (a) {\n    console.log(a++)\n})\nconsole.log(a++)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 🌰 异步解决方案\n\n同步操作：顺序执行，同一时间只能做一件事情。会阻塞后面代码的执行\n\n异步：当前代码的执行作为任务放进任务队列。当程序执行到异步的代码时，将该异步的代码作为任务放进任务队列，而不是推入主线程的调用栈。等主线程执行完之后，再去任务队列里执行对应的任务。不会阻塞后续代码的运行\n\n\n# 异步场景?\n\n * 定时任务：settimeout、setinterval\n * 网络请求：ajax请求、动态创建img标签的加载\n * 事件监听器：addeventlistener\n\n\n# 回调\n\n回调函数就是我们请求成功后需要执行的函数\n\n实现了异步，但是带来一个非常严重的问题——回调地狱，即 我们表达异步操作的执行顺序的唯一方法是 将一个回调嵌套在另一个回调中\n\n\n# 发布/订阅\n\nnode.js eventemitter 中的 on 和 emit\n\n当一个对象的状态改变时，所有依赖于它的对象都得到状态改变的通知\n\n比如公众号推送\n\n> 手写 发布-订阅模式\n\n * 创建对象\n * 创建缓存列表\n * on 将handler 加到缓存列表中(订阅者注册事件)\n * emit 根据event值执行函数\n * off根据event取消订阅\n * once监听一次，调用完毕后删除\n\nlet eventemitter = {\n    // 缓存列表\n    list: {},\n    on(event, fn) {\n        let _this = this;\n        // 如果对象中没有对应的 event 值，也就是说明没有订阅过，就给 event 创建个缓存列表\n        // 如有对象中有相应的 event 值，把 fn 添加到对应 event 的缓存列表里\n        (_this.list[event] || (_this.list[event] = [])).push(fn);\n        return _this;\n    },\n    once(event, fn) {\n        // 先绑定，调用后删除\n        let _this = this;\n        function on() {\n            _this.off(event, on);\n            fn.apply(_this, arguments);\n        }\n        on.fn = fn;\n        _this.on(event, on);\n        return _this;\n    },\n    off(event, fn) {\n        let _this = this;\n        let fns = _this.list[event];\n        // 如果缓存列表中没有相应的 fn，返回false\n        if (!fns) return false;\n        if (!fn) {\n            // 如果没有传 fn 的话，就会将 event 值对应缓存列表中的 fn 都清空\n            fns && (fns.length = 0);\n        } else {\n            // 若有 fn，遍历缓存列表，看看传入的 fn 与哪个函数相同，如果相同就直接从缓存列表中删掉即可\n            let cb;\n            for (let i = 0, cblen = fns.length; i < cblen; i++) {\n                cb = fns[i];\n                if (cb === fn || cb.fn === fn) {\n                    fns.splice(i, 1);\n                    break\n                }\n            }\n        }\n        return _this;\n    },\n    emit() {\n        let _this = this;\n        // 第一个参数是对应的 event 值，直接用数组的 shift 方法取出\n        let event = [].shift.call(arguments),\n            fns = [..._this.list[event]];\n        // 如果缓存列表里没有 fn 就返回 false\n        if (!fns || fns.length === 0) {\n            return false;\n        }\n        // 遍历 event 值对应的缓存列表，依次执行 fn\n        fns.foreach(fn => {\n            fn.apply(_this, arguments);\n        });\n        return _this;\n    }\n};\nfunction user1(content) {\n    console.log('用户1订阅了:', content);\n}\nfunction user2(content) {\n    console.log('用户2订阅了:', content);\n}\nfunction user3(content) {\n    console.log('用户3订阅了:', content);\n}\nfunction user4(content) {\n    console.log('用户4订阅了:', content);\n}\n\n// 订阅\neventemitter.on('article1', user1);\neventemitter.on('article1', user2);\neventemitter.on('article1', user3);\n\n// 取消user2方法的订阅\neventemitter.off('article1', user2);\n\neventemitter.once('article2', user4)\n\n// 发布\neventemitter.emit('article1', 'javascript 发布-订阅模式');\neventemitter.emit('article1', 'javascript 发布-订阅模式');\neventemitter.emit('article2', 'javascript 观察者模式');\neventemitter.emit('article2', 'javascript 观察者模式');\n\neventemitter.on('article1', user3).emit('article1', 'test111');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\nclass myeventemitter {\n  constructor() {\n    this.eventmap = {};  // 存储事件和监听函数之间的关系\n  }\n  \n  // type:事件名称; handler:事件处理函数\n  on(type, handler) {\n    // hanlder 必须是一个函数\n    if (!(handler instanceof function)) {\n      throw new error(\"hanler必须是函数\");\n    }\n    // 判断 type 事件对应的队列是否存在\n    if (!this.eventmap[type]) {\n      // 若不存在，新建该队列\n      this.eventmap[type] = [];\n    }\n    // 若存在，直接往队列里推入 handler\n    this.eventmap[type].push(handler);\n  }\n  \n  // type:事件名称; params:支持传参\n  emit(type, params) {\n    // 假设该事件是有订阅的（对应的事件队列存在）\n    if (this.eventmap[type]) {\n      // 将事件队列里的 handler 依次执行出队\n      this.eventmap[type].foreach((handler, index) => {\n        handler(params); // 别忘了读取 params\n      });\n    }\n  }\n  \n  off(type, handler) {\n    if (this.eventmap[type]) {\n      this.eventmap[type].splice(this.eventmap[type].indexof(handler) >>> 0, 1);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# promise\n\n\n# 事件循环\n\n\n# generator\n\n\n# iterator\n\nes6推出，方便创建iterator，generator是一个返回``iterator`对象的函数\n\n> iterator——迭代器\n> \n> 为各种数据结构(array、set、map)提供统一的访问机制。任何数据结构只要部署了iterator接口，就可以完成遍历操作\n\n作用：\n\n * 使得数据结构的成员能够按某种次序排列\n * es6 创造了一种新的遍历命令for…of循环，iterator 接口主要供for…of\n\niterator的结构： 有next方法，该方法返回一个包含value和done两个属性的对象（我们假设叫result）\n\nvalue是迭代的值，后者是表明迭代是否完成的标志\n\niterator内部有指向迭代位置的指针，每次调用next，自动移动指针并返回相应的result\n\n原生具备iterator接口的数据结构如下：\n\n * array\n * map\n * set\n * string\n * typedarray\n * 函数里的arguments对象\n * nodelist对象\n\n这些数据结构都有一个symbol.iterator属性，可以直接通过这个属性创建迭代器\n\nlet arr = ['a','b','c'];\n\nlet iter = arr[symbol.iterator]();\n\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfor ... of首先调用被遍历集合对象的 symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象是可以拥有.next()方法的任何对象，每次循环，调用该迭代器对象上的 .next 方法\n\n对于不具备iterator接口的数据结构，比如object，我们可以采用自定义的方式来创建一个遍历器\n\n\n# generator\n\nfunction* createiterator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\n//generators像正常函数一样被调用，返回iterator\nlet iterator = createiterator();\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\nconsole.log(iterator.next().value); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ngenerator 是一个普通函数，两个特征:\n\n * function关键字与函数名之间有一个星号\n * 函数体内部使用yield语句，定义不同的内部状态\n\ngenerator函数的调用方法与普通函数一样，在函数名后面加上一对圆括号。不同的是，调用generator函数后，该函数不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象——遍历器对象（iterator object）\n\nfunction* generator(){\n    yield 1;\n}\nconsole.dir(generator);\n\n\n1\n2\n3\n4\n\n\ngenerator函数的返回值的原型链上有iterator对象该有的next，说明generator的返回值是一个iterator。除此之外还有函数该有的return方法和throw方法。\n\ngenerator和普通的函数完全不同。当以function*的方式声明一个generator生成器时，内部可以有许多状态，以yield进行断点间隔。期间我们执行调用这个生成的generator，他返回一个遍历器对象，用这个对象上的方法，实现获得yield后面输出的结果\n\nyield和return的区别\n\n * 都能返回紧跟在语句后面的那个表达式的值\n * yield更像是一个断点。遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能\n * 一个函数里面，只能执行一个return语句，但可以执行多次yield表达式\n * 正常函数只能返回一个值，因为只能执行一次return；generator 函数可以返回一系列的值，因为可以有任意多个yield\n\n语法注意点：\n\n * yield表达式只能用在 generator 函数里面\n * yield表达式如果用在另一个表达式之中，必须放在圆括号里面\n * yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号\n * 如果 return 语句后面还有 yield 表达式，后面的 yield 完全不生效\n\n使用generator的其余注意事项：\n\n * yield 不能跨函数，需要和*配套使用，别处使用无效\n\nfunction* createiterator(items) {\n  items.foreach(function (item) {\n    // 语法错误\n    yield item + 1;\n  });\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 箭头函数不能用做 generator\n\ngenerator到底有什么用呢？\n\n * generator可以在执行过程中多次返回，它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator可以实现需要用面向对象才能实现的功能\n * generator还有另一个巨大的好处——把异步回调代码变成“同步”代码\n\n> 原理\n\n采用 编译 转换思路，运用 状态机 模型，同时 利用闭包保存 函数上下文信息，最终实现新的语言特性\n\n\n# async/await\n\njs单线程语言，异步防止用户界面被阻塞\n\n> 特点\n\n * 异步变成同步，代码更具 表现力和可读性\n * 统一异步编程；提供更好的错误堆栈跟踪\n\nes7提出的关于异步的终极解决方案\n\n * 一说async/await是generator的语法糖\n * 二 说async/await是promise的语法糖\n\n> async/await是generator的语法糖：\n\ngenerator语法糖，表明 aysnc/await实现的就是generator实现的功能。但async/await比generator要好用。因为generator执行yield设下的断点就是不断调用iterator方法，这是个手动调用的过程。针对generator的这个缺点，后面提出了co这个库函数自动执行next，相比之前的方案，这种方式有了进步，但是仍然麻烦。async配合await得到的就是断点执行后的结果。async/await比generator使用更普遍\n\nasync函数对 generator函数的改进，主要体现\n\n * 内置执行器：generator函数的执行必须靠执行器，不能一次执行完成，所以之后才有了开源的 co函数库。但async和正常的函数一样执行，不用 co函数库，不用 next方法，async函数自带执行器，自动执行\n * 适用性更好：co函数库有条件约束，yield命令后面只能是 thunk函数或 promise对象，但async函数的 await关键词后面，不受约束\n * 可读性更好：async和 await，比起使用 *号和 yield，语义清晰明了\n\n> async/await是promise的语法糖：\n\n如果不使用async/await的话，promise需要通过链式调用执行then之后的代码\n\npromise搭配async/await的使用才是正解！\n\nasync/await基于promise。async把promise包装了一下，async函数更简洁，不需要像promise一样需要写then，不需要写匿名函数处理promise的resolve值，也不需要定义多余的data，避免嵌套代码\n\nasync是generator函数的语法糖，async函数返回值promise对象，比generator函数返回值 iterator对象更方便，可使用 await 代替then 指定下一步操作(await==promise.then)\n\nfunction f() {\n    return promise.resolve('test');\n}\n\n// asyncf is equivalent to f!\nasync function asyncf() {\n    return 'test';\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> async方法执行时，遇到await会立即执行，然后把表达式后面的代码放到微任务队列，让出执行栈让同步代码先执行\n\nconst one=()=>promise.resolve('one');\nasync function myfunc(){\n    console.log('in function');\n    const res=await one();\n    console.log(res);\n}\n\nconsole.log('before function');\nmyfunc();\nconsole.log('after function');\n\n//before fucntion\n//in function\n//after funciton\n//one\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 定时器原理\n\n * var id=settimeout(fn,delay); 初始化一个只执行一次的定时器，这个定时器会在指定的时间延迟 delay 之后调用函数 fn ，该 settimeout 函数返回定时器的唯一 id ，可以通过这个 id 取消定时器的执行\n * var id=setinvertal(fn,delay); 与 settimeout 类似，它会以 delay 为周期，反复调用函数 fn ，直到我们通过id取消该定时器\n * clearinterval(id),cleartimeout(id); 这两个函数接受定时器的 id，并停止对定时器中指定函数的调用\n\n> 定时器指定的延迟时间不能得到保证\n\n所有的js代码都运行在单一线程中，异步事件只有在被触发时，其回调才会执行\n\n这个图是一维的，垂直方向是时间，以毫秒为单位。蓝色的盒子代表正在执行的js代码所占时间片段\n\n因为单线程在同一时间只能执行一条 代码，每一个代码块（蓝色盒子）都会阻塞其他异步事件的执行\n\n这就意味着，当一个异步事件发生时（例如鼠标点击，定时器触发，一个 xmlhttprequest 请求完成），它进入了代码的执行队列，执行线程空闲时会依照该执行队列中顺序依次执行代码\n\n总结：\n\n * js 引擎是单线程的，会迫使异步事件进入执行队列，等待执行\n * settimeout 和 setinterval 在执行异步代码时从根本上有所不同\n * 如果一个定时器事件被阻塞，使得它不能立即执行，它会被延迟，直到下一个可能的时间点，才被执行（可能比指定的 delay 时间要长）\n * interval 回调有可能‘背靠背’无间隔执行，interval的回调函数的执行时间比指定的 delay 时间还要长\n\njs中定时器的工作原理\n\n\n# 💙 原型\n\n\n# 原型\n\n每个实例对象有有私有属性（proto）指向它构造函数的原型对象。该原型对象有自己的原型对象（proto）,层层向上直到对象的原型为null。null没有原型，作为原型链终点\n\n> 实例是类的具象化产品\n> \n> 对象是一个具有多种属性的内容结构\n> \n> 实例都是对象，对象不一定是实例（object.prototype是对象但不是实例），构造函数也是对象\n> \n> prototype是构造函数的属性\n> \n> __proto__是对象的属性\n\n试图访问对象属性时，它不仅在该对象搜寻，还会搜寻该对象原型，以及该对象的原型的原型，层层向上搜索，直到找到名字匹配的属性或到达原型链的末尾\n\n每个对象都有__proto__属性，指向它的prototype原型对象\n\n每个构造函数都有prototype原型对象\n\nprototype原型对象的constructor指向构造函数本身\n\n有默认constructor属性，记录实例由哪个构造函数创建\n\n\n\n对象都具有的属性，叫_proto_，指向该对象的原型，原型有两个属性，constructor和proto\n\n\n\n实例对象和构造函数都可以指向原型，原型有属性指向构造函数或实例吗?\n\nproto与其说是一个属性，不如说是个getter/setter，使用obj._proto_时，可理解为返回object.getprototypeof(obj)\n\n原型都有constructor属性指向关联的构造函数\n\n\n\nfunction person() {\n\n}\n\nvar person = new person();\nconsole.log(person.__proto__ == person.prototype) // true\nconsole.log(person.prototype.constructor == person) // true 原型对象的constructor指向构造函数本身\n// 顺便学习一个es5的方法,可以获得对象的原型\nconsole.log(object.getprototypeof(person) === person.prototype) // true\n\nconsole.log(object.getprototypeof(person))\nperson.__proto__\nperson.prototype//constructor\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n读取实例属性时，若找不到，会查找与对象关联原型中的属性，若还查不到，就去找原型的原型，一直找到最顶层为止\n\n实例的proto指向构造函数的prototype\n\n\n\n\n# 原型链\n\n每个构造函数都有原型对象（prototype），原型上有属性（constructor）指回构造函数，实例有内部指针指向原型。原型本身也有内部指针指向另一个原型，相应的这个另一个原型也会有个属性指向另一个构造函数，在实例与原型之间形成链式关系\n\nfoo.__proto__ => function.prototype => function.prototype.__proto__ => object.prototype => object.prototype.__proto__ => null\n\n\n1\n\n\nconsole.log(object.prototype.__proto__ === null) // true\n\n\n1\n\n\n意思就是object.prototype没得原型\n\n\n\n> 图中由相互关联的原型组成的练状结构就是原型链(蓝色线)\n\n\n# 创建没有原型的对象\n\nlet obj=object.create(null)\nobj.name='merry'\nconsole.log(obj)\n\n\n1\n2\n3\n\n\n参考文档https://zh.javascript.info/prototype-methods\n\n\n# proto、prototype\n\n\n\nprototype是原型对象\n\n__ proto __ 将对象和该对象的原型相连\n\n特殊的 function 对象，function 的 __proto__ 指向自身的 prototype\n\n构造函数 prototype 的 __proto__ 指向构造函数的构造函数的 prototype\n\n> 构造函数是一个函数对象，通过function构造器产生\n> \n> 原型对象本身是一个普通对象，普通对象的构造函数是object\n\n\n\n> 除了object的原型对象（object.prototype）的__proto__指向null，其他内置函数对象的原型对象（例如：array.prototype）和自定义构造函数的 __proto__都指向object.prototype， 因为原型对象本身是普通对象\n\nobject.prototype.__proto__ = null;\narray.prototype.__proto__ = object.prototype;\nfoo.prototype.__proto__  = object.prototype;\n\n\n1\n2\n3\n\n * 一切对象都继承object对象，object 对象直接继承根源对象null\n * 一切函数对象（包括 object 对象），都继承自 function 对象\n * object 对象直接继承自 function 对象\n * function对象的__proto__指向自己的原型对象，最终还是继承自object对象\n\n\n# 原型、原型链\n\n\n\n需要new关键字，成为“构造器constructor或构造函数”\n\n通过prototype定义的属性，再被多个实例化后，引用地址是同一个\n\n继承链 从祖父——到爷爷——到爸爸——到自己\n\n * constructor指向构造函数，每个对象的__proto__指向创建它的构造函数的prototype，构造函数的prototype也有__proto__，指向他的父辈或者是object，当查找一个对象中不存在的属性时，会去它的__proto__、__proto__中的__proto__中寻找，直到找到或是null为止\n * instanceof判断对象的__proto__和构造函数的prototype是不是同一个地址\n * object.setprototypeof改变对象的__proto__\n\n原型(prototype)：一个对象，实现对象的属性继承，简单理解为对象的爹\n\nprototype可通过object.getprototypeof() 和 object.setprototypeof() 访问器访问\n\n当继承的函数被调用时，this 指向当前继承的对象，而不是继承的函数所在原型对象\n\n不是所有对象都有原型\n\nclass a{}\nclass b extends a{}\nconst a = new a()\nconst b = new b()\na.__proto__\nb.__proto__\nb. __proto__\nb. prototype.__proto__\nb.__proto__.__proto__\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# object是function实例，那function是谁的实例\n\nfunction.__proto__=== function.prototype;\n//true\n\n\n1\n2\n\n\nfunction构造函数的prototype和__proto__属性指向同一个原型，说明function对象是function构造函数创建的一个实例？\n\nyes and no\n\n> yes ：\n\n按照js中“实例”定义，a 是 b 的实例即 a instanceof b 为 true，默认是 b.prototype 在 a 的原型链上。而 function instanceof function 为 true，本质上即 object.getprototypeof(function) === function.prototype，符合定义\n\n> no ：\n\nfunction 是 built-in 的对象，不存在“function对象由function构造函数创建”会造成鸡生蛋蛋生鸡问题。实际上 直接写一个函数时（如 function f() {} 或 x => x），不存在调用 function 构造器，只有显式调用 function 构造器时（如 new function('x', 'return x') ）才有\n\n本质上，a instanceof b 只是运算，满足条件返回 true/false，我们说 a 是 b 的实例时，只是表示他们符合某种关系。js 是强大的动态语言，你甚至可在运行时改变这种关系，如修改对象原型改变instanceof 运算的结果。es6+ 已允许通过 symbol.hasinstance 自定义 instanceof 运算\n\n function.prototype//\"function\"\n\n\n1\n\n\n后来意见：\n\n> 先有object.prototype， object.prototype构造function.prototype，function.prototype构造object和function\n> \n> object.prototype是鸡，object和function都是蛋\n\n\n# 栗子\n\n不是没有，只是是undefined，所以不会继续往上找\n\nfunction a(x) {\n    this.x = x\n}\n\na.prototype.x = 1\n\nfunction b(x) {\n    this.x = x\n}\n\nb.prototype = new a()\nvar a = new a(2), b = new b(3)\ndelete b.x\nconsole.log(a.x)\nconsole.log(b.x)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n此题涉及的知识点 包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等\n\n\nfunction foo () {\n    getname = function () { console.log(1) }\n    /*\n    是函数赋值语句，没有var声明，先向当前foo函数作用域寻找getname变量，没有，再向当前函数作用域上层寻找是否有getname变量，找到了，即console.log(4)函数，将此变量赋值为console.log(1)\n    */\n    return this;//指向window\n}\nfoo.getname = function () { console.log(2) }\n\nfoo.prototype.getname = function () { console.log(3) }\n\nvar getname = function () { console.log(4) }\n\nfunction getname () { console.log(5) }\n\nfoo.getname();//2\ngetname();//4\n/*\n所有声明变量或声明函数都会被提升到当前函数顶部\n函数提升优先级高于变量提升，不会被变量声明覆盖，但会被变量赋值之后覆盖\n*/\nfoo().getname();//1\ngetname();//1\nnew foo.getname();//2\n/*\n相当于 new (foo.getname)()，将getname作为了构造函数执行\n*/\nnew foo().getname();//3\n/*\n相当于(new foo()).getname()，先执行foo函数，有返回值\nthis本就代表当前实例化对象，调用this的getname函数，prototype中寻找getname\n*/\nnew new foo().getname();//\n/*\nnew ((new foo()).getname)()\n先初始化foo的对象，将原型上的getname作为构造函数再次new\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n构造函数的返回值\n\n传统中，构造函数不该有返回值，实际执行的返回值就是实例化对象\n\njs中构造函数可有可不有返回值\n\n 1. 没有返回值就返回实例化对象\n 2. 有返回值就检查返回值是否为引用类型，非引用类型则返回实例化对象\n 3. 若返回值是引用类型，则返回这个引用类型\n\n\n# 继承\n\n构造函数会在每一个实例上都创建一遍！\n\n使用原型模式定义的属性和方法由所有实例共享！\n\n\n# 原型链\n\n原型链向上查找的机制实现继承，子类prototype原本指向 子类构造函数本身，改变子类原型指向，把子类的原型指向父类实例，酱紫可在子类的实例上，既能继承父类属性和方法，也能继承父类原型属性和方法\n\nfunction animal() { // 父类\n    this.name = '父类name -> animal';\n    this.arr = [1,2,3]\n}\nanimal.prototype.speak = function () { // 父类原型上的方法\n    return '父类原型的方法 speak ---\x3e'\n};\nfunction dog(type) {\n    this.type = type\n}\nconsole.log('----\x3e>', dog.prototype); // 未改变指向之前的原型 指向子类函数本身: dog{}\n\ndog.prototype = new animal(); #// 子类原型指向父类实例\n\nlet dog1 = new dog('dog1');\nlet dog2 = new dog('dog2');\nconsole.log(dog1.name); // 父类name -> animal\ndog1.arr.push('又push了一个元素');\nconsole.log(dog1.speak()); // 父类原型的方法 speak ---\x3e\nconsole.log(dog2.name); // 父类name -> animal\nconsole.log(dog2.arr); // [ 1, 2, 3, '又push了一个元素' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n缺点\n\n 1. 引用类型的属性被所有实例共享，我们通常不希望2个子类实例相互影响\n 2. 创建child实例时，不能向parent传参\n\n\n# 构造函数(经典继承)\n\ncall实现继承，本质是改变this的指向，父类的this指向当前子类的上下文，这样在父类中通过this设置的属性/方法被写到子类上\n\nfunction animal() {\n    console.log('父类里的 this ------',this);\n    this.name = 'animal'\n}\nanimal.prototype.speak = function () {\n    console.log('speak --\x3e');\n};\nfunction dog() {\n    console.log('子类里的 this ---\x3e>>',this);\n    animal.call(this); // 这时父类里的this是 dog{}\n    this.type = 'dog'\n}\nvar dog = new dog(); // new 的时候执行 obj 构造函数, 调用父类\nconsole.log(dog.name); // fun\nconsole.log(dog.speak); // undefined\n\nfunction cat() {\n    animal.call(this) // 这时父类里的this是 cat{}\n}\nvar cat = new cat(); // new 的时候执行 obj2 构造函数, 调用父类\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 1. 避免了 引用类型的属性被所有实例共享\n 2. 可以在 child 中向 parent 传参\n\n缺点\n\n * 方法都在构造函数中 定义，每次创建实例都会创建一遍方法\n * 只能继承父类构造函数上的属性和方法，不能继承父类原型上的属性和方法\n\n\n# 组合继承\n\n原型链继承+经典继承 双剑合璧\n\n子类中执行parent.call(this) 改变当前子类child的父类中this，等于 将父类构造函数在子类中调用执行了一遍， 将父类构造函数本身 的属性和方法设置到了子类，让子类单独维护一套从父类构造函数继承来的属性和方法，避免其沿着原型链向上查找共同的父类 属性和方法，保持了相互独立\n\n然后 再次通过改变子类的原型指向父类的实例，实现继承父类原型的属性和方法\n\nfunction parent() {\n    this.name = 'i am parent';\n    this.arr = [1,2,3]\n}\n\nparent.prototype.speak = function () {\n    console.log('我是父类原型上的方法 speak --\x3e ');\n};\nfunction child() {\n    parent.call(this); // 构造函数继承的 call 方法\n    this.type = 'child'\n}\nchild.prototype = new parent(); // 子类的原型指向父类的实例\n\nlet child1 = new child();\nlet child2 = new child();\nchild1.arr.push('child1 push一个元素');\nconsole.log(child1.arr); // [ 1, 2, 3, 'child1 push一个元素' ]\nconsole.log(child2.arr); // [ 1, 2, 3 ]\nconsole.log(child1.speak); // [function] 可以访问父类原型的熟悉和方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n融合 原型链 继承和构造函数的优点，js最常用继承模式\n\n缺点\n\n * 父类构造函数被执行两遍，分别是 parent.call(this) 和child.prototype=new parent()\n * 父类构造函数的属性在子类自身和子类原型上都存在，若delete child.arr时，只是删除了child1上的arr属性，其原型上的arr属性依然存在，原型链上依旧可以查找到\n\n优化: 把之前 子类原型指向父类实例, 改为 子类原型指向父类原型来只继承父类原型属性和方法, 避免重复继承父类本身属性方法\n\n同样有缺点:\n\nchild.prototype == parent.prototype, 父类和子类的实例无法区分\n\n\n# 原型式继承\n\nfunction createobj(o) {\n    function f(){}\n    f.prototype = o;\n    return new f();\n}\n\n\n1\n2\n3\n4\n5\n\n\nes5 object.create的模拟实现，将传入对象 作为 创建的对象的原型\n\ncreate创建中间对象，将2个对象区分开\n\nobject.assign 实现同时继承多个对象, 如object.assign(对象1, 对象2, ...对象n) 实现同时继承多个对象\n\n包含引用类型的属性值都会共享相应的值——和原型链 继承一样\n\nfunction parent() {\n    this.name = 'i am parent';\n    this.arr = [1,2,3]\n}\n\nparent.prototype.speak = function () {\n    console.log('我是父类原型上的方法 speak --\x3e ');\n};\nfunction child() {\n    parent.call(this); // 构造函数继承的 call 方法\n    this.type = 'child'\n}\n\n// 子类原型指向一个新创建的对象,这个对象依据父类原型创建\nchild.prototype = object.create(parent.prototype);\nchild.prototype.constructor = child; // 让子类原型的构造函数 重新指回 子类本身构造函数\n\nlet child1 = new parent();\nlet child2 = new child();\n\nconsole.log(child1 instanceof parent); // true\nconsole.log(child1 instanceof child); // false 区分出其不是子类的实例,而是父类的实例\nconsole.log(child2 instanceof child); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 寄生式继承\n\n创建一个仅用于封装继承过程的函数，该函数在内部以某种形式 做增强对象，再返回对象\n\nfunction createobj (o) {\n    var clone = object.create(o);\n    clone.sayname = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n缺点\n\n和借用构造函数一样，每次创建对象都会创建一遍方法\n\n\n# 寄生组合式继承\n\n组合继承 最大缺点——调用2次 父构造方法\n\n 1. 设置子实例的原型时\n 2. 创建子类型的实例时\n\n如何 避免 重复调用？\n\n如果我们不使用child.prototype=new parent()，而是间接让 child.prototype访问parent.prototype呢？\n\n// 精简版\nclass child {\n  constructor() {\n    // 调用父类的构造函数\n    parent.call(this);\n    // 利用object.create生成一个对象，新生成对象的原型是父类的原型，并将该对象作为子类构造函数的原型，继承了父类原型上的属性和方法\n    child.prototype = object.create(parent.prototype);\n    // 原型对象的constructor指向子类的构造函数\n    child.prototype.constructor = child;\n  }\n}\n\n// 通用版\nfunction parent(name) {\n  this.name = name;\n}\nparent.prototype.getname = function() {\n  console.log(this.name);\n};\nfunction child(name, age) {\n  // 调用父类的构造函数\n  parent.call(this, name); \n  this.age = age;\n}\nfunction createobj(o) {\n  // 目的是为了继承父类原型上的属性和方法，在不需要实例化父类构造函数的情况下，避免生成父类的实例，如new parent()\n  function f() {}\n  f.prototype = o;\n  // 创建一个空对象，该对象原型指向父类的原型对象\n  return new f(); \n}\n\n// 等同于 child.prototype = object.create(parent.prototype)\nchild.prototype = createobj(parent.prototype); \nchild.prototype.constructor = child;\n\nlet child = new child(\"tom\", 12);\nchild.getname(); // tom\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n优点——引用类型最理想的继承方式\n\n只调用一次parent 构造函数，避免了在parent.prototype上面创建不必要的、多余的属性\n\n同时，原型链能保持不变，能正常使用instanceof和isprototypeof\n\n\n# class\n\n基于寄生组合式继承，是目前最理想的继承方式\n\nes6的extends实现(底层 寄生组合式继承)\n\n是原型系统上的语法糖\n\n\nclass game{\n  constructor(name){\n    this.name = name;\n  }\n}\nconst game = new game('fornite');\nconsole.log(game.__proto__ === game.prototype);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# class原理\n\n手撕class\n\n// child 为子类的构造函数， parent为父类的构造函数\nfunction selfclass(child, parent) {\n  // object.create 第二个参数，给生成的对象定义属性和属性描述符/访问器描述符\n  child.prototype = object.create(parent.prototype, {\n    // 子类继承父类原型上的属性和方法\n    constructor: {\n      enumerable: false,\n      configurable: false,\n      writable: true,\n      value: child\n    }\n  });\n  // 继承父类的静态属性和静态方法\n  object.setprototypeof(child, parent);\n}\n\n// 测试\nfunction child() {\n  this.name = 123;\n}\nfunction parent() {}\n// 设置父类的静态方法getinfo\nparent.getinfo = function() {\n  console.log(\"info\");\n};\nparent.prototype.getname = function() {\n  console.log(this.name);\n};\nselfclass(child, parent);\nchild.getinfo(); // info\nlet tom = new child();\ntom.getname(); // 123\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nlet a=5\nclass a{\n    a=10\n    fn(){\n        console.log(this)\n        console.log(this.a)\n    }\n}\nconst b=new a().fn\nb()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# super\n\n> 用作函数\n\nsuper作为函数调用时 代表父类 构造函数，子类构造函数必须执行 super()，super()只能用在子类的构造函数中\n\n作为函数调用时，this指的是子类实例\n\n> 用作对象\n\n1、super在普通方法及this\n\nsuper作为对象时，在普通方法中，指向父类 原型对象(所以若父类的方法/属性 定义在实例上，无法通过super调用)；静态方法中 指向父类\n\n子类普通方法通过super调用父类方法时，方法内部this指向当前子类实例\n\n2、super在静态方法中及this\n\nsuper作为对象，用在静态方法中，super直接指向父类，而不是父类 原型对象\n\n子类静态方法中通过super调用父类方法时，方法内部this指向当前子类，而不是子类实例\n\n\n# ✅创建对象\n\n\n# 工厂方法\n\n\n# 构造函数\n\n\n# 原型模式\n\n\n# 构造函数+原型模式\n\n\n# 动态原型\n\n判断实例上是否有函数\n\n没有的话，就在原型上定义一个函数\n\n\n# 寄生构造函数\n\n\n# 稳妥构造函数\n\n安全\n\n不用this和new\n\n\n# ❤️ proxy？\n\nes6新增功能\n\n在目标对象前设一层\"拦截\"，外界对该对象的访问，必须先通过这层拦截，可过滤和更改外界访问\n\n代理是一种很有用的抽象机制，能够通过api只公开部分信息，同时还能对数据源进行全面控制\n\n在需要公开api，同时又要避免使用者直接操作底层数据时，可使用代理\n\n比如，实现一个传统的栈数据类型，数组可以作为栈使用，但要保证人们只使用push pop 和length，我们可以基于数组创建一个代理对象，只对外公开这个三个对象成员\n\nvue3.0中使用proxy替换原本的object.defineproperty实现数据响应式\n\nlet p = new proxy(target, handler)\n\n\n1\n\n\ntarget 表示需要添加代理的对象，handler表示自定义对象中的操作，可以用来自定义set或get函数\n\n使用proxy实现数据响应式：\n\nlet onwatch = (obj, setbind, getlogger) => {\n  let handler = {\n    get(target, property, receiver) {\n      getlogger(target, property)\n      return reflect.get(target, property, receiver)\n    },\n    set(target, property, value, receiver) {\n      setbind(value, property)\n      return reflect.set(target, property, value)\n    }\n  }\n  return new proxy(obj, handler)\n}\nlet obj = { a: 1 }\nlet p = onwatch(\n  obj,\n  (v, property) => {\n    console.log(`监听到属性${property}改变为${v}`)\n  },\n  (target, property) => {\n    console.log(`'${property}' = ${target[property]}`)\n  }\n)\np.a = 2 // 监听到属性a改变\np.a // 'a' = 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n自定义set和get函数，在原本逻辑中插入函数逻辑，实现 在对 对象任何属性进行读写时 发出通知\n\n如果 是实现vue中的响应式，需要在get中收集依赖，在set派发更新，vue3.0使用proxy代替原来api的原因在于 proxy无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能更好，proxy可以完美监听到任何方式的数据改变，兼容性 不太好\n\nconst obj = {\n   name: '徐小夕',\n   age: '120'\n }\n const proxy = new proxy(obj, {\n   get(target, propkey, receiver) {\n    console.log('get:' + propkey)\n    return reflect.get(target, propkey, receiver)\n   },\n   set(target, propkey, value, receiver) {\n    console.log('set:' + propkey)\n    return reflect.set(target, propkey, value, receiver)\n   }\n })\n console.log(proxy.name) // get:name 徐小夕\n proxy.work = 'frontend' // set:work frontend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# reflect\n\n配合proxy使用，将对象的一些明显属于语言内部的方法放到reflect对象上，并修改某些对象方法的返回结果\n\n\n# 🔥 new\n\n> 创建给定构造函数的实例，可以访问构造函数的属性方法，同时实例和构造函数通过原型链接起来\n\nnew做了如下工作：\n\n 1. 创建新对象\n 2. 将对象和构造函数通过原型链连接\n 3. 将构造函数中的this绑定到新建的对象\n 4. 根据构造函数返回类型判断，若是原始值则忽略，若是对象则返回\n\nfunction person(name, age){\n    this.name = name;\n    this.age = age;\n}\nconst person1 = new person('tom', 20)\nconsole.log(person1)  // person {name: \"tom\", age: 20}\n\n\n1\n2\n3\n4\n5\n6\n\n\n实现\n\nfunction mynew2(func, ...args) {\n    const obj = {};\n    obj.__proto__ = func.prototype;\n    let res = func.apply(obj, args);\n    return res instanceof object ? res : obj;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 第二版的代码\nfunction objectfactory() {\n    var obj = new object(),\n    constructor = [].shift.call(arguments);\n    obj.__proto__ = constructor.prototype;\n    var ret = constructor.apply(obj, arguments);\n    return typeof ret === 'object' ? ret : obj;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n构造函数中 不要显示返回任何值！！\n\n因为返回 原始值不生效，返回对象会导致new失效！\n\n> 为啥\n\n构造函数不是由我们的代码直接调用，是由运行时的内存分配和对象初始化代码调用。它的返回值(编译为机器码时实际上有一个)对用户来说不透明——所以，我们不能指定它\n\nlet a=[]//let a=new array()\nfunction(){} //let a=new function(){}\n\n\n1\n2\n\n\n\n# 🍉 懒加载\n\n过度使用的弊端\n\n * 减慢快速滚动的速度\n * 页面缓冲\n * 内容变化导致延迟\n\n何时使用\n\n * 懒加载不妨碍网页使用的内容\n\n\n# lazy\n\n<img src=\"./example.jpg\" loading=\"lazy\">\n\n\n1\n\n * loading\n * 判断元素是否在视口\n * 递归获取滚动容器\n * 添加滚动事件\n * 元素出现在视口中 展示真正内容，取消监控事件\n\n判断元素是否出现在视口\n\n 1. offsettop计算body到元素距离(繁琐)\n 2. getboundingclientrect计算\n\n\n# offsettop\n\nclientheight 包括元素的内容 和内边距，不包括边框\n\noffsettop 元素的偏移量，获取元素到有定位的父盒子顶部距离\n\n先给图片一个占位资源:\n\n<img src=\"default.jpg\" data-src=\"http://www.xxx.com/target.jpg\" />\n\n\n1\n\n\n监听 scroll 判断图片是否到达视口:\n\nlet img = document.getelementsbytagname(\"img\");\nlet num = img.length;\nlet count = 0;//计数器，从第一张图片开始计\n\nlazyload();//首次加载别忘了显示图片\n\nwindow.addeventlistener('scroll', lazyload);\n\nfunction lazyload() {\n  let viewheight = document.documentelement.clientheight;//视口高度\n  let scrolltop = document.documentelement.scrolltop || document.body.scrolltop;//滚动条卷去的高度\n  for(let i = count; i <num; i++) {\n    // 元素现在已经出现在视口中\n    if(img[i].offsettop < scrollheight + viewheight) {\n      if(img[i].getattribute(\"src\") !== \"default.jpg\") continue;\n      img[i].src = img[i].getattribute(\"data-src\");\n      count ++;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n最好对 scroll 事件做节流处理，以免频繁触发:\n\n节流就是一段时间内执行一次\n\n// throttle函数我们上节已经实现\nwindow.addeventlistener('scroll', throttle(lazyload, 200));\nfunction throttle(fn,wait){\n    let pre=0;\n    return function(){\n        let now=date now();\n        if(now-pre>=wait){\n            pre=now;\n            fn.apply(this,arguments);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# getboundingclientrect\n\n判断图片是否出现在当前视口，返回 domrect对象，有left， top， right， bottom， x， y， width，height属性\n\nconst target = document.queryselector('.target');\nconst clientrect = target.getboundingclientrect();\nconsole.log(clientrect);\n\n// {\n//   bottom: 556.21875,\n//   height: 393.59375,\n//   left: 333,\n//   right: 1017,\n//   top: 162.625, 元素到视窗顶部的距离\n//   width: 684\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n图片不可以看见，说明图片到窗口顶部距离＞窗口显示区高度\n\n图片可以看见，说明图片距离视窗顶部距离＜窗口显示区高度\n\n上述的 lazyload 函数改成下面这样:\n\nfunction lazyload() {\n  for(let i = count; i <num; i++) {\n    // 元素现在已经出现在视口中\n    if(img[i].getboundingclientrect().top < document.documentelement.clientheight) {\n      if(img[i].getattribute(\"src\") !== \"default.jpg\") continue;\n      img[i].src = img[i].getattribute(\"data-src\");\n      count ++;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n缺点：即使图片加载完成，监听到滚动事件，还是会触发函数\n\n多2个处理\n\n * 图片全部加载后移除事件监听\n * 加载完的图片从imglist移除\n\nlet imglist = [...document.queryselectorall('img')]\nlet length = imglist.length\n\nconst imglazyload = (function() {\n    let count = 0\n    return function() {\n        let deleteindexlist = []\n        imglist.foreach((img, index) => {\n            let rect = img.getboundingclientrect()\n            if (rect.top < window.innerheight) {\n                img.src = img.dataset.src\n                deleteindexlist.push(index)\n                count++\n                if (count === length) {\n                    document.removeeventlistener('scroll', imglazyload)\n                }\n            }\n        })\n        imglist = imglist.filter((img, index) => !deleteindexlist.includes(index))\n    }\n})()\n\n// 这里最好加上防抖处理\ndocument.addeventlistener('scroll', imglazyload)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n防抖指的是 n s 后执行一次，重复触发则重新计时\n\n\n# intersection observer\n\n重叠观察者，判断两个元素是否重叠，不用事件监听，性能比getboundingclientrect好 浏览器内置api，实现监听window的scroll事件、判断是否在视口中、节流三大功能\n\nlet img = document.getelementsbytagname(\"img\");\n\nconst observer = new intersectionobserver(changes => {\n  //changes 是被观察的元素集合\n  for(let i = 0, len = changes.length; i < len; i++) {\n    let change = changes[i];\n    // 通过这个属性判断是否在视口中\n    if(change.isintersecting) {\n      const imgelement = change.target;\n      imgelement.src = imgelement.getattribute(\"data-src\");\n      observer.unobserve(imgelement);\n    }\n  }\n})\narray.from(img).foreach(item => observer.observe(item));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 💚 防抖、节流\n\n浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，不断调用事件回调，浪费资源\n\n防抖（debounce） 和 节流（throttle） 减少调用频率\n\n设置事件频率为500ms，2s内，频繁触发函数\n\n节流——每隔500ms执行一次( 隔一段时间 再执行)\n\n防抖——不管调用多少次，在2s后只会执行一次 (一段时间之后执行)\n\n\n# 防抖\n\n控制次数\n\nn 秒后再执行，若在 n 秒内重复触发，会重新计时\n\n高频到最后一次操作，这事儿需要等待，如果你反复操作，我就重新计时\n\n函数被连续触发，只执行最后一次\n\n原理：维护一个定时器，延迟计时以最后一次触发为计时起点，到达延迟时间后触发函数执行\n\n\n# 普通版\n\n支持this 和 event 对象\n\nfunction debounce(fn, wait) {\n        // 4、创建一个标记用来存放定时器的返回值\n        let timer = null;\n        // 返回闭包函数 ，闭包保存timer，保证其不被销毁，重复点击会清理上一次的定时器\n        return function () {\n            let that = this;\n            // 5、每次当用户点击/输入的时候，把前一个定时器清除\n            if (timer) {\n                cleartimeout(timer);\n                timer = null;\n            }\n            // 6、创建一个新的 settimeout，保证点击按钮后的 interval 间隔\n            // 如果用户还点击了的话，不会执行 fn 函数\n            timer = settimeout(() => {\n                fn.call(that, arguments);\n            }, wait);\n        };\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n使用\n\nvar node = document.getelementbyid('layout')\nfunction getuseraction(e) {\n    console.log(this, e)  // 分别打印：node 这个节点 和 mouseevent\n    node.innerhtml = count++;\n};\nnode.onmousemove = debounce(getuseraction, 1000)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 非立即执行版\n\n感觉 和普通版 是一个道理？？\n\n<body>\n<button id=\"debounce\">点击</button>\n<script>\n  window.onload = function () {\n    var mydebounce = document.getelementbyid(\"debounce\")\n    mydebounce.addeventlistener(\"click\", debounce(saydebounce, 1000))\n  }\n\n  //防抖函数\n  function debounce(fn, time) {\n    let timer = null;\n    return function () {\n      let context = this;\n      if (timer) cleartimeout(timer);  //清除前一个定时器\n      timer = settimeout(() => {  //在时间间隙内再次点击不会执行fn函数\n        fn.apply(context, arguments);\n      }, time || 500)\n    }\n  }\n\n  //要防抖的事件处理\n  function saydebounce() {\n    console.log(\"处理防抖的事件写在这里,比如发送请求\");\n  }\n<\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 立即执行版\n\n如果timer不存在的话，设置flag标志立即调用\n\n function debounce(fn,time) {\n    let timer = null\n    return function () {\n      let context = this\n      if(timer) cleartimeout(timer)  //清除前一个定时器\n      let callnow = !timer\n      timer = settimeout(()=>{\n        timer = null\n      },time || 500)\n      if (callnow) fn.apply(context,arguments)\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 双剑合璧版\n\n如果需要立即执行，可加入第三个参数判断\n\n  window.onload = function () {\n    var mydebounce = document.getelementbyid(\"debounce\")\n    mydebounce.addeventlistener(\"click\", debounce(saydebounce, 1000, true))\n  }\n\n  //immediate 为true表 立即执行\n  function debounce(func, wait, immediate) {\n    let timer;\n    return function () {\n      let context = this;\n      if (timer) cleartimeout(timer);\n      if (immediate) {\n        var callnow = !timer;//第一次会立即执行，后面每次触发时执行\n        timer = settimeout(() => {\n          timer = null;\n        }, wait)\n        if (callnow) func.apply(context, arguments)\n      } else {\n        timer = settimeout(function () {\n          func.apply(context, arguments)\n        }, wait);\n      }\n    }\n  }\n  function saydebounce() {\n    console.log(\"处理防抖的事件写在这里,比如发送请求\");\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 加强版\n\n触发过于频繁导致一次响应都没有，希望到了固定时间必须给用户一个响应\n\n function debounce(fn, await) {\n        let last = 0;\n        let timer = null;\n        return function () {\n            let that = this;\n            let now = new date();\n            if (now - last < await) {\n                cleartimeout(timer);\n                settimeout(() => {\n                    last = now;\n                    fn.apply(that, arguments);\n                }, await);\n            } else {\n                // 时间到了，必须给响应\n                last = now;\n                fn.apply(that, arguments);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 取消debounce（终极版）\n\n\n\n\n1\n\n\n\n# 节流\n\n用户反复触发一些操作，如 鼠标移动，需要一个\"巡视\"的间隔时间，不管用户期间触发多少次，只会在间隔点上执行给定的回调\n\n> 水龙头的水一直往下流，浪费水，我们可以把龙头关小，让水一滴一滴流，每隔一段时间掉下来一滴水\n\nn 秒内只运行一次，若在 n 秒内重复触发，只有一次生效\n\n稀释函数的执行频率\n\nfunction throttle(fn) {\n        // 4、通过闭包保存一个标记\n        let canrun = true;\n        return function () {\n            // 5、判断标志是否为 true，不为 true 则中断\n            if (!canrun) {\n                return;\n            }\n            // 6、将 canrun 设置为 false，防止执行之前再被执行\n            canrun = false;\n            // 7\n            settimeout(() => {\n                fn.call(this, arguments);\n                // 8、执行完事件后，重新将这个标志设置为 true\n                canrun = true;\n            }, 1000);\n        };\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 时间戳 首节流\n\n立即执行，每wait执行一次，停止触发后不再执行\n\n时间戳\n\n  function throttle(fn, wait) {\n    //记录第一次调用时间\n    let pretime = 0;\n    return function () {\n      const that = this;\n      let nowtime = date.now();\n      // 如果两次时间间隔 超过了指定时间，则执行函数\n      if (nowtime - pretime >= wait) {\n        //将现在的时间设置为上一次执行时间\n        pretime = nowtime;\n        return fn.apply(that, arguments);\n      }\n    };\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 定时器 尾节流\n\n不会立即执行，每wait执行一次，停止触发后，再执行一次\n\n定时器\n\n  function throttle(fn, wait = 500) {\n    let timer = null;\n    return function () {\n      if (!timer) {\n        timer = settimeout(() => {\n          fn.apply(this, arguments);\n          //执行完毕后重置定时器\n          timer = null;\n        }, wait);\n      }\n    };\n  };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 双剑合璧版\n\n立刻执行，停止触发后还能再执行一次\n\n时间戳+定时器\n\nfunction throttle(fn, await) {\n    // 初始化定时器\n    let timer = null;\n    // 上一次调用时间\n    let prev = null;\n    return function () {\n      // 现在触发事件时间\n      let now = date.now();\n      // 触发间隔是否大于await\n      let remaining = await - (now - prev);\n      cleartimeout(timer);\n      // 如果间隔时间满足await\n      if (remaining <= 0) {\n        fn.apply(this, arguments);\n        prev = date.now();\n      } else {\n        // 否则，过了剩余时间执行最后一次fn\n        timer = settimeout(() => {\n          fn.apply(this, arguments)\n        }, await);\n      }\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 应用场景\n\n防抖在连续的事件只触发一次：\n\n * 鼠标滑动\n * 登录注册等表达提交操作用户单击过快触发多次请求\n * 编辑器内容实时保存\n * iinput.change实时输入校验(输入实时查询，不可能摁一个字就查一次，肯定是输一串，统一查询一次)\n * window.resize(窗口缩放完成后，才会重新计算部分 dom 尺寸)\n\n节流在间隔一段时间执行一次回调的场景：\n\n * 搜索框，搜索联想功能\n * 滑动定时/滑动高度，埋点请求\n * 运维系统查看日志，n秒刷新\n * 进度条位置计算\n * 监听 mousemove、 鼠标滚动等事件，常用于：拖拽动画、下拉加载、滚动加载、加载更多或滚到底部监听\n\n> 节流常用在比防抖刷新更频繁的场景，大部分需要涉及动画操作\n\n\n# 🍉 模块化\n\n指定规范约束我们按照规范写代码\n\n规范包括模板可暴露的属性 和 可导入自己所需的属性\n\n\n# 特点\n\n 1. 解决命名污染，全局污染，变量冲突等\n 2. 内聚私有，变量不能被外部访问\n 3. 更好的分离，按需加载\n 4. 引入其他模块可能存在循环引用\n 5. 代码抽象，封装，复用\n 6. 避免通过script标签从上至下加载资源\n 7. 大型项目资源难以维护\n\n\n# commonjs\n\n服务端解决方案。加载速度快(因为模块·文件一般存在本地硬盘)\n\n * node中 **每个文件是一个模块，**有自己的作用域。在一个文件里面定义的变量、函数 都是私有的，对其他文件不可见\n\n * 运行时加载，只能在运行时才能确定一些东西\n\n * 同步加载，加载完成后，才能执行后续操作。 文件都在本地，同步导入即使卡住主线程影响也不大\n\n * 导出时是值拷贝，想更新值，必须重新导入\n\n * 模块在首次执行后会缓存，再次加载只返回缓存结果，若想再次执行，可清除缓存\n\n * 模块加载的顺序就是代码出现的顺序\n\n\n# 基本语法\n\n核心变量——exports，module.exports，require\n\n * 暴露模块：module.exports = value或exports.xxx = value\n * 引入模块：require(xxx)，xxx为模块 名/文件路径\n\ncommonjs规范规定，每个模块内部，module变量代表当前模块，它是一个对象，它的exports属性是对外的接口。加载某个模块，其实是加载该模块的module.exports属性\n\n// 加载模块\nvar example = require('./example.js');\nvar config = require('config.js');\nvar http = require('http');\n// 对外暴露模块\nmodule.exports.example = function () {\n  ...\n}\nmodule.exports = function(x){  \n    console.log(x)\n}\nexports.xxx=value;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\nrequire 读入并执行一个js文件，返回该模块的exports对象。如果没有发现指定模块，报错\n\nnodejs主要用于服务器编程，模块文件一般存在本地硬盘，所以加载比较快，不用考虑异步加载——使用commonjs规范\n\n浏览器环境，要从服务器端加载模块，用commonjs需要等模块下载完并运行后才能使用，将阻塞后面代码执行，这时必须采用非同步模式，浏览器端一般采用amd规范，解决异步加载\n\n 1. exports 记录当前模块导出的变量\n 2. module 记录当前模块的详细信息\n 3. require 进行模块的导入\n\n\n# exports、module.exports\n\n两者指向同一块内存\n\n 1. 绑定同一属性时，2者相等\n 2. 不能直接赋值给exports，即不能直接使用exports={}\n 3. 只要最后直接给module.exports赋值了，之前绑定的属性都会被覆盖掉\n\n\n\n和exports对象没有任何关系了，exports 你自己随便玩吧\n\nmodule.exports 现在导出一个自己的对象，不带你玩了\n\n新的对象 取代了 exports 的导出，即 require 导入的对象 是新的对象\n\n\n\n\n# 循环引入\n\n//index.js\nvar a = require('./a')\nconsole.log('入口模块引用a模块：',a)\n\n// a.js\nexports.a = '原始值-a模块内变量'\nvar b = require('./b')\nconsole.log('a模块引用b模块：',b)\nexports.a = '修改值-a模块内变量'\n\n// b.js\nexports.b ='原始值-b模块内变量'\nvar a = require('./a')\nconsole.log('b模块引用a模块',a)\nexports.b = '修改值-b模块内变量'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\ncommonjs做了处理——模块缓存\n\n每一个模块都会先加入缓存再执行，每次遇到require都先检查缓存，这样不会出现死循环；借助缓存，就能找到输出的值\n\n\n# 多次引入\n\n//index.js\nvar a = require('./a')\nvar b= require('./b')\n\n// a.js\nmodule.exports.a = '原始值-a模块内变量'\nconsole.log('a模块执行')\nvar c = require('./c')\n\n// b.js\nmodule.exports.b = '原始值-b模块内变量'\nconsole.log('b模块执行')\nvar c = require('./c')\n\n// c.js\nmodule.exports.c = '原始值-c模块内变量'\nconsole.log('c模块执行')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nc模块只执行一次，第二次读取时，发现有缓存，直接读取缓存\n\n\n# 路径解析\n\n> 为什么简单写一个'react'就能找到包的位置\n\n路径分类\n\n 1. 内置核心模块，node已将其编译为二进制代码，直接书写标识符fs、http就可\n 2. 本地文件模块，自己书写的文件模块，需要使用'./' \"../\"开头，require将其转化为真实路径\n 3. 第三方模块，npm下载的包，用到paths变量，依次查找当前路径下的node_modules->父级目录的node_modules->根目录为止\n\n\n# amd\n\nasynchronous module definition（异步模块定义）\n\n编译成 require/exports 来执行\n\n浏览器一般使用amd规范，异步加载\n\nrequirejs是一个工具库。用于客户端的模块管理。可以让客户端的代码分成一个个模块，实现异步或动态加载，提高代码的性能和可维护性。遵守amd规范\n\nrequire.js的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载\n\n> 基本语法\n\n定义暴露模块:\n\n//定义没有依赖的模块\ndefine(function(){\n   return 模块\n})\n//定义有依赖的模块\ndefine(['module1', 'module2'], function(m1, m2){\n   return 模块\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n引入使用模块:\n\nrequire(['module1', 'module2'], function(m1, m2){\n   使用m1/m2\n})\n\n\n1\n2\n3\n\n * 采用异步加载的方式来加载模块，模块的加载不影响后面语句执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调；也可以根据需要动态加载模块\n * amd模块定义的方法清晰，不会污染全局环境，可清楚地显示依赖关系\n\n\n# cmd\n\ncommon module definition（通用模块定义）\n\ncmd规范用于浏览器端，异步加载，使用模块时才会加载执行\n\n整合了commonjs和amd规范的特点\n\nsea.js中，所有js模块都遵循cmd模块定义规范\n\n> 基本语法\n\n定义暴露模块：\n\n//定义没有依赖的模块\ndefine(function(require, exports, module){\n  exports.xxx = value\n  module.exports = value\n})\n//定义有依赖的模块\ndefine(function(require, exports, module){\n  //引入依赖模块(同步)\n  var module2 = require('./module2')\n  //引入依赖模块(异步)\n    require.async('./module3', function (m3) {\n    })\n  //暴露模块\n  exports.xxx = value\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n引入使用模块：\n\ndefine(function (require) {\n  var m1 = require('./module1')\n  var m4 = require('./module4')\n  m1.show()\n  m4.show()\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# es6\n\nimport 和 export 的形式导入导出模块。这种方案和上面三种方案都不同\n\n尽量静态化，保证在编译时就能确定模块的依赖关系和输入输出的变量\n\n异步导入，用于浏览器，需要下载文件，同步导入对渲染有很大影响\n\n实时绑定，导入导出的值都指向同一个内存地址，导入值跟随导出值变化\n\n编译成 require/exports 来执行\n\n * 使用export命令定义了模块的对外接口以后，其他 js 文件可以通过import命令加载这个模块\n\n一个模块是一个独立的文件，该文件内部的所有变量，外部无法获取。如果希望外部读取模块内部的某个变量，必须使用export关键字输出该变量\n\n编译阶段，import会提升到整个模块的头部，首先执行\n\n如果不需要知道变量名或函数就完成加载，用export default命令，为模块指定默认输出\n\nexport default指定模块的默认输出。一个模块只能有一个默认输出，export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令\n\n\n# 基本语法\n\nexport\n\n1.如果不想对外暴露内部变量真实名称，可使用as关键字设置别名，同一个属性可设置多个别名\n\n外部引入时，可通过name2这个变量访问king值\n\nconst name='king';\nexport {name as name2};\n\n\n1\n2\n\n\n2.同一文件中，同一变量名只能export一次，否则抛出异常\n\nconst name='king';\nconst _name='king';\nexport {name as _name};\nexport {_name};//抛出异常，_name作为对外输出的变量，只能export一次\n\n\n1\n2\n3\n4\n\n\nimport\n\nimport {标识符列表} from '模块'\n{}不是对象，里面知识存放导入的标识符\n\n\n1\n2\n\n\n1.import和export的变量名相同\n\n2.相同变量名的值只能import一次\n\n3.import命令具有提升的效果\n\n//export.js\nexport const name='king';\n\n//import.js\nconsole.log(name);//king\nimport {name} from './export.js'\n\n\n1\n2\n3\n4\n5\n6\n\n\n本质：import在编译期间运行，执行console语句之前就已经执行了import语句。因此能够打印出 name的值，即，king\n\n4.多次import时，只会加载一次\n\n以下代码，我们import了两次export.js文件，最终只输出一次“start”，可推断出import导入的模块是单例模式\n\n//export.js\nconsole.log('start');\nexport const name='king';\nexport const age=19;\n\n//import.js\nimport {name} from './export.js\nimport {age} from './export.js''\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n5.允许在需要的时候动态加载模块，而不是一开始就加载所有模块，提高性能\n\n这个新功能允许我们将import()作为函数调用，将其作为参数传递给模块的路径。 它返回 promise，用一个模块对象实现，可以访问该对象的导出\n\nimport('/modules/mymodule.mjs')\n  .then((module) => {\n    // do something with the module.\n  });\n\n\n1\n2\n3\n4\n\n\n\n# 循环引入\n\n> 模块地图和模块记录\n\n模块记录类似模块的身份证，记录关键信息——模块导出值的内存地址，加载状态，其他模块导入时，做一个\"连接\"——根据模块记录，把导入的变量指向同一块内存，实现动态绑定\n\n模块地图，标记进入过的模块为\"获取中\"，所以循环引用时不会再次进入，地图中每个节点是一个模块记录，上面有导出变量的内存地址\n\n// index.mjs\nimport * as a from './a.mjs'\nconsole.log('入口模块引用a模块：',a)\n\n// a.mjs\nlet a = \"原始值-a模块内变量\"\nexport { a }\nimport * as b from \"./b.mjs\"\nconsole.log(\"a模块引用b模块：\", b)\na = \"修改值-a模块内变量\"\n\n// b.mjs\nlet b = \"原始值-b模块内变量\"\nexport { b }\nimport * as a from \"./a.mjs\"\nconsole.log(\"b模块引用a模块：\", a)\nb = \"修改值-b模块内变量\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n\n# 对比总结\n\ncommonjs输出值的浅拷贝（加载一个对象，及module.exports属性，该对象只有在脚本运行时生成），同步的，运行时加载\n\nes6 编译时加载，且是异步的，输出值的引用\n\n\n\n 1. commonjs规范用于服务端编程，同步加载，不适合浏览器，同步意味阻塞，而浏览器资源异步加载，因此诞生amd 和 cmd\n 2. amd规范在浏览器环境中异步加载，可以并行加载。开发成本高，代码阅读困难，模块定义语义不顺畅\n 3. cmd和amd相似，依赖就近，延迟执行，易在nodejs运行。但是，依赖spm打包，模块加载逻辑偏重\n 4. es6实现模块功能且实现简单，完全可以取代commonjs和amd规范，成为浏览器和服务器通用模块解决方案的宠儿\n\n\n * # 为什么模块循环依赖不会死循环？commonjs和es module的处理不同？\n\n 1. commonjs和es module都对循环引入做了处理，不会进入死循环，但方式不同：\n\n 2. * commonjs借助模块缓存，遇到require函数会先检查是否有缓存，已经有的则不会进入执行，在模块缓存中还记录着导出的变量的拷贝值\n    * es module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——指向同一块内存\n\n 3. commonjs的export和module.export指向同一块内存，由于最后导出的是module.export，不能直接给export赋值，会导致指向丢失\n\n 4. 查找模块时，核心模块和文件模块的查找都比较简单，对于react/vue这种第三方模块，会从当前目录下的node_module文件下开始，递归往上找，找到该包后，根据package.json的main字段找到入口文件\n\n\n# 💛 dom\n\n\n# 操作\n\n（1）创建新节点\n\nconst fragment = document.createdocumentfragment();\nconst divel = document.createelement(\"div\");\nconst textel = document.createtextnode(\"content\");\n\n\n1\n2\n3\n\n\n（2）添加、移除、替换、插入\n\nappendchild(node)\nremovechild(node)\nreplacechild(new,old)\ninsertbefore(new,old)\n\n\n1\n2\n3\n4\n\n\n（3）查找\n\ndocument.getelementbyid('id属性值');返回拥有指定id的对象的引用\ndocument.getelementsbyclassname('class属性值');返回拥有指定class的对象集合\ndocument.getelementsbytagname('标签名');返回拥有指定标签名的对象集合\ndocument.getelementsbyname('name属性值'); 返回拥有指定名称的对象结合\ndocument/element.queryselector('css选择器');  仅返回第一个匹配的元素\ndocument/element.queryselectorall('css选择器');   返回所有匹配的元素\ndocument.documentelement;  获取页面中的html标签\ndocument.body; 获取页面中的body标签\ndocument.all[''];  获取页面中的所有元素节点的对象集合型\ndocument.queryselector('.element')\ndocument.queryselector('#element')\ndocument.queryselector('div')\ndocument.queryselector('[name=\"username\"]')\ndocument.queryselector('div + p > span')\nconst notlive = document.queryselectorall(\"p\");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nhtmlcollection 是动态集合， dom 树变化时， htmlcollection 随之改变。 nodelist 是静态集合， nodelist 不受 dom 树变化影响\n\n（4）属性操作\n\ngetattribute(key);\nsetattribute(key,value);\nhasattribute(key);\nremoveattribute(key);\nconst dataattribute = document.createattribute('custom');\nconsle.log(dataattribute);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# dom事件\n\nonerror()\n\nonconfirm()应该是在表单提交前触发，确认\n\n\n# location\n\n包含有关当前url的信息\n\n是window的一部分，通过window.location访问\n\n属性\n\n属性         描述\nhash       从井号 (#) 开始的 url（锚）\nhost       主机名和当前 url 的端口号\nhostname   当前 url 的主机名\nhref       完整的 url\npathname   当前 url 的路径部分\nport       当前 url 的端口号\nprotocol   当前 url 的协议\nsearch     从问号 (?) 开始的 url（查询部分）\norigin     url 来源的 unicode 序列化，包括协议\n\n方法\n\n属性          描述\nassign()    加载新的文档\nreload()    重新加载当前文档\nreplace()   用新的文档替换当前文档\n\n> document、window\n\nwindow代表浏览器窗口，是js在浏览器中的全局对象\n\ndocument代表文档对象，window的一个属性\n\n> element、node\n\nnode是基类，element、text都继承于它\n\nelement、text分别叫做element_node，text_node\n\nhtml上的元素，即element，是类型为element_node的node\n\nnode表示dom树的结构，html中节间可以插入文本，这个插入的空隙就是text_node\n\n可使用childnodes得到nodelist，如何获取elementlist？\n\ngetelementbyxxx返回elementlist，它的真名是 elementcollection\n\n就像nodelist是node的集合一样，elementcollection也是element的集合\n\n他们都不是真正的数组\n\n\n# htmlcollection、nodelist\n\n\n# htmlcollection\n\n类数组对象， 包含元素（元素顺序为文档流中的接口）的通用集合，提供从该集合中选择元素的属性和方法\n\nlive——即时更新\n\n因此，最好创建副本后再迭代 以 add 、delete 或是 move节点\n\ngetelementbytagname()返回htmlcollection对象\n\nhtmlcollection有nameditem方法，其他和nodelist保持一致\n\nhtmlcollection只包含元素节点（elementnode）\n\n属性和方法\n\n * item(index) —— 返回 htmlcollection 指定索引元素，不存在则返回 null\n * length —— 返回 htmlcollection 元素的数量\n\n\n# nodelist\n\n节点的集合\n\n不是数组，是类数组对象\n\n可以使用foreach迭代，使用array.from()转换为数组\n\n一些情况下，nodelist动态变化，如果文档节点树变化，nodelist会随之而变，node.childnodes是实时的\n\n其他情况，nodelist是静态集合，document.queryselectorall返回静态nodelist\n\n可使用for循环 或 for-of 遍历，不要使用 for-in 遍历nodelist，因为nodelist对象的length和item属性会被遍历出来，可能导致错误，且for-in无法保证属性顺序\n\nnodelist可包含任何节点类型\n\n通过以下方法，可 获取 nodelist\n\n①**一些旧版本浏览器 getelementsclassname() 返回 nodelist ，而不是 htmlcollection **\n\n②**所有浏览器的node.childnodes 返回 nodelist **\n\n③大部分浏览器 document.queryselectorall() 返回nodelist\n\nnodelist 属性和方法\n\n * item() —— 返回元素索引\n * length() —— 返回 nodelist 节点数量\n * nodelist.foreach() —— 遍历 nodelist 所有成员。接收回调函数作为参数，遍历一回就要执行这个回调，与数组 foreach 完全一致\n * nodelist.keys()/values()/entries() —— 都返回 es6 遍历器对象，通过 for…of… 循环遍历，获取每一个成员\n\n\n# 总结\n\n         htmlcollection                                                 nodelist\n集合       元素集合                                                           节点集合\n静态和动态    动态集合。dom 树变化，随之变化，其节点的增删敏感                                     静态集合，不受 dom 树元素变化影响；相当于是 dom 树、节点数量和类型的快照，对节点增删时，nodelist\n                                                                        感觉不到。但是对节点内部内容修改，可以感觉到，修改 innerhtml\n节点       不包含属性节点和文本节点                                                   只有 nodelist 对象有包含属性节点和文本节点\n元素获取方式   元素可以通过 name，id / index 索引获取                                    只能通过 index 索引获取\n伪数组      htmlcollection 和 nodelist 都是类数组。所以使用数组方法，pop()，push()/join()   与 htmlcollection 一样\n\n\n# 获取dom大小\n\ngetboundingclientrect()\n\n获取 元素 大小及 相对于视窗的位置，返回 包含left, top, right, bottom, x, y, width, 和 height 参数对象，除 width 和 height 以外 属性 相对于视图窗口的左上角 计算\n\n\n# 💛 ajax、fetch、axios\n\n\n# ajax\n\najax（asynchronous javascript and xml，异步js与xml技术），实现网页异步更新，不重新加载网页对网页部分进行更新\n\n不是一种新技术，而是2005年被提出的新术语\n\nxmlhttprequest的api实现\n\n\n * # axios洋葱模型\n\n\n * # 请求步骤\n\n//创建 xmlhttprequest 对象\nconst ajax = new xmlhttprequest();\n//规定请求类型、url 以及是否异步处理请求,open() 方法与服务端建立连接\najax.open('get',url,true);\n//为对象添加一些信息和监听函数\najax.setrequestheader(\"content-type\", \"application/x-www-form-urlencoded\"); \n//发送请求\najax.send(null);  \n//监听服务端的通信状态\najax.onreadystatechange = function () {\n    if (ajax.readystate == 4 && (ajax.status == 200 || ajax.status == 304)) { \n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nxmlhttprequest对象有5个状态，状态变化触发onreadystatechange事件，可设置监听函数处理请求结果\n\n当对象的 readystate 变为 4时，代表服务器返回的数据接收完毕， 可对 请求状态进行判断\n\n\n * # promise封装ajax请求\n\nfunction getjson(url){\n    let promise=new promise((resolve,reject)=>{\n        let xhr=new xmlhttprequest();\n        xhr.open('get',url,true);\n        xhr.onreadystatechange=()=>{\n            if(this.readystate!==4) return;\n            if(this.status===200){\n                resolve(this.response);\n            }else{\n                reject(new error(this.statustext));\n            }\n        };\n        xhr.onerror=()=>{\n            reject(new error(this.statustext));\n        };\n        xhr.responsetype='json';\n        xhr.setrequestheader('accept','application/json');\n        xhr.send(null);\n    });\n    return promise;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n特点：\n\n * 局部刷新页面\n * 基于原生xhr开发，而xhr本身架构不清晰\n * 对基于异步的事件不友好\n\n\n# ajax底层实现？\n\n\n# fetch\n\n获取资源的接口，**替换笨重繁琐xmlhttprequest。**有request 、response 、headers 概念，与后端语言请求资源更接近\n\n> 会创建微任务，因为返回 promise\n\n * 使用 promise，支持async/await\n * 模块化设计，response request 和 header对象\n * 不携带cookie，需要手动配置\n\nfetch是底层api，真实存在\n\n\n# fetch能监听网络请求超时吗\n\nxmlhttprequest可设置请求超时时间，fetch不能监听网络请求超时\n\n\n# axios\n\naxios ——基于 promise 的http网络请求库，用于浏览器和nodejs\n\n体积小，提供简单易用的库，接口易于扩展\n\n本质是对原生xmlhttprequest的封装，只不过它是promise的实现版本\n\n特点：\n\n * 从浏览器中创建 xmlhttprequests\n * 支持浏览器和nodejs环境\n * 支持 promise api\n * 转换请求数据和响应数据\n * 取消请求\n * 客户端支持防御 xsrf\n\naxios({        \n  url:'xxx',    // 设置请求的地址\n  method:\"get\", // 设置请求方法\n  params:{      // get请求使用params进行参数凭借,如果是post请求用data\n    type: '',\n    page: 1\n  }\n}).then(res => {  \n  // res为后端返回的数据\n  console.log(res);   \n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n * # 设置接口请求前缀\n\n利用node环境变量判断，区分开发、测试、生产环境\n\nif (process.env.node_env === 'development') {\n  axios.defaults.baseurl = 'http://dev.xxx.com'\n} else if (process.env.node_env === 'production') {\n  axios.defaults.baseurl = 'http://prod.xxx.com'\n}\n\n\n1\n2\n3\n4\n5\n\n\n本地调试时，在config.js中配置proxy实现代理转发\n\n\n * # 设置请求头和超时时间\n\nconst service = axios.create({\n    ...\n    timeout: 30000,  // 请求 30s 超时\n      headers: {\n        get: {\n          'content-type': 'application/x-www-form-urlencoded;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        },\n        post: {\n          'content-type': 'application/json;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        }\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n * # 封装请求方法\n\n// get 请求\nexport function httpget({\n  url,\n  params = {}\n}) {\n  return new promise((resolve, reject) => {\n    axios.get(url, {\n      params\n    }).then((res) => {\n      resolve(res.data)\n    }).catch(err => {\n      reject(err)\n    })\n  })\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n> 请求拦截器\n\n在每个请求里加上token，统一处理维护方便\n\n> 响应拦截器\n\n在接收到响应后先做一层判断，比如状态码判断登录状态、授权\n\n\n# axios和fetch\n\n就个人体验， axios优于fetch\n\nfetch的优势仅在于浏览器原生支持\n\n不像axios需引入包，需要即时测试接口直接在chrome浏览器中使用fetch请求，尤其是编写爬虫/脚本\n\naxios是对xmlhttprequest的封装，fetch是新的获取资源的接口方式，不是对xmlhttprequest的封装\n\n最大的不同点在于fetch浏览器原生支持，axios需要引入axios库\n\naxios兼容ie，fetch在ie和一些老版浏览器没有支持，但有库可让老版浏览器支持fetch，很多网站为了减少成本而选择不再兼容ie浏览器\n\n在旧的浏览器上可能还需要使用promise兼容库\n\naxios可设置 超时，直接设置timeout属性，fetch不行\n\naxios 自动对数据转化，fetch 需要 手动转化\n\naxios 提供拦截器，统一对请求或响应处理，可为请求附加token、增加时间戳防止请求缓存、拦截响应，状态码不符合预期直接将响应消息通过弹框的形式展示在界面，密码错误、服务器内部错误、表单验证不通过\n\nfetch没有拦截器功能，重写全局fetch方法就可办到\n\n\n# cdn\n\ncontent delivery network，内容分发网络\n\n我们访问一个页面的时候，会请求很多资源，包括各种图片、声音、影片、文字等信息。这和我们要购买多种货物一样\n\n网站可以预先把内容分发至全国各地的加速节点。用户可以就近获取内容，避免网络拥堵、地域、运营商等因素带来的访问延迟问题\n\n\"内容分发网络\"像前面提到的\"全国仓配网络\"，解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景\n\n用户可就近取得所需内容，解决 internet网络拥挤的状况\n\n> cdn本质 是一大堆遍布在全球各个 角落 的缓存服务器。通过与dns的配合，找到最靠近用户的一台cdn缓存服务器，将数据快速 分发 给用户\n> \n> 减少对整体骨干网的流量负担，提高用户体验\n\ndns解析之后，浏览器向服务器请求内容后发生\n\n\n\n长途骨干网的传输最耗时，需经过网站服务器所在的机房、骨干网、用户所在城局域网、用户所在接入网等，物理传输距离遥远\n\n1亿人同时请求12306上一张一模一样的图片，对国家的互联网基础设施是一个灾难\n\ncdn 提前把数据存在离用户最近的数据节点，避免长途跋涉经过长途骨干网，最终 减少骨干网负担、提高访问速度\n\n\n\n请求图片数据，先去cdn缓存服务器获取，若获取到数据直接返回，否则才 经过 长途骨干网，最终达到 网站服务器 获取数据\n\ncdn其实还缩短了请求数据的距离\n\n用户分布全国各地，一般会在 离用户在 较近的地方设置 cdn 缓存服务器，酱紫各个 地区的用户能直接请求对应的cdn服务器，不需要来回跑 大半个 中国！\n\n\n# 过程\n\n 1.  发起请求，本地 dns 解析，将域名解析权交给域名 cname 指向的 cdn 专用 dns 服务器\n 2.  cdn 的 dns 服务器将 cdn 的全局负载均衡设备 ip 地址返回浏览器\n 3.  浏览器向 cdn 全局负载均衡设备发起 url 请求\n 4.  cdn 全局负载均衡设备根据用户 ip ，以及url，选择一台用户所属区域的区域负载均衡设备，向其发请求\n 5.  区域负载均衡设备为用户选最合适的 cdn 缓存服务器（考虑的依据包括：服务器负载情况，距离用户的距离等），返回给全局负载均衡设备\n 6.  全局负载均衡设备将选中的 cdn 缓存服务器 ip 返回给用户\n 7.  根据用户ip，判断最近边缘节点\n 8.  根据用户请求url中内容，判断有用户所需内容的边缘节点\n 9.  查询边缘节点负载情况，判断有服务能力的边缘节点\n 10. 全局负载均衡设备将服务器ip返回给用户\n 11. 用户向 cdn 缓存服务器发起请求，缓存服务器响应用户请求，最终将内容返回\n\n\n# 组成\n\n（cdn）由多个节点组成。一般，cdn网络主要由中心节点、边缘节点两部分构成\n\n> 中心节点\n\n中心节点包括cdn网管中心和全局负载均衡dns重定向解析系统，负责整个cdn网络的分发及管理\n\n> 边缘节点\n\ncdn边缘节点主要指异地分发节点，有负载均衡设备、高速缓存服务器两部分\n\n负载均衡设备负责每个节点中各个cache的负载均衡，保证节点 工作效率；同时负责收集节点与周围环境的信息，保持与全局负载均衡dns的通信，实现整个系统的负载均衡\n\n高速缓存服务器（cache）负责存储客户网站信息，像一个靠近用户的网站服务器一样响应本地用户的请求\n\n通过全局负载均衡dns的控制，用户的请求被透明 指向离他最近的节点，节点中cache服务器像网站的原始服务器一样，响应终端用户的请求\n\n中心节点像仓配网络中负责货物调配的总仓，边缘节点就是负责存储货物的各个城市的本地仓库\n\n\n# 前端路由\n\n\n# location.replace/ href\n\nhref会写入 浏览器 window.history 对象中\n\nreplace不会，replace将当前url替换，而非跳转，不会保存记录\n\nlocation.href=\"http://www.baidu.com\"\nlocation.replace(\"http://www.baidu.com\")\n\n\n1\n2\n\n\n\n# 前端路由\n\n * 路由是根据不同的 url 地址展示不同的内容或页面\n * 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。\n\n前端路由实现原理很简略，实质上就是检测 url 的变动，截获 url 地址，通过解析、匹配路由规定实现 ui 更新\n\n\n# spa路由跳转实现\n\n不是真正的页面跳转，另一个角度来说，其实就是组件的挂载和卸载罢了。通过监听知道某一个组件的状态并对其进行渲染\n\n单页面应用中的路由分为两种: hash模式和history模式\n\n\n# hash模式\n\n监听浏览器地址hash值变化，执行事件\n\nhash会在浏览器url后增加 # 号\n\n一个完整的的 url 包含：协定、域名、端口、虚拟目录、文件名、参数、锚\n\n比如 https://www.google.com/#abc中的hash值为abc 特点：hash的变化不会刷新页面，也不会发送给服务器\n\n但hash的变化会被浏览器记录下来，用来指导浏览器中的前进和后退\n\n使用window.location.hash变化触发窗口的onhashchange事件，监听hash变化\n\n触发路由时视图容器更新——多数前端框架哈希路由的实现原理\n\n# 触发hashchange\n\n * url变化(包括浏览器的前进、后退)修改window.location.hash的值\n * 浏览器发送http://www.baidu.com/ 至服务器，请求完毕后设置散列值为#/home，触发onhashchange\n * 只修改hash部分，不发请求，但触发onhashchange\n * a标签可设置页面hash，浏览器自动设置hash属性，触发onhashchange\n\nwindow.location.hash='abc';\nlet {hash}=window.location\nwindow.addeventlistener('hashchange',function(){\n    //监听hash变化\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 特点\n\n * 不需要后端配合\n\n * 兼容性好\n\n * 路径在#后面，不好看\n\n\n# history模式\n\nh5新特性，允许我直接修改前端路由，更新url但不重新发请求，history可自定义地址\n\nwindow.history属性指向 history 对象，它表示当前窗口的浏览历史，保存了当前窗口访问过的所有页面网址\n\n由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航\n\n// 后退到前一个网址\nhistory.back()\n\n// 等同于\nhistory.go(-1)\n\n\n1\n2\n3\n4\n5\n\n\n浏览器工具栏的“前进”和“后退”按钮，其实就是对 history 对象进行操作\n\nhistory 对象主要有两个属性。\n\n * history.length：当前窗口访问过的网址数量（包括当前网页）\n * history.state：history 堆栈最上层的状态值（详见下文）\n\n// 当前窗口访问过多少个网页\nwindow.history.length // 1\n\n// history 对象的当前状态\n// 通常是 undefined，即未设置\nwindow.history.state // undefined\n\n\n1\n2\n3\n4\n5\n6\n\n\n# history.back()、history.forward()、history.go()\n\n用于在历史之中移动\n\n * history.back()：移动到上一个网址，等于点击浏览器后退键。对于第一个访问的网址，该方法无效\n * history.forward()：移动到下一个网址，等于点击浏览器前进键。对于最后一个访问的网址，该方法无效果\n * history.go()：跳转到指定记录页，go(1)相当于forward()，go(-1)相当于back()。如果参数超过实际存在的网址范围，该方法无效；如果不指定参数，默认0，相当于刷新当前页面\n\n# history.pushstate()\n\n在历史中添加一条记录，不会导致页面刷新\n\nwindow.history.pushstate(state, title, url)\n\n\n1\n\n\n * state：对象，触发popstate事件将该对象传递到新页面。不需要可以填null\n\n * title：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串\n\n * url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址\n\n假定当前网址是example.com/1.html，使用pushstate()方法在浏览记录（history 对象）中添加一个新记录\n\nvar stateobj = { foo: 'bar' };\nhistory.pushstate(stateobj, 'page 2', '2.html');\n\n\n1\n2\n\n\n添加新记录后，浏览器地址栏立刻显示example.com/2.html，但并不会跳转到2.html，甚至也不会检查2.html是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问google.com)，然后点击了倒退按钮，页面的 url 将显示2.html；再点击一次倒退按钮，url 将显示1.html\n\npushstate()不会触发页面刷新，只是导致 history 对象发生变化，地址栏会有反应\n\n使用该方法之后，可以用history.state读出状态对象\n\nvar stateobj = { foo: 'bar' };\nhistory.pushstate(stateobj, 'page 2', '2.html');\nhistory.state // {foo: \"bar\"}\n\n\n1\n2\n3\n\n\n如果pushstate的 url 参数设置了一个新的锚点值（即hash），不会触发hashchange事件。反过来，如果 url 的锚点值变了，会在 history 对象创建一条浏览记录\n\n如果pushstate()方法设置了一个跨域网址，报错\n\n// 报错\n// 当前网址为 http://example.com\nhistory.pushstate(null, '', 'https://twitter.com/hello');\n\n\n1\n2\n3\n\n\npushstate想要插入一个跨域的网址，导致报错。防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转\n\n# history.replacestate()\n\n修改 history 当前记录，其他与pushstate()一模一样\n\n假定当前网页是example.com/example.html\n\nhistory.pushstate({page: 1}, 'title 1', '?page=1')\n// url 显示为 http://example.com/example.html?page=1\n\nhistory.pushstate({page: 2}, 'title 2', '?page=2');\n// url 显示为 http://example.com/example.html?page=2\n\nhistory.replacestate({page: 3}, 'title 3', '?page=3');\n// url 显示为 http://example.com/example.html?page=3\n\nhistory.back()\n// url 显示为 http://example.com/example.html?page=1\n\nhistory.back()\n// url 显示为 http://example.com/example.html\n\nhistory.go(2)\n// url 显示为 http://example.com/example.html?page=3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# popstate事件\n\n当同一个文档的浏览历史变化触发popstate\n\n注意\n\n * 调用pushstate()/replacestate() ，不会触发该事件\n\n * 只有点击浏览器倒退/前进，或调用history.back()、history.forward()、history.go()才会触发\n\n * 只针对同一个文档，如果浏览历史切换，导致加载不同文档，不会触发\n\npopstate指定回调函数\n\nwindow.onpopstate = function (event) {\n  console.log('location: ' + document.location);\n  console.log('state: ' + json.stringify(event.state));\n};\n\n// 或者\nwindow.addeventlistener('popstate', function(event) {\n  console.log('location: ' + document.location);\n  console.log('state: ' + json.stringify(event.state));\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n回调函数参数event事件对象，state指向当前状态对象，这个state也可以通过history对象读取\n\nvar currentstate = history.state;\n\n\n1\n\n\n页面第一次加载不会触发popstate事件\n\n# 特点\n\n路径正规\n\n兼容性不比hash，需服务端支持\n\n对于一个应用而言，url 的改变(不包括 hash 值得改变)只能由下面三种情况引起：\n\n * 点击浏览器的前进或后退按钮 => 可以监听popstate事件\n * 点击 a 标签\n * 在 js 代码中触发 history.pushstate()、history.replacestate()\n\nhistory router的实现思路是：监听页面中和路由有关的a标签点击事件，阻止默认的跳转行为，然后调用history.pushstate()方法，让浏览器记住路由，手动更新相应视图。为了监听用户手点击浏览器的前进后退按钮，还需要监听popstate事件，动态的修改相应视图\n\n\n# ✅ 页面生命周期\n\n\n\n包含三个重要事件：\n\n * domcontentloaded —— 已完全加载 html，并构建了 dom 树，像 <img> 和样式表之类的外部资源可能尚未加载完成\n * load —— 浏览器不仅加载完成了 html，还加载完了所有外部资源：图片，样式等\n * beforeunload/unload —— 用户正在离开页面时\n\n每个事件都有用：\n\n * domcontentloaded 事件 —— dom 已经就绪，因此处理程序可以查找 dom 节点，并初始化接口\n * load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知\n * beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开\n * unload 事件 —— 用户几乎已经离开，但是我们仍然可以启动一些操作，例如发送统计数据\n\n\n# domcontentloaded\n\n遇到script标签，会在dom构建之前运行它，因为脚本可能修改dom，所以domcontentloaded必须等待脚本执行结束\n\n外部样式表不影响dom，因为domcontenloaded不会等待他们\n\n但是，如果在样式后面有一个脚本，该脚本必须等待样式表加载完成：\n\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n<script>\n  // 在样式表加载完成之前，脚本都不会执行\n  alert(getcomputedstyle(document.body).margintop);\n<\/script>\n\n\n1\n2\n3\n4\n5\n\n\n原因是，脚本可能想要获取元素的坐标或其他与样式相关的属性，如上例所示。必须等待样式加载完成\n\n当 domcontentloaded 等待脚本时，它也在等待脚本前面的样式\n\n\n# 不会阻塞 domcontentloaded 的脚本\n\n 1. 具有 async 特性的脚本不会阻塞 domcontentloaded\n 2. 使用 document.createelement('script') 动态生成并添加到网页的脚本也不会阻塞 domcontentloaded\n\n\n# onload\n\n当整个页面，包括样式、图片和其他资源被加载完成时，触发 window 对象上的 load 事件\n\n\n# onunload\n\n当访问者离开页面时，window 对象上的 unload 事件就会被触发。我们可以做一些不涉及延迟的操作，例如关闭相关的弹出窗口\n\n> 和onpagehide事件相互替换的是\n> \n> onunload\n> \n> 用户离开网页执行onpagehide，但onunload无法缓存页面\n\n\n# onbeforeunload\n\n如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，beforeunload 处理程序将进行更多确认\n\n如果我们要取消事件，浏览器会询问用户是否确定\n\n\n# readystate\n\n如果我们在文档加载完成之后设置 domcontentloaded 事件处理程序，会发生什么？\n\n> 它永远不会运行\n\n在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 dom 加载完成时执行，无论现在还是以后\n\ndocument.readystate 属性可以为我们提供当前加载状态的信息\n\n它有 3 个可能值：\n\n * loading —— 文档正在被加载\n * interactive —— 文档被全部读取\n * complete —— 文档被全部读取，所有资源（例如图片等）都已加载完成\n\n所以，我们可以检查 document.readystate 并设置一个处理程序，或在代码准备就绪时立即执行它\n\n\n# 🌰css、js位置问题\n\n渲染引擎判断脚本时，html解析器暂停dom解析，js引擎介入，因为js脚本可能修改当前已生成dom\n\n如果js脚本通过文件加载，需先下载js代码，js文件下载会阻塞dom解析，下载耗时，受到 网络、文件大小 因素影响\n\n如果脚本内嵌，则 直接执行，阻塞dom构建\n\n如果js脚本修改 dom内容，执行脚本后，div被修改，html解析器恢复解析过程\n\n如果js代码出现修改css的语句，操纵 cssdom，执行js前，先解析js语句之上所有css样式，如果引用外部css文件，执行js前，需等待外部css文件下载完成，解析生成cssom后，才执行 js 脚本\n\n解析js前，不知道js是否操纵cssom，所以渲染引擎遇到js脚本时，不管该脚本是否操纵了cssom，都会执行css文件下载，解析，再执行js脚本，构建dom，生成布局树\n\n所以js脚本依赖样式表\n\n> js文件下载会阻塞dom解析\n> \n> 样式文件会阻塞js执行\n\n> js阻塞了啥\n\njs文件放在head中，构建dom树遇到js文件加载会阻塞，直到js加载执行完页面都是空白！\n\nscript标签最好放在body，浏览器为了用户体验 渲染引擎尝试尽快显示，不会等到所有dom解析完成 才布局渲染树，js阻塞发生时，将已经构建的dom元素渲染，减少白屏——这就是为啥将script标签放body标签底部的原因，不影响前面页面渲染\n\n有了async和defer，script标签位置不再那么重要\n\n> css阻塞了啥\n\n解析html遇到link/style标签 会计算样式，构建cssom\n\ncss不会阻塞dom树构建，但会阻塞页面显示，因为 构建cssom过程中，不渲染任何内容，即便dom解析完毕，只要cssom没构建好，不显示\n\n如果link标签前有dom元素，加载css阻塞时，浏览器会将前面已经构建好的dom元素渲染到屏幕上，减少白屏时间\n\n但是，会出现 页面闪烁！**因此将css标签放在head中，如果放在body标签前面，因为css不阻塞dom构建，**dom树构建完成 render树渲染，渲染树构建完成，浏览器不得不re-render，造成资源浪费，在head中，边构建边渲染，效率更高\n\n放在head尽早加载，减少请求阻塞时间\n\n> script放head和body\n\nhead中，代表的function只加载不执行\n\nbody中，加载并执行\n\n\n# 🍉 defer、async\n\ndomcontentloaded触发时间：html文档被加载解析完成\n\n\n\n\n\n\n# sync 同步\n\n\n\n\n# async 异步\n\n 1. html未被解析完，async脚本已经加载完，html停止解析去执行脚本\n\n\n\n 2. html解析完，async脚本才加载完，再执行脚本\n\n\n\n\n# defer 延迟\n\n不影响html解析，html解析完才执行，阻止 domcontentloaded，直到脚本被加载且解析完成\n\n 1. html未解析完，defer脚本加载完毕，defer等html解析完再执行\n\n\n\n 2. html解析完，defer脚本还没加载完毕，defer脚本继续加载，加载完直接执行\n\n\n\n\n# 总结\n\nscript标签属性\n\n脚本下载执行和文档解析同步，会阻塞文档解析，若控制不好，会造成页面卡顿\n\n可以在script声明defer和async （仅适用外部脚本）\n\ndefer：html解析完成后按照脚本出现次序 顺序执行，构建dom树和js文件的加载 并行 执行，js文件执行在dom树构建完成之后\n\nasync：h5新增，下载完成立即执行，阻塞页面解析，**谁先下载好谁执行 **\n\nasync脚本和domcontentloaded不会彼此等待\n\n\n\n推荐与主业务无关的js脚本使用async，例如 监控、广告 脚本，它们都是独立的文件，没有外部依赖，无需访问dom，使用async有效避免 非核心功能的加载影响页面解析速度\n\n\n# 💚 排序\n\n\n# 数组、链表\n\n数据的物理存储结构：连续存储（数组）离散存储（链表）\n\n区别：\n\n对数组，查找方便，连续存储，增删改效率低；事先申请好连续的内存空间小，太大浪费内存，太小越界\n\n对链表，动态申请内存空间，不需要提前申请好内存的大小，只需在用的时候申请就可以，根据需要动态申请或者删除内存空间，对数据增加和删除以及插入比数组灵活\n\n应用场景：\n\n数组：数据量固定，频繁查询，较少增删的场景\n\n链表：数据量不固定，频繁增删，较少查询的场景\n\n * 单向链表：线型数据结构，指针指向下一个节点，终点指向null\n * 双向链表：可以往前或者往后添加节点，指针指向前一个节点和后一个节点\n\n\n# 链表在js的应用\n\n原型链\n\nhooks state存储\n\nfiber架构的fiber数据结构本身是链表结构\n\n\n# 选择排序\n\n> 买苹果每次都选择最大的\n\n找到数组最小的元素，将其和数组第一个元素交换位置\n\n在剩下的元素中找到最小的元素，将其与数组第二个元素交换位置\n\n如此往复，直到整个数组排序\n\nfunction selectsort(arr) {\n    let len = arr.length;\n    let minindex;\n    for (let i = 0; i < len - 1; i++) {\n        minindex = i;\n        for (let j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minindex]) {\n                minindex = j;\n            }\n        }\n        [arr[i], arr[minindex]] = [arr[minindex], arr[i]];\n    }\n    return arr;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n 1. 无论什么数据进去都是 o(n²) 的时间复杂度\n 2. 空间复杂度o(1)\n 3. 非稳定排序\n 4. 原地排序\n\n\n# 冒泡\n\n第一个元素和第二个元素比较，如果第一个比第二个大，则交换\n\n继续比较第二个和第三个元素，若第二个比第三个大，则交换……\n\n对每一个相邻元素做同样工作，从第一对开始到最后一对结尾，一趟比较下来后，排在最后的元素是最大元素\n\nfunction bubblesort(arr) {\n    if (arr.length < 2) {\n        return arr;\n    }\n    const len = arr.length;\n    for (let i = 0; i < len - 1; i++) {\n        for (let j = 0; j < len - i - 1; j++) {\n            if (arr[j + 1] < arr[j]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n 1. 时间复杂度o(n²)\n 2. 空间复杂度o(1)\n 3. 稳定排序\n 4. 原地排序\n\n\n# 优化\n\n如果从第一队到最后一对，相邻元素间没有交换，意味着右边的元素总是≥左边元素，此时数组有序，无需再对剩下元素重复比较\n\nfunction bubblesortperformance(arr) {\n    if (arr.length < 2) {\n        return arr;\n    }\n    const len = arr.length;\n    for (let i = 0; i < len - 1; i++) {\n        let flag = true;\n        for (let j = 0; j < len - i - 1; j++) {\n            if (arr[j + 1] < arr[j]) {\n                flag = false;\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n        if (flag) {\n            break;\n        }\n    }\n    return arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n如何优化？\n\n优化后时间复杂度？\n\n与快排相比？\n\n快排思路？\n\n相比冒泡，快排每次交换是跳跃式。每次排序设置基准点，将≤基准点的数放到基准点左边，将大≥基准点的数放到基准点右边。这样每次交换不会像冒泡每次只在相邻数间交换，交换距离大的多。因此总比较和交换次数少，速度提高。最坏的情况仍可能是相邻两数交换\n\n\n# ❤️ 插入排序\n\n适合处理数据量少或部分有序的数据(移动少)\n\n 1. 从第二个元素开始抽取\n 2. 把它和左边第一个元素比较，若左边第一个元素比它大，则继续与左边第二个元素比较，直到遇到比它小的元素，然后插入到这个元素的右边\n 3. 继续选取第 3 4 ...n个元素，重复步骤2，选择适当位置插入\n\nfunction insertsort(arr) {\n    let preindex = 0;\n    let curval = 0;\n    for (let i = 1; i < arr.length; i++) {\n        preindex = i - 1;\n        curval = arr[i];\n        while (preindex >= 0 && arr[preindex] > curval) {\n            //腾出位置插入\n            arr[preindex + 1] = arr[preindex];\n            preindex--;\n        }\n        //插入元素\n        arr[preindex + 1] = curval;\n    }\n    return arr;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n 1. 时间复杂度o(n)，最坏时间复杂度为o(n²)\n 2. 空间复杂度o(1)\n 3. 稳定排序\n 4. 原地排序\n\n\n# ❤️ 希尔排序\n\nlet arr=[16,9,49,7,1,45,23,13]\ngap=4\n一趟排序后 数组为\n\n\n1\n2\n3\n\n\n对大规模且无序数据有效率\n\n对 数组 进行 多次 间隔的 插入排序\n\n加速简单改进了插入排序，交换不相邻元素对数组局部排序\n\n先让数组中任意间隔为h的元素有序，刚开始h可以为n/2，接着使h=n/4，h一直缩小，当h=1时，即，此时数组中任意间隔为1的元素有序\n\nfunction shellsort2(arr) {\n    const len = arr.length;\n    let gap = math.floor(len);\n    while (gap) {\n        for (let i = gap; i < len; i++) {\n            const tmp = arr[i];\n            let j;\n            for (j = i - gap; j >= 0 && tmp < arr[j]; j -= gap) {\n                arr[j + gap] = arr[j];\n            }\n            arr[j + gap] = tmp;\n        }\n        gap = math.floor(gap / 2);\n    }\n    return arr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n对各个分组插入时并不是先对一个组排序完成后再对另一个组排序，而是轮流对每个组排序\n\n 1. 时间复杂度o(nlogn)\n 2. 空间复杂度o(1)\n 3. 非稳定排序\n 4. 原地排序\n\n\n# 💙 归并(讲过)\n\n分治法\n\n大的数组一分为二，分别对2个数组排序，然后将其合并一个有序数组\n\n递归，分割数组，直到数组大小为1，然后\n\n把2个数组大小为1的合并为一个大小为2的，再把大小为2的合并为大小为4的，直到全部小数组都合并\n\nlet arr = [2, 11, 10, 6, 12, 3, 4, 8, 9, 5, 1, 15, 13, 7, 14];\n\nfunction mergesort(arr) {\n//    自上而下递归法\n    let len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n    let mid = math.floor(len / 2);\n    let left = arr.slice(0, mid);\n    let right = arr.slice(mid);\n    return merge(mergesort(left), mergesort(right));\n}\n\nfunction merge(left, right) {\n    let res = [];\n    while (left.length && right.length) {\n        if (left[0] <= right[0]) {\n            res.push(left.shift());\n        } else {\n            res.push(right.shift());\n        }\n    }\n    while (left.length) {\n        res.push(left.shift());\n    }\n    while (right.length) {\n        res.push(right.shift());\n    }\n    return res;\n}\n\nconsole.log(mergesort(arr));\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n 1. 时间复杂度o(nlogn)，切logn次，合并一个大的有序数组为o(n)\n 2. 空间复杂度o(n)\n 3. 稳定排序\n 4. 非原地排序\n\n\n# 💙 快排\n\n分治法\n\n选取一个元素作为中轴元素，把所有小于中轴的元素放在左边，所有≥中轴的元素放在右边，此时，中轴所处位置有序\n\n从中轴开始将大树组切割为2个小数组，递归让中轴左边数组和右边数组执行同样操作，直到数组大小为1\n\nfunction quicksort1(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    let pivotindex = math.floor(arr.length / 2);\n    //返回删除的元素\n    let tmp=arr.splice(pivotindex, 1);\n    let pivot = tmp[0];\n    let left = [];\n    let right = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return quicksort1(left).concat([pivot], quicksort1(right));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n 1. 时间复杂度o(nlogn)\n 2. 空间复杂度o(logn)\n 3. 非稳定排序\n 4. 原地排序\n\n不像归并，还需要辅助数组\n\n不像归并，需要把2部分有序子数组汇总到临时数组，还要copy回原数组\n\n\n# 堆排序\n\n堆顶元素是最值，将堆顶元素和最后一个元素交换，交换后破坏堆的特性，再把剩下元素再次构成一个大顶堆，把堆顶元素和最后第二个元素交换\n\n往复……\n\n\n\n\n\n\n\n删除包括3个步骤\n\n 1. 交换堆顶与堆最后一个元素\n 2. 堆大小-1\n 3. 调整堆\n\n\n\n\n1\n\n\n\n# 计数排序\n\n适用于最大值和最小值差值不大的排序\n\n数组元素作为数组下表，临时数组统计该元素出现次数，最后汇总\n\nfunction cntsort(arr) {\n    const maxval = math.max.apply(null, arr);\n    //元素出现的次数\n    const count = array(maxval + 1).fill(0);\n    arr.foreach(item => {\n        count[item]++;\n    })\n    let ans = [];\n    for (let i = 0; i < count.length; i++) {\n        while (count[i]--) {\n            ans.push(i);\n        }\n    }\n    return ans;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n 1. 时间复杂度o()\n 2. 空间复杂度o(ans.length)\n 3. 稳定排序\n 4. 非原地排序\n\n\n# 优化\n\n偏移量，min=1000，max=1005，临时数组大小为(max-min+1)即可\n\n\n# 桶排序\n\n计数排序不适用时，可以使用桶排序\n\n把最大值和最小值间的数瓜分，例如分成10个区间，对应10个桶，把元素放到对应区间的桶，在对每个桶中数进行排序，合并汇总\n\n\n\n\n# 基数排序\n\n先以个位数大小对数据排序，接着以十位数大小排序，接着是百位……\n\n以某位数排序时，用 桶 排序\n\n将相同数值元素放进同一个桶，再把桶里的数按照0-9的顺序取出来，一趟下来，按照某位数的排序就完成了\n\n\n\n\n1\n\n\n不建议以最高位排序，致命问题——对各部分 单独排序，每一部分类似于原问题的子问题，采用递归处理，每个小部分 排序中，需要10个桶将它们排序 ，导致空间花费大\n\n\n# 总结\n\n\n\n\n# others\n\n\n# utf-8、utf-16、unicode\n\nascii 可以表示的编码有限，想表示其他语言的编码，需要使用 unicode，unicode可以说是 ascii的超集\n\nunicode是字符集，为每种语言的每个字符设定 **统一且唯一 的二进制编码 **\n\nunicode的编码方式有很多，常见的是 utf-8、utf-16\n\nutf-8判断每个字节中的开头标志信息，如果某个字节在传送过程出错，会导致后面的字节解析出错；utf-16不会判断开头标志，即使错只会错一个字符，容错能力较强\n\n字符内容 英文占大多数，utf-8比utf-16更节省空间；如果中文占多数，utf-16占优势\n\n\n# js二进制\n\n谈谈js二进制：file、blob、filereader、arraybuffer、base64\n\njs提供api处理文件或原始文件数据\n\nfile、blob、filereader、arraybuffer、base64\n\n\n\nblob及binary large object，二进制大对象，表示原始类似文件的数据\n\nblob对象是包含只读原始数组的类文件对象，就是一个不可修改的二进制文件\n\n\n# base64\n\n把不可见字符转换为可见字符\n\n1、字符三三分组，不够0补齐\n\n> 为啥是三三分组？\n> \n> 因为ascii码每个字符时8位二进制，3*8=24，正好可以被第三步拆分为4个6位二进制\n\n2、把字符转换为二进制ascii编码，再转换为二进制\n\n3、二进制，六位分隔开\n\n4、6位二进制能代表0-63\n\n\n\n补位产生的0，使用=表示\n\nabcd->ywjjza==\n\n\n1\n\n\n> 图片base64、url\n\n前端传给后端的是base64编码的字符串，后端将解码的图片存起来\n\n后端返回图片数据流，前端解析？\n\n将图片转换blob，通过 blob 创建 url\n\n\n# 位运算\n\n运算符   描述   运算规则\n&     与    两个位都为1时，结果才为1\n|     或    两个位都为0时，结果才为0\n^     异或   两个位相同为0，相异为1\n~     取反   0变1，1变0\n<<    左移   各二进制位全部左移若干位，高位丢弃，低位补0\n>>    右移   各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃\n\n&\n\n判断奇偶，最末位是0就是偶数，为1就是奇数\n\nif ((i & 1) == 0)\n    //等价\nif (i % 2 == 0 )\n\n\n1\n2\n3\n\n\n> 原码 补码 反码\n\n符号位和数值位，符号位 0 表示 正，1 表示 负\n\n原码\n\n数的 二进制\n\n反码\n\n * 正数的反码和原码相等\n * 负数的反码为 除符号位，按位取反\n\n-10\n原码 1000 1010\n反码 1111 0101\n\n\n1\n2\n3\n\n\n补码\n\n * 正数的补码 与 原码 相同\n * 负数的补码 是原码 除符号位外的所有位 取反，再加1（即 反码+1）\n\n-10\n原码 1000 1010\n反码 1111 0101\n补码 1111 0110\n\n\n1\n2\n3\n4\n\n\n\n# 点击事件延迟\n\n移动端点击有 300ms 的延迟，因为移动端有双击缩放操作，浏览器在 click 之后要等待 300ms（js捕获click事件的回调处理），看用户有没有下一次点击，判断这次操作是不是双击\n\n有三种办法解决这个问题：\n\n * meta 标签禁用网页的缩放\n\n<meta name=\"viewport\" content=\"width=device-width user-scalable= 'no'\">\n\n\n1\n\n * 更改默认视口宽度\n\n<meta name=\"viewport\" content=\"width=device-width\">\n\n\n1\n\n\n如果能识别网站是响应式的网站，那么移动端浏览器就可以自动禁掉默认的双击缩放行为并去掉300ms的点击延迟\n\n * 调用 js 库，比如 fastclick\n\nclick 延时问题可能引起点击穿透，如在一个元素上注册了 touchstart 的监听事件，这个事件会将这个元素隐藏掉，发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件\n\n\n# 滚动穿透\n\n若页面超过一屏高度出现滚动条时，fixed定位的弹窗遮罩层上下滑动，下面的内容也会一起滑动——滚动穿透\n\n1、默认情况，平移（滚动）和缩放手势由浏览器专门处理，但可通过 css 特性 touch-action 改变触摸手势的行为\n\n2、\n\nstep 1、监听弹窗最外层元素（popup）的 touchmove 事件并阻止默认行为来禁用所有滚动（包括弹窗内部的滚动元素） step 2、释放弹窗内的滚动元素，允许其滚动：同样监听 touchmove 事件，但是阻止该滚动元素的冒泡行为（stoppropagation），使得在滚动的时候最外层元素（popup）无法接收到 touchmove 事件\n\n\n# 滚动溢出\n\n弹窗内也含有滚动元素，在滚动元素滚到底部或顶部时，再往下或往上滚动，也会触发页面的滚动，这种现象称之为滚动链（scroll chaining）， 也称为滚动溢出（overscroll）\n\n借用 event.preventdefault 的能力，当组件滚动到底部或顶部时，通过调用 event.preventdefault 阻止所有滚动，从而页面滚动也不会触发了，而在滚动之间则不做处理\n\n\n# with\n\n> 警告：混淆错误和兼容性的问题\n\n扩展一个语句的作用域链\n\n\n# if内的函数？\n\nlet phrase = \"hello\";\nif (true) {\n  let user = \"john\";\n  function sayhi() {\n    alert(`${phrase}, ${user}`);\n  }\n}\n\nsayhi();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * https://zh.javascript.info/closure这里说因为if内声明的函数，所以报错\n * 实际运行，能够正常输出值\n\n\n# polyfills\n\n补丁\n\n例如浏览器太老，不支持promise，我们可以自己定制实现现代语言功能\n\nif (!window.promise) {\n  window.promise = ... // 定制实现现代语言功能\n}\n\n\n1\n2\n3\n\n\n\n# use strict\n\necmascript5 添加的（严格）运行模式，使 js 在更严格的条件下运行\n\n * 消除 js 语法的一些不合理、不严谨之处，减少一些怪异行为\n * 消除代码运行的一些不安全之处，保证代码运行的安全\n * 提高编译器效率，增加运行速度\n * 为未来新版本的 js 做好铺垫\n\n区别：\n\n * 1.禁止使用 with 语句\n * 2.禁止 this 关键字指向全局对象\n * 3.对象不能有重名的属性\n\n只要函数参数使用了默认值、解构赋值、或者扩展运算符，函数内部就不能显式设定为严格模式，否则会报错\n\nvar num = 117\n\nfunction func1() {\n    console.log(this.num)\n}\n\n(function () {\n    \"use strict\";\n    func1()\n})()\n\"use strict\"\n\nfunction func2() {\n    console.log(this.num)\n}\n\nsettimeout(function () {\n    func2.call(this)\n}, 0)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 定时刷新\n\nsetinterval不行，5s一刷新，万一请求10s返回数据，不久轮询了，直接卡死\n\nsettimeout\n\nrequestanimationframe\n\n<meta http-equiv=\"refresh\" content=\"20\">\n \n// 注释：其中20指每隔20秒刷新一次页面\n\n\n1\n2\n3\n\n\n\n# 切面编程\n\n/*实现在function的原型链新增before(fn),after(fn)两个函数*/\n\nfunction.prototype.before = function (beforefn) {\n    let _this = this;\n    return function () {\n        beforefn.apply(this, arguments);\n        return _this.apply(this, arguments)\n    }\n}\nfunction.prototype.after = function (afterfn) {\n    var _self = this;\n    return function () {\n        var ret = _self.apply(this, arguments);\n        afterfn.apply(this, arguments);\n        return ret;\n    }\n}\nlet func1 = () => console.log('func1');\nfunc1 = func1.before(() => {\n    console.log('==before==');\n}).after(() => {\n    console.log('==after');\n});\nlet func2 = () => console.log('func2');\nfunc2 = func2.before(() => {\n    console.log('==before==');\n}).after(() => {\n    console.log('==after');\n});\n\nfunction main() {\n    func1();\n    func2();\n}\n\nmain()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n面向切面编程(aop) 和面向对象编程(oop)一样，是编程范式\n\naop主要应用在 与核心业务无关但又在多个模块使用的功能比如权限控制、日志记录、数据校验、异常处理等领域\n\n\n# 尾递归\n\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n]递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误\n\n> 为啥尾递归优化\n\n\n# 解构赋值\n\n是es6提供的语法糖，针对可迭代对象的iterator接口，按顺序获取对应的值赋值\n\nfor...of...也是遍历器，遍历数据结构时，寻找iterator接口\n\niterator——为各种数据解构提供统一访问接口，使数据结构能按次序排列处理\n\n> 解构赋值，是浅拷贝！\n\n解构的不定参数只能出现在 最后一个位置！\n\n> 解构多层对象嵌套\n\n使用 可选链 或 判断空值 解决\n\n\n# es2022\n\n以前定义实例的默认值，只能通过constructor定义\n\n现在\n\nclass counter {\n  num = 0;\n}\n\n\n1\n2\n3\n\n\nstatic声明静态字段和方法，静态类字段和方法属于整个类，并非某一具体的实例\n\nclass counter {\n  // 静态字段\n  static num = 1\n  // 静态方法\n  static getnum() {\n    return this.num\n  }\n}\n\n//只能通过类来直接访问类的静态字段和静态方法\nconsole.log(counter.num) //1\nconsole.log(counter.getnum()) // 1\n\n// 无法通过实例访问类的静态字段和静态方法\nconst counter = new counter()\nconsole.log(counter.num) // undefined\nconsole.log(counter.getnum()) // typeerror: counter.getnum is not a function\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n以前await只能和async用，限制一些场景，如在全局作用域使用import的异步加载方式\n\n可以使用.at()取数组的倒数元素\n\n\n# 拖拽\n\n * dragstart 元素被拖拽时触发【拖拽元素上绑定】\n * dragend 被拖拽元素结束拖拽时触发【拖拽元素上绑定】\n * dragover 被拖拽元素拖入目标区域后 触发 【目标区域绑定事件】\n * drop 被拖拽元素拖入目标区域结束 触发 【在目标区域绑定】",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Optimize",frontmatter:{title:"Optimize",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/c60f99/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/07.Optimize.html",relativePath:"08.专栏/07.Optimize.md",key:"v-72709de4",path:"/pages/c60f99/",headers:[{level:3,title:"权衡",slug:"权衡",normalizedTitle:"权衡",charIndex:363},{level:2,title:"会造成阻塞吗",slug:"会造成阻塞吗",normalizedTitle:"会造成阻塞吗",charIndex:1287},{level:2,title:"合成",slug:"合成",normalizedTitle:"合成",charIndex:1633},{level:3,title:"DNS预解析",slug:"dns预解析",normalizedTitle:"dns预解析",charIndex:1843},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:448},{level:3,title:"使用HTTP2.0",slug:"使用http2-0",normalizedTitle:"使用http2.0",charIndex:2280},{level:3,title:"预加载(首屏优化不提)",slug:"预加载-首屏优化不提",normalizedTitle:"预加载(首屏优化不提)",charIndex:2343},{level:3,title:"预渲染",slug:"预渲染",normalizedTitle:"预渲染",charIndex:2485},{level:3,title:"减少HTTP请求",slug:"减少http请求",normalizedTitle:"减少http请求",charIndex:2608},{level:3,title:"SSR",slug:"ssr",normalizedTitle:"ssr",charIndex:2621},{level:3,title:"Gzip压缩",slug:"gzip压缩",normalizedTitle:"gzip压缩",charIndex:2839},{level:3,title:"避免重定向",slug:"避免重定向",normalizedTitle:"避免重定向",charIndex:2850},{level:3,title:"懒执行",slug:"懒执行",normalizedTitle:"懒执行",charIndex:2869},{level:3,title:"懒加载",slug:"懒加载",normalizedTitle:"懒加载",charIndex:2963},{level:3,title:"节流防抖",slug:"节流防抖",normalizedTitle:"节流防抖",charIndex:3143},{level:2,title:"合适图片格式",slug:"合适图片格式",normalizedTitle:"合适图片格式",charIndex:3399},{level:4,title:"JPEG/JPG",slug:"jpeg-jpg",normalizedTitle:"jpeg/jpg",charIndex:3677},{level:4,title:"PNG",slug:"png",normalizedTitle:"png",charIndex:3472},{level:4,title:"SVG",slug:"svg",normalizedTitle:"svg",charIndex:3491},{level:4,title:"GIF",slug:"gif",normalizedTitle:"gif",charIndex:3808},{level:4,title:"Webp",slug:"webp",normalizedTitle:"webp",charIndex:3824},{level:2,title:"webpack压缩",slug:"webpack压缩",normalizedTitle:"webpack压缩",charIndex:4086},{level:2,title:"雪碧图",slug:"雪碧图",normalizedTitle:"雪碧图",charIndex:3514},{level:2,title:"iconfont",slug:"iconfont",normalizedTitle:"iconfont",charIndex:4320},{level:2,title:"内联Base 64",slug:"内联base-64",normalizedTitle:"内联base 64",charIndex:4385},{level:2,title:"CSS代替图",slug:"css代替图",normalizedTitle:"css代替图",charIndex:4518},{level:2,title:"CDN图片",slug:"cdn图片",normalizedTitle:"cdn图片",charIndex:4551},{level:2,title:"图片懒加载",slug:"图片懒加载",normalizedTitle:"图片懒加载",charIndex:4561},{level:2,title:"图片预加载",slug:"图片预加载",normalizedTitle:"图片预加载",charIndex:4657},{level:2,title:"响应式图加载",slug:"响应式图加载",normalizedTitle:"响应式图加载",charIndex:4688},{level:2,title:"渐进式图片",slug:"渐进式图片",normalizedTitle:"渐进式图片",charIndex:4719},{level:3,title:"Webpack 优化",slug:"webpack-优化",normalizedTitle:"webpack 优化",charIndex:4856},{level:3,title:"监控",slug:"监控",normalizedTitle:"监控",charIndex:354},{level:2,title:"加载慢的原因",slug:"加载慢的原因",normalizedTitle:"加载慢的原因",charIndex:5191},{level:2,title:"解决",slug:"解决",normalizedTitle:"解决",charIndex:2085},{level:3,title:"减少入口文件体积",slug:"减少入口文件体积",normalizedTitle:"减少入口文件体积",charIndex:5260},{level:3,title:"组件重复打包",slug:"组件重复打包",normalizedTitle:"组件重复打包",charIndex:5306},{level:3,title:"SSR",slug:"ssr-2",normalizedTitle:"ssr",charIndex:2621},{level:2,title:"补充",slug:"补充",normalizedTitle:"补充",charIndex:6197}],headersStr:"权衡 会造成阻塞吗 合成 DNS预解析 缓存 使用HTTP2.0 预加载(首屏优化不提) 预渲染 减少HTTP请求 SSR Gzip压缩 避免重定向 懒执行 懒加载 节流防抖 合适图片格式 JPEG/JPG PNG SVG GIF Webp webpack压缩 雪碧图 iconfont 内联Base 64 CSS代替图 CDN图片 图片懒加载 图片预加载 响应式图加载 渐进式图片 Webpack 优化 监控 加载慢的原因 解决 减少入口文件体积 组件重复打包 SSR 补充",content:'# 优化指标\n\n写给中高级前端关于性能优化的9大策略和6大指标 | 网易四年实践\n\n让用户感觉这个网站很「快」 ， 一种是「真的快」一种是「觉得快」\n\n * 「真的快」 可 客观衡量的指标， 网页访问时间、交互响应时间、跳转页面时间\n\n * 「觉得快」 用户主观感知的性能，通过视觉引导等手段转移用户对等待时间的关注\n\n * 动画流畅\n\n * 表单提交速度\n\n * 列表滚动页面切换是否卡顿\n\n * 响应速度：页面初始访问速度 + 交互响应速度\n\n * 页面稳定性：页面出错率，资源加载错误，JS 执行报错\n\n * 外部服务调用：网络请求访问速度\n\n最好的性能指标：100ms 内响应用户输入；动画/滚动在 10ms 内下一帧；最大化空闲时间；页面加载时长不超过 5 秒\n\n系统架构、性能分析、网站优化、网站监控\n\n\n> # 权衡\n\n一种优化方案可能适用于大多数项目，但是特殊情况下可能会起反效果\n\n浏览器有单域名下并发请求限制，通常我们将依赖统一打包减少首屏请求数，依赖不变动文件指纹不变，利用缓存。依赖不多这么处理有助于提升加载速度，一旦依赖多起来，包就会特别 大， 弱网条件 严重拖慢页面显示\n\n所以 根据情况 对vendor拆分， 如拆分到CDN，或者直接拆分到页面\n\n因此， 在 性能优化过程中，必须根据最终能给用户体验带来的提升权衡后做出适合 的选择\n\n\n# 优化手法\n\n * 聚焦用户\n * 尽快响应用户输入\n * 动画执行流畅\n * 最大化主线程空闲时间\n * 网页可交互性\n\n\n# HTML\n\n * 避免HTML中直接写CSS\n * viewport加速页面渲染\n * 使用语义化标签\n * 减少标签的使用，DOM解析是一个大量遍历的过程\n * 避免src和href空值\n * 减少DNS查询数\n\n\n# CSS\n\n * 避免后代选择符\n\n * 避免链式~\n\n * 避免!important\n\n * link代替@import\n\n> @import会将请求变得 串行化，导致加载增加延迟\n\n * 减少回流与重绘\n * CSS 放在 head 中\n * 压缩CSS 开启gzip压缩\n * 骨架屏+合理的loading\n * 优化选择器路径，避免 过多嵌套\n * 选择器合并：压缩空间和资源开销\n * 精确样式\n\n> 比如设置{padding-left:10px}的值，避免{padding:0 0 0 10px}这样的写法\n\n * 异步加载CSS\n * 避免通配符\n\n> .a .b *{} 像这样的选择器，从右到左解析，在解析过程中遇到通配符（**）会去遍历整个dom\n\n * 少用float：渲染时计算量大\n * 0值不加单位：兼容性\n * 避免使用 昂贵 的属性\n\n> 因为他们渲染成本挺高，渲染速度慢一些\n> \n>  * border-radius\n>  * box-shadow\n>  * opacity\n>  * transform\n>  * filter\n>  * position: fixed\n\n * 使用先进布局方式——flex\n\n\n# 会造成阻塞吗\n\n * CSS加载不会阻塞DOM树解析\n * CSS加载会阻塞DOM树渲染\n * CSS加载会阻塞后面JS执行\n\n\n# JS\n\n * 避免循环操作DOM\n * 事件委托\n\n> 绑定事件时，不绑定到目标元素上，而是绑定到其祖先元素上\n> \n>  * 监听事件少\n>  * 新增节点时，无需增加事件绑定\n\n * scrip标签放在body后\n\n> CSS放在head\n> \n> 因为JS阻塞DOM的构建(因为DOM解析遇到JS会停止解析，开始下载脚本并执行) ，CSSOM的构建阻塞JS执行\n\n * 压缩文件\n * 按需加载\n * 避免逐个操作DOM样式，尽可能预留好CSS样式，通过样式名的修改改变DOM样式，集中式操作减少reflow的次数\n * 减少iframe数量\n\n\n# 合成\n\n * 合成层的位图 交由GPU处理，比CPU块\n * repaint本身，不影响其它层\n * transform和opacity不触发重绘\n\n\n# 代码问题\n\n * 频繁使用JSON.parse/JSON.stringify大对象\n * 正则灾难性回溯\n * 内存泄漏\n * 服务端开启文件压缩功能\n * 执行 JS 代码过长会卡顿，对需要很多时间计算的代码可用 web worker\n\n\n# 网络相关\n\n\n# DNS预解析\n\n预先获得域名所对应的 IP，href的值是预解析的域名\n\n<link rel="dns-prefetch" href="//xxx.example.com" />\n\n\n1\n\n\n> preload和prefetch\n> \n> preload强制浏览器立即获取资源， 具有较高优先级\n> \n> prefetch的资源获取时可选 和 较低 优先级的，是否获取取决于浏览器\n\n\n# 缓存\n\n强缓存\n\n协商缓存\n\n选择合适缓存策略\n\n对于大部分的场景都可以使用强缓存配合协商缓存解决\n\n * 使用 Cache-control: no-store ，表示该资源不需要缓存\n * 使用 Cache-Control: no-cache 并配合 ETag ，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新\n * 使用 Cache-Control: max-age=31536000 并配合策略缓存使用，对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件\n\n\n# 使用HTTP2.0\n\n * 解析速度快\n * 头部压缩\n * 多路复用\n * 服务器推送\n * 浏览器由并发请求限制\n\n\n# 预加载(首屏优化不提)\n\n * 有些资源不需要马上用到，但希望尽早获取\n\n * 预加载强制请求资源，不会阻塞 onload 事件\n   \n   <link rel="preload" href="http://example.com" />\n   \n   \n   1\n   \n\n\n# 预渲染\n\n将下载的文件预先在后台渲染\n\n<link rel="prerender" href="http://example.com" />\n\n\n1\n\n\n> 预渲染可以提高页面的加载速度，但是要确保该页面百分百会被用户，否则白白浪费资源\n\n\n# 减少HTTP请求\n\n\n# SSR\n\nSSR （service side render），后端将HTML拼接好返回前端\n\n> 优点\n\n * 前端耗时少\n * 利于SEO，有完整HTML页面，爬虫更易获取信息\n * 无需占用客户端资源\n * 后端生成静态化文件\n * 首屏加载更快\n\n> 缺点\n\n * 不利于前后端分离\n * 占用服务器资源\n\n客户端渲染\n\n> 优点\n\n * 前后端分离\n * 体验更好\n\n> 缺点\n\n * 前端响应较慢\n * 不利于SEO\n\n\n# Gzip压缩\n\n\n# 避免重定向\n\n\n# 渲染优化\n\n\n# 懒执行\n\n将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。\n\n\n# 懒加载\n\n将不关键的资源延后加载——尽量只加载用户正 浏览 或即将会 浏览的图片\n\n只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西\n\n对于图片来说，先设置图片标签的 src 属性为一张占位图，真实的图片资源放入自定义属性data-src 中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样就会下载图片资源\n\n\n# 节流防抖\n\n防抖：单位时间内多次触发，只执行最后的那一次，原理：延迟执行，期间但凡有新的触发就重置定时器\n\n节流：单位时间只触发一次，原理：上锁，只有满足一定间隔时间才能执行\n\n\n# 图片\n\n电商类项目，存在大量图片，banner 广告图、菜单导航栏、列表头图等\n\n图片众多以及体积过大影响页面加载速度\n\n> 为啥？\n> \n> 有些图片请求并发，Chrome最多支持并发请求数有限，其他请求被push进队列中等待或停滞，直到上轮请求完成后才被发出，一部分资源需要排队等待时间，过多的图片影响页面加载展示\n\n\n# 合适图片格式\n\n * WebP 格式具有更好的图像数据压缩算法，更小的图片体积，拥有肉眼识别无差异的图像质量，缺点是兼容性并不好\n * 小图使用 PNG，对于大部分图标，完全可以使用 SVG 代替\n * 照片使用 JPEG\n * 雪碧图( 将多个图标文件整合到一张图片中 )\n\n> 可能请求非常多的小图片，会受到浏览器并发 HTTP 请求数的限制\n\n * 图片压缩\n * 不用图片，用CSS代替\n * 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片\n\n# JPEG/JPG\n\n * 高质量 有损压缩，体积小，不支持透明\n * 应用于轮播图 大的背景图、banner\n\n# PNG\n\n * 无损压缩，质量好，体积大，支持透明\n * 应用小的logo\n\n# SVG\n\n * 体积小，不失真，兼容好\n * 应用于图标\n\n# GIF\n\n * 支持透明\n\n# Webp\n\n有损压缩与无损压缩（可逆压缩）的图片文件格式\n\n比PNG/JPEG格式小\n\n支持透明度\n\n体积和效果上都做的不错\n\n<picture>\n    <source type="image/webp" srcset="/static/img/perf.webp">\n    <source type="image/jpeg" srcset="/static/img/perf.jpg">\n    <img src="/static/img/perf.jpg">\n</picture>\n\n\n1\n2\n3\n4\n5\n\n\n\n# webpack压缩\n\n配置 image-webpack-loader\n\n\n# 雪碧图\n\nCSS Sprites ，精灵图，图像合成技术，主要用于小图片显示\n\n同原域名请求有最大并发限制，Chrome为6个，如 页面有10个小图，需要10次请求，2次并发\n\n若把10个图合成一个大图，只需1次请求\n\n 1. 减少请求次数\n 2. 减少服务器压力\n 3. 减少并发\n 4. 提高加载速度\n 5. 减少鼠标滑过的一些bug\n 6. 解决网页设计师在图片命名上的困扰\n\n\n# iconfont\n\n通过字体方式展示图标，用户 图标渲染、简单图形、特殊字体等\n\n * 轻量，已修改\n * 减少请求次数\n\n\n# 内联Base 64\n\n图片转为base64串，解析图片不会请求下载，而是解析字符串\n\n> 缺点\n> \n>  1. 比使用二进制体积增大 33%\n>  2. 全部内联后，原本可并行加载的图片会串行放入请求\n> \n> 适用于 更新频率低、首屏或骨架图上的小图标\n\n\n# CSS代替图\n\n实现修饰效果，半透明、阴影、圆角、渐变等\n\n\n# CDN图片\n\n\n# 图片懒加载\n\n暂时不设置图片的src属性，先卸载data-src中，等图片到了可视区域再将真实src放进src属性\n\n使用background-url，应用到具体元素时，才会下载图片\n\n\n# 图片预加载\n\n需要展示大量图，将图提前加载到本地缓存\n\n\n# 响应式图加载\n\n在不同分辨率的设备上显示不同尺寸的图\n\n\n# 渐进式图片\n\n和骨架屏 原理类似\n\n在图完全加载完前先显示低画质版本，让用户产生图片加载变快的印象，而不是盯着一片空白\n\n\n# CDN\n\n内容分发网络\n\n静态资源使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名\n\n\n# 其他\n\n\n# Webpack 优化\n\n * 对于 Webpack，打包项目使用 production 模式，会自动开启代码压缩\n * ES6 模块开启 tree shaking，移除没有使用的代码\n * 优化图片，对于小图使用 base64 的方式写入文件\n * 按照路由拆分代码，实现按需加载\n * 给打包出来的文件名添加哈希，实现浏览器缓存文件\n\n\n# 监控\n\n采集——>上传——>分析——>报警\n\n\n# 渲染几万条数据?\n\nrequestAnimationFrame 每 16 ms 刷新\n\n分页+虚拟滚动、图片懒加载、图片的动态裁剪\n\n\n# SPA首屏优化\n\n浏览器从响应用户输入网址地址，到首屏内容渲染完成时间，整个网页不一定要完全渲染完成，但需要展示当前视窗内容\n\n\n# 加载慢的原因\n\n * 网络延时\n * 资源文件体积过大\n * 资源加载重复发送请求\n * 加载脚本时，渲染内容阻塞\n\n\n# 解决\n\n * 减少入口文件体积\n * 静态资源本地缓存\n * UI框架按需加载\n * 图片资源压缩\n * 组件重复打包\n * GZip压缩\n * 使用SSR\n * JS外联文件放在HTML文档底部，CSS外联文件放在HTML文档头部\n * 减少cookie体积\n * 骨架屏\n * h5方式一次性渲染\n\n\n# 减少入口文件体积\n\n路由懒加载，将不同路由对应组件分割成不同代码块，待路由被请求时单独打包路由，使得入口文件变小\n\n> 以函数形式动态加载路由，可以把各自的路由文件分别打包，只在解析给定路由时，才会加载路由组件\n\n\n# 组件重复打包\n\n若A.js是一个常用库，多个路由使用它会造成重复下载\n\n在webpack的config中，修改CommonChunkPlugin的配置\n\nminChunks为3表示会把使用3次及以上的包抽离，放进公共依赖文件\n\n\n# SSR\n\n服务端渲染，Server Side ，组件或页面通过服务器生成html字符串，发送到浏览器\n\n 1. 二次启动时先利用缓存渲染，后台进行异步数据更新\n 2. 减少不必要的请求 和数据获取\n 3. 提前请求或减少http请求\n 4. 优化图片文件尺寸，压缩图片格式，压缩代码\n 5. 启用gzip 压缩功能\n 6. 使用CDN\n 7. 网址后面加上“/”:对服务器而言，不加斜杠服务器会多一次判断的过程，加斜杠就会直接返回网站设置的存放在网站根目录下的默认页面。\n 8. Ajax采用缓存调用\n\n\n# 网页卡顿？\n\n 1. 网络请求是否过多，导致数据传输变慢，可通过缓存优化\n 2. 资源bundle太大，考虑拆分\n 3. 代码是否有太多循环在主线程上花费太长时间\n 4. 浏览器某个帧 中 渲染太多东西\n 5. 页面渲染时，大量回流和重绘\n 6. 内存泄露\n\n\n# 动画优化\n\n * 合理布局\n * transform代替left、top 减少重排\n * 硬件加速\n * 避免不必要的图形层\n * requestAnimationFrame实现动画\n\n动画每一帧都是re-render，显示器刷新频率 60 HZ，意味着每一帧任务耗时不超过 16ms\n\n\n# React官网优化\n\nReact 渲染的未来\n\n\n# 补充\n\nreact官网不完全由react开发，得益于Gatsby库\n\n> Gatsby 性能很好，开发很自由，基于 React 和 GraphQL 构建网站的库。用于构建静态网站，如博客、企业官网、静态内容相对比较多的网站\n\n监听link如何实现？\n\nresult：使用 Intersection Observer，兼容问题',normalizedContent:'# 优化指标\n\n写给中高级前端关于性能优化的9大策略和6大指标 | 网易四年实践\n\n让用户感觉这个网站很「快」 ， 一种是「真的快」一种是「觉得快」\n\n * 「真的快」 可 客观衡量的指标， 网页访问时间、交互响应时间、跳转页面时间\n\n * 「觉得快」 用户主观感知的性能，通过视觉引导等手段转移用户对等待时间的关注\n\n * 动画流畅\n\n * 表单提交速度\n\n * 列表滚动页面切换是否卡顿\n\n * 响应速度：页面初始访问速度 + 交互响应速度\n\n * 页面稳定性：页面出错率，资源加载错误，js 执行报错\n\n * 外部服务调用：网络请求访问速度\n\n最好的性能指标：100ms 内响应用户输入；动画/滚动在 10ms 内下一帧；最大化空闲时间；页面加载时长不超过 5 秒\n\n系统架构、性能分析、网站优化、网站监控\n\n\n> # 权衡\n\n一种优化方案可能适用于大多数项目，但是特殊情况下可能会起反效果\n\n浏览器有单域名下并发请求限制，通常我们将依赖统一打包减少首屏请求数，依赖不变动文件指纹不变，利用缓存。依赖不多这么处理有助于提升加载速度，一旦依赖多起来，包就会特别 大， 弱网条件 严重拖慢页面显示\n\n所以 根据情况 对vendor拆分， 如拆分到cdn，或者直接拆分到页面\n\n因此， 在 性能优化过程中，必须根据最终能给用户体验带来的提升权衡后做出适合 的选择\n\n\n# 优化手法\n\n * 聚焦用户\n * 尽快响应用户输入\n * 动画执行流畅\n * 最大化主线程空闲时间\n * 网页可交互性\n\n\n# html\n\n * 避免html中直接写css\n * viewport加速页面渲染\n * 使用语义化标签\n * 减少标签的使用，dom解析是一个大量遍历的过程\n * 避免src和href空值\n * 减少dns查询数\n\n\n# css\n\n * 避免后代选择符\n\n * 避免链式~\n\n * 避免!important\n\n * link代替@import\n\n> @import会将请求变得 串行化，导致加载增加延迟\n\n * 减少回流与重绘\n * css 放在 head 中\n * 压缩css 开启gzip压缩\n * 骨架屏+合理的loading\n * 优化选择器路径，避免 过多嵌套\n * 选择器合并：压缩空间和资源开销\n * 精确样式\n\n> 比如设置{padding-left:10px}的值，避免{padding:0 0 0 10px}这样的写法\n\n * 异步加载css\n * 避免通配符\n\n> .a .b *{} 像这样的选择器，从右到左解析，在解析过程中遇到通配符（**）会去遍历整个dom\n\n * 少用float：渲染时计算量大\n * 0值不加单位：兼容性\n * 避免使用 昂贵 的属性\n\n> 因为他们渲染成本挺高，渲染速度慢一些\n> \n>  * border-radius\n>  * box-shadow\n>  * opacity\n>  * transform\n>  * filter\n>  * position: fixed\n\n * 使用先进布局方式——flex\n\n\n# 会造成阻塞吗\n\n * css加载不会阻塞dom树解析\n * css加载会阻塞dom树渲染\n * css加载会阻塞后面js执行\n\n\n# js\n\n * 避免循环操作dom\n * 事件委托\n\n> 绑定事件时，不绑定到目标元素上，而是绑定到其祖先元素上\n> \n>  * 监听事件少\n>  * 新增节点时，无需增加事件绑定\n\n * scrip标签放在body后\n\n> css放在head\n> \n> 因为js阻塞dom的构建(因为dom解析遇到js会停止解析，开始下载脚本并执行) ，cssom的构建阻塞js执行\n\n * 压缩文件\n * 按需加载\n * 避免逐个操作dom样式，尽可能预留好css样式，通过样式名的修改改变dom样式，集中式操作减少reflow的次数\n * 减少iframe数量\n\n\n# 合成\n\n * 合成层的位图 交由gpu处理，比cpu块\n * repaint本身，不影响其它层\n * transform和opacity不触发重绘\n\n\n# 代码问题\n\n * 频繁使用json.parse/json.stringify大对象\n * 正则灾难性回溯\n * 内存泄漏\n * 服务端开启文件压缩功能\n * 执行 js 代码过长会卡顿，对需要很多时间计算的代码可用 web worker\n\n\n# 网络相关\n\n\n# dns预解析\n\n预先获得域名所对应的 ip，href的值是预解析的域名\n\n<link rel="dns-prefetch" href="//xxx.example.com" />\n\n\n1\n\n\n> preload和prefetch\n> \n> preload强制浏览器立即获取资源， 具有较高优先级\n> \n> prefetch的资源获取时可选 和 较低 优先级的，是否获取取决于浏览器\n\n\n# 缓存\n\n强缓存\n\n协商缓存\n\n选择合适缓存策略\n\n对于大部分的场景都可以使用强缓存配合协商缓存解决\n\n * 使用 cache-control: no-store ，表示该资源不需要缓存\n * 使用 cache-control: no-cache 并配合 etag ，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新\n * 使用 cache-control: max-age=31536000 并配合策略缓存使用，对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件\n\n\n# 使用http2.0\n\n * 解析速度快\n * 头部压缩\n * 多路复用\n * 服务器推送\n * 浏览器由并发请求限制\n\n\n# 预加载(首屏优化不提)\n\n * 有些资源不需要马上用到，但希望尽早获取\n\n * 预加载强制请求资源，不会阻塞 onload 事件\n   \n   <link rel="preload" href="http://example.com" />\n   \n   \n   1\n   \n\n\n# 预渲染\n\n将下载的文件预先在后台渲染\n\n<link rel="prerender" href="http://example.com" />\n\n\n1\n\n\n> 预渲染可以提高页面的加载速度，但是要确保该页面百分百会被用户，否则白白浪费资源\n\n\n# 减少http请求\n\n\n# ssr\n\nssr （service side render），后端将html拼接好返回前端\n\n> 优点\n\n * 前端耗时少\n * 利于seo，有完整html页面，爬虫更易获取信息\n * 无需占用客户端资源\n * 后端生成静态化文件\n * 首屏加载更快\n\n> 缺点\n\n * 不利于前后端分离\n * 占用服务器资源\n\n客户端渲染\n\n> 优点\n\n * 前后端分离\n * 体验更好\n\n> 缺点\n\n * 前端响应较慢\n * 不利于seo\n\n\n# gzip压缩\n\n\n# 避免重定向\n\n\n# 渲染优化\n\n\n# 懒执行\n\n将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。\n\n\n# 懒加载\n\n将不关键的资源延后加载——尽量只加载用户正 浏览 或即将会 浏览的图片\n\n只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西\n\n对于图片来说，先设置图片标签的 src 属性为一张占位图，真实的图片资源放入自定义属性data-src 中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样就会下载图片资源\n\n\n# 节流防抖\n\n防抖：单位时间内多次触发，只执行最后的那一次，原理：延迟执行，期间但凡有新的触发就重置定时器\n\n节流：单位时间只触发一次，原理：上锁，只有满足一定间隔时间才能执行\n\n\n# 图片\n\n电商类项目，存在大量图片，banner 广告图、菜单导航栏、列表头图等\n\n图片众多以及体积过大影响页面加载速度\n\n> 为啥？\n> \n> 有些图片请求并发，chrome最多支持并发请求数有限，其他请求被push进队列中等待或停滞，直到上轮请求完成后才被发出，一部分资源需要排队等待时间，过多的图片影响页面加载展示\n\n\n# 合适图片格式\n\n * webp 格式具有更好的图像数据压缩算法，更小的图片体积，拥有肉眼识别无差异的图像质量，缺点是兼容性并不好\n * 小图使用 png，对于大部分图标，完全可以使用 svg 代替\n * 照片使用 jpeg\n * 雪碧图( 将多个图标文件整合到一张图片中 )\n\n> 可能请求非常多的小图片，会受到浏览器并发 http 请求数的限制\n\n * 图片压缩\n * 不用图片，用css代替\n * 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 cdn 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片\n\n# jpeg/jpg\n\n * 高质量 有损压缩，体积小，不支持透明\n * 应用于轮播图 大的背景图、banner\n\n# png\n\n * 无损压缩，质量好，体积大，支持透明\n * 应用小的logo\n\n# svg\n\n * 体积小，不失真，兼容好\n * 应用于图标\n\n# gif\n\n * 支持透明\n\n# webp\n\n有损压缩与无损压缩（可逆压缩）的图片文件格式\n\n比png/jpeg格式小\n\n支持透明度\n\n体积和效果上都做的不错\n\n<picture>\n    <source type="image/webp" srcset="/static/img/perf.webp">\n    <source type="image/jpeg" srcset="/static/img/perf.jpg">\n    <img src="/static/img/perf.jpg">\n</picture>\n\n\n1\n2\n3\n4\n5\n\n\n\n# webpack压缩\n\n配置 image-webpack-loader\n\n\n# 雪碧图\n\ncss sprites ，精灵图，图像合成技术，主要用于小图片显示\n\n同原域名请求有最大并发限制，chrome为6个，如 页面有10个小图，需要10次请求，2次并发\n\n若把10个图合成一个大图，只需1次请求\n\n 1. 减少请求次数\n 2. 减少服务器压力\n 3. 减少并发\n 4. 提高加载速度\n 5. 减少鼠标滑过的一些bug\n 6. 解决网页设计师在图片命名上的困扰\n\n\n# iconfont\n\n通过字体方式展示图标，用户 图标渲染、简单图形、特殊字体等\n\n * 轻量，已修改\n * 减少请求次数\n\n\n# 内联base 64\n\n图片转为base64串，解析图片不会请求下载，而是解析字符串\n\n> 缺点\n> \n>  1. 比使用二进制体积增大 33%\n>  2. 全部内联后，原本可并行加载的图片会串行放入请求\n> \n> 适用于 更新频率低、首屏或骨架图上的小图标\n\n\n# css代替图\n\n实现修饰效果，半透明、阴影、圆角、渐变等\n\n\n# cdn图片\n\n\n# 图片懒加载\n\n暂时不设置图片的src属性，先卸载data-src中，等图片到了可视区域再将真实src放进src属性\n\n使用background-url，应用到具体元素时，才会下载图片\n\n\n# 图片预加载\n\n需要展示大量图，将图提前加载到本地缓存\n\n\n# 响应式图加载\n\n在不同分辨率的设备上显示不同尺寸的图\n\n\n# 渐进式图片\n\n和骨架屏 原理类似\n\n在图完全加载完前先显示低画质版本，让用户产生图片加载变快的印象，而不是盯着一片空白\n\n\n# cdn\n\n内容分发网络\n\n静态资源使用 cdn 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 cdn 域名\n\n\n# 其他\n\n\n# webpack 优化\n\n * 对于 webpack，打包项目使用 production 模式，会自动开启代码压缩\n * es6 模块开启 tree shaking，移除没有使用的代码\n * 优化图片，对于小图使用 base64 的方式写入文件\n * 按照路由拆分代码，实现按需加载\n * 给打包出来的文件名添加哈希，实现浏览器缓存文件\n\n\n# 监控\n\n采集——>上传——>分析——>报警\n\n\n# 渲染几万条数据?\n\nrequestanimationframe 每 16 ms 刷新\n\n分页+虚拟滚动、图片懒加载、图片的动态裁剪\n\n\n# spa首屏优化\n\n浏览器从响应用户输入网址地址，到首屏内容渲染完成时间，整个网页不一定要完全渲染完成，但需要展示当前视窗内容\n\n\n# 加载慢的原因\n\n * 网络延时\n * 资源文件体积过大\n * 资源加载重复发送请求\n * 加载脚本时，渲染内容阻塞\n\n\n# 解决\n\n * 减少入口文件体积\n * 静态资源本地缓存\n * ui框架按需加载\n * 图片资源压缩\n * 组件重复打包\n * gzip压缩\n * 使用ssr\n * js外联文件放在html文档底部，css外联文件放在html文档头部\n * 减少cookie体积\n * 骨架屏\n * h5方式一次性渲染\n\n\n# 减少入口文件体积\n\n路由懒加载，将不同路由对应组件分割成不同代码块，待路由被请求时单独打包路由，使得入口文件变小\n\n> 以函数形式动态加载路由，可以把各自的路由文件分别打包，只在解析给定路由时，才会加载路由组件\n\n\n# 组件重复打包\n\n若a.js是一个常用库，多个路由使用它会造成重复下载\n\n在webpack的config中，修改commonchunkplugin的配置\n\nminchunks为3表示会把使用3次及以上的包抽离，放进公共依赖文件\n\n\n# ssr\n\n服务端渲染，server side ，组件或页面通过服务器生成html字符串，发送到浏览器\n\n 1. 二次启动时先利用缓存渲染，后台进行异步数据更新\n 2. 减少不必要的请求 和数据获取\n 3. 提前请求或减少http请求\n 4. 优化图片文件尺寸，压缩图片格式，压缩代码\n 5. 启用gzip 压缩功能\n 6. 使用cdn\n 7. 网址后面加上“/”:对服务器而言，不加斜杠服务器会多一次判断的过程，加斜杠就会直接返回网站设置的存放在网站根目录下的默认页面。\n 8. ajax采用缓存调用\n\n\n# 网页卡顿？\n\n 1. 网络请求是否过多，导致数据传输变慢，可通过缓存优化\n 2. 资源bundle太大，考虑拆分\n 3. 代码是否有太多循环在主线程上花费太长时间\n 4. 浏览器某个帧 中 渲染太多东西\n 5. 页面渲染时，大量回流和重绘\n 6. 内存泄露\n\n\n# 动画优化\n\n * 合理布局\n * transform代替left、top 减少重排\n * 硬件加速\n * 避免不必要的图形层\n * requestanimationframe实现动画\n\n动画每一帧都是re-render，显示器刷新频率 60 hz，意味着每一帧任务耗时不超过 16ms\n\n\n# react官网优化\n\nreact 渲染的未来\n\n\n# 补充\n\nreact官网不完全由react开发，得益于gatsby库\n\n> gatsby 性能很好，开发很自由，基于 react 和 graphql 构建网站的库。用于构建静态网站，如博客、企业官网、静态内容相对比较多的网站\n\n监听link如何实现？\n\nresult：使用 intersection observer，兼容问题',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"OS",frontmatter:{title:"OS",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/1312c8/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/08.OS.html",relativePath:"08.专栏/08.OS.md",key:"v-c1961cb8",path:"/pages/1312c8/",headers:[{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:128},{level:2,title:"CPU类比一个工厂",slug:"cpu类比一个工厂",normalizedTitle:"cpu类比一个工厂",charIndex:421},{level:4,title:"线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约CPU时间。",slug:"线程和进程的区别在于-子进程和父进程有不同的代码和数据空间-而多个线程则共享数据空间-每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约cpu时间。",normalizedTitle:"线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约cpu时间。",charIndex:724},{level:2,title:"进程间通信",slug:"进程间通信",normalizedTitle:"进程间通信",charIndex:812},{level:3,title:"管道",slug:"管道",normalizedTitle:"管道",charIndex:822},{level:3,title:"消息队列",slug:"消息队列",normalizedTitle:"消息队列",charIndex:990},{level:3,title:"共享内存",slug:"共享内存",normalizedTitle:"共享内存",charIndex:533},{level:3,title:"信号量",slug:"信号量",normalizedTitle:"信号量",charIndex:660},{level:3,title:"套接字",slug:"套接字",normalizedTitle:"套接字",charIndex:1531}],headersStr:"区别 CPU类比一个工厂 线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约CPU时间。 进程间通信 管道 消息队列 共享内存 信号量 套接字",content:"# 对OS理解？\n\nOS是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。\n\n相当于是软件管家。\n\n\n# 🍅 进程&线程\n\n\n\n\n# 区别\n\n 1. 线程是进程的一个实体，是程序执行的最小单位\n 2. 进程是具有一定功能的程序在一个数据集上的一次动态执行的过程\n 3. 进程是资源分配的独立单元，线程是资源调度的基本单元\n 4. 资源开销：进程是拥有资源的一个独立单位，每个进程都有自己单独的地址空间，进程切换会消耗较大的资源——进程调度算法。线程只拥有一点在运行中必不可少的资源，一类线程共享代码和内存空间，线程切换消耗较小\n 5. 内存分配：进程间地址空间和资源相互独立；线程共享本进程地址空间和资源\n 6. 进程比线程健壮\n 7. 执行过程：进程有独立的运行入口\n 8. 执行顺序；进程和线程均可并发执行\n\n\n# CPU类比一个工厂\n\n 1. 一个进程 就是 一个车间，同时只能有一个进程运行，单个CPU一次只能运行一个任务\n 2. 多个线程 类比 车间的工人\n 3. 进程内存空间共享 类比 车间房间工人可进出\n 4. 一个线程使用某些共享内存时，其他线程必须等它结束才能使用这块内存类比 洗手间只能容纳一人\n 5. 防止多个线程同时读写某一块区域，加一把“互斥锁” 类比 在门上加一把锁\n 6. 某些内存区域只能供给固定数目的线程使用 类比 厨房容纳n个人，多的人只能在外面等着\n 7. 信号量，保证多个线程不会冲突 类比 门口放n把钥匙，进去取钥匙，出来放钥匙，后面的人发现钥匙架空就知道必须在门口等着\n\n> # 线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约CPU时间。\n\n\n# 进程间通信\n\n\n# 管道\n\n匿名管道和命名管道。\n\n管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，而且管道是单向传输的。\n\n效率低下，因为如果a进程给b进程传输数据，只有等b进程取到数据之后a进程才能返回，所以管道不适用于频繁通信的进程。当然，优点就是简单，能够保证我们的数据是真的已经被其他进程拿走的。\n\n\n# 消息队列\n\n那我们是否可以把进程的数据放在某个内存后就马上让进程返回呢？不用等待其他进程来取就返回？\n\n可以的。我们可以利用消息队列解决这个问题，例如a需要给b进程发送消息，只需将消息放在对应的消息队列中就可以，b进程需要的时候再去对应的消息队列中取出。这种通行方式类似于 缓存。\n\n有缺点吗？ 如果a进程发送的数据内存比较大，且两个进程通信非常频繁的话，队列模式就不大适合了。因为如果a发送的数据很大的话，意味着发送消息这个过程需要花很多时间读内存。\n\n\n# 共享内存\n\n共享内存这个通信方式就可以很好的解决 拷贝 所消耗的时间。\n\n进程拥有自己的独立内存，两个进程怎么共享一块内存？\n\n我们知道，系统加载一个进程时，分配给进程的内存不是实际物理内存，而是虚拟内存空间。那么我们就可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但是有一部分却是映射到相同的物理内存，即，完成进程的内存共享机制。\n\n\n# 信号量\n\n共享内存存在问题吗？\n\n最大的问题就是 多进程竞争内存。\n\n我们可以通过信号量解决这个问题。\n\n信号量的本质就是一个计数器，用来实现进程间的互斥和同步。\n\n我们用信号量这个变量来辅助内存共享。\n\n\n# 套接字\n\n前面的4个通信方式(管道，消息队列，内存共享，信号量)都是多个进程在一台主机上的通信，如果是两个相隔万里的进程还能通信吗？\n\nSocket可以解决这个问题，我们平时通过浏览器发起一个HTTP请求，然后服务器返回我们对应的数据，即是，socket通信\n\n\n# 🍅反码 补码 原码\n\n * 原码：计算机对数字二进制的定点表示方法，最高位表示符号位，其余位表示数值位。\n   \n   * 优点：易于分辨，缺点：不能够直接参与运算。\n\n * 正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。 如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。\n\n * 正数的补码和其原码一样；负数的补码为其反码加1。 例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001\n\n * 补码来表示负数的原因：可以将加法运算扩展到所有的数值计算上，因此在数字电路中只需考虑加法器的设计就行，而不用再为减法设置新的数字电路。\n\n\n# 死锁\n\n\n#",normalizedContent:"# 对os理解？\n\nos是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。\n\n相当于是软件管家。\n\n\n# 🍅 进程&线程\n\n\n\n\n# 区别\n\n 1. 线程是进程的一个实体，是程序执行的最小单位\n 2. 进程是具有一定功能的程序在一个数据集上的一次动态执行的过程\n 3. 进程是资源分配的独立单元，线程是资源调度的基本单元\n 4. 资源开销：进程是拥有资源的一个独立单位，每个进程都有自己单独的地址空间，进程切换会消耗较大的资源——进程调度算法。线程只拥有一点在运行中必不可少的资源，一类线程共享代码和内存空间，线程切换消耗较小\n 5. 内存分配：进程间地址空间和资源相互独立；线程共享本进程地址空间和资源\n 6. 进程比线程健壮\n 7. 执行过程：进程有独立的运行入口\n 8. 执行顺序；进程和线程均可并发执行\n\n\n# cpu类比一个工厂\n\n 1. 一个进程 就是 一个车间，同时只能有一个进程运行，单个cpu一次只能运行一个任务\n 2. 多个线程 类比 车间的工人\n 3. 进程内存空间共享 类比 车间房间工人可进出\n 4. 一个线程使用某些共享内存时，其他线程必须等它结束才能使用这块内存类比 洗手间只能容纳一人\n 5. 防止多个线程同时读写某一块区域，加一把“互斥锁” 类比 在门上加一把锁\n 6. 某些内存区域只能供给固定数目的线程使用 类比 厨房容纳n个人，多的人只能在外面等着\n 7. 信号量，保证多个线程不会冲突 类比 门口放n把钥匙，进去取钥匙，出来放钥匙，后面的人发现钥匙架空就知道必须在门口等着\n\n> # 线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约cpu时间。\n\n\n# 进程间通信\n\n\n# 管道\n\n匿名管道和命名管道。\n\n管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，而且管道是单向传输的。\n\n效率低下，因为如果a进程给b进程传输数据，只有等b进程取到数据之后a进程才能返回，所以管道不适用于频繁通信的进程。当然，优点就是简单，能够保证我们的数据是真的已经被其他进程拿走的。\n\n\n# 消息队列\n\n那我们是否可以把进程的数据放在某个内存后就马上让进程返回呢？不用等待其他进程来取就返回？\n\n可以的。我们可以利用消息队列解决这个问题，例如a需要给b进程发送消息，只需将消息放在对应的消息队列中就可以，b进程需要的时候再去对应的消息队列中取出。这种通行方式类似于 缓存。\n\n有缺点吗？ 如果a进程发送的数据内存比较大，且两个进程通信非常频繁的话，队列模式就不大适合了。因为如果a发送的数据很大的话，意味着发送消息这个过程需要花很多时间读内存。\n\n\n# 共享内存\n\n共享内存这个通信方式就可以很好的解决 拷贝 所消耗的时间。\n\n进程拥有自己的独立内存，两个进程怎么共享一块内存？\n\n我们知道，系统加载一个进程时，分配给进程的内存不是实际物理内存，而是虚拟内存空间。那么我们就可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但是有一部分却是映射到相同的物理内存，即，完成进程的内存共享机制。\n\n\n# 信号量\n\n共享内存存在问题吗？\n\n最大的问题就是 多进程竞争内存。\n\n我们可以通过信号量解决这个问题。\n\n信号量的本质就是一个计数器，用来实现进程间的互斥和同步。\n\n我们用信号量这个变量来辅助内存共享。\n\n\n# 套接字\n\n前面的4个通信方式(管道，消息队列，内存共享，信号量)都是多个进程在一台主机上的通信，如果是两个相隔万里的进程还能通信吗？\n\nsocket可以解决这个问题，我们平时通过浏览器发起一个http请求，然后服务器返回我们对应的数据，即是，socket通信\n\n\n# 🍅反码 补码 原码\n\n * 原码：计算机对数字二进制的定点表示方法，最高位表示符号位，其余位表示数值位。\n   \n   * 优点：易于分辨，缺点：不能够直接参与运算。\n\n * 正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。 如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。\n\n * 正数的补码和其原码一样；负数的补码为其反码加1。 例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001\n\n * 补码来表示负数的原因：可以将加法运算扩展到所有的数值计算上，因此在数字电路中只需考虑加法器的设计就行，而不用再为减法设置新的数字电路。\n\n\n# 死锁\n\n\n#",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Project-Others",frontmatter:{title:"Project-Others",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/a9e64c/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/09.Project-Others.html",relativePath:"08.专栏/09.Project-Others.md",key:"v-50e6ac38",path:"/pages/a9e64c/",headers:[{level:2,title:"🙋 反问",slug:"反问",normalizedTitle:"🙋 反问",charIndex:10},{level:3,title:"问业务面试官",slug:"问业务面试官",normalizedTitle:"问业务面试官",charIndex:20},{level:3,title:"问HR",slug:"问hr",normalizedTitle:"问hr",charIndex:433},{level:2,title:"🔥 被问",slug:"被问",normalizedTitle:"🔥 被问",charIndex:917},{level:3,title:"最有挑战的事",slug:"最有挑战的事",normalizedTitle:"最有挑战的事",charIndex:927},{level:3,title:"职业规划",slug:"职业规划",normalizedTitle:"职业规划",charIndex:906},{level:3,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:1395},{level:3,title:"🍅缺点",slug:"🍅缺点",normalizedTitle:"🍅缺点",charIndex:1420},{level:3,title:"🍅优点",slug:"🍅优点",normalizedTitle:"🍅优点",charIndex:1715},{level:3,title:"为啥不考研？",slug:"为啥不考研",normalizedTitle:"为啥不考研？",charIndex:2488},{level:3,title:"为什么选择我们公司？",slug:"为什么选择我们公司",normalizedTitle:"为什么选择我们公司？",charIndex:2580},{level:3,title:"对我们公司了解多少？",slug:"对我们公司了解多少",normalizedTitle:"对我们公司了解多少？",charIndex:3271},{level:3,title:"擅长啥？",slug:"擅长啥",normalizedTitle:"擅长啥？",charIndex:3383},{level:3,title:"期望薪资",slug:"期望薪资",normalizedTitle:"期望薪资",charIndex:3557},{level:3,title:"如何看待加班",slug:"如何看待加班",normalizedTitle:"如何看待加班",charIndex:3903},{level:3,title:"有其它offer吗",slug:"有其它offer吗",normalizedTitle:"有其它offer吗",charIndex:4214},{level:3,title:"希望与什么样的上级共事",slug:"希望与什么样的上级共事",normalizedTitle:"希望与什么样的上级共事",charIndex:4397},{level:3,title:"不喜欢和什么人打交道",slug:"不喜欢和什么人打交道",normalizedTitle:"不喜欢和什么人打交道",charIndex:4559},{level:3,title:"希望加入什么样的公司？",slug:"希望加入什么样的公司",normalizedTitle:"希望加入什么样的公司？",charIndex:4775},{level:3,title:"入职如何开展工作",slug:"入职如何开展工作",normalizedTitle:"入职如何开展工作",charIndex:5107},{level:3,title:"可以来实习吗",slug:"可以来实习吗",normalizedTitle:"可以来实习吗",charIndex:5277},{level:3,title:"最能概括你的三个词？",slug:"最能概括你的三个词",normalizedTitle:"最能概括你的三个词？",charIndex:5368},{level:3,title:"失败的经历",slug:"失败的经历",normalizedTitle:"失败的经历",charIndex:5701},{level:3,title:"实习收获",slug:"实习收获",normalizedTitle:"实习收获",charIndex:6005},{level:3,title:"看了啥书",slug:"看了啥书",normalizedTitle:"看了啥书",charIndex:6193},{level:2,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:6327},{level:2,title:"项目深度",slug:"项目深度",normalizedTitle:"项目深度",charIndex:6938},{level:2,title:"Webpack",slug:"webpack",normalizedTitle:"webpack",charIndex:7418},{level:3,title:"loader、plugin",slug:"loader、plugin",normalizedTitle:"loader、plugin",charIndex:7447},{level:3,title:"proxy原理？",slug:"proxy原理",normalizedTitle:"proxy原理？",charIndex:7955},{level:2,title:"早期npm",slug:"早期npm",normalizedTitle:"早期npm",charIndex:8212},{level:2,title:"yarn",slug:"yarn",normalizedTitle:"yarn",charIndex:8483},{level:2,title:"npm参数",slug:"npm参数",normalizedTitle:"npm参数",charIndex:8815},{level:3,title:"1.不填参数：",slug:"_1-不填参数",normalizedTitle:"1.不填参数：",charIndex:8906},{level:3,title:"2.使用--save：",slug:"_2-使用-save",normalizedTitle:"2.使用--save：",charIndex:9049},{level:3,title:"3.使用--save-dev：",slug:"_3-使用-save-dev",normalizedTitle:"3.使用--save-dev：",charIndex:9274},{level:3,title:"4.使用 -g：",slug:"_4-使用-g",normalizedTitle:"4.使用 -g：",charIndex:9511},{level:2,title:"运行npm run xxx发生了啥？",slug:"运行npm-run-xxx发生了啥",normalizedTitle:"运行npm run xxx发生了啥？",charIndex:9665},{level:2,title:"package.json",slug:"package-json",normalizedTitle:"package.json",charIndex:9686},{level:2,title:"package-lock.json",slug:"package-lock-json",normalizedTitle:"package-lock.json",charIndex:8560},{level:2,title:"pnpm",slug:"pnpm",normalizedTitle:"pnpm",charIndex:10953},{level:3,title:"为啥选taro",slug:"为啥选taro",normalizedTitle:"为啥选taro",charIndex:11185},{level:3,title:"踩坑记录",slug:"踩坑记录",normalizedTitle:"踩坑记录",charIndex:11334},{level:2,title:"基本",slug:"基本",normalizedTitle:"基本",charIndex:2011},{level:2,title:"工作原理",slug:"工作原理",normalizedTitle:"工作原理",charIndex:12690},{level:2,title:"为啥使用redux",slug:"为啥使用redux",normalizedTitle:"为啥使用redux",charIndex:12985},{level:2,title:"异步请求处理",slug:"异步请求处理",normalizedTitle:"异步请求处理",charIndex:13309},{level:2,title:"context",slug:"context",normalizedTitle:"context",charIndex:12020},{level:2,title:"Redux、Vuex",slug:"redux、vuex",normalizedTitle:"redux、vuex",charIndex:14552},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:7960},{level:2,title:"路由切换",slug:"路由切换",normalizedTitle:"路由切换",charIndex:15768},{level:2,title:"重定向",slug:"重定向",normalizedTitle:"重定向",charIndex:16666},{level:2,title:"Link、a",slug:"link、a",normalizedTitle:"link、a",charIndex:17029},{level:2,title:"获取URL参数",slug:"获取url参数",normalizedTitle:"获取url参数",charIndex:17482},{level:2,title:"获取历史对象",slug:"获取历史对象",normalizedTitle:"获取历史对象",charIndex:17813},{level:2,title:"路由模式",slug:"路由模式",normalizedTitle:"路由模式",charIndex:17968},{level:2,title:"微信小程序",slug:"微信小程序",normalizedTitle:"微信小程序",charIndex:11445},{level:3,title:"原理",slug:"原理-2",normalizedTitle:"原理",charIndex:7960},{level:2,title:"和web端区别？",slug:"和web端区别",normalizedTitle:"和web端区别？",charIndex:18639},{level:2,title:"H5",slug:"h5",normalizedTitle:"h5",charIndex:11204},{level:2,title:"App",slug:"app",normalizedTitle:"app",charIndex:18480},{level:2,title:"babel",slug:"babel",normalizedTitle:"babel",charIndex:19091},{level:2,title:"ESLint",slug:"eslint",normalizedTitle:"eslint",charIndex:19101},{level:2,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:14564},{level:2,title:"puppeteer",slug:"puppeteer",normalizedTitle:"puppeteer",charIndex:19392},{level:2,title:"TS",slug:"ts",normalizedTitle:"ts",charIndex:7546},{level:2,title:"UmiJs",slug:"umijs",normalizedTitle:"umijs",charIndex:19749},{level:2,title:"微前端",slug:"微前端",normalizedTitle:"微前端",charIndex:19812},{level:2,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:19830},{level:2,title:"低代码",slug:"低代码",normalizedTitle:"低代码",charIndex:20273},{level:2,title:"WebGL",slug:"webgl",normalizedTitle:"webgl",charIndex:20536},{level:2,title:"Web2.0",slug:"web2-0",normalizedTitle:"web2.0",charIndex:20873},{level:2,title:"CI/CD",slug:"ci-cd",normalizedTitle:"ci/cd",charIndex:21217},{level:2,title:"树莓派",slug:"树莓派",normalizedTitle:"树莓派",charIndex:21339},{level:2,title:"React Native、Flutter",slug:"react-native、flutter",normalizedTitle:"react native、flutter",charIndex:21464},{level:2,title:"RN",slug:"rn",normalizedTitle:"rn",charIndex:21491},{level:2,title:"Flutter",slug:"flutter",normalizedTitle:"flutter",charIndex:21477},{level:2,title:"uniapp",slug:"uniapp",normalizedTitle:"uniapp",charIndex:21797},{level:2,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:21816},{level:3,title:"常用指令",slug:"常用指令",normalizedTitle:"常用指令",charIndex:21829},{level:2,title:"洋葱模型",slug:"洋葱模型",normalizedTitle:"洋葱模型",charIndex:21989},{level:2,title:"WebRTC",slug:"webrtc",normalizedTitle:"webrtc",charIndex:22009},{level:3,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:22142},{level:2,title:"元宇宙",slug:"元宇宙",normalizedTitle:"元宇宙",charIndex:22218}],headersStr:"🙋 反问 问业务面试官 问HR 🔥 被问 最有挑战的事 职业规划 优缺点 🍅缺点 🍅优点 为啥不考研？ 为什么选择我们公司？ 对我们公司了解多少？ 擅长啥？ 期望薪资 如何看待加班 有其它offer吗 希望与什么样的上级共事 不喜欢和什么人打交道 希望加入什么样的公司？ 入职如何开展工作 可以来实习吗 最能概括你的三个词？ 失败的经历 实习收获 看了啥书 注意 项目深度 Webpack loader、plugin proxy原理？ 早期npm yarn npm参数 1.不填参数： 2.使用--save： 3.使用--save-dev： 4.使用 -g： 运行npm run xxx发生了啥？ package.json package-lock.json pnpm 为啥选taro 踩坑记录 基本 工作原理 为啥使用redux 异步请求处理 context Redux、Vuex 原理 路由切换 重定向 Link、a 获取URL参数 获取历史对象 路由模式 微信小程序 原理 和web端区别？ H5 App babel ESLint 区别 puppeteer TS UmiJs 微前端 微服务 低代码 WebGL Web2.0 CI/CD 树莓派 React Native、Flutter RN Flutter uniapp Linux 常用指令 洋葱模型 WebRTC 应用场景 元宇宙",content:"# 软技能\n\n\n# 🙋 反问\n\n\n# 问业务面试官\n\n[我为公司提供的价值]\n\n 1. **业务？**技术栈是什么?团队规模\n 2. 对这个岗位的预期是什么？ 如果我来做，希望我在短期或长期内完成什么目标？\n 3. 公司对于一个合格的人才是什么要求\n 4. 对于公司/部门/小组（确定面试官的职位）来说，现在什么是最重要的优先级？如果我入职了，有什么工作是需要我立马去做的？\n 5. 您认为优秀员工的标准是什么？(问题太泛)\n 6. 如果我被录取了，请问贵公司更看重我哪方面的优势呢？这样可以让面试官回想一下你的优点\n\n[问leader]\n\n判断leader是否具有领导力\n\n 1. 对日报 周报 的看法？\n 2. 部门构成，年龄构成是什么样的？\n 3. 组织架构，我向上级直接汇报的领导的层级是什么？\n 4. 这个工作和哪个部门配合比较多，我们之间工作的交集集中在哪里？\n\n[部门主管]\n\n 1. 如果我可以入职这个岗位，您对我3到5年的建议是什么呢？\n\n\n# 问HR\n\n之前我确实有很多问题想问，但是在刚才经过和您的一番沟通之后，您已经完全解答了我所有的疑惑，非常感谢，我也期待我能够入职\n\n 1.  年终奖的构成，部门普遍能拿到多少\n\n 2.  职级情况、晋升机制\n\n 3.  所在部门校招hc整体情况\n\n 4.  三方后提前实习的工资情况\n\n 5.  工资是否有可谈空间\n\n 6.  一个典型的一天或者一周的工作是怎样安排的？\n\n 7.  工作内容？男女比例？岗位分配？\n\n 8.  您觉得公司氛围如何\n\n 9.  公司对人才的培养和晋升制度是怎样的\n\n 10. 公司绩效考核是怎样的？绩效影响哪些事情？多少人能拿到合格绩效？\n\n论我今天在面试中是这么反问的，笑死^^\n\n 1. 可以分享一些您对我们校招生的建议吗？\n 2. 方便的话，可以透露下 您工作已经多久了吗？\n 3. 可以的话，可以分享一些 从学生到工作转变这段期间，一两点给您印象最深刻的吗？\n 4. 如果您对现在工作打分的话，您会怎么权衡呢？\n 5. 您平常是早几晚几呢？\n 6. 站在您的位置，可以分享您对您未来3-5年 在互联网行业的职业规划吗？\n\n\n# 🔥 被问\n\n\n# 最有挑战的事\n\n问题-角色-过程-结果-复盘\n\n可以是突破了一个固有的自己的行为表现\n\n比如 某个第一次，可以说对自己的影响和改变，从中得到的认识\n\n面试官希望的 我通过一个具体的事例，描述遇到的有难度且自己解决了的事\n\n\n# 职业规划\n\n🌰 这个问题我也有去思考过，对我自己而言，我和您分享一下现下我对几个阶段的规划吧\n\n第一阶段，一年之内我要求自己通过快速高效的学习，努力踏实做好本职工作，不断提高自己的专业和技能水平。同时我也会在1-2年内建立起对本行业、对竞品较为全面而深刻的了解\n\n在第二阶段，自己入职的两年内，我希望自己的能力可以继续稳定提升，继续学到更多与工作相关的知识。希望自己在工作中能够独当一面，去为某个具体的事情、具体的项目负责，能够为公司解决具体的问题\n\n在第三阶段，差不多入职2-3年，我希望能在工作中能有更多的创新与发展，有能力参与公司的重要项目，并不断推进发展，锻炼自己的领导能力和沟通协作能力，扩大团队影响力，为公司的业务发展贡献力量，为公司带来更大的价值\n\n总之，行业上有所发展+岗位上深耕\n\n\n# 优缺点\n\n考验 分析能力和自我意识\n\n\n * # 🍅缺点\n\n> 是缺点，同时附上解决办法，不能伤害到工作的缺点，不能和公司提出的要求相悖\n\n联系所学专业的发展趋势(知识结构不甚合理、专业知识不足以应对新的挑战)\n\n对运维那块部署相关不熟悉，经验不足，对某块边缘知识不够了解\n\n🌰 我对自我认知的确定就是现在还年轻，对于行业知识，业务的理解不够深**，缺乏实践经验，社会阅历较浅**，这块需要自己多去参与历练，同时做好总结和复盘工作\n\n然后在项目过程中我也发现自己有时候会过于局限技术细节而忽视产品业务的重要性，导致开发过程受阻，比如以前会因为一个技术点的流程不同卡顿 ，现在会积极参与产品业务的早起阶段，加强对业务的理解\n\n\n * # 🍅优点\n\n能力+实例+对工作业绩的作用\n\n> 具体化，比如管理一个项目，用了哪些手段，使项目进度加快，质量得到提升\n\n和钻研精神、沟通能力和深度思考\n\n做事有计划、做事全力以赴，或者说是一个比较拼命的人。一旦确定了目标，会尽自己全部的力量，直到成功\n\n比较有条理，个人物品和工作文件都很有规律\n\n善于发现问题，解决问题，求知欲望强，有好奇心\n\n有较强的信息检索能力，擅长通过国外论坛/文档解决技术问题\n\n热爱互联网，对互联网产品和技术有浓厚的兴趣，热衷于追求技术极致与创新\n\n优秀的分析问题和解决问题的能力，能够快速学习，主动性和责任心强\n\n学习能力：学习方法/速度\n\n身体素质：啥病没有，基本没有感冒过，能加班，吃苦耐劳\n\n对技术的追求：空闲时间都研究XX技术，有新的技术，自己就去尝试，做一个小demo （这块可以放心吹，HR也不懂）\n\n团队合作：适应团队协作，在校的时候 就 组织XXX活动，沟通能力好，在团队是 润滑剂 ，能让不同性格的人都愉快合作在一起\n\n工作态度：工作认真，学校老师安排的任务，都是超前交付，责任心强，如果项目因为我的失误出问题 会特别自责\n\n🌰 因为我经常进行总结和复盘，包括学习工作和生活，工作上，我有良好的沟通能力和团队合作精神，有较强的适应能力，环境改变时，首先要积极学习，所谓自助者天助，其次，更为重要的是要学会寻求帮助，和团队共同推进项目的开展\n\n另一方面，我觉得自己主观能动性也比较强， 会对任务进行合理规划并严格执行， 做事认真不拖沓 ，会给自己预留出足够的容错和复盘时间，不至于耽误团队进度，影响整体安排\n\n生活上，我自己本身也有写日记的习惯，我是一个做事有计划的人，我习惯于提前将生活和工作安排得井井有条，不会遗漏重要的事情，做事情有计划并全力以赴\n\n以上就是我对自己优缺点的一个认知\n\n\n# 为啥不考研？\n\n🌰 看个人选择和规划，更想去实际的环境中锻炼自己的能力，同时能参与到团队中和大家一起完成共同的目标对我来说成就感更多，收获也会更多，也能为公司做出自己的贡献\n\n\n# 为什么选择我们公司？\n\n夸！使劲夸！夸公司、夸行业、夸价值观……\n\n行业好+公司好+岗位符合自己的期待\n\n从技术氛围，职业发展，公司潜力等方面说为什么选择这家公司。\n\n表现自己如何如何看好这家公司，想要和这家公司一起成长\n\n贵公司非常符合我的职业规划\n\n你很优秀我也很优秀，我们很般配\n\n第一，公司目前所处的行业是我十分看好的，因为XXX（公司业务所在的大行业）是未来的发展趋势，同时XXX（用一句话总结这个行业是在上升期），我觉得有很大的机遇。\n\n第二，公司的业务也是我非常看好的，因为XXX（公司的具体业务）虽然已经发展了一段时间，但是对比一线城市/领头企业/国外仍然是有差距的。\n\n第三，XXX岗位（你应聘的岗位）是我希望能够深入发展的方向。\n\n结合以上，我非常希望能够跟公司的业务、产品，一起成长、一起发展。所以，非常希望能够有机会加入公司\n\n🌰 首先，我个人非常喜欢贵公司的企业文化和技术氛围，很尊重公司以人为本的理念，包括对社会的反馈相关的共享都是值得赞美的\n\n同时，贵公司非常注重员工的个人提升这一点我也觉得是非常棒的，因为员工的进步可以反哺公司的发展，有利于公司团队走得持久走得长远\n\n公司目前所处的行业是我十分看好的，因为XXX（公司业务所在的大行业）是未来的发展趋势，同时XXX（用一句话总结这个行业是在上升期），我觉得有很大的机遇，这一方面刚好也是我比较感兴趣的一块\n\n最后，XXX岗位（你应聘的岗位）也是我自己希望能够进行深入发展的方向。\n\n综合以上，我觉得贵公司很符合我的职业规划，同时也非常希望能加入贵公司和贵公司的产品业务一起成长、一起发展\n\n\n# 对我们公司了解多少？\n\n（面试前一定要提前查询该公司主营业务）\n\n🌰 我了解到我们公司主要是做...业务的，主要面向...国家/群体等，提供...服务的，近期公司的品牌在...发展等等（根据公司的实际情况来回答）\n\n\n# 擅长啥？\n\n总结，学习，阅读文档，提炼重点，复盘\n\n🌰 经过对自己的复盘和自省，我觉得自己主要擅长总结和复盘以及对周围环境的适应\n\n因为我一直有写日记的习惯，每次对于课程的学习或是参与项目的一个阶段，我都会有复盘的习惯，这种不断自省和总结的习惯也为我带来了很多帮助，同时以输出的方式倒逼自己的输入，对于核心竞争力的提升也是一个不错的渠道\n\n\n# 期望薪资\n\n个人情况+公司情况+对比报价\n\n要听他没说什么，而不是说了什么\n\n比自己预期的高一些，比如20k说成22k，但是不能把话说太死\n\n但是，由于公司的薪资结构有差异，所以要根据咱们公司的薪资结构，薪资预算范围再看\n\n比如：公司在郊区，租房便宜，我就说，公司在郊区，比较偏啊；如果公司在市中心，我就说租房贵啊\n\n就我的面试表现，咱们公司最高可以给到多少？\n\n> 弱化对方提出的福利，抓住对方福利的劣势，作为我的要求，以此为条涨薪\n\n预算是15-20，你的期望是17，报18~20。坐等HR还价，再配合深度的思考、评估，做一个艰难的决定。一边表达期待一边说，如果能给到17也可以\n\n当然如果手上有其他的offer也可以小心透露一下聊聊，比如给到多少肯定是优先考虑，非常喜欢贵公司\n\n\n# 如何看待加班\n\n愿意牺牲自我时间帮助团队和企业，强调责任心，无意义的加班的话就好好学习\n\n 1. 紧急/⻓期加班\n 2. 紧急加班，这是公司都会遇到的情况，愿意牺牲时间帮助公司和团队\n 3. ⻓期加班，会磨练技能，提⾼效率，团队⻓期加班，会帮助团队找到问题，利⽤⾃动化⼯具或者更⾼效的协作流程来提⾼效率\n\n🌰 肯定是ok的\n\n首先，我是以应届生的身份进入公司，我需要更多的时间来进行学习和完成社会上角色的转换，我觉得公司里也有很多技术需要我去学习。\n\n在之后我觉得工作时间是和我的职责和项目进度来保证的，我会尽最大的努力在规定时间内完成工作任务，如果是未完成，或者是紧急工作，我也会适应公司的节奏和加班的强度。\n\n\n# 有其它offer吗\n\n不交实底，也不过分吹牛\n\n没有offer的话\n\n🌰 我才开始面试，时间不长，目前有一两个机会 在复试 跟 终试的这个阶段\n\n有offer\n\n🌰 有收到两三个offer，不过呢，我关注咱们公司已经很长时间了，非常看好咱们公司的发展方向和目前的经营理念。这个岗位呢 也是我很喜欢的，所以非常珍惜这次机会，也特别期待能得到咱们公司的认可\n\n\n# 希望与什么样的上级共事\n\n回避对上级具体的希望，转移到对自己的要求上\n\n🌰 因为我们是以应届生的身份加入公司的，这是一个从学校到职场身份的切换，对于公司业务 相关的东西都是需要多熟悉的，可以的话，我希望上级能够对我多加指导\n\n对于工作中相关的东西多加提点，以让我们更加快速灵活地适应团队日常工作的开展和项目的开发\n\n\n# 不喜欢和什么人打交道\n\n分析不好相处的原因，强调对良好人际关系的重视，处理好同事/上级的真诚合作态度\n\n🌰 我是属于那种有耐心，性子不急躁，情绪稳定的人，一般来说，和什么人都合得来，但若遇到没有团队协作精神的人，或对工作态度不积极的人，我会比较难融入，因为这样导致的结果不仅仅是我们个人之间了，我们都知道沟通协作对一个团队工作开展的重要性，我会根据不同的特点采取不同人际协调、合作方式，避免耽误项目进度，影响团队间的关系\n\n\n# 希望加入什么样的公司？\n\n潜台词就是我就想要加入贵司这样环境的公司\n\n公平竞争，共同进步，互相团结\n\n从公司规模（平台）、企业文化、地域、薪资、人才培养机制（晋升/个人发展）、公司产品、公司底蕴等方面进行阐述。比如一个公司的平台好，可以重点突出这个点\n\n🌰 首先，我觉得是工作氛围和企业文化吧，在一个公平和睦的环境中工作对我们效率的提升也是有帮助的，可以更加心无旁骛的投入工作本身，不至于考虑太多其他无关紧要的因素\n\n其次就是公司的地域、规模相关(结合具体情况具体分析！！)\n\n公司的产品业务线是我非常感兴趣的，对于个人进步提升相关也需要关注下，因为成长是双向的，当员工能够更上一层楼时，也能以更快的速度为公司提升更多的价值，反哺公司\n\n差不多就是这些\n\n\n# 入职如何开展工作\n\n对岗位的了解+表忠心+工作方法+工作态度\n\n🌰 我有了解到我的大概工作内容是XXX\n\n入职前，我会通过前辈详细去了解我入职部门相关信息，包括部门负责业务 生产线 及我入职后汇报工作成果的窒息领导等\n\n和我的mentor及时沟通请教，查看有关文档，如何能够快速地上手项目\n\n保持一个不断学习的状态和自己的执行力\n\n\n# 可以来实习吗\n\n这个是坑！先问清楚是签了三方来实习，还是实习转正的机会！！！\n\n🌰 如果是签了三方再去实习，是可以的\n\n我也很希望可以提前进入公司提前适应节奏和学习新知识\n\n\n# 最能概括你的三个词？\n\n耐心 负责 坚持\n\n自省 专注 主动 坚持 信心 责任 乐观\n\n🌰 学习 心态 执行力\n\n学习包括两个方面，有随时学习的意识和良好的学习方法。遇到不懂的东西就马上去学习，上网查资料，向同行的高手学习，这都是我经常用的学习方法。\n\n心态好，遇到困难不会被困难吓住，不会退缩，我会尽自己最大的努力来解决。执行力：执行力强，我每天坚持学习，写总结反思自己\n\n这是一个不断更迭的领域，需要我们有终身学习的能力\n\n做事情认真负责，专注做好自己的工作，遇到困难不轻言放弃，而是想方设法解决\n\n其次就是执行力，光说不做谁都会，我们要看一个人做了什么，要做行动上的巨人\n\n不断地对过去的自己表示不满足，同时总结复盘，这是一个不断学习不断进步的过程\n\n\n# 失败的经历\n\n之后也有复盘整改和提升，会很快振奋起来的那种经历\n\n🌰 那就是考六级吧，第一次考的时候离及格差了2分，其实我的英语成绩从初中开始都是属于不错的类型的，当时考六级时有点不在状态，加上对六级题目难度的判断不是特别地全面，得知没有过的时候，也是蛮伤心的，后面调整过来 就开始寻找一个正确的学习方法，想着下次如何提升自己的成绩\n\n找到一套学习方法后，还需要每天固定的时间练习，包括听力 阅读 写作，第二次考试的时候，就涨了将近100分\n\n这一点我学到的东西也是蛮多的，首先，不能焦躁，其次，要有自己发展进步的轨道和时区，多去专注于自己技术能力的发展，其次就是要稳住，多从过去的教训中汲取经验\n\n\n# 实习收获\n\n实习都做了什么。\n\n实习中遇到了哪些问题（技术上，开发流程上，部门沟通上）。\n\n你是如何解决这些问题的。\n\n实习中收获了什么 技术上成长 （学习了哪些技术组件，自己有没有去深挖）\n\n代码风格上 （如何写出易于维护的代码）\n\n开发流程上 （单元检测，打日志，Git团队合作）\n\n对业务理解能力上 （如果把业务场景转为系统设计转为工程代码，都考虑了哪些问题）\n\n\n# 看了啥书\n\n《图解HTTP》\n\n《JavaScript高级程序设计》\n\n阮一峰老师写的《ECMAScript 6 入门》\n\n《JavaScript 权威指南》犀牛书\n\n《高性能JavaScript》\n\n《深入理解ES6》\n\n《你不知道的JavaScript》\n\n\n# 注意\n\n不抢答\n\n“水深则缓流，人贵则语迟”\n\n不管问题多简单，回答之前停顿思考，哪怕一秒。因为每一次提问，都是面试官在我身上找价值的过程，而不是找不足\n\n有好奇心\n\n面试官：我就很好奇，你真的不关心我们的**作息时间，薪资待遇，审批流程**吗？你对我们很了解吗？你对我不感兴趣吗？\n\n不用面试题反问面试官\n\n面试官：你要知道不管你是有意无意，是不是真的虚心求教。我们都有一种被人“戏弄”的“错觉”。面试仅仅是一个双向选择的过程，不是一个你提升自我的过程\n\n> 测评\n\n前后一定要一致\n\n必要时记录关键词提醒自己\n\n\n# offer有关\n\n谈offer要注意哪些事项（避坑指南）\n\n还有应届生不关注五险一金？来看看五险一金的影响\n\n\n# 🌈 star法则\n\nstar法则超好用\n\n 1. situation 项目背景和环境\n 2. task 任务职责\n 3. action 基于任务采取的措施和应对方法\n 4. result 收获和总结\n\n项目如何描述\n\n\n# 简历\n\n个人信息明确\n\n项目描述丰富点\n\n个人贡献详细一点\n\n总结\n\n【项目经验】分 「项目描述」「个人工作」「个人收获」写\n\n * 代码风格，编程风格对项目开发的帮助，亲身体会对技术的追求\n\n * 开发日志和上线日志 单元检测\n\n * git上的使用\n\n * 对业务理解，业务场景转换为系统设计，系统设计转换为工程代码\n\n * 状态机 状态归一化\n\n\n# 项目深度\n\n 1. 你的项目的技术难点是什么？\n 2. 你是如何克服这个技术难点的？\n 3. 你做这个项目的收获是什么？\n 4. 为什么使用这个技术/组件？\n\n\n# 组件封装\n\n先说 为啥出现 组件封装的需求\n\n其次说为啥需要组件化开发\n\n * 减少代码量\n * 支持共享组件库\n * 减少开发成本\n * 代码易维护\n\n啥时候需要封装组件\n\n设计原则\n\n * 层次结构和类图\n\n具体细节的实现，例如数据类型，方法实现，所需状态属性\n\n * 纯粹的state变化\n * 统一/集中的状态管理\n\nRedux或Vuex\n\n * 低耦合高内聚\n\n呈现更好复用性 而不 受限于特定上下文环境\n\n * 模块化\n\n命名污染，保持作用域、变量的独立性\n\n可使用命名空间\n\n * 样式隔离\n\n * 数据配置外部处理，外部传入\n\n对props做数据校验\n\n * 数据传递不依赖全局\n\n数据泄露\n\n内存占用过大\n\n * 使用文档(配套的md文档)\n\n标注组件名、入参、事件\n\n\n# 构建工具\n\n前端工程化那些事\n\n构建工具：rollup、Parcel、grunt、gulp\n\n\n# Webpack\n\nwebpack 面试题整理\n\n\n\n\n# loader、plugin\n\n【loader处理某一类文件而plugin可以做「任何」事】\n\nloader webpack本身只能打包JS和JSON文件，但实际中我们还有CSS 、SCSS、png和TS等其他文件，此时我们就需要使用loader让他们正确打包\n\nloader 处理编译JS和JSON以外的文件时用——翻译官\n\nLoader——加载器，本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果\n\nLoader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是 Object，内部包含了 test(类型文件)、loader(使用)、options等属性啥加载\n\nplugin可以在webpack运行到某个阶段时，帮助我们做一些事情，类似于React/Vue的生命周期\n\nPlugin——插件，扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 监听这些事件，在合适的时机通过 提供的 API 改变输出结果。是扩展器，在打包过程中，基于事件驱动的机制，监听webpack打包过程中的某些节点，执行广泛的任务\n\n\n# proxy原理？\n\n> 为啥 配置webpack的proxy 可解决跨域？\n\nproxy是webpack提供的代理服务，基本行为——接收客户端发送的请求 转发给其他服务器，便于在开发模式下解决跨域问题\n\n实现代理需要中间服务器，webpack-dev-server 是webpack推出的一款开发工具，将自动编译和自动刷新浏览器等系列对开发优化的功能集成\n\n只适用于 开发阶段\n\nproxy—— 利用http-proxy-middleware http代理中间件，实现请求转发给其他服务器\n\n\n# npm\n\n\n# 早期npm\n\nnpm v2 设计很简单，安装依赖时将依赖放到node_modules；若某个直接依赖A依赖于其他依赖包B，依赖B会作为间接依赖，安装到依赖A的文件夹，可能多个包出现同样依赖递归，若项目过大 必然形成巨大的依赖树，出现重复，形成嵌套地狱\n\n\"嵌套地狱\"\n\n * 依赖树层级过于深不利于排查和调试\n * 依赖分支中可能出现同样版本相互依赖的问题\n\n重复问题带来什么后果？\n\n * 安装的结果占据空间资源\n * 依赖重复造成安装依赖时间过长\n * 目录层级过深，文件路径过长，出现删除不掉node_modules的情况\n\n\n\n\n# yarn\n\n新的JavaScript包管理器。 解决历史 npm 不足(npm对于依赖的完整性和一致性的保证，安装速度很慢)\n\n2016年， npm还没有package-lock.json文件，安装速度慢，稳定 很差，yarn解决了：\n\n * 确定性: yarn.lock等机制， 不同安装顺序，相同依赖关系在任何 环境容器 都 以相同方式安装\n * 采用模块扁平化的安装模式: 不同版本依赖包，按照 策略，归结 单个版本;避免创建多个版本造成冗余(目前版本的npm也有优化)\n * 网络性能更好: yarn采用请求排队 理念，类似 并发池连接， 利用网络资源; 引入安装失败的重试机制\n * 采用缓存机制，实现 离线模式 (目前的npm也有类似的实现)\n\n\n# npm参数\n\ndevDependencies：用于开发环境\n\ndependencies：用于线上环境，生产环境\n\n8.x版本中的容错设计\n\n\n\nnonuplets 九胞胎！\n\n\n# 1.不填参数：\n\nnpm install\n\n\n1\n\n\n\\1. 仅安装模块到项目node_modules目录下。\n\n\\2. 不会将模块依赖写入devDependencies或dependencies 节点。\n\n\\3. 运行 npm install 初始化项目时不会下载模块依赖。\n\n\n# 2.使用--save：\n\nnpm install --save\n\n\n1\n\n\n\\1. 安装模块到项目node_modules目录下。\n\n\\2. 会将模块依赖写入dependencies 节点。\n\n\\3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。\n\n\\4. 运行npm install --production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。\n\n\n# 3.使用--save-dev：\n\nnpm install --save-dev\n\n\n1\n\n\n\\1. 安装模块到项目node_modules目录下。\n\n\\2. 会将模块依赖写入devDependencies 节点。\n\n\\3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。\n\n\\4. 运行npm install --production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。\n\n\n# 4.使用 -g：\n\nnpm install -g\n\n\n1\n\n 1. 安装模块到全局，不会在项目node_modules目录中保存模块包。\n\n\\2. 不会将模块依赖写入devDependencies或dependencies 节点。\n\n\\3. 运行 npm install 初始化项目时不会下载模块。\n\n\n# 运行npm run xxx发生了啥？\n\n去package.json中招scripts对应的xxx，执行xxx的命令，npm run serve实际执行 vue-cli-service serve\n\n> 为什么不直接执行vue-cli-service serve\n\n直接执行报错，因为OS中不存在vue-cli-service 指令\n\n> 为啥npm run serve不报错\n\n安装依赖时，通过npm i xxx执行，在node-modules目录中创建好可执行文件，.bin 是一个软链接，可知道其实一个脚本，使用npm run serve执行vue-cli-service serve时，没有安装这个全局命令，但是npm会到node-modules中找到对应文件 执行 脚本\n\n> .bin目录下的软链接何处而来？它如何知道执行什么\n\n\n# package.json\n\n> ~ ^ *\n\n1.2.3\n\n主要版本：更改代表一个破坏兼容的大变化，若用户不适应主要版本更改，内容将无法正常工作\n\n次要版本：更改不会破坏任何内容的新功能\n\n补丁：更改不会破坏任何内容的错误修复\n\n（1）指定版本：\"axios\": \"0.21.0\"，表示安装0.21.0的版本\n\n（2）~指定版本： \"core-js\": \"~3.6.5\"， 表示安装3.6.x的最新版本（不低于3.6.5），但是不安装3.7.x，安装时不改变大版本号和次要版本号\n\n（3）^指定版本：\"antd\": \"^3.1.4\"， 表示安装3.1.4及以上版本，但是不安装4.0.0，安装时***不改变大版本号***\n\n（4）* 安装最新版本的依赖包，*1.2.3 会匹配 x.x.x\n\n^ 版本更新可能比较大，会造成项目代码错误，建议使用 ~ 标记版本号，酱紫可以保证项目不出现大的问题，也能保证包中的小bug 得到修复\n\n* 意味着安装最新版本的依赖包，缺点同上，可能造成版本不兼容，慎用！！\n\n\n# package-lock.json\n\n为了解决不同人电脑安装的所有依赖版本都是一致的，确保项目代码在安装所执行的运行结果一样\n\nnpm(^5.x.x.x) 后才有\n\npackage-lock.json 会在 npm 更改node_modules 目录树或 package.json 时自动生成，准确描述当前项目npm 包的依赖树，在随后的安装中 根据 package-lock.json 安装，保证是同一依赖树，不考虑这个过程中是否有某个依赖有小版本更新\n\n目的——对整个 依赖树 进行版本固定的（锁死）\n\n当我们下次再npm install时候，npm 发现如果项目中有 package-lock.json 文件，会根据 package-lock.json 里的内容来处理和安装依赖而不再根据 package.json\n\n> 使用cnpm install时候，不会生成 package-lock.json ，也不会根据 package-lock.json 安装依赖包，还是使用 package.json 安装\n\n\n# pnpm\n\n速度快、节省磁盘空间的软件包管理器\n\n> 快速\n\n是同类工具速度的将近 2 倍\n\n> 高效\n\nnode_modules 中的所有文件均链接自单一存储位置\n\n> 支持单体仓库\n\n内置了对单个源码仓库中包含多个软件包的支持\n\n> 权限严格\n\n创建的 node_modules 默认 非扁平结构，因此代码无法对任意软件包进行访问\n\n\n# Nginx\n\n作为一名前端，该如何理解Nginx？\n\n前端工程师不可不知的Nginx知识\n\n\n# 🍅Taro\n\n\n# 为啥选taro\n\n通用性问题\n\n转换为H5页面\n\n这是学生团队，需要高手 低手，一个易用性\n\n锻炼大家解决问题的能力，而不是有问题就找导师，然后就成了 排坑 工具，这样得不到收获，没有锻炼\n\n确实有很多坑！\n\n一个页面不像是原生中4个文件\n\n原生的v-for和react的list遍历问题\n\n\n# 踩坑记录\n\nTaro主打react技术栈\n\n项目体积过大，无法预览，要进行分包处理\n\nTaro.showToast添加image属性时，图片不显示bug\n\n原因：Taro.showToast中引用了图片，但图片无法被打包到微信小程序中\n\n解决：config/index.js处理\n\ncopy: {\n    patterns: [\n        { from: 'src/imgs/', to: 'dist/imgs' } // 指定需要copy的文件\n    ]\n}\n// 使用时image路径\nTaro.showToast({\n  title: '上传成功',\n  image: '/imgs/success.png',\n  duration: 2000\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 🌈 DvaJS\n\nVuex、Flux、Redux、Redux-saga、Dva、MobX\n\n> 为啥使用dva react\n\ndva 一个基于redux和redux-saga的数据流方案，为了简化开发体验，dva额外内置了react-router和fetch， 轻量级的应用框架。\n\ndva = React-Router + Redux + Redux-saga\n\n将redux的store进一步封装，很好地解决了异步数据流和数据源不一致的问题\n\nDva官网\n\n\n# 🙋 Redux\n\nRedux官网\n\nRedux 是Reducer+Flux，——视图层框架，帮助处理共享状态管理\n\nredux 是JS应用程序的可预测！！！状态容器，通用的context提供者，可以应用在任何一个应用中——Provider 组件！\n\nProvider只是把渲染工作完全交给子组件，提供Context包住最顶层组件\n\nContext提供全局可访问的对象，但是全局对象应该避免，只要有一个地方做了修改，其他地方会受影响\n\ncontext 只有对个别组件适用，不要滥用！\n\nRedux的store封装得好，没有提供直接修改状态功能，克服了全局对象的缺点。**且一个应用只有一个Store，**store是context唯一需要，不算是滥用\n\n> redux对比flux\n\n 1. Redux没有Dispatcher\n 2. Redux只有一个Store而Flux有很多Store\n 3. Action对象由Store直接接收处理\n\n\n# 基本\n\n它认为：\n\n * web应用是一个状态机，视图和状态一一对应\n * 所有的状态，保存在一个对象中\n\n\n\n应用程序的全局状态存储在单个store内的对象树中。更改状态树的唯一方法是创建action(返回action对象)，要指定状态如何更新以响应操作，纯reducer函数根据旧状态和操作更新\n\n好处是 可很好扩展到大型复杂 的应用程序，使更改具有预测性和可追溯性\n\n> 原则\n\n 1. 单一数据源\n 2. state可读\n 3. 纯函数修改\n\n> 啥情况使用\n\n * 需要使用大量application状态\n * application状态频繁更新\n * 更新状态的逻辑可能很复杂\n * application具有中/大型代码库，可能由许多人开发\n\n\n# 工作原理\n\n单向数据流\n\n当多个组件需共享/使用相同状态时，简单性可能被打破\n\n可通过\"状态 提升\"父组件 解决，但并不总是有帮助\n\n解决的一种方法——组件中提取共享状态，将其放在组件树之外的集中位置，酱紫，组件树变成 \"大 视图\"，任何组件都可访问状态/触发 动作，无论在树中啥位置\n\n为代码提供更多结构和维护性\n\n> 用户交互流程\n\n 1. 用户(View)发出 action，使用dispatch\n 2. store 自动调用 reducer，传参：state 和收到的action，reducer返回新的state\n 3. state变化，store调用监听更新 View\n\n\n# 为啥使用redux\n\n前端复杂性的根本原因——大量无规律的交互(交互上存在父子、子父、兄弟组件间通信，数据也存在跨层、反向数据流)和异步操作\n\n我们很容易对这些状态何时发生、为啥发生及如何发生 失去控制，怎样才能让这些状态变化被我们预先掌握、可以复制追踪呢？\n\nRedux试图让每个state变化都是可预测的，将应用中所有动作与状态统一起来，让一切有迹可循\n\n架构层面上，我们希望UI跟数据和逻辑分离，UI只负责渲染，业务和逻辑交由其它部分处理，从数据流向方面来说, 单向数据流确保了整个流程清晰\n\nRedux做到：\n\n * 每个State变化可预测\n * 动作与状态统一管理\n * 调试简单\n * 易测试\n * 状态持久化\n * SSR\n\n\n# 异步请求处理\n\n借助 redux 的中间件 异步处理\n\n主要有 redux-thunk，redux-saga(常用)\n\n此处主要介绍 redux-saga\n\n优点：\n\n * 异步解耦，不会掺杂在 action 或 component 中，代码简洁度提高\n * 异常处理，可使用 try/catch 捕获异常\n * 功能强大，无需封装或简单封装 即可使用\n * 灵活，可将saga 串行 起来，形成异步 flow\n * 易测性\n\n缺陷：\n\n * 学习成本高\n * 体积略大\n * 功能过剩\n * yield无法返回 TS 类型\n\n> @connect\n\n连接React和Redux\n\n 1. connect通过context获取Provider中的state，通过store.getState()获取store tree上所有state\n 2. 将state和action通过 props 的方式传入组件内部，wrapWithConnect 返回一个Component对象connect，connect重新render 外部传入的元组件 wrapWithConnect ，将connect中传入的mapStateToProps ，mapDispatchToProps 与组件上原有的props 合并，通过属性的方式传给 WrappedComponent\n 3. 监听 state tree 变化。connect缓存了store tree中state的状态，根据state当前和变更前状态比较，确定是否setState触发connect及re-render\n\n> connect的工作\n\n 1. 把store上的状态转化为内层傻瓜组件的prop\n 2. 把内层傻瓜组件的用户动作 转化为派送给store的动作\n\n\n# context\n\ncontext“上下文环境”，让一个树状组件上所有的组件都能访问一个共同的对象，context 由其父节点链上所有组件通过 getChildContext() 返回context对象组合而成，通过context 可以访问其父组件链上context\n\ncreateContext创建context对象，有_currentValue保存值，引用了Provider和Consumer两个对象，Provider和Consumer里有 _context属性引用了context\n\njsx渲染时会把Provider和Consumer对象保存在VDOM 上，后面reconcile时会转移到fiber的type属性上，处理fiber节点时会根据类型做不同处理\n\n如果是Provider，会根据传入的value修改context的值，也就是 _currentValue属性\n\n如果是 Consumer，会读取 context的值，触发子组件render\n\n函数组件使用useContext的hook，最终也是读取同一个context的_currenValue值\n\n\n# Redux、Vuex\n\n区别\n\n * vuex改进了redux中的action和reducer，以mutations 变化函数取代 reducer，无需 switch，只需在mutations中修改对应state即可\n * vuex无需订阅re-render，只需要生成新的state\n * vuex数据流，view调用store，commit提交对应请求到store中对应mutations，store修改，vue检测state修改自动渲染\n\nvuex弱化dispatch和reducer，更简易\n\n共同点\n\n * 单一数据流\n * 可预测变化\n\n都是对MVVM思想服务\n\n> 中间件如何拿到store和action\n\nredux 中间件本质是一个函数柯里化\n\n涉及 源码\n\n\n# React-Redux\n\n如果不用 react-redux，手动处理 Redux 和 UI 的绑定，需要写很多重复的代码，容易出错，且有很多 UI 渲染逻辑的优化不一定能处理好\n\n为了让redux更好适用react的一个库\n\n管理状态、组织代码\n\nconnect连接组件和store\n\nconnect接受两个参数：mapStateToProps和mapDispatchToProps。定义 UI 组件的业务逻辑。前者负责输入逻辑，将state映射到 UI 组件的参数（props），后者输出逻辑，将用户对 UI 组件的操作映射成 Action\n\nimport { connect } from 'react-redux';\n\nconst Component = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Con);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Redux-Saga\n\nReact中间件，更好解决异步操作，一个直观的 Redux 副作用管理器\n\n易于管理、易于测试和高效执行\n\n相当于在redux原有数据流中多了一层，对Action进行监听，捕获到监听的action可以派生一个新的任务维护state\n\n通过Generator创建，同步的方式写异步代码，不会被细节困扰\n\n\n# 💜 React-Router\n\n\n# 原理\n\n客户端路由 实现原理\n\n * 基于hash 路由，监听hashchange 事件，location.hash=xxxx 改变路由\n * 基于H5的 history，通过history，pushState 和 replaceState 修改URL，能应用 history.go() 等 API，允许通过 自定义事件 触发实现\n\nreact-router实现：\n\n * 基于 history 库实现，history知道如何监听浏览器地址变化，解析URL转换为location\n * router使用location匹配路由，渲染 Component\n\n\n# 路由切换\n\n * Route标签组件 ，通过 比较 <Route>的path属性和当前地址的 pathname 实现，匹配成功则 render，否则渲染null\n\n// when location = { pathname: '/about' }\n<Route path='/about' component={About}/> // renders <About/>\n<Route path='/contact' component={Contact}/> // renders null\n<Route component={Always}/> // renders <Always/>\n\n\n1\n2\n3\n4\n\n * <Switch> +<Route>，<Swicth>对<route>进行分组，遍历所有的子<route>，渲染匹配的第一个元素\n\n<Switch>\n    <Route exact path=\"/\" component={Home} />\n    <Route path=\"/about\" component={About} />\n    <Route path=\"/contact\" component={Contact} />\n</Switch>\n\n\n1\n2\n3\n4\n5\n\n * <Link> <NavLink> <Redirect>，<Link> 组件创建链接，会在HTML处 渲染锚(<a>)\n\n<Link to=\"/\">Home</Link>   \n// <a href='/'>Home</a>\n\n\n1\n2\n\n\n当 <NavLink>的 to 属性与当前地址匹配时，可将其定义为活跃的\n\n// location = { pathname: '/react' }\n<NavLink to=\"/react\" activeClassName=\"hurray\">\n    React\n</NavLink>\n// <a href='/react' className='hurray'>React</a>\n\n\n1\n2\n3\n4\n5\n\n\n渲染<Redirect>强制导航\n\n\n# 重定向\n\n<Redirect>实现路由重定向\n\n<Switch>\n  <Redirect from='/users/:id' to='/users/profile/:id'/>\n  <Route path='/users/profile/:id' component={Profile}/>\n</Switch>\n\n\n1\n2\n3\n4\n\n\n请求 /users/:id 被重定向去 '/users/profile/:id'：\n\n * 属性 from: string：匹配的将要被重定向路径\n * 属性 to: string：重定向的 URL 字符串\n * 属性 to: object：重定向的 location 对象\n * 属性 push: bool：若为真，重定向将会把新地址加入到访问历史记录里，且无法回退到前面的页面\n\n\n# Link、a\n\n都是链接，都是标签\n\n<Link>是 react-router 中实现路由跳转的链接，一般配合 <Route>使用，跳转 只会触发相匹配的 <Route> 对应页面内容更新，不会刷新all page\n\n<Link>行为\n\n 1. 有onClick 就 onClick\n 2. click 时阻止a 默认事件\n 3. 根据to属性，使用histor 或 hash 跳转，跳转只是链接变了，没有all page 刷新，<a>是普通的超链接\n\n<a> 禁用后咋实现跳转？\n\n手动赋值给<a>标签 location 属性\n\nlet domArr = document.getElementsByTagName('a')\n[...domArr].forEach(item=>{\n    item.addEventListener('click',function () {\n        location.href = this.href\n    })\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 获取URL参数\n\n * get 方法\n\nthis.props.location.search 获取 URL 得到字符串，解析参数，或者自己封装方法获取参数\n\n * 动态路由传值\n\n如 path='/admin/:id'，this.props.match.params.id 获取 URL中动态部分路由 id值，或者使用hooks的 API获取\n\n * query 或 state传值\n\n<Link>组件 的 to属性可以传递对象 {pathname:'/admin',query:'111',state:'111'}，this.props.location.state或 this.props.location.query 获取，一旦刷新页面 数据丢失\n\n\n# 获取历史对象\n\n * React>=16.8 ，使用 React Router的Hooks\n\nimport { useHistory } from \"react-router-dom\";\nlet history = useHistory();\n\n\n1\n2\n\n * this.props.history\n\n\n# 路由模式\n\n * BrowserRouter\n\nH5的history API控制路由跳转\n\n * HashRouter\n\nURl的hash 属性控制路由挑转\n\n\n# 各端\n\n\n# 微信小程序\n\n不需下载安装即可使用，不用担心是否安装太多应用\n\n\n# 原理\n\nwxml、wxss、JS开发，本质是单页应用，所有页面渲染和事件处理都在一个页面进行，可通过微信客户端调用原生各种接口\n\n架构时MVVM模式，视图UI和数据分离，所有更新通过数据变更实现\n\n分为Webview 和APPService，Webview展现页面，APPService处理业务逻辑、数据及接口调用，通过系统层JSBridge实现通信，实现UI渲染和事件处理\n\n小程序框架包含View视图层和APPService逻辑层，View层渲染页面，APPService用来 逻辑处理、数据请求、接口调用，他们在2个进程运行，具体实现在2个WebView运行\n\n\n\n微信将所有视图加载到WebView(View层)；所有逻辑处理的JS全部加载到另一个WebView(APPService层)，每个小程序只有一个且整个生命周期常驻内存，JSBridge封装消息通信及通过App访问OS能力的实现，消息通信在不同平台调用相应方法通信，开发环境为window.postMessage\n\n使用View层和APPService逻辑层实现双线程 的小程序运行方案，可将代码放入沙箱执行，对代码执行安全和管控\n\n一个APP运行多个小程序，采用多线程方案执行，为了性能 也防止小程序间相互影响\n\n\n# 和web端区别？\n\n运行环境\n\n * 微信小程序只能通过微信打开\n\n * web项目可以通过多个终端的浏览器打开\n\n项目规模\n\n * 微信小程序一般是小应用级别的，大小限制为2M，否则上传不了审核\n * Web项目可以支持大项目或者复杂的项目\n\n开发语言\n\n * 微信小程序是HTML＋CSS＋JS\n * Web项目可以支持多种语言\n\n开发工具\n\n * 微信小程序有专门的微信开发者工具\n\n\n# H5\n\nH5理解为一个网页，依赖外壳为浏览器\n\n可在微信 微博 qq 及所有浏览器使用，没有平台限制\n\n修改内容后可直接发布，不需审核\n\n开发容易\n\n开发高 (分配一种开发人员即可)\n\n跨平台分享（所有浏览器、及微信等嵌有浏览器功能产品），快速迭代\n\n\n# App\n\n三条主线：iOS Android H5跨平台混合开发\n\n前两者成为Native开发，后者为Hybrid开发\n\n开发语言分别 Object-C java HTML5\n\n\n# others\n\n当你有了技术深度，很可能也同时有了技术广度\n\n\n# babel\n\n\n# ESLint\n\n识别ECMAScript，按照规则给出报告的代码检测工具，避免低级错误和统一代码的风格。有效控制项目代码的质量\n\nESLint 提供了根据 AST 节点拿到它的 token 信息的 api，比如块语句可以拿到 { 的 token 信息，也就是所在的行列号等\n\n\n# 区别\n\nBabel 插件和 ESLint 插件至少两处不同：\n\n * ESLint 通过 api 拿到 AST 关联的 token 信息，检查出格式问题， Babel 插件不行\n * ESLint 自动 fix 修改代码通过字符串替换实现，Babel 通过递归打印修改后的 AST 为字符串\n\n\n# puppeteer\n\n基于 CDP 实现，就是调试模式跑了一个 Chromium，连上 CDP 远程控制\n\n * 生成页面 PDF\n * 抓取 SPA（单页应用）并生成预渲染内容（即“SSR”（服务器端渲染））\n * 自动提交表单，进行 UI 测试，键盘输入等\n * 创建一个时时更新的自动化测试环境。 使用最新的 JavaScript 和浏览器功能直接在最新版本的Chrome中执行测试\n * 捕获网站的 timeline trace，用来帮助分析性能问题\n * 测试浏览器扩展\n\n\n# TS\n\n是JS的强类型版本，编译时去掉类型和特有语法，生成纯粹的JS代码，最终运行的还是JS，TS不依赖浏览器支持，也没有兼容性问题\n\n支持所有的JS语法，在此之上对JS做了扩展，提升可阅读性\n\n更易阅读和理解代码\n\n\n# UmiJs\n\n主要解决了什么问题？\n\nwebpack打包问题\n\n因为简化了很多webpack打包问题\n\n路由跳转问题\n\n\n# 微前端\n\n微前端的前世今生\n\n\n# 微服务\n\n早期软件所有功能都写在一起，称为 单体架构，整个软件是单一的整体(类似 一体化的机器)，软件功能越多，单体架构越复杂，缺点暴露\n\n * 功能耦合，互相影响\n * 修改一行代码，软件需要重新构建和部署，成本高\n * 软件做成了整体，不可能每个功能单独开发和测试，只能整体开发和测试，导致必须 采用瀑布式开发模型\n\n面向服务架构(SOA) 将一个大型的单体程序，拆分成一个个独立服务，每个服务都是一个独立的功能单元，承担不同功能，服务之间通过通信协议连接\n\n> 优点\n\n 1. 服务功能单一，类似一个小型软件，便于开发和测试\n 2. 服务独立运行，简化架构，提高可靠性\n 3. 鼓励 支持代码复用\n 4. 单独开发和部署，便于升级\n 5. 扩展性好\n 6. 不容易出现单点故障\n\n微服务——采用容器技术的面向服务架构\n\n微服务轻量级实现，不需要新增服务器，只需要新建 容器(一个进程)，所以叫做 \"微服务\"\n\n因为 微服务 更加轻量级，所以 功能解耦和服务化 可以更彻底\n\n\n# 低代码\n\n减少编码时间，把更多时间经历用在网站体验，设计中\n\n零代码基础也可轻松构建web页面\n\n * 上手快，开发效率高\n * 无需考虑学习成本带来的负担\n * 页面可视化的加持，布局、设计、UI尽在掌握\n\n拖拽的方式 在最短时间内实现最初想法/设计\n\n> 实现\n\n * 快速完成静态页面布局\n * 确定能够被拖拽的组件有哪些，以及它们的存在方式是什么\n * 选择一种适用于各组件间进行通信的方式\n * 实现拖拽\n * 渲染被拖拽组件\n * 确保组件属性更改后可以实时映射至画布区域\n\n所见即所得\n\n技术服务于业务\n\n\n# WebGL\n\nWeb图形库 是一个JS API，可渲染高性能的交互式 3D 和2D图形，无需插件\n\nWebGL引入一个与 OpenGL ES 2.0非常一致的 API 做到这一点，该 API 可在HTML5 <canvas>元素中使用，一致性使 API 可以利用用户设备提供的硬件图形加速\n\n光栅Raster\n\n图形系统基于光栅 绘制图形，光栅 指构成图像的像素矩阵\n\n像素Pixel\n\n一个像素对应图像上一个点，通常保存图像上某个具体位置的颜色\n\n帧缓存Frame buffer\n\n绘图过程，像素信息被存放在帧缓存中，帧缓存是一块内存地址\n\nGPU由大量的小运算单元构成，每个运算单元只负责处理 很简单的运算，每个运算单元 彼此 独立，因此 所有计算 可并行处理\n\n\n# Web2.0\n\nweb2.0——用户主动获取并产生内容\n\nweb1.0——由系统向用户展示内容\n\nweb3.0——个性化内容的获取\n\n比如新浪就是1.0，你上它的网站，它放了很多新闻给你看\n\n比如google是2.0，你跟它说我要搜索最近新上映电影的信息\n\n微博是2.0，因为它是是由用户编写的内容\n\n豆瓣是3.0，它根据你一贯听歌的口味向你推荐你可能喜欢的歌曲\n\n再举个通俗的例子\n\n你去饭店，服务员把菜单放在你面前说：我们今天提供番茄炒蛋，你吃不吃？这是web1.0\n\n你去饭店跟服务员说：我要番茄炒蛋，不要番茄只要蛋，少放盐，这是web2.0\n\n你去饭店，服务员说：这位爷，您经常来咱们饭店，根据您以往的点菜习惯，我们向您推荐我们的最新菜肴番茄鸡蛋炒牛肉。这是web3.0\n\n\n# CI/CD\n\n持续集成、持续交付、持续部署\n\n作用——开发阶段引入自动化频繁向用户交付应用\n\n让持续自动化和持续监控贯穿于应用的整个声明周期(集成到测试，交付和部署)\n\n没必要纠结语义，就是一个路程，实现应用开发的高度持续自动化和监控\n\n\n# 树莓派\n\n信用卡大小的微型电脑，基于LInux\n\n别看外表“娇小”，内“心”却很强大，视频、音频等功能皆有，麻雀虽小，五脏俱全\n\n树莓派就是一台主机，可外接显示器，键盘鼠标，u盘等外设，它体积小，有很多串口和外接的口，可直接调用很多底层硬件\n\n\n# React Native、Flutter\n\n个人玩玩就RN，轻量级产品化Flutter，深度产品化原生\n\n\n * # RN\n\nRN是Facebook 的 跨平台 移动应用 开发框架——React 在原生移动应用平台的衍生产物，支持 iOS 和安卓。 RN使用JSX、CSS开发移动应用\n\n * 开发体验好，统一代码规范，无需关注移动端差异\n\n * 开发成本低，开发一次，支持Android和iOS\n\n * 学习成本低，掌握JS和React即可\n\n * 不成熟，项目版本更新维护频繁\n\n * 试错成本高，问题解决方案少\n\n * 性能不如原生\n\n * 兼容性，涉及底层需要针对Android和iOS单独开发\n\n\n * # Flutter\n\n有Dart基础\n\n\n * # uniapp\n\n有vue基础\n\n\n# Linux\n\n\n * # 常用指令\n\nrimraf 删除文件/文件夹（没想起还有这个指令）\n\nls 查看文件夹包含文件\n\npwd查看当前工作目录路径\n\nrm删除文件\n\nwhich查找某个文件的位置\n\nps查看运行进程状态\n\nkill结束进程\n\nchromd 控制用户对文件权限的控制\n\ncat 显示文件信息\n\napt-get 安装软件包\n\n\n# 洋葱模型\n\nkoa和redux\n\n\n# WebRTC\n\n实时通讯技术，允许网络应用/站点，在不借助中间媒介的情况下，建立浏览器之间点对点的连接，实现视频流/音频流/其他任意数据的传输\n\nWebRTC包含的标准使用户在无需安装任何插件/第三方软件的情况下，创建点对点的数据分享和电话会议成为可能\n\n\n> # 应用场景\n\n * 直播\n * 游戏\n * 视频会议/在线教育\n * 屏幕共享/远程控制\n\n网速和硬件越来越好的趋势下，WebRTC'有无限可能\n\n\n# 元宇宙\n\n我们在虚拟世界中与一个全新的身份一一对应，并且不会间断地“生活下去”",normalizedContent:"# 软技能\n\n\n# 🙋 反问\n\n\n# 问业务面试官\n\n[我为公司提供的价值]\n\n 1. **业务？**技术栈是什么?团队规模\n 2. 对这个岗位的预期是什么？ 如果我来做，希望我在短期或长期内完成什么目标？\n 3. 公司对于一个合格的人才是什么要求\n 4. 对于公司/部门/小组（确定面试官的职位）来说，现在什么是最重要的优先级？如果我入职了，有什么工作是需要我立马去做的？\n 5. 您认为优秀员工的标准是什么？(问题太泛)\n 6. 如果我被录取了，请问贵公司更看重我哪方面的优势呢？这样可以让面试官回想一下你的优点\n\n[问leader]\n\n判断leader是否具有领导力\n\n 1. 对日报 周报 的看法？\n 2. 部门构成，年龄构成是什么样的？\n 3. 组织架构，我向上级直接汇报的领导的层级是什么？\n 4. 这个工作和哪个部门配合比较多，我们之间工作的交集集中在哪里？\n\n[部门主管]\n\n 1. 如果我可以入职这个岗位，您对我3到5年的建议是什么呢？\n\n\n# 问hr\n\n之前我确实有很多问题想问，但是在刚才经过和您的一番沟通之后，您已经完全解答了我所有的疑惑，非常感谢，我也期待我能够入职\n\n 1.  年终奖的构成，部门普遍能拿到多少\n\n 2.  职级情况、晋升机制\n\n 3.  所在部门校招hc整体情况\n\n 4.  三方后提前实习的工资情况\n\n 5.  工资是否有可谈空间\n\n 6.  一个典型的一天或者一周的工作是怎样安排的？\n\n 7.  工作内容？男女比例？岗位分配？\n\n 8.  您觉得公司氛围如何\n\n 9.  公司对人才的培养和晋升制度是怎样的\n\n 10. 公司绩效考核是怎样的？绩效影响哪些事情？多少人能拿到合格绩效？\n\n论我今天在面试中是这么反问的，笑死^^\n\n 1. 可以分享一些您对我们校招生的建议吗？\n 2. 方便的话，可以透露下 您工作已经多久了吗？\n 3. 可以的话，可以分享一些 从学生到工作转变这段期间，一两点给您印象最深刻的吗？\n 4. 如果您对现在工作打分的话，您会怎么权衡呢？\n 5. 您平常是早几晚几呢？\n 6. 站在您的位置，可以分享您对您未来3-5年 在互联网行业的职业规划吗？\n\n\n# 🔥 被问\n\n\n# 最有挑战的事\n\n问题-角色-过程-结果-复盘\n\n可以是突破了一个固有的自己的行为表现\n\n比如 某个第一次，可以说对自己的影响和改变，从中得到的认识\n\n面试官希望的 我通过一个具体的事例，描述遇到的有难度且自己解决了的事\n\n\n# 职业规划\n\n🌰 这个问题我也有去思考过，对我自己而言，我和您分享一下现下我对几个阶段的规划吧\n\n第一阶段，一年之内我要求自己通过快速高效的学习，努力踏实做好本职工作，不断提高自己的专业和技能水平。同时我也会在1-2年内建立起对本行业、对竞品较为全面而深刻的了解\n\n在第二阶段，自己入职的两年内，我希望自己的能力可以继续稳定提升，继续学到更多与工作相关的知识。希望自己在工作中能够独当一面，去为某个具体的事情、具体的项目负责，能够为公司解决具体的问题\n\n在第三阶段，差不多入职2-3年，我希望能在工作中能有更多的创新与发展，有能力参与公司的重要项目，并不断推进发展，锻炼自己的领导能力和沟通协作能力，扩大团队影响力，为公司的业务发展贡献力量，为公司带来更大的价值\n\n总之，行业上有所发展+岗位上深耕\n\n\n# 优缺点\n\n考验 分析能力和自我意识\n\n\n * # 🍅缺点\n\n> 是缺点，同时附上解决办法，不能伤害到工作的缺点，不能和公司提出的要求相悖\n\n联系所学专业的发展趋势(知识结构不甚合理、专业知识不足以应对新的挑战)\n\n对运维那块部署相关不熟悉，经验不足，对某块边缘知识不够了解\n\n🌰 我对自我认知的确定就是现在还年轻，对于行业知识，业务的理解不够深**，缺乏实践经验，社会阅历较浅**，这块需要自己多去参与历练，同时做好总结和复盘工作\n\n然后在项目过程中我也发现自己有时候会过于局限技术细节而忽视产品业务的重要性，导致开发过程受阻，比如以前会因为一个技术点的流程不同卡顿 ，现在会积极参与产品业务的早起阶段，加强对业务的理解\n\n\n * # 🍅优点\n\n能力+实例+对工作业绩的作用\n\n> 具体化，比如管理一个项目，用了哪些手段，使项目进度加快，质量得到提升\n\n和钻研精神、沟通能力和深度思考\n\n做事有计划、做事全力以赴，或者说是一个比较拼命的人。一旦确定了目标，会尽自己全部的力量，直到成功\n\n比较有条理，个人物品和工作文件都很有规律\n\n善于发现问题，解决问题，求知欲望强，有好奇心\n\n有较强的信息检索能力，擅长通过国外论坛/文档解决技术问题\n\n热爱互联网，对互联网产品和技术有浓厚的兴趣，热衷于追求技术极致与创新\n\n优秀的分析问题和解决问题的能力，能够快速学习，主动性和责任心强\n\n学习能力：学习方法/速度\n\n身体素质：啥病没有，基本没有感冒过，能加班，吃苦耐劳\n\n对技术的追求：空闲时间都研究xx技术，有新的技术，自己就去尝试，做一个小demo （这块可以放心吹，hr也不懂）\n\n团队合作：适应团队协作，在校的时候 就 组织xxx活动，沟通能力好，在团队是 润滑剂 ，能让不同性格的人都愉快合作在一起\n\n工作态度：工作认真，学校老师安排的任务，都是超前交付，责任心强，如果项目因为我的失误出问题 会特别自责\n\n🌰 因为我经常进行总结和复盘，包括学习工作和生活，工作上，我有良好的沟通能力和团队合作精神，有较强的适应能力，环境改变时，首先要积极学习，所谓自助者天助，其次，更为重要的是要学会寻求帮助，和团队共同推进项目的开展\n\n另一方面，我觉得自己主观能动性也比较强， 会对任务进行合理规划并严格执行， 做事认真不拖沓 ，会给自己预留出足够的容错和复盘时间，不至于耽误团队进度，影响整体安排\n\n生活上，我自己本身也有写日记的习惯，我是一个做事有计划的人，我习惯于提前将生活和工作安排得井井有条，不会遗漏重要的事情，做事情有计划并全力以赴\n\n以上就是我对自己优缺点的一个认知\n\n\n# 为啥不考研？\n\n🌰 看个人选择和规划，更想去实际的环境中锻炼自己的能力，同时能参与到团队中和大家一起完成共同的目标对我来说成就感更多，收获也会更多，也能为公司做出自己的贡献\n\n\n# 为什么选择我们公司？\n\n夸！使劲夸！夸公司、夸行业、夸价值观……\n\n行业好+公司好+岗位符合自己的期待\n\n从技术氛围，职业发展，公司潜力等方面说为什么选择这家公司。\n\n表现自己如何如何看好这家公司，想要和这家公司一起成长\n\n贵公司非常符合我的职业规划\n\n你很优秀我也很优秀，我们很般配\n\n第一，公司目前所处的行业是我十分看好的，因为xxx（公司业务所在的大行业）是未来的发展趋势，同时xxx（用一句话总结这个行业是在上升期），我觉得有很大的机遇。\n\n第二，公司的业务也是我非常看好的，因为xxx（公司的具体业务）虽然已经发展了一段时间，但是对比一线城市/领头企业/国外仍然是有差距的。\n\n第三，xxx岗位（你应聘的岗位）是我希望能够深入发展的方向。\n\n结合以上，我非常希望能够跟公司的业务、产品，一起成长、一起发展。所以，非常希望能够有机会加入公司\n\n🌰 首先，我个人非常喜欢贵公司的企业文化和技术氛围，很尊重公司以人为本的理念，包括对社会的反馈相关的共享都是值得赞美的\n\n同时，贵公司非常注重员工的个人提升这一点我也觉得是非常棒的，因为员工的进步可以反哺公司的发展，有利于公司团队走得持久走得长远\n\n公司目前所处的行业是我十分看好的，因为xxx（公司业务所在的大行业）是未来的发展趋势，同时xxx（用一句话总结这个行业是在上升期），我觉得有很大的机遇，这一方面刚好也是我比较感兴趣的一块\n\n最后，xxx岗位（你应聘的岗位）也是我自己希望能够进行深入发展的方向。\n\n综合以上，我觉得贵公司很符合我的职业规划，同时也非常希望能加入贵公司和贵公司的产品业务一起成长、一起发展\n\n\n# 对我们公司了解多少？\n\n（面试前一定要提前查询该公司主营业务）\n\n🌰 我了解到我们公司主要是做...业务的，主要面向...国家/群体等，提供...服务的，近期公司的品牌在...发展等等（根据公司的实际情况来回答）\n\n\n# 擅长啥？\n\n总结，学习，阅读文档，提炼重点，复盘\n\n🌰 经过对自己的复盘和自省，我觉得自己主要擅长总结和复盘以及对周围环境的适应\n\n因为我一直有写日记的习惯，每次对于课程的学习或是参与项目的一个阶段，我都会有复盘的习惯，这种不断自省和总结的习惯也为我带来了很多帮助，同时以输出的方式倒逼自己的输入，对于核心竞争力的提升也是一个不错的渠道\n\n\n# 期望薪资\n\n个人情况+公司情况+对比报价\n\n要听他没说什么，而不是说了什么\n\n比自己预期的高一些，比如20k说成22k，但是不能把话说太死\n\n但是，由于公司的薪资结构有差异，所以要根据咱们公司的薪资结构，薪资预算范围再看\n\n比如：公司在郊区，租房便宜，我就说，公司在郊区，比较偏啊；如果公司在市中心，我就说租房贵啊\n\n就我的面试表现，咱们公司最高可以给到多少？\n\n> 弱化对方提出的福利，抓住对方福利的劣势，作为我的要求，以此为条涨薪\n\n预算是15-20，你的期望是17，报18~20。坐等hr还价，再配合深度的思考、评估，做一个艰难的决定。一边表达期待一边说，如果能给到17也可以\n\n当然如果手上有其他的offer也可以小心透露一下聊聊，比如给到多少肯定是优先考虑，非常喜欢贵公司\n\n\n# 如何看待加班\n\n愿意牺牲自我时间帮助团队和企业，强调责任心，无意义的加班的话就好好学习\n\n 1. 紧急/⻓期加班\n 2. 紧急加班，这是公司都会遇到的情况，愿意牺牲时间帮助公司和团队\n 3. ⻓期加班，会磨练技能，提⾼效率，团队⻓期加班，会帮助团队找到问题，利⽤⾃动化⼯具或者更⾼效的协作流程来提⾼效率\n\n🌰 肯定是ok的\n\n首先，我是以应届生的身份进入公司，我需要更多的时间来进行学习和完成社会上角色的转换，我觉得公司里也有很多技术需要我去学习。\n\n在之后我觉得工作时间是和我的职责和项目进度来保证的，我会尽最大的努力在规定时间内完成工作任务，如果是未完成，或者是紧急工作，我也会适应公司的节奏和加班的强度。\n\n\n# 有其它offer吗\n\n不交实底，也不过分吹牛\n\n没有offer的话\n\n🌰 我才开始面试，时间不长，目前有一两个机会 在复试 跟 终试的这个阶段\n\n有offer\n\n🌰 有收到两三个offer，不过呢，我关注咱们公司已经很长时间了，非常看好咱们公司的发展方向和目前的经营理念。这个岗位呢 也是我很喜欢的，所以非常珍惜这次机会，也特别期待能得到咱们公司的认可\n\n\n# 希望与什么样的上级共事\n\n回避对上级具体的希望，转移到对自己的要求上\n\n🌰 因为我们是以应届生的身份加入公司的，这是一个从学校到职场身份的切换，对于公司业务 相关的东西都是需要多熟悉的，可以的话，我希望上级能够对我多加指导\n\n对于工作中相关的东西多加提点，以让我们更加快速灵活地适应团队日常工作的开展和项目的开发\n\n\n# 不喜欢和什么人打交道\n\n分析不好相处的原因，强调对良好人际关系的重视，处理好同事/上级的真诚合作态度\n\n🌰 我是属于那种有耐心，性子不急躁，情绪稳定的人，一般来说，和什么人都合得来，但若遇到没有团队协作精神的人，或对工作态度不积极的人，我会比较难融入，因为这样导致的结果不仅仅是我们个人之间了，我们都知道沟通协作对一个团队工作开展的重要性，我会根据不同的特点采取不同人际协调、合作方式，避免耽误项目进度，影响团队间的关系\n\n\n# 希望加入什么样的公司？\n\n潜台词就是我就想要加入贵司这样环境的公司\n\n公平竞争，共同进步，互相团结\n\n从公司规模（平台）、企业文化、地域、薪资、人才培养机制（晋升/个人发展）、公司产品、公司底蕴等方面进行阐述。比如一个公司的平台好，可以重点突出这个点\n\n🌰 首先，我觉得是工作氛围和企业文化吧，在一个公平和睦的环境中工作对我们效率的提升也是有帮助的，可以更加心无旁骛的投入工作本身，不至于考虑太多其他无关紧要的因素\n\n其次就是公司的地域、规模相关(结合具体情况具体分析！！)\n\n公司的产品业务线是我非常感兴趣的，对于个人进步提升相关也需要关注下，因为成长是双向的，当员工能够更上一层楼时，也能以更快的速度为公司提升更多的价值，反哺公司\n\n差不多就是这些\n\n\n# 入职如何开展工作\n\n对岗位的了解+表忠心+工作方法+工作态度\n\n🌰 我有了解到我的大概工作内容是xxx\n\n入职前，我会通过前辈详细去了解我入职部门相关信息，包括部门负责业务 生产线 及我入职后汇报工作成果的窒息领导等\n\n和我的mentor及时沟通请教，查看有关文档，如何能够快速地上手项目\n\n保持一个不断学习的状态和自己的执行力\n\n\n# 可以来实习吗\n\n这个是坑！先问清楚是签了三方来实习，还是实习转正的机会！！！\n\n🌰 如果是签了三方再去实习，是可以的\n\n我也很希望可以提前进入公司提前适应节奏和学习新知识\n\n\n# 最能概括你的三个词？\n\n耐心 负责 坚持\n\n自省 专注 主动 坚持 信心 责任 乐观\n\n🌰 学习 心态 执行力\n\n学习包括两个方面，有随时学习的意识和良好的学习方法。遇到不懂的东西就马上去学习，上网查资料，向同行的高手学习，这都是我经常用的学习方法。\n\n心态好，遇到困难不会被困难吓住，不会退缩，我会尽自己最大的努力来解决。执行力：执行力强，我每天坚持学习，写总结反思自己\n\n这是一个不断更迭的领域，需要我们有终身学习的能力\n\n做事情认真负责，专注做好自己的工作，遇到困难不轻言放弃，而是想方设法解决\n\n其次就是执行力，光说不做谁都会，我们要看一个人做了什么，要做行动上的巨人\n\n不断地对过去的自己表示不满足，同时总结复盘，这是一个不断学习不断进步的过程\n\n\n# 失败的经历\n\n之后也有复盘整改和提升，会很快振奋起来的那种经历\n\n🌰 那就是考六级吧，第一次考的时候离及格差了2分，其实我的英语成绩从初中开始都是属于不错的类型的，当时考六级时有点不在状态，加上对六级题目难度的判断不是特别地全面，得知没有过的时候，也是蛮伤心的，后面调整过来 就开始寻找一个正确的学习方法，想着下次如何提升自己的成绩\n\n找到一套学习方法后，还需要每天固定的时间练习，包括听力 阅读 写作，第二次考试的时候，就涨了将近100分\n\n这一点我学到的东西也是蛮多的，首先，不能焦躁，其次，要有自己发展进步的轨道和时区，多去专注于自己技术能力的发展，其次就是要稳住，多从过去的教训中汲取经验\n\n\n# 实习收获\n\n实习都做了什么。\n\n实习中遇到了哪些问题（技术上，开发流程上，部门沟通上）。\n\n你是如何解决这些问题的。\n\n实习中收获了什么 技术上成长 （学习了哪些技术组件，自己有没有去深挖）\n\n代码风格上 （如何写出易于维护的代码）\n\n开发流程上 （单元检测，打日志，git团队合作）\n\n对业务理解能力上 （如果把业务场景转为系统设计转为工程代码，都考虑了哪些问题）\n\n\n# 看了啥书\n\n《图解http》\n\n《javascript高级程序设计》\n\n阮一峰老师写的《ecmascript 6 入门》\n\n《javascript 权威指南》犀牛书\n\n《高性能javascript》\n\n《深入理解es6》\n\n《你不知道的javascript》\n\n\n# 注意\n\n不抢答\n\n“水深则缓流，人贵则语迟”\n\n不管问题多简单，回答之前停顿思考，哪怕一秒。因为每一次提问，都是面试官在我身上找价值的过程，而不是找不足\n\n有好奇心\n\n面试官：我就很好奇，你真的不关心我们的**作息时间，薪资待遇，审批流程**吗？你对我们很了解吗？你对我不感兴趣吗？\n\n不用面试题反问面试官\n\n面试官：你要知道不管你是有意无意，是不是真的虚心求教。我们都有一种被人“戏弄”的“错觉”。面试仅仅是一个双向选择的过程，不是一个你提升自我的过程\n\n> 测评\n\n前后一定要一致\n\n必要时记录关键词提醒自己\n\n\n# offer有关\n\n谈offer要注意哪些事项（避坑指南）\n\n还有应届生不关注五险一金？来看看五险一金的影响\n\n\n# 🌈 star法则\n\nstar法则超好用\n\n 1. situation 项目背景和环境\n 2. task 任务职责\n 3. action 基于任务采取的措施和应对方法\n 4. result 收获和总结\n\n项目如何描述\n\n\n# 简历\n\n个人信息明确\n\n项目描述丰富点\n\n个人贡献详细一点\n\n总结\n\n【项目经验】分 「项目描述」「个人工作」「个人收获」写\n\n * 代码风格，编程风格对项目开发的帮助，亲身体会对技术的追求\n\n * 开发日志和上线日志 单元检测\n\n * git上的使用\n\n * 对业务理解，业务场景转换为系统设计，系统设计转换为工程代码\n\n * 状态机 状态归一化\n\n\n# 项目深度\n\n 1. 你的项目的技术难点是什么？\n 2. 你是如何克服这个技术难点的？\n 3. 你做这个项目的收获是什么？\n 4. 为什么使用这个技术/组件？\n\n\n# 组件封装\n\n先说 为啥出现 组件封装的需求\n\n其次说为啥需要组件化开发\n\n * 减少代码量\n * 支持共享组件库\n * 减少开发成本\n * 代码易维护\n\n啥时候需要封装组件\n\n设计原则\n\n * 层次结构和类图\n\n具体细节的实现，例如数据类型，方法实现，所需状态属性\n\n * 纯粹的state变化\n * 统一/集中的状态管理\n\nredux或vuex\n\n * 低耦合高内聚\n\n呈现更好复用性 而不 受限于特定上下文环境\n\n * 模块化\n\n命名污染，保持作用域、变量的独立性\n\n可使用命名空间\n\n * 样式隔离\n\n * 数据配置外部处理，外部传入\n\n对props做数据校验\n\n * 数据传递不依赖全局\n\n数据泄露\n\n内存占用过大\n\n * 使用文档(配套的md文档)\n\n标注组件名、入参、事件\n\n\n# 构建工具\n\n前端工程化那些事\n\n构建工具：rollup、parcel、grunt、gulp\n\n\n# webpack\n\nwebpack 面试题整理\n\n\n\n\n# loader、plugin\n\n【loader处理某一类文件而plugin可以做「任何」事】\n\nloader webpack本身只能打包js和json文件，但实际中我们还有css 、scss、png和ts等其他文件，此时我们就需要使用loader让他们正确打包\n\nloader 处理编译js和json以外的文件时用——翻译官\n\nloader——加载器，本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果\n\nloader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是 object，内部包含了 test(类型文件)、loader(使用)、options等属性啥加载\n\nplugin可以在webpack运行到某个阶段时，帮助我们做一些事情，类似于react/vue的生命周期\n\nplugin——插件，扩展 webpack 的功能，在 webpack 运行的生命周期中会广播出许多事件，plugin 监听这些事件，在合适的时机通过 提供的 api 改变输出结果。是扩展器，在打包过程中，基于事件驱动的机制，监听webpack打包过程中的某些节点，执行广泛的任务\n\n\n# proxy原理？\n\n> 为啥 配置webpack的proxy 可解决跨域？\n\nproxy是webpack提供的代理服务，基本行为——接收客户端发送的请求 转发给其他服务器，便于在开发模式下解决跨域问题\n\n实现代理需要中间服务器，webpack-dev-server 是webpack推出的一款开发工具，将自动编译和自动刷新浏览器等系列对开发优化的功能集成\n\n只适用于 开发阶段\n\nproxy—— 利用http-proxy-middleware http代理中间件，实现请求转发给其他服务器\n\n\n# npm\n\n\n# 早期npm\n\nnpm v2 设计很简单，安装依赖时将依赖放到node_modules；若某个直接依赖a依赖于其他依赖包b，依赖b会作为间接依赖，安装到依赖a的文件夹，可能多个包出现同样依赖递归，若项目过大 必然形成巨大的依赖树，出现重复，形成嵌套地狱\n\n\"嵌套地狱\"\n\n * 依赖树层级过于深不利于排查和调试\n * 依赖分支中可能出现同样版本相互依赖的问题\n\n重复问题带来什么后果？\n\n * 安装的结果占据空间资源\n * 依赖重复造成安装依赖时间过长\n * 目录层级过深，文件路径过长，出现删除不掉node_modules的情况\n\n\n\n\n# yarn\n\n新的javascript包管理器。 解决历史 npm 不足(npm对于依赖的完整性和一致性的保证，安装速度很慢)\n\n2016年， npm还没有package-lock.json文件，安装速度慢，稳定 很差，yarn解决了：\n\n * 确定性: yarn.lock等机制， 不同安装顺序，相同依赖关系在任何 环境容器 都 以相同方式安装\n * 采用模块扁平化的安装模式: 不同版本依赖包，按照 策略，归结 单个版本;避免创建多个版本造成冗余(目前版本的npm也有优化)\n * 网络性能更好: yarn采用请求排队 理念，类似 并发池连接， 利用网络资源; 引入安装失败的重试机制\n * 采用缓存机制，实现 离线模式 (目前的npm也有类似的实现)\n\n\n# npm参数\n\ndevdependencies：用于开发环境\n\ndependencies：用于线上环境，生产环境\n\n8.x版本中的容错设计\n\n\n\nnonuplets 九胞胎！\n\n\n# 1.不填参数：\n\nnpm install\n\n\n1\n\n\n\\1. 仅安装模块到项目node_modules目录下。\n\n\\2. 不会将模块依赖写入devdependencies或dependencies 节点。\n\n\\3. 运行 npm install 初始化项目时不会下载模块依赖。\n\n\n# 2.使用--save：\n\nnpm install --save\n\n\n1\n\n\n\\1. 安装模块到项目node_modules目录下。\n\n\\2. 会将模块依赖写入dependencies 节点。\n\n\\3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。\n\n\\4. 运行npm install --production或者注明node_env变量值为production时，会自动下载模块到node_modules目录中。\n\n\n# 3.使用--save-dev：\n\nnpm install --save-dev\n\n\n1\n\n\n\\1. 安装模块到项目node_modules目录下。\n\n\\2. 会将模块依赖写入devdependencies 节点。\n\n\\3. 运行 npm install 初始化项目时，会将模块下载到项目目录下。\n\n\\4. 运行npm install --production或者注明node_env变量值为production时，不会自动下载模块到node_modules目录中。\n\n\n# 4.使用 -g：\n\nnpm install -g\n\n\n1\n\n 1. 安装模块到全局，不会在项目node_modules目录中保存模块包。\n\n\\2. 不会将模块依赖写入devdependencies或dependencies 节点。\n\n\\3. 运行 npm install 初始化项目时不会下载模块。\n\n\n# 运行npm run xxx发生了啥？\n\n去package.json中招scripts对应的xxx，执行xxx的命令，npm run serve实际执行 vue-cli-service serve\n\n> 为什么不直接执行vue-cli-service serve\n\n直接执行报错，因为os中不存在vue-cli-service 指令\n\n> 为啥npm run serve不报错\n\n安装依赖时，通过npm i xxx执行，在node-modules目录中创建好可执行文件，.bin 是一个软链接，可知道其实一个脚本，使用npm run serve执行vue-cli-service serve时，没有安装这个全局命令，但是npm会到node-modules中找到对应文件 执行 脚本\n\n> .bin目录下的软链接何处而来？它如何知道执行什么\n\n\n# package.json\n\n> ~ ^ *\n\n1.2.3\n\n主要版本：更改代表一个破坏兼容的大变化，若用户不适应主要版本更改，内容将无法正常工作\n\n次要版本：更改不会破坏任何内容的新功能\n\n补丁：更改不会破坏任何内容的错误修复\n\n（1）指定版本：\"axios\": \"0.21.0\"，表示安装0.21.0的版本\n\n（2）~指定版本： \"core-js\": \"~3.6.5\"， 表示安装3.6.x的最新版本（不低于3.6.5），但是不安装3.7.x，安装时不改变大版本号和次要版本号\n\n（3）^指定版本：\"antd\": \"^3.1.4\"， 表示安装3.1.4及以上版本，但是不安装4.0.0，安装时***不改变大版本号***\n\n（4）* 安装最新版本的依赖包，*1.2.3 会匹配 x.x.x\n\n^ 版本更新可能比较大，会造成项目代码错误，建议使用 ~ 标记版本号，酱紫可以保证项目不出现大的问题，也能保证包中的小bug 得到修复\n\n* 意味着安装最新版本的依赖包，缺点同上，可能造成版本不兼容，慎用！！\n\n\n# package-lock.json\n\n为了解决不同人电脑安装的所有依赖版本都是一致的，确保项目代码在安装所执行的运行结果一样\n\nnpm(^5.x.x.x) 后才有\n\npackage-lock.json 会在 npm 更改node_modules 目录树或 package.json 时自动生成，准确描述当前项目npm 包的依赖树，在随后的安装中 根据 package-lock.json 安装，保证是同一依赖树，不考虑这个过程中是否有某个依赖有小版本更新\n\n目的——对整个 依赖树 进行版本固定的（锁死）\n\n当我们下次再npm install时候，npm 发现如果项目中有 package-lock.json 文件，会根据 package-lock.json 里的内容来处理和安装依赖而不再根据 package.json\n\n> 使用cnpm install时候，不会生成 package-lock.json ，也不会根据 package-lock.json 安装依赖包，还是使用 package.json 安装\n\n\n# pnpm\n\n速度快、节省磁盘空间的软件包管理器\n\n> 快速\n\n是同类工具速度的将近 2 倍\n\n> 高效\n\nnode_modules 中的所有文件均链接自单一存储位置\n\n> 支持单体仓库\n\n内置了对单个源码仓库中包含多个软件包的支持\n\n> 权限严格\n\n创建的 node_modules 默认 非扁平结构，因此代码无法对任意软件包进行访问\n\n\n# nginx\n\n作为一名前端，该如何理解nginx？\n\n前端工程师不可不知的nginx知识\n\n\n# 🍅taro\n\n\n# 为啥选taro\n\n通用性问题\n\n转换为h5页面\n\n这是学生团队，需要高手 低手，一个易用性\n\n锻炼大家解决问题的能力，而不是有问题就找导师，然后就成了 排坑 工具，这样得不到收获，没有锻炼\n\n确实有很多坑！\n\n一个页面不像是原生中4个文件\n\n原生的v-for和react的list遍历问题\n\n\n# 踩坑记录\n\ntaro主打react技术栈\n\n项目体积过大，无法预览，要进行分包处理\n\ntaro.showtoast添加image属性时，图片不显示bug\n\n原因：taro.showtoast中引用了图片，但图片无法被打包到微信小程序中\n\n解决：config/index.js处理\n\ncopy: {\n    patterns: [\n        { from: 'src/imgs/', to: 'dist/imgs' } // 指定需要copy的文件\n    ]\n}\n// 使用时image路径\ntaro.showtoast({\n  title: '上传成功',\n  image: '/imgs/success.png',\n  duration: 2000\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 🌈 dvajs\n\nvuex、flux、redux、redux-saga、dva、mobx\n\n> 为啥使用dva react\n\ndva 一个基于redux和redux-saga的数据流方案，为了简化开发体验，dva额外内置了react-router和fetch， 轻量级的应用框架。\n\ndva = react-router + redux + redux-saga\n\n将redux的store进一步封装，很好地解决了异步数据流和数据源不一致的问题\n\ndva官网\n\n\n# 🙋 redux\n\nredux官网\n\nredux 是reducer+flux，——视图层框架，帮助处理共享状态管理\n\nredux 是js应用程序的可预测！！！状态容器，通用的context提供者，可以应用在任何一个应用中——provider 组件！\n\nprovider只是把渲染工作完全交给子组件，提供context包住最顶层组件\n\ncontext提供全局可访问的对象，但是全局对象应该避免，只要有一个地方做了修改，其他地方会受影响\n\ncontext 只有对个别组件适用，不要滥用！\n\nredux的store封装得好，没有提供直接修改状态功能，克服了全局对象的缺点。**且一个应用只有一个store，**store是context唯一需要，不算是滥用\n\n> redux对比flux\n\n 1. redux没有dispatcher\n 2. redux只有一个store而flux有很多store\n 3. action对象由store直接接收处理\n\n\n# 基本\n\n它认为：\n\n * web应用是一个状态机，视图和状态一一对应\n * 所有的状态，保存在一个对象中\n\n\n\n应用程序的全局状态存储在单个store内的对象树中。更改状态树的唯一方法是创建action(返回action对象)，要指定状态如何更新以响应操作，纯reducer函数根据旧状态和操作更新\n\n好处是 可很好扩展到大型复杂 的应用程序，使更改具有预测性和可追溯性\n\n> 原则\n\n 1. 单一数据源\n 2. state可读\n 3. 纯函数修改\n\n> 啥情况使用\n\n * 需要使用大量application状态\n * application状态频繁更新\n * 更新状态的逻辑可能很复杂\n * application具有中/大型代码库，可能由许多人开发\n\n\n# 工作原理\n\n单向数据流\n\n当多个组件需共享/使用相同状态时，简单性可能被打破\n\n可通过\"状态 提升\"父组件 解决，但并不总是有帮助\n\n解决的一种方法——组件中提取共享状态，将其放在组件树之外的集中位置，酱紫，组件树变成 \"大 视图\"，任何组件都可访问状态/触发 动作，无论在树中啥位置\n\n为代码提供更多结构和维护性\n\n> 用户交互流程\n\n 1. 用户(view)发出 action，使用dispatch\n 2. store 自动调用 reducer，传参：state 和收到的action，reducer返回新的state\n 3. state变化，store调用监听更新 view\n\n\n# 为啥使用redux\n\n前端复杂性的根本原因——大量无规律的交互(交互上存在父子、子父、兄弟组件间通信，数据也存在跨层、反向数据流)和异步操作\n\n我们很容易对这些状态何时发生、为啥发生及如何发生 失去控制，怎样才能让这些状态变化被我们预先掌握、可以复制追踪呢？\n\nredux试图让每个state变化都是可预测的，将应用中所有动作与状态统一起来，让一切有迹可循\n\n架构层面上，我们希望ui跟数据和逻辑分离，ui只负责渲染，业务和逻辑交由其它部分处理，从数据流向方面来说, 单向数据流确保了整个流程清晰\n\nredux做到：\n\n * 每个state变化可预测\n * 动作与状态统一管理\n * 调试简单\n * 易测试\n * 状态持久化\n * ssr\n\n\n# 异步请求处理\n\n借助 redux 的中间件 异步处理\n\n主要有 redux-thunk，redux-saga(常用)\n\n此处主要介绍 redux-saga\n\n优点：\n\n * 异步解耦，不会掺杂在 action 或 component 中，代码简洁度提高\n * 异常处理，可使用 try/catch 捕获异常\n * 功能强大，无需封装或简单封装 即可使用\n * 灵活，可将saga 串行 起来，形成异步 flow\n * 易测性\n\n缺陷：\n\n * 学习成本高\n * 体积略大\n * 功能过剩\n * yield无法返回 ts 类型\n\n> @connect\n\n连接react和redux\n\n 1. connect通过context获取provider中的state，通过store.getstate()获取store tree上所有state\n 2. 将state和action通过 props 的方式传入组件内部，wrapwithconnect 返回一个component对象connect，connect重新render 外部传入的元组件 wrapwithconnect ，将connect中传入的mapstatetoprops ，mapdispatchtoprops 与组件上原有的props 合并，通过属性的方式传给 wrappedcomponent\n 3. 监听 state tree 变化。connect缓存了store tree中state的状态，根据state当前和变更前状态比较，确定是否setstate触发connect及re-render\n\n> connect的工作\n\n 1. 把store上的状态转化为内层傻瓜组件的prop\n 2. 把内层傻瓜组件的用户动作 转化为派送给store的动作\n\n\n# context\n\ncontext“上下文环境”，让一个树状组件上所有的组件都能访问一个共同的对象，context 由其父节点链上所有组件通过 getchildcontext() 返回context对象组合而成，通过context 可以访问其父组件链上context\n\ncreatecontext创建context对象，有_currentvalue保存值，引用了provider和consumer两个对象，provider和consumer里有 _context属性引用了context\n\njsx渲染时会把provider和consumer对象保存在vdom 上，后面reconcile时会转移到fiber的type属性上，处理fiber节点时会根据类型做不同处理\n\n如果是provider，会根据传入的value修改context的值，也就是 _currentvalue属性\n\n如果是 consumer，会读取 context的值，触发子组件render\n\n函数组件使用usecontext的hook，最终也是读取同一个context的_currenvalue值\n\n\n# redux、vuex\n\n区别\n\n * vuex改进了redux中的action和reducer，以mutations 变化函数取代 reducer，无需 switch，只需在mutations中修改对应state即可\n * vuex无需订阅re-render，只需要生成新的state\n * vuex数据流，view调用store，commit提交对应请求到store中对应mutations，store修改，vue检测state修改自动渲染\n\nvuex弱化dispatch和reducer，更简易\n\n共同点\n\n * 单一数据流\n * 可预测变化\n\n都是对mvvm思想服务\n\n> 中间件如何拿到store和action\n\nredux 中间件本质是一个函数柯里化\n\n涉及 源码\n\n\n# react-redux\n\n如果不用 react-redux，手动处理 redux 和 ui 的绑定，需要写很多重复的代码，容易出错，且有很多 ui 渲染逻辑的优化不一定能处理好\n\n为了让redux更好适用react的一个库\n\n管理状态、组织代码\n\nconnect连接组件和store\n\nconnect接受两个参数：mapstatetoprops和mapdispatchtoprops。定义 ui 组件的业务逻辑。前者负责输入逻辑，将state映射到 ui 组件的参数（props），后者输出逻辑，将用户对 ui 组件的操作映射成 action\n\nimport { connect } from 'react-redux';\n\nconst component = connect(\n  mapstatetoprops,\n  mapdispatchtoprops\n)(con);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# redux-saga\n\nreact中间件，更好解决异步操作，一个直观的 redux 副作用管理器\n\n易于管理、易于测试和高效执行\n\n相当于在redux原有数据流中多了一层，对action进行监听，捕获到监听的action可以派生一个新的任务维护state\n\n通过generator创建，同步的方式写异步代码，不会被细节困扰\n\n\n# 💜 react-router\n\n\n# 原理\n\n客户端路由 实现原理\n\n * 基于hash 路由，监听hashchange 事件，location.hash=xxxx 改变路由\n * 基于h5的 history，通过history，pushstate 和 replacestate 修改url，能应用 history.go() 等 api，允许通过 自定义事件 触发实现\n\nreact-router实现：\n\n * 基于 history 库实现，history知道如何监听浏览器地址变化，解析url转换为location\n * router使用location匹配路由，渲染 component\n\n\n# 路由切换\n\n * route标签组件 ，通过 比较 <route>的path属性和当前地址的 pathname 实现，匹配成功则 render，否则渲染null\n\n// when location = { pathname: '/about' }\n<route path='/about' component={about}/> // renders <about/>\n<route path='/contact' component={contact}/> // renders null\n<route component={always}/> // renders <always/>\n\n\n1\n2\n3\n4\n\n * <switch> +<route>，<swicth>对<route>进行分组，遍历所有的子<route>，渲染匹配的第一个元素\n\n<switch>\n    <route exact path=\"/\" component={home} />\n    <route path=\"/about\" component={about} />\n    <route path=\"/contact\" component={contact} />\n</switch>\n\n\n1\n2\n3\n4\n5\n\n * <link> <navlink> <redirect>，<link> 组件创建链接，会在html处 渲染锚(<a>)\n\n<link to=\"/\">home</link>   \n// <a href='/'>home</a>\n\n\n1\n2\n\n\n当 <navlink>的 to 属性与当前地址匹配时，可将其定义为活跃的\n\n// location = { pathname: '/react' }\n<navlink to=\"/react\" activeclassname=\"hurray\">\n    react\n</navlink>\n// <a href='/react' classname='hurray'>react</a>\n\n\n1\n2\n3\n4\n5\n\n\n渲染<redirect>强制导航\n\n\n# 重定向\n\n<redirect>实现路由重定向\n\n<switch>\n  <redirect from='/users/:id' to='/users/profile/:id'/>\n  <route path='/users/profile/:id' component={profile}/>\n</switch>\n\n\n1\n2\n3\n4\n\n\n请求 /users/:id 被重定向去 '/users/profile/:id'：\n\n * 属性 from: string：匹配的将要被重定向路径\n * 属性 to: string：重定向的 url 字符串\n * 属性 to: object：重定向的 location 对象\n * 属性 push: bool：若为真，重定向将会把新地址加入到访问历史记录里，且无法回退到前面的页面\n\n\n# link、a\n\n都是链接，都是标签\n\n<link>是 react-router 中实现路由跳转的链接，一般配合 <route>使用，跳转 只会触发相匹配的 <route> 对应页面内容更新，不会刷新all page\n\n<link>行为\n\n 1. 有onclick 就 onclick\n 2. click 时阻止a 默认事件\n 3. 根据to属性，使用histor 或 hash 跳转，跳转只是链接变了，没有all page 刷新，<a>是普通的超链接\n\n<a> 禁用后咋实现跳转？\n\n手动赋值给<a>标签 location 属性\n\nlet domarr = document.getelementsbytagname('a')\n[...domarr].foreach(item=>{\n    item.addeventlistener('click',function () {\n        location.href = this.href\n    })\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 获取url参数\n\n * get 方法\n\nthis.props.location.search 获取 url 得到字符串，解析参数，或者自己封装方法获取参数\n\n * 动态路由传值\n\n如 path='/admin/:id'，this.props.match.params.id 获取 url中动态部分路由 id值，或者使用hooks的 api获取\n\n * query 或 state传值\n\n<link>组件 的 to属性可以传递对象 {pathname:'/admin',query:'111',state:'111'}，this.props.location.state或 this.props.location.query 获取，一旦刷新页面 数据丢失\n\n\n# 获取历史对象\n\n * react>=16.8 ，使用 react router的hooks\n\nimport { usehistory } from \"react-router-dom\";\nlet history = usehistory();\n\n\n1\n2\n\n * this.props.history\n\n\n# 路由模式\n\n * browserrouter\n\nh5的history api控制路由跳转\n\n * hashrouter\n\nurl的hash 属性控制路由挑转\n\n\n# 各端\n\n\n# 微信小程序\n\n不需下载安装即可使用，不用担心是否安装太多应用\n\n\n# 原理\n\nwxml、wxss、js开发，本质是单页应用，所有页面渲染和事件处理都在一个页面进行，可通过微信客户端调用原生各种接口\n\n架构时mvvm模式，视图ui和数据分离，所有更新通过数据变更实现\n\n分为webview 和appservice，webview展现页面，appservice处理业务逻辑、数据及接口调用，通过系统层jsbridge实现通信，实现ui渲染和事件处理\n\n小程序框架包含view视图层和appservice逻辑层，view层渲染页面，appservice用来 逻辑处理、数据请求、接口调用，他们在2个进程运行，具体实现在2个webview运行\n\n\n\n微信将所有视图加载到webview(view层)；所有逻辑处理的js全部加载到另一个webview(appservice层)，每个小程序只有一个且整个生命周期常驻内存，jsbridge封装消息通信及通过app访问os能力的实现，消息通信在不同平台调用相应方法通信，开发环境为window.postmessage\n\n使用view层和appservice逻辑层实现双线程 的小程序运行方案，可将代码放入沙箱执行，对代码执行安全和管控\n\n一个app运行多个小程序，采用多线程方案执行，为了性能 也防止小程序间相互影响\n\n\n# 和web端区别？\n\n运行环境\n\n * 微信小程序只能通过微信打开\n\n * web项目可以通过多个终端的浏览器打开\n\n项目规模\n\n * 微信小程序一般是小应用级别的，大小限制为2m，否则上传不了审核\n * web项目可以支持大项目或者复杂的项目\n\n开发语言\n\n * 微信小程序是html＋css＋js\n * web项目可以支持多种语言\n\n开发工具\n\n * 微信小程序有专门的微信开发者工具\n\n\n# h5\n\nh5理解为一个网页，依赖外壳为浏览器\n\n可在微信 微博 qq 及所有浏览器使用，没有平台限制\n\n修改内容后可直接发布，不需审核\n\n开发容易\n\n开发高 (分配一种开发人员即可)\n\n跨平台分享（所有浏览器、及微信等嵌有浏览器功能产品），快速迭代\n\n\n# app\n\n三条主线：ios android h5跨平台混合开发\n\n前两者成为native开发，后者为hybrid开发\n\n开发语言分别 object-c java html5\n\n\n# others\n\n当你有了技术深度，很可能也同时有了技术广度\n\n\n# babel\n\n\n# eslint\n\n识别ecmascript，按照规则给出报告的代码检测工具，避免低级错误和统一代码的风格。有效控制项目代码的质量\n\neslint 提供了根据 ast 节点拿到它的 token 信息的 api，比如块语句可以拿到 { 的 token 信息，也就是所在的行列号等\n\n\n# 区别\n\nbabel 插件和 eslint 插件至少两处不同：\n\n * eslint 通过 api 拿到 ast 关联的 token 信息，检查出格式问题， babel 插件不行\n * eslint 自动 fix 修改代码通过字符串替换实现，babel 通过递归打印修改后的 ast 为字符串\n\n\n# puppeteer\n\n基于 cdp 实现，就是调试模式跑了一个 chromium，连上 cdp 远程控制\n\n * 生成页面 pdf\n * 抓取 spa（单页应用）并生成预渲染内容（即“ssr”（服务器端渲染））\n * 自动提交表单，进行 ui 测试，键盘输入等\n * 创建一个时时更新的自动化测试环境。 使用最新的 javascript 和浏览器功能直接在最新版本的chrome中执行测试\n * 捕获网站的 timeline trace，用来帮助分析性能问题\n * 测试浏览器扩展\n\n\n# ts\n\n是js的强类型版本，编译时去掉类型和特有语法，生成纯粹的js代码，最终运行的还是js，ts不依赖浏览器支持，也没有兼容性问题\n\n支持所有的js语法，在此之上对js做了扩展，提升可阅读性\n\n更易阅读和理解代码\n\n\n# umijs\n\n主要解决了什么问题？\n\nwebpack打包问题\n\n因为简化了很多webpack打包问题\n\n路由跳转问题\n\n\n# 微前端\n\n微前端的前世今生\n\n\n# 微服务\n\n早期软件所有功能都写在一起，称为 单体架构，整个软件是单一的整体(类似 一体化的机器)，软件功能越多，单体架构越复杂，缺点暴露\n\n * 功能耦合，互相影响\n * 修改一行代码，软件需要重新构建和部署，成本高\n * 软件做成了整体，不可能每个功能单独开发和测试，只能整体开发和测试，导致必须 采用瀑布式开发模型\n\n面向服务架构(soa) 将一个大型的单体程序，拆分成一个个独立服务，每个服务都是一个独立的功能单元，承担不同功能，服务之间通过通信协议连接\n\n> 优点\n\n 1. 服务功能单一，类似一个小型软件，便于开发和测试\n 2. 服务独立运行，简化架构，提高可靠性\n 3. 鼓励 支持代码复用\n 4. 单独开发和部署，便于升级\n 5. 扩展性好\n 6. 不容易出现单点故障\n\n微服务——采用容器技术的面向服务架构\n\n微服务轻量级实现，不需要新增服务器，只需要新建 容器(一个进程)，所以叫做 \"微服务\"\n\n因为 微服务 更加轻量级，所以 功能解耦和服务化 可以更彻底\n\n\n# 低代码\n\n减少编码时间，把更多时间经历用在网站体验，设计中\n\n零代码基础也可轻松构建web页面\n\n * 上手快，开发效率高\n * 无需考虑学习成本带来的负担\n * 页面可视化的加持，布局、设计、ui尽在掌握\n\n拖拽的方式 在最短时间内实现最初想法/设计\n\n> 实现\n\n * 快速完成静态页面布局\n * 确定能够被拖拽的组件有哪些，以及它们的存在方式是什么\n * 选择一种适用于各组件间进行通信的方式\n * 实现拖拽\n * 渲染被拖拽组件\n * 确保组件属性更改后可以实时映射至画布区域\n\n所见即所得\n\n技术服务于业务\n\n\n# webgl\n\nweb图形库 是一个js api，可渲染高性能的交互式 3d 和2d图形，无需插件\n\nwebgl引入一个与 opengl es 2.0非常一致的 api 做到这一点，该 api 可在html5 <canvas>元素中使用，一致性使 api 可以利用用户设备提供的硬件图形加速\n\n光栅raster\n\n图形系统基于光栅 绘制图形，光栅 指构成图像的像素矩阵\n\n像素pixel\n\n一个像素对应图像上一个点，通常保存图像上某个具体位置的颜色\n\n帧缓存frame buffer\n\n绘图过程，像素信息被存放在帧缓存中，帧缓存是一块内存地址\n\ngpu由大量的小运算单元构成，每个运算单元只负责处理 很简单的运算，每个运算单元 彼此 独立，因此 所有计算 可并行处理\n\n\n# web2.0\n\nweb2.0——用户主动获取并产生内容\n\nweb1.0——由系统向用户展示内容\n\nweb3.0——个性化内容的获取\n\n比如新浪就是1.0，你上它的网站，它放了很多新闻给你看\n\n比如google是2.0，你跟它说我要搜索最近新上映电影的信息\n\n微博是2.0，因为它是是由用户编写的内容\n\n豆瓣是3.0，它根据你一贯听歌的口味向你推荐你可能喜欢的歌曲\n\n再举个通俗的例子\n\n你去饭店，服务员把菜单放在你面前说：我们今天提供番茄炒蛋，你吃不吃？这是web1.0\n\n你去饭店跟服务员说：我要番茄炒蛋，不要番茄只要蛋，少放盐，这是web2.0\n\n你去饭店，服务员说：这位爷，您经常来咱们饭店，根据您以往的点菜习惯，我们向您推荐我们的最新菜肴番茄鸡蛋炒牛肉。这是web3.0\n\n\n# ci/cd\n\n持续集成、持续交付、持续部署\n\n作用——开发阶段引入自动化频繁向用户交付应用\n\n让持续自动化和持续监控贯穿于应用的整个声明周期(集成到测试，交付和部署)\n\n没必要纠结语义，就是一个路程，实现应用开发的高度持续自动化和监控\n\n\n# 树莓派\n\n信用卡大小的微型电脑，基于linux\n\n别看外表“娇小”，内“心”却很强大，视频、音频等功能皆有，麻雀虽小，五脏俱全\n\n树莓派就是一台主机，可外接显示器，键盘鼠标，u盘等外设，它体积小，有很多串口和外接的口，可直接调用很多底层硬件\n\n\n# react native、flutter\n\n个人玩玩就rn，轻量级产品化flutter，深度产品化原生\n\n\n * # rn\n\nrn是facebook 的 跨平台 移动应用 开发框架——react 在原生移动应用平台的衍生产物，支持 ios 和安卓。 rn使用jsx、css开发移动应用\n\n * 开发体验好，统一代码规范，无需关注移动端差异\n\n * 开发成本低，开发一次，支持android和ios\n\n * 学习成本低，掌握js和react即可\n\n * 不成熟，项目版本更新维护频繁\n\n * 试错成本高，问题解决方案少\n\n * 性能不如原生\n\n * 兼容性，涉及底层需要针对android和ios单独开发\n\n\n * # flutter\n\n有dart基础\n\n\n * # uniapp\n\n有vue基础\n\n\n# linux\n\n\n * # 常用指令\n\nrimraf 删除文件/文件夹（没想起还有这个指令）\n\nls 查看文件夹包含文件\n\npwd查看当前工作目录路径\n\nrm删除文件\n\nwhich查找某个文件的位置\n\nps查看运行进程状态\n\nkill结束进程\n\nchromd 控制用户对文件权限的控制\n\ncat 显示文件信息\n\napt-get 安装软件包\n\n\n# 洋葱模型\n\nkoa和redux\n\n\n# webrtc\n\n实时通讯技术，允许网络应用/站点，在不借助中间媒介的情况下，建立浏览器之间点对点的连接，实现视频流/音频流/其他任意数据的传输\n\nwebrtc包含的标准使用户在无需安装任何插件/第三方软件的情况下，创建点对点的数据分享和电话会议成为可能\n\n\n> # 应用场景\n\n * 直播\n * 游戏\n * 视频会议/在线教育\n * 屏幕共享/远程控制\n\n网速和硬件越来越好的趋势下，webrtc'有无限可能\n\n\n# 元宇宙\n\n我们在虚拟世界中与一个全新的身份一一对应，并且不会间断地“生活下去”",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"React",frontmatter:{title:"React",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/727eb5/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/10.React.html",relativePath:"08.专栏/10.React.md",key:"v-cb206f50",path:"/pages/727eb5/",headers:[{level:2,title:"相同",slug:"相同",normalizedTitle:"相同",charIndex:175},{level:2,title:"不同",slug:"不同",normalizedTitle:"不同",charIndex:307},{level:2,title:"区别？",slug:"区别",normalizedTitle:"区别？",charIndex:454},{level:3,title:"组件化",slug:"组件化",normalizedTitle:"组件化",charIndex:182},{level:3,title:"VDOM",slug:"vdom",normalizedTitle:"vdom",charIndex:62},{level:3,title:"react、vue VDOM相同点",slug:"react、vue-vdom相同点",normalizedTitle:"react、vue vdom相同点",charIndex:1263},{level:4,title:"diff 优化基本上思路相同",slug:"diff-优化基本上思路相同",normalizedTitle:"diff 优化基本上思路相同",charIndex:1478},{level:4,title:"diff  源码 相同之处",slug:"diff-源码-相同之处",normalizedTitle:"diff  源码 相同之处",charIndex:null},{level:3,title:"react和vue中VDOM差别",slug:"react和vue中vdom差别",normalizedTitle:"react和vue中vdom差别",charIndex:1723},{level:4,title:"dom的更新策略不同",slug:"dom的更新策略不同",normalizedTitle:"dom的更新策略不同",charIndex:1930},{level:5,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2277},{level:3,title:"数据驱动视图",slug:"数据驱动视图",normalizedTitle:"数据驱动视图",charIndex:207},{level:3,title:"vue 数据驱动视图",slug:"vue-数据驱动视图",normalizedTitle:"vue 数据驱动视图",charIndex:2446},{level:3,title:"react的数据驱动视图",slug:"react的数据驱动视图",normalizedTitle:"react的数据驱动视图",charIndex:2937},{level:2,title:"核心思想",slug:"核心思想",normalizedTitle:"核心思想",charIndex:3258},{level:2,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:1089},{level:2,title:"不习惯之处",slug:"不习惯之处",normalizedTitle:"不习惯之处",charIndex:3496},{level:2,title:"JSX",slug:"jsx",normalizedTitle:"jsx",charIndex:71},{level:2,title:"状态提升",slug:"状态提升",normalizedTitle:"状态提升",charIndex:3907},{level:2,title:"React 16前!img",slug:"react-16前",normalizedTitle:"react 16前!img",charIndex:null},{level:2,title:"React 16后",slug:"react-16后",normalizedTitle:"react 16后",charIndex:5645},{level:2,title:"constructor",slug:"constructor",normalizedTitle:"constructor",charIndex:5046},{level:2,title:"16新增2个",slug:"_16新增2个",normalizedTitle:"16新增2个",charIndex:6024},{level:3,title:"getDerivedStateFromProps",slug:"getderivedstatefromprops",normalizedTitle:"getderivedstatefromprops",charIndex:5361},{level:3,title:"getSnapshotBeforeUpdate",slug:"getsnapshotbeforeupdate",normalizedTitle:"getsnapshotbeforeupdate",charIndex:5456},{level:2,title:"componentDidMount",slug:"componentdidmount",normalizedTitle:"componentdidmount",charIndex:5243},{level:2,title:"shouldComponentDidMount",slug:"shouldcomponentdidmount",normalizedTitle:"shouldcomponentdidmount",charIndex:7536},{level:2,title:"componentDidUpdate",slug:"componentdidupdate",normalizedTitle:"componentdidupdate",charIndex:5220},{level:2,title:"componentWillUnmount",slug:"componentwillunmount",normalizedTitle:"componentwillunmount",charIndex:5291},{level:2,title:"准备废弃",slug:"准备废弃",normalizedTitle:"准备废弃",charIndex:7909},{level:3,title:"componentWillMount",slug:"componentwillmount",normalizedTitle:"componentwillmount",charIndex:5147},{level:3,title:"componentWillReceiveProps(nextProps)",slug:"componentwillreceiveprops-nextprops",normalizedTitle:"componentwillreceiveprops(nextprops)",charIndex:8110},{level:3,title:"componentWillUpdate",slug:"componentwillupdate",normalizedTitle:"componentwillupdate",charIndex:5187},{level:2,title:"🔥 setState",slug:"setstate",normalizedTitle:"🔥 setstate",charIndex:9179},{level:2,title:"有状态组件",slug:"有状态组件",normalizedTitle:"有状态组件",charIndex:10041},{level:2,title:"无状态组件",slug:"无状态组件",normalizedTitle:"无状态组件",charIndex:10031},{level:2,title:"受控组件",slug:"受控组件",normalizedTitle:"受控组件",charIndex:4466},{level:2,title:"非受控组件",slug:"非受控组件",normalizedTitle:"非受控组件",charIndex:4700},{level:2,title:"class、hooks",slug:"class、hooks",normalizedTitle:"class、hooks",charIndex:11030},{level:2,title:"卡顿原因",slug:"卡顿原因",normalizedTitle:"卡顿原因",charIndex:11389},{level:2,title:"优化场景",slug:"优化场景",normalizedTitle:"优化场景",charIndex:11711},{level:2,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:1488},{level:2,title:"React.memo",slug:"react-memo",normalizedTitle:"react.memo",charIndex:10937},{level:2,title:"React.useMemo",slug:"react-usememo",normalizedTitle:"react.usememo",charIndex:12479},{level:2,title:"PureComponent",slug:"purecomponent",normalizedTitle:"purecomponent",charIndex:11736},{level:2,title:"高阶组件",slug:"高阶组件",normalizedTitle:"高阶组件",charIndex:3374},{level:2,title:"避免内联对象",slug:"避免内联对象",normalizedTitle:"避免内联对象",charIndex:14004},{level:2,title:"避免匿名函数",slug:"避免匿名函数",normalizedTitle:"避免匿名函数",charIndex:14486},{level:2,title:"组件懒加载",slug:"组件懒加载",normalizedTitle:"组件懒加载",charIndex:15041},{level:2,title:"用 CSS",slug:"用-css",normalizedTitle:"用 css",charIndex:15439},{level:2,title:"React.Fragment",slug:"react-fragment",normalizedTitle:"react.fragment",charIndex:15846},{level:2,title:"key",slug:"key-2",normalizedTitle:"key",charIndex:1538},{level:2,title:"合理使用Context",slug:"合理使用context",normalizedTitle:"合理使用context",charIndex:16530},{level:2,title:"虚拟列表",slug:"虚拟列表",normalizedTitle:"虚拟列表",charIndex:16858},{level:2,title:"合理设计组件",slug:"合理设计组件",normalizedTitle:"合理设计组件",charIndex:16907},{level:2,title:"同步or异步",slug:"同步or异步",normalizedTitle:"同步or异步",charIndex:17517},{level:2,title:"第二个参数",slug:"第二个参数",normalizedTitle:"第二个参数",charIndex:6509},{level:2,title:"state如何注入到组件",slug:"state如何注入到组件",normalizedTitle:"state如何注入到组件",charIndex:18527},{level:2,title:"解决",slug:"解决",normalizedTitle:"解决",charIndex:8724},{level:2,title:"限制",slug:"限制",normalizedTitle:"限制",charIndex:6547},{level:2,title:"hooks和生命周期",slug:"hooks和生命周期",normalizedTitle:"hooks和生命周期",charIndex:20107},{level:2,title:"useState",slug:"usestate",normalizedTitle:"usestate",charIndex:15573},{level:4,title:"模拟componentDidMount",slug:"模拟componentdidmount",normalizedTitle:"模拟componentdidmount",charIndex:20850},{level:2,title:"useLayoutEffect、useEffect",slug:"uselayouteffect、useeffect",normalizedTitle:"uselayouteffect、useeffect",charIndex:20944},{level:4,title:"第二个参数",slug:"第二个参数-2",normalizedTitle:"第二个参数",charIndex:6509},{level:2,title:"useMemo",slug:"usememo",normalizedTitle:"usememo",charIndex:12485},{level:2,title:"useCallback",slug:"usecallback",normalizedTitle:"usecallback",charIndex:14668},{level:2,title:"useRef",slug:"useref",normalizedTitle:"useref",charIndex:22807},{level:3,title:"为啥ref获取不到hooks？",slug:"为啥ref获取不到hooks",normalizedTitle:"为啥ref获取不到hooks？",charIndex:23069},{level:2,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:2277},{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:4856},{level:2,title:"如何使用",slug:"如何使用",normalizedTitle:"如何使用",charIndex:23735},{level:2,title:"render不能访问refs",slug:"render不能访问refs",normalizedTitle:"render不能访问refs",charIndex:24564},{level:2,title:"声明式编程",slug:"声明式编程",normalizedTitle:"声明式编程",charIndex:1200},{level:2,title:"惰性执行（Lazy Evaluation）",slug:"惰性执行-lazy-evaluation",normalizedTitle:"惰性执行（lazy evaluation）",charIndex:25189},{level:2,title:"核心概念",slug:"核心概念",normalizedTitle:"核心概念",charIndex:25242},{level:3,title:"数据不可变",slug:"数据不可变",normalizedTitle:"数据不可变",charIndex:25251},{level:3,title:"无状态",slug:"无状态",normalizedTitle:"无状态",charIndex:10031},{level:2,title:"没有副作用",slug:"没有副作用",normalizedTitle:"没有副作用",charIndex:10973},{level:2,title:"纯函数",slug:"纯函数",normalizedTitle:"纯函数",charIndex:6344},{level:2,title:"SPA",slug:"spa",normalizedTitle:"spa",charIndex:25383},{level:2,title:"MPA",slug:"mpa",normalizedTitle:"mpa",charIndex:25419},{level:2,title:"MVVM",slug:"mvvm",normalizedTitle:"mvvm",charIndex:239},{level:2,title:"MVC",slug:"mvc",normalizedTitle:"mvc",charIndex:25645},{level:2,title:"MVVM、MVC",slug:"mvvm、mvc",normalizedTitle:"mvvm、mvc",charIndex:25689},{level:2,title:"单向数据流框架始祖Flux",slug:"单向数据流框架始祖flux",normalizedTitle:"单向数据流框架始祖flux",charIndex:25725},{level:2,title:"import react 导致文件变大？",slug:"import-react-导致文件变大",normalizedTitle:"import react 导致文件变大？",charIndex:25950},{level:2,title:"React.lazy",slug:"react-lazy",normalizedTitle:"react.lazy",charIndex:15081},{level:2,title:"使用 React.lazy",slug:"使用-react-lazy",normalizedTitle:"使用 react.lazy",charIndex:26118},{level:3,title:"Suspense 组件",slug:"suspense-组件",normalizedTitle:"suspense 组件",charIndex:26573},{level:2,title:"render()",slug:"render",normalizedTitle:"render()",charIndex:5282},{level:2,title:"diff",slug:"diff",normalizedTitle:"diff",charIndex:500},{level:2,title:"re-render",slug:"re-render",normalizedTitle:"re-render",charIndex:2905},{level:3,title:"window.requestIdleCallback()",slug:"window-requestidlecallback",normalizedTitle:"window.requestidlecallback()",charIndex:30199},{level:2,title:"双缓冲优化策略",slug:"双缓冲优化策略",normalizedTitle:"双缓冲优化策略",charIndex:30468},{level:2,title:"dangerouslySetInnerHTML",slug:"dangerouslysetinnerhtml",normalizedTitle:"dangerouslysetinnerhtml",charIndex:32177},{level:2,title:"import React from 'react'",slug:"import-react-from-react",normalizedTitle:"import react from 'react'",charIndex:32473}],headersStr:"相同 不同 区别？ 组件化 VDOM react、vue VDOM相同点 diff 优化基本上思路相同 diff  源码 相同之处 react和vue中VDOM差别 dom的更新策略不同 总结 数据驱动视图 vue 数据驱动视图 react的数据驱动视图 核心思想 优点 不习惯之处 JSX 状态提升 React 16前!img React 16后 constructor 16新增2个 getDerivedStateFromProps getSnapshotBeforeUpdate componentDidMount shouldComponentDidMount componentDidUpdate componentWillUnmount 准备废弃 componentWillMount componentWillReceiveProps(nextProps) componentWillUpdate 🔥 setState 有状态组件 无状态组件 受控组件 非受控组件 class、hooks 卡顿原因 优化场景 思路 React.memo React.useMemo PureComponent 高阶组件 避免内联对象 避免匿名函数 组件懒加载 用 CSS React.Fragment key 合理使用Context 虚拟列表 合理设计组件 同步or异步 第二个参数 state如何注入到组件 解决 限制 hooks和生命周期 useState 模拟componentDidMount useLayoutEffect、useEffect 第二个参数 useMemo useCallback useRef 为啥ref获取不到hooks？ 总结 使用场景 如何使用 render不能访问refs 声明式编程 惰性执行（Lazy Evaluation） 核心概念 数据不可变 无状态 没有副作用 纯函数 SPA MPA MVVM MVC MVVM、MVC 单向数据流框架始祖Flux import react 导致文件变大？ React.lazy 使用 React.lazy Suspense 组件 render() diff re-render window.requestIdleCallback() 双缓冲优化策略 dangerouslySetInnerHTML import React from 'react'",content:"> 虽然你知道可以优化，但不代表你应该优化\n\n\n# 为啥用React\n\n答React的好处就是了\n\n * 合成事件\n\n * VDOM\n\n * JSX\n\n * 生命周期\n\n * 单向数据流\n\n * ……\n\n\n# React、Vue\n\n引出mvc和mvvm\nreact和vue底层思想\n优缺点\n实践：技术选型\n得出结论\n\n\n1\n2\n3\n4\n5\n\n\n\n# 相同\n\n * 组件化开发和VDOM\n * 支持props\n * 数据驱动视图，不直接操作ADOM\n * 支持SSR\n * 都借鉴MVVM的思想\n * 将注意力集中在 保持核心库，将其他功能 如 路由 和全局状态管理 交给相关的库\n * 都有自己的构建工具\n\n\n# 不同\n\n * vue实现数据双向绑定，react单向数据流\n\n * react的jsx功能强大，扩展性强\n\n * vue的dom操作方便，for/if指令\n\n * react思想很棒，代码更美观\n\n * Vue标签更方便，也是封装好的语法糖\n\n * VDOM\n\nVue比React好？\n\n\n# 区别？\n\n大体相同，都使用VDOM高效 更新视图， 提倡组件化， 实现 数据驱动视图， 使用diff算法， 对diff算法 优化， router库实现url到组件的映射， 状态管理\n\n具体实现 不尽相同\n\n\n# 组件化\n\n组件是独立和可复用的代码组织单元，它使开发者使用小型、独立和通常可复用的组件构建大型应用\n\n提高开发效率**、测试性、**复用性\n\n降低耦合度，在保持接口不变可以替换不同组件快速完成需求，输入框，可替换日历、时间、范围等组件作具体的实现\n\n调试方便，整个系统通过组件组合，出现问题时，排除法移除组件，根据报错组件快速定位问题，因为每个组件低耦合，职责单一，逻辑会比分析整个系统简单\n\n提高可维护性，组件职责单一，被复用，对代码优化可获得系统整体升级\n\n都推崇组件化，将页面拆分成小的可复用单元提高 复用率和开发效率。 开发时react和vue有相同的套路，父子组件传参，数据状态管理，前端路由\n\nReact推荐 JSX + inline style， 把 HTML 和 CSS 写进 JavaScript\n\nVue 推荐 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解)，即 html，css，JS 写在同一个文件(vue也支持JSX写法)\n\n\n# VDOM\n\n表现为描述 DOM 结构及其属性信息的 对象\n\n * 存储在内存\n * 描述ADOM\n * 数据变化 生成新的DOM，对比新旧VDOM将差异更新到ADOM\n\n> 优点\n\n * 减少 DOM 操作：虚拟 DOM 可以将多次 DOM 操作合并为一次操作\n * 研发效率的问题：虚拟 DOM 的出现，为数据驱动视图 思想提供 高度可用 载体， 前端开发 基于函数式 UI 编程方式实现高效的声明式编程\n * 跨平台的问题： 同一套虚拟 DOM，可 对接不同平台 渲染逻辑，从而实现“一次编码，多端运行”\n\n\n> # react、vue VDOM相同点\n\n都使用 Virtual DOM + Diff算法，最后都是生成render函数，render函数执行返回VNode(VDOM的数据结构，本质是树)\n\n每次UI更新，会根据render重新生成最新VNode，跟以前缓存起来老的VNode比对，使用Diff算法 更新ADOM（VDOM是 对象 ， 在JS引擎中， ADOM在浏览器渲染引擎中，所以操作VDOM比操作ADOM开销要小 ）\n\n> # diff 优化基本上思路相同\n\n * tag不同认为是不同节点\n * 只比较同一层级，不跨级比较\n * 同一层级的节点用key唯一标识，tag和key都相同则认为是同一节点\n\n> # diff 源码 相同之处\n\n处理老节点部分，都需要把节点处理 key - value 的 Map 结构，方便在往后的比对中 快速通过节点的 key 取到对应 节点。同样在比对两个新老节点是否相同时，key 是否相同也是 判断标准。 设置一个唯一值 key 在 diff 处理 时 性能才最大化\n\n\n> # react和vue中VDOM差别\n\n都是用js对象 模拟ADOM，VDOM的diff 最小化更新ADOM， 减小 性能损耗，按颗粒度分为不同的类型比较同层级dom节点，进行增、删、移\n\n按颗粒度分为tree diff， component diff， element diff. tree diff 比较同层级dom节点，进行增、删、移操作。如果遇到component， 就会重新tree diff流程\n\n> # dom的更新策略不同\n\nreact 自顶向下全diff。vue 跟踪每 个组件 依赖关系，不需要re-rendr\n\nreact 状态 改变时， 重新render 生成新的VDOM tree， 新旧dom tree 比较， patch打补丁方式，局部更新 。 react为 避免父组件更新 引起不必要 子组件更新， 在shouldComponentUpdate 逻辑判断，减少没必要 render， 重新生成VDOM，做差量对比\n\nvue通过Object.defineProperty 把 data 属性全部转为 getter/setter。 watcher实例对象 在组件渲染时，将属性记录为dep， 当dep 项中的 setter被调用时，通知watch重新计算，使得关联组件更新\n\n> # 总结\n\nVue2 核心Diff算法采用 双端比较 ，同时从新旧children的两端 比较，借助key值找到可复用的节点，再 操作。相比React的Diff算法，同样情况 可以减少移动节点次数，减少 性能损耗，更加 优雅\n\n\n# 数据驱动视图\n\n数据变化 相应 视图 更新。开发者只需要关注数据 变化而不用 手动 操作DOM\n\n\n> # vue 数据驱动视图\n\nMVVM 框架实现。MVVM 包含3个部分:model、view和 viewModel\n\n * Model 数据\n * View 视图部分， dom\n * ViewModel 连接视图与数据的中间件\n\nViewModel是实现数据驱动视图的核心， 数据变化 ViewModel能够监听到 ， 及时 通知view 修改。同样当页面有事件触发 ，ViewModel也能够监听 ，并通知model响应。ViewModel相当于观察者，监控着双方的动作，及时通知对方操作\n\n首先，vuejs实例化过程中，会对遍历传给实例化对象选项中的data 选项，遍历其属性使用 Object.defineProperty 全部转为 getter/setter\n\n同时每个实例对象都有watcher实例对象，在模板编译的过程中，用getter访问data的属性，watcher此时把用到的data属性记为依赖，建立视图与数据联系。之后渲染视图的数据依赖改变，watcher对比前后两个的数值是否变化，确定是否通知视图re-render。这样实现所谓的数据对于视图驱动\n\n\n> # react的数据驱动视图\n\n * pending 当前所有等待更新的state队列\n * isBatchingUpdates 标识当前是否处理批量更新状态，默认false\n * dirtyComponent 当前所有待更新state的组件队列\n\nsetState实现数据驱动视图，引发一次组件的更新过程从而实现页面的re-render\n\n * setState() 将接收的第一个参数state存储在pending队列\n * 判断是否处于批量更新，是 就将需要更新state的组件添加到dirtyComponents\n * 不是 会遍历dirtyComponents所有组件，调用updateComponent更新每个dirty组件\n\n\n# 核心思想\n\n\n\n\n# React设计实现\n\n * 是一个简单的JS UI库，用于构建高效、快速的用户界面\n\n * 是一个轻量级库\n\n * 遵循组件设计模式、声明式编程范式和函数式编程\n\n * 使用VDOM操作ADOM\n\n * 遵循从高阶组件到低阶组件的单向数据流\n\n\n# 优点\n\n * 提高性能\n\n * JSX 可读性增加\n\n * 易集成使用\n\n * 代码直观\n\n * 组件简单可复用\n\n * VDOM\n\n * 函数式编程\n\nReact 老矣，我建议大家用用别的框架\n\n\n# 不习惯之处\n\nReact 我爱你，但你太让我失望了\n\n\n# JSX\n\nconst ele=<h1>hello world</h1>\n\n\n1\n\n\n既不是字符串也不是HTML，是jsx，是JS的语法扩展，生成React元素\n\nReact认为渲染逻辑本质与其他UI逻辑内在耦合，将标签和逻辑共同存放在组件中，实现关注点分离\n\n编译之后，JSX被转换为JS普通函数调用，取值后得到JS对象\n\n允许在条件或循环语句中使用JSX，将其赋值给变量，传入JSX作为参数，以及从函数中返回JSX\n\n防止注入攻击\n\n 1. 可以安全地在JSX中插入用户内容\n 2. React的DOM在渲染所有内容后，会进行转义，确保应用中永不会注入那些不是自己写的内容\n\nJSX表示对象\n\nBabel将JSX转译为一个名为React.createElement()函数调用\n\nReact读取这些React元素对象并使用它们构建DOM以保持随时更新\n\n\n# 状态提升\n\n将多个组件需要共享的state 向上 移动到它们最近的公共组件 中，实现state 的共享\n\n让数据自顶向下单向流动，所有组件数据来自父辈组件，由父辈组件来统一存储和修改，再传入子组件\n\n**为了组件之间的数据更加单向性，**数据的传输上始终出现一对一的情况，方便我们只需要在向子组件传递数据的父组件上操作，并传回子组件，更新数据，体现了React单向数据流的设计思想，复用组件时，组件数据不会相互干扰，代码逻辑上便于管理\n\n\n# key\n\nWarning:Each child in an array or iterator should have a unique \"key\" prop\n\n\n1\n\n\n> 为啥使用\n\nkey在DOM中元素增删改查时帮助识别哪些元素发生变化，所以需要给每一个元素赋予唯一标志，想要访问key属性值，需要使用其他属性名 显性 访问\n\ndiff算法将key作为唯一id对比组件value确定是否更新\n\n不传key也能用是因为react检测子组件没有key，默认将index作为key\n\n原则\n\n * key同，组件属性有变化，react只会更新组件变化的属性\n * key不同，销毁之前的组件，导致re-render\n\n> 使用index存在啥问题\n\nspan单纯展示组件，是受控组件，值由我们定好\n\n若子组件只是受控组件，index作为key，表面可能不会出问题，实际性能可能受影响\n\n列表数据源 顺序 改变，若适用 index 作为key，对应key为0 1 2的组件都变，子组件全部会re-render\n\n注意：未添加key，兄弟节点更新位置前后错位一个，后续全部的比较都会 错误，导致找不到对比目标，性能大打折扣\n\n若使用id作为key，根据更新原则，子组件和key均未改变，顺序改变，我们只移动而不是re-render\n\ninput是非受控组件，用户可任意改变value\n\n> 正确赋值key\n\n若纯粹展示没有其他变更，使用index或其他值作为key没有问题，因为没有diff，就不会用key\n\n * 和具体元素一一对应\n * 尽力不使用 index 作为key\n * 不使用随机数等 加上不稳定的key，否则性能开销比不加key更糟糕\n\n> 使用场景\n\n由数组动态创建的子组件的情况\n\n为一个有复杂繁琐逻辑的组件添加key后，后续操作可改变key值，从而 达到 先销毁之前的组件，再重新创建该组件\n\n\n\n\n# ⭐️ 生命周期\n\n * 挂载 mount，组件第一次在 DOM 树中被渲染\n * 更新过程 update，re-render\n * 卸载 unmount，组件从 DOM树中被移除过程\n\nReact15生命周期\n\nconstructor() \ncomponentWillReceiveProps() // 父组件状态属性更新触发\nshouldComponentUpdate() // 组件更新时调用，在此可拦截更新\ncomponentWillMount() // 初始化渲染时调用（挂载前调用）\ncomponentWillUpdate() // 组件更新时调用\ncomponentDidUpdate() /\ncomponentDidMount() // 初始化渲染时调用（挂载后调用）\nrender()\ncomponentWillUnmount() \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nReact16\n\nconstructor() \ngetDerivedStateFromProps() // 组件初始化和更新时调用\nshouldComponentUpdate() // 组件更新时调用，在此可拦截更新\nrender() \ngetSnapshotBeforeUpdate() // 组件更新时调用\ncomponentDidMount() // 组件初始化时调用（挂载后调用）\ncomponentDidUpdate(prevProps, prevState) // 组件更新后调用\ncomponentWillUnmount() \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# React 16前\n\n\n# React 16后\n\n\n\n首次挂载 getDefaultProps、getInitialState、componentWillMount、render 和 componentDidMount\n\n卸载组件\n\n重新挂载组件 getInitialState、componentWillMount、render 和 componentDidMount，但并不执行 getDefaultProps\n\n更新组件 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render 和 componentDidUpdate\n\n\n# constructor\n\n实例过程中自动调用，方法内部通过super关键字获取父组件的props\n\n * 初始化state\n * this上挂载方法\n\n\n# 16新增2个\n\n\n# getDerivedStateFromProps\n\nstatic getDerivedStateFromProps(nextProps, prevState) {\n    const {type} = nextProps;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevState.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 静态方法(纯函数)\n * 只能通过preState 而不是 prevProps 作对比，保证了state 和 props 间的简单关系及不需要处理第一次渲染时 prevProps 为空的情况\n\n执行时机：组件创建和更新阶段，不论是props变化还是state变化，也会调用\n\n在每次render方法前调用，第一个参数为即将更新的props，第二个参数为当前组件的state，可以比较props 和 state来加一些限制条件，防止无用的state更新\n\n该方法返回新对象更新state，不更新则返回 null\n\n静态方法阻止操作instance，阻止多次操作setState，没有instance就不能操作DOM\n\n逻辑应该会很简单，就不会出错，不出错就不会打断DFS过程\n\ngetDerivedStateFromProps() contains the following legacy lifecycles: componentWillMount componentWillReceiveProps componentWillUpdate\n\n> React 16.4后对getDerivedStateFromProps做了微调。在>=16.4以后的版本中，组件任何的更新流程都会触发getDerivedStateFromProps，而在16.4以前，只有父组件的更新会触发该生命周期\n> \n> 不咋使用\n\n\n# getSnapshotBeforeUpdate\n\n返值Snapshot值(默认为 null )，作为componentDidUpdate第三个参数\n\n运行在render后，表示ADOM构建完成，但还没有渲染到页面，可理解为更新前的快照，用来做一些附加的DOM操作\n\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n    console.log('#enter getSnapshotBeforeUpdate');\n    return 'foo';\n}\n\ncomponentDidUpdate(prevProps, prevState, snapshot) {\n    console.log('#enter componentDidUpdate snapshot = ', snapshot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n获取组件更新前的一些信息，比如组件的滚动位置之类\n\n\n# componentDidMount\n\n组件挂载到ADOM节点后执行，render之后执行\n\n * 执行数据获取，事件监听等操作\n\n此处 调用 setState 触发一次额外的渲染，它 在浏览器刷新屏幕前执行！所以用户没有感知，但会带来一定性能问题\n\n和 componentWillMount 一样，有且仅有一次 调用！\n\n\n# shouldComponentDidMount\n\n告知组件本身基于当前的props和state是否需要 re-render，默认返回true\n\n执行时机：到新的props/state 调用，返回true/false告知组件更新与否\n\n一般情况，不建议在该周期方法中深层比较，影响效率\n\n同时也不能调用setState，会导致无限循环更新\n\n\n# componentDidUpdate\n\nADOM挂载到页面后运行\n\n可根据前后的props和state变化操作，如获取数据，修改DOM等\n\ncomponentDidUpdate(prevProps, prevState, snapshot){}\n\n\n1\n\n\n\n# componentWillUnmount\n\n组件卸载前，清理副作用\n\n一旦一个组件实例被卸载，不会被再次挂载，只可能被重新创建\n\n\n# 准备废弃\n\n 1. 被废弃的3个方法都在render之前，因为fiber出现，可能因为高优先级任务 打断现有任务导致它们被执行多次\n 2. React想约束使用者，好的框架能让人写出易维护和扩展的代码\n\n\n# componentWillMount\n\n风险很高，鸡肋\n\n此函数可以使用 componentDidMount 和 constructor 代替\n\n为了约束开发者，直接干掉了此 API\n\n\n# componentWillReceiveProps(nextProps)\n\n一个API并非越复杂才越优秀\n\nprops 变化执行，初始化render 时不执行\n\n老版本React中，若组件自身的某个state跟其props密切相关，没有一种优雅的方式处理state，而是需要在 componentWillReceiveProps 中判断前后2个props是否相同，若不同再将新的props更新到相应的state上\n\n通过 setState更新组件状态，旧属性通过this.props 获得，此处调用更新状态是安全的，不会触发额外render\n\n优点\n\n * 可以在子组件的render函数执行前获取新的props，进而更新子组件自己的state\n * 可以将数据请求放在这里执行，需要的参数中nextProps获取，不必将所有请求都放在父组件中\n\n缺点\n\n * 破坏state数据的单一数据源，导致组件状态不可预测\n * 增加组件的重绘次数\n\n\n# componentWillUpdate\n\n> componentWillUpdate( nextProps, nextState )\n\n挡了新的Fiber架构的路\n\n * 一次更新可能被调用多次，因为一次更新中 componentDidUpdate 只会被调用一次，所以将原先写在 componentWillUpdate 中的回调移至componentDidUpdate 就可以解决这个问题\n * 获取 DOM 元素状态，fiber中render可被打断，可能在WillMount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用getSnapshotBeforeUpdate解决\n\n由getSnapshotBeforeUpdate(prevProps,prevState) 代替，在最终的render之前调用\n\n> 为何要废弃它们？\n\n在Fiber机制下，render阶段允许被暂停、终止和重启\n\n**导致render阶段的生命周期都可能重复执行。**这几个方法常年被滥用，执行过程中存在风险。比如setState fetch发起请求 操作ADOM等\n\n这些操作完全可以转移到其他方法中做\n\n即使没有开启异步渲染，Recat15中也可能导致一些严重的问题，比如componentWillReceiveProps和componentWillUpdate里滥用setState导致重复渲染，死循环\n\n首先确保了Fiber机制下数据安全性，同时也确保生命周期方法的行为更纯粹\n\n\n# 🔥 setState\n\n> componentWillMount中setState\n\n无意义，应当将setState放在constructor中（初始化state）\n\n组件只挂载一次，componentWillMount中的setState回合constructor中state合并执行\n\n> componentDidMount中setState\n\n导致组件初始化时触发更新，渲染2次\n\n> componentWillUnmount中setState\n\n不会更新，无意义\n\n> shouldComponentUpdate和componentWillUpdate中setState\n\n禁止\n\n造成死循环\n\nsetState后会再次触发这2个函数，然后又触发setState\n\n> componentDidUpdate中setState\n\n可以\n\n组件刚更新完成，又要更新一次，连续render两次\n\n和componentDidMount类似\n\n> componentWillReceiveProps中setState\n\n可以\n\n不会re-render，因为只有 props变化才会触发，setState不会造成死循环\n\n\n# 💚 组件通信\n\n * 父组件向子组件传递\n * 子组件向父组件传递\n * 兄弟组件之间的通信\n * 父组件向后代组件传递\n * 非关系组件传递\n\n> 父组件向子组件传递\n\nReact的数据流是单向的，这是最常见的方式，props\n\n父子通信底层如何实现?\n\n> 子组件向父组件传递\n\n父组件向子组件**传一个函数，然后通过这个函数的回调拿到子组件传递的值**\n\n> 兄弟组件之间的通信\n\n父组件作为**中间层实现数据互通**\n\n> 父组件向后代组件传递\n\n最普通的事情，像全局数据一样\n\n使用context可共享数据，其他数据都能读取对应的数据\n\n> 非关系组件传递\n\n组件间关系类型复杂，可以将数据进行一个全局资源管理，从而实现通信，例如redux dva\n\n\n# 💙有/无状态组件\n\n\n# 有状态组件\n\n特点\n\n * 是类组件\n * 有继承\n * 有this\n * 有生命周期\n * 使用较多，易触发生命周期钩子函数\n * 内部使用state，根据外部组件传入的props和自身state渲染\n\n使用场景\n\n * 需要使用状态的\n * 需要状态操作组成的\n\n总结\n\n可维护自己的state，可以对组件做更多的控制\n\n\n# 无状态组件\n\n特点\n\n * 不依赖自身state\n * 可以是类组件或函数组件\n * 可避免使用this\n * 组件内部不维护state，props改变，组件re-render\n\n使用场景\n\n组件不需要管理state\n\n优点\n\n * 简化代码 专注render\n * 组件不需要实例化，无生命周期\n * 视图和数据解耦\n\n缺点\n\n * 无法使用ref\n * 无生命周期\n * 无法控制组件re-render\n\n> 当一个组件不需要管理自身状态时，就是无状组件，应该优先设计为函数组件，比如定义的\n\n\n# 受/非受控组件\n\n\n# 受控组件\n\n表单状态变化，触发onChange，更新state\n\n受控组件中，组件渲染出的状态和value/checked属性相对应，react通过这种方式消除组件的局部状态，使组件变得可控\n\n缺点\n\n多个输入框需要获取到全部值时，需要每个都编写事件处理函数，代码臃肿\n\n后来，出现了非受控组件\n\n\n# 非受控组件\n\nInput组件有内部value，没有任何属性——非受控组件，组件状态不受外部环境控制，而是封闭在组件内部\n\n若把state的value放到props中——变成 受控组件(此时input值取决于外部传递的props)\n\n表单组件没有value props\n\n可使用ref 从 DOM 中获取表单值，而不是编写事件处理函数\n\n非受控组件可以减少代码量\n\n\n\n\n# 类/函数组件\n\n相同点\n\n基本可认为两者完全一致\n\n不同点\n\n函数组件 是 无状态组件 的思想\n\n函数组件 无法使用 state，没有 生命周期方法，接收 props，渲染 DOM\n\n函数组件没有 this\n\n函数组件 更易理解\n\n函数组件性能优化依靠 React.memo缓存渲染结果实现\n\n类组件 基于面向对象编程，主打 没有副作用，引用透明等特点\n\n类组件性能优化依靠shouldC omponentUpdate阻断渲染实现\n\n\n# class、hooks\n\n函数式编程？\n\nclass占内存啊，写了class写hooks可以快速切换，但是写了hooks再写class就不得行，因为所有最终回归的是C++ C 和操作系统，class相当于提供了一个框框，约束我们代码的编写\n\nhooks就有点放飞自我，因为是函数式编程不像class是一个类，实例 有静态方法，占用内存，而函数式就是运行完内存即释放，需要使用的变量得不到一个合适的保存，于是只有使用闭包方式，但是闭包存在挺多的问题，涉及到内存泄漏等，而且存在很多闭包，\n\n链式编程？\n\n如果有bug怎么调试，大家都是学生，首先是为了提高自己发现问题并解决问题的能力\n\nReact存在兼容性，之所以不升级antd版本，为了兼容id浏览器\n\n\n# 💚 性能优化\n\nReact 性能优化的那些事儿\n\n\n# 卡顿原因\n\nrender时会根据现有render产生新的jsx数据和现有fiberRoot对比，找到不同地方，生成新的workInProgress，进而在挂载阶段把新的workInProgress交给服务器渲染\n\n这个过程中，为了让底层机制更加高效快速，react做了大量优化，设立任务优先级、异步调度、diff算法和时间分片等\n\n整个链路为了快速高效完成从数据更新到页面渲染的整体流程\n\n为了不让递归遍历寻找所有更新节点太大而占用浏览器资源，React升级了fiber架构，时间分片，实现增量更新\n\ndiff——高效查找所有更新节点\n\n任务调度优先级——高效更新\n\n优化——控制刷新渲染的波及范围，只让该更新的更新，更新链路尽快走完\n\n\n# 优化场景\n\n * 父组件更新，子组件不更新\n\n> PureComponent、shouldComponentUpdate、父组件对子组件缓冲、memo\n\n * 组件自己控制是否刷新\n * 减少波及范围，无关刷新不存在state\n * 合并state，减少setState执行次数\n * 更快完成diff比较过程\n\n\n# 思路\n\n * 减少render次数\n * 减少渲染的节点\n * key\n * 降低计算量\n * 缓存\n * VDOM\n * 使用工具分析性能瓶颈\n * 使用不可突变数据结构，数组使用concat，对象使用Object.assign()\n * 组件尽可能拆分\n * 列表类组件优化\n * bind函数优化\n * 不滥用props\n * reactDOMServer进行服务端渲染组件\n\n\n# React.memo\n\nReact16.6新增，缓存组件\n\n和PureComponent相似，但memo只用于函数组件\n\n使用其对航班信息可视化系统做了优化\n\nReact17+antvL7+antd\n\n记忆组件渲染结果，提高组件性能\n\n只检查props是否变化\n\n做浅比较\n\n第二个参数可传入自定义比较函数\n\nareEqual方法和shouldComponentUpdate返回值相反\n\nconst App=React.memo(\n    function myApp(props){\n   //使用props渲染 \n\t}\n    function areEqual(prevProps, nextProps){\n    //如果把prevProps传入render方法的返回结果和将nextProps传入render的返回结果一样，则返回true，否则返回false\n}\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# React.useMemo\n\n缓存大量计算\n\n函数组件中，匿名函数，箭头函数和普通函数会重新声明\n\nuseMemo 第一个参数是函数，这个函数返回的值会被缓存，同时作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组值变化，会重新执行第一个参数的函数，并将函数返回的值缓存起来作为 useMemo 的返回值\n\n// 避免这样做\nfunction Component(props) {\n  const someProp = heavyCalculation(props.item);\n  return <AnotherComponent someProp={someProp} /> \n}\n  \n// 只有 `props.item` 改变时someProp的值才会被重新计算\nfunction Component(props) {\n  const someProp = useMemo(() => heavyCalculation(props.item), [props.item]);\n  return <AnotherComponent someProp={someProp} /> \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# PureComponent\n\n避免重复渲染\n\nReact.Component并未实现 shouldComponentUpdate()，而 React.PureComponent以浅层对比 Prop 和 State 的方式实现了该函数\n\nshouldComponentUpdate做的是“浅层比较”。若是“深层比较”，某个特定组件的行为，需要我们自己编写\n\n父组件状态的每次更新，都会导致子组件re-render，即使传入相同props。但这里的re-render 不是说会更新DOM，而是每次都会调用diif算法判断是否需要更新DOM。这对大型组件例如组件树来说 非常消耗性能\n\nshouldComponentUpdate确保只有当组件props状态改变时才会re-render，返回false表示不希望组件re-render\n\nPureComponent进行浅比较判断组件是否应该re-render，对于传入的基本类型props，只要值相同，浅比较就会认为相同，对于传入的引用类型props，浅比较只会认为传入的props是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是不同的props。\n\nPureComponent，因为进行浅比较也会花费时间，这种优化更适用于大型的展示组件上。大型组件也可以拆分成多个小组件，并使用memo来包裹小组件，也可以提升性能。\n\n * 确保数据类型是值类型\n * 如果是引用类型，不应当有深层次的数据变化(解构)\n\n判断步骤：\n\n 1. 直接比较新老 props /新老 state 是否相等。相等不更新组件\n 2. 判断新老 state / props ，有不是对象/为 null 的，返回 false ，更新组件\n 3. Object.keys 将新老 props /新老 state 属性名 key 变成数组，判断数组长度是否相等，不相等证明有属性增加/减少，更新组件\n 4. 遍历老 props /老 state ，判断对应新 props /新 state ，有没有与之对应且相等的（这个相等是浅比较），有一个不对应/不相等，直接返回 false ，更新组件\n\n\n# 高阶组件\n\n函数组件没有 shouldComponentUpdate 方法，可利用 高阶组件 封装一个类似PureComponent 方法\n\n\n# 避免内联对象\n\n使用内联对象时，react会在每次渲染时重新创建对此对象的引用，这会导致接收此对象的组件将其视为不同的对象，因此，该组件对于prop的浅层比较始终返回false，导致组件一直re-render。\n\n// Don't do this!\nfunction Component(props) {\n  const aProp = { someProp: 'someValue' }\n  return <AnotherComponent style={{ margin: 0 }} aProp={aProp} />  \n}\n\n// Do this instead :)\nconst styles = { margin: 0 };\nfunction Component(props) {\n  const aProp = { someProp: 'someValue' }\n  return <AnotherComponent style={styles} {...aProp} />  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 避免匿名函数\n\n// 避免这样做\nfunction Component(props) {\n  return <AnotherComponent onChange={() => props.callback(props.id)} />  \n}\n\n// 优化方法一\nfunction Component(props) {\n  const handleChange = useCallback(() => props.callback(props.id), [props.id]);\n  return <AnotherComponent onChange={handleChange} />  \n}\n\n// 优化方法二\nclass Component extends React.Component {\n  handleChange = () => {\n   this.props.callback(this.props.id) \n  }\n  render() {\n    return <AnotherComponent onChange={this.handleChange} />\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 组件懒加载\n\n使用新的React.Lazy和React.Suspense完成\n\nReact.lazy\n\n定义动态加载的组件，可直接缩减打包后 bundle 体积，延迟加载在初次渲染时不需要渲染的组件\n\nReact.Suspense\n\n悬挂 终止 暂停\n\n配合渲染 lazy 组件，在等待加载 lazy组件时展示 loading 元素，不至于直接空白，提升用户体验；\n\n> 网球后台用到\n> \n> 只有在生产环境下展示SettingDrawer\n\n<Suspense fallback={<PageLoading />}>{this.renderSettingDrawer()}</Suspense>\n\n\nconst SettingDrawer = React.lazy(() => import('@/components/SettingDrawer'));\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 用 CSS\n\n而不是强制加/卸载组件\n\n渲染成本很高，尤其是在需要更改DOM时。此操作可能非常消耗性能并可能导致延迟\n\n// 避免对大型的组件频繁对加载和卸载\nfunction Component(props) {\n  const [view, setView] = useState('view1');\n  return view === 'view1' ? <SomeComponent /> : <AnotherComponent />  \n}\n\n// 使用该方式提升性能和速度\nconst visibleStyles = { opacity: 1 };\nconst hiddenStyles = { opacity: 0 };\nfunction Component(props) {\n  const [view, setView] = useState('view1');\n  return (\n    <React.Fragment>\n      <SomeComponent style={view === 'view1' ? visibleStyles : hiddenStyles}>\n      <AnotherComponent style={view !== 'view1' ? visibleStyles : hiddenStyles}>\n    </React.Fragment>\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# React.Fragment\n\n无需 在DOM中添加额外标签，不会渲染任何元素\n\nfunction Component() {\n        return (\n            <React.Fragment>\n                <h1>Hello world!</h1>\n                <h1>Hello there!</h1>\n                <h1>Hello there again!</h1>\n            </React.Fragment>\n        )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# key\n\n * 保证key具有唯一性\n * DIff算法根据key判断元素时新创建还是被移动的元素，从而减少不必要渲染\n\n虽然key是一个prop，但是接受key的组件并不能读取到key的值，因为key和ref是React保留的两个特殊prop\n\n\n1\n\n\n\n# 合理使用Context\n\n无需为每层组件手动添加 Props，通过provider接口在组件树间进行数据传递\n\n原则\n\nContext 中只定义被大多数组件所共用的属性\n\n * 使用createContext创建一个上下文\n * 设置provider并通过value接口传递state数据\n * 局部组件从value接口中传递的数据对象中获取读写接口\n\n> 网球系统后台使用了这个技术\n\ntoggle——切换\n\nimport { createContext } from 'react';\n\nconst LoginContext = createContext();\nexport default LoginContext;\n\n\n1\n2\n3\n4\n\n\n\n# 虚拟列表\n\n只渲染当前视口可见元素\n\n * 无限滚动列表，table\n * 无限切换日历\n\n\n# 合理设计组件\n\n简化Props\n\n简化State\n\n减少组件嵌套\n\n渲染函数内不该放太多副作用\n\n不滥用context，因为context可穿透React.memo或shouldComponentUpdate的对比，一旦context变化，所以依赖该context的组件都会刷新\n\ncontext不能精细化渲染\n\n\n# PureComponent、Component\n\nComponent需要实现shouldComponentDidMount，而PureComponent通过浅对比默认实现了shouldComponentDidMount，当组件更新时，若组件的props 和 state都没有改变，不会触发render函数，省去VDOM的生成和对比过程\n\nPureComponent其最佳情况是展示组件，因为其shouldComponentUpdate()进行浅比较，如果是引用数据类型，只会比较是不是同一个地址，不会比较这个地址的数据是否改变，浅比较会忽略属性或状态突变情况\n\n如果确保 state和 props 经常在变，不用 PureComponent反而效率可能更好，因为浅比较也会耗性能\n\n\n# ❤️ setState\n\n告诉组件数据有更新，可能需要re-render，react通常会集齐一批需更新的组件，再一次性保证渲染性能\n\nsetState改变之后，立即用this.state拿不到最新状态\n\n\n# 同步or异步\n\n根据变量isBatchingUpdates(是否 是批量更新) 判断是直接更新this.state还是放到队列中回头再说，isBatchUpdates默认false(同步更新 this.state)，函数batchUpdates 会将isBatchingUpdates修改为true，当React调用事件处理/生命周期函数之前 调用batchedUpdates，后果就是 setState异步更新\n\n若isBatchingUpdates为true，命中batchUpdate机制，进行 \"异步更新\"，反之为 \"同步更新\"\n\nAPI层面，setState是普通的调用执行的函数，自然是同步API\n\n此 同步 非 彼 同步\n\n同步还是异步 指的是调用API后更新DOM是异步还是同步？——取决于 被调用的环境\n\n * React能控制的范围调用，如 合成事件、生命周期，会批量更新，状态合并后再更新DOM，为异步\n * 原生JS控制的范围调用，如 原生事件，定时器回调，Ajax回调，setState调用后立即更新DOM，为同步\n\n异步 就是 批量更新，减少ADOM渲染次数，在React能控制范围内，一定是批量更新(为了性能着想)，先合并 状态，再一次性 更新DOM\n\nsetState意味着一个完整的渲染流程，包括\n\nshouldComponentUpdate->componentWillUpdate->render->componentDidUpdate\n\n\n1\n\n\nsetState 批量更新(异步) 是为了避免 频繁 re-render，消耗性能\n\n批量更新 过程 和 事件循环 类似，来一个setState将其加入 队列，待时机成熟， 队列中 state 结果合并，最后只对最新的state 进行更新\n\n\n\n在 react17 中，setState 批量执行，但如果在 setTimeout、事件监听器等函数里，setState 会同步执行。可以在外面包一层 batchUpdates 函数，手动设置 excutionContext 切换成批量执行\n\nreact18 中所有的 setState 都是异步批量执行了\n\n\n# 第二个参数\n\n是一个可选的回调函数，这个函数 在 组件re-render后执行，等价于 componentDidUpdate 中执行\n\n可拿到更新后的state\n\n\n# state如何注入到组件\n\n通过connect 和 mapStateToProps 将state注入 到组件\n\nmapStateToProps(state,ownProps)中带有两个参数，含义是\n\n * state-store管理的 全局状态对象，所有组件状态都存储在该对象中\n * ownProps 组件通过 props 传入的参数\n\n\n# 🍊 事件机制\n\nreact为了解决跨平台、兼容性问题，自己封装了一套事件机制，代理了原生事件，例如JSX的onClick和onChange都是合成事件\n\n充当浏览器原生事件的跨浏览器包装器 的对象\n\n将不同浏览器行为组合到一个 API中，确保事件显示一致的 属性\n\n<div onClick={this.handleClick.bind(this)}>点我</div>\n\n\n1\n\n\nReact并不是将click事件绑定到了div的ADOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样减少内存消耗，还能在组件挂在销毁时统一订阅和移除事件\n\n除此之外，冒泡到document上的事件也不是原生浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。如果不想要事件冒泡的话应调用event.preventDefault()方法，而不是调用event.stopProppagation()方法\n\n\n\n合成事件 是react 模拟原生 DOM 事件 所有能力的事件对象，优点如下\n\n * 兼容 所有浏览器，更好跨平台\n * 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果有很多的事件监听，就需要分配很多事件对象，造成高额内存分配。对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，便于下次复用\n * 事件统一 存放在一个数组，避免频繁新增和删除(垃圾回收)\n * 便于 react 统一管理\n\n原生事件 先执行，合成事件 后执行，合成事件 冒泡绑定到 document 上，所以 尽量避免 原生事件和合成事件 混用，(为啥呢？？)\n\n因为 如果原生事件 阻止冒泡，可能导致合成事件无法执行，因为合成事件需要冒泡到 document 上才会执行\n\n\n# 💚 Hooks\n\nReact16.8新增特性，主要解决了函数式组件无状态的问题\n\n类组件内部逻辑难以拆分和复用\n\n函数组件，内部无法定义和维护state，也叫 无状态 组件\n\n轻量 灵活 易于维护和组织，学习成本低\n\n组件功能清晰很小巧！\n\n * 类组件需继承 class\n * 类组件可访问生命周期方法\n * 类组件可获取实例化后 的 this\n * 类组件可定义并维护state\n\nhooks前，类组件边界强于函数组件\n\nUI=render(data)\n或\nUI=func(date)\n\n\n1\n2\n3\n\n\n\n# 解决\n\n * 组件 逻辑复用，render props/HOC也为了复用，hooks作为官方底层API，最轻量且改造成本小，不影响组件层次结构和嵌套地狱\n * 复杂组件理解\n * 难以理解的class，不同生命周期使逻辑分散混乱，不易维护管理，关注this指向问题，代码复用代价高，HOC使整个组件变得臃肿\n * 状态与UI隔离，状态逻辑变成更小的粒度，易抽象为自定义hooks，组件状态和UI更清晰\n\n\n# 限制\n\n * 不在循环、条件和嵌套函数中调用(链表 实现Hook，可能导致 数组取值错位)\n * 仅在函数组件中调用hook(因为没有 this)\n * useEffect中避免使用useState\n\n\n# hooks和生命周期\n\nCLASS 组件                   HOOKS 组件\nconstructor                useState\ngetDerivedStateFromProps   useState 里面 update 函数\nshouldComponentUpdate      useMemo\nrender                     函数本身\ncomponentDidMount          useEffect\ncomponentDidUpdate         useEffect\ncomponentWillUnmount       useEffect 里面返回的函数\ncomponentDidCatch          无\ngetDerivedStateFromError   无\n\n\n# useState\n\n和class组件的state差不多\n\n返回一个state和更新state的函数\n\n初始渲染期间，返回状态和传入第一个参数相同\n\nsetState用于state的更新，接收新的state并将组件的一次re-render加入 队列\n\n> 为啥useState使用数组\n\n解构赋值！！\n\n使用数组，我们可以对数组中元素命名，代码比较干净\n\n使用对象，解构时必须要和useState内部实现返回对象同名，多次使用只能设置别名\n\n// 第一次使用\nconst { state, setState } = useState(false);\n// 第二次使用\nconst { state: counter, setState: setCounter } = useState(0) \n\n\n1\n2\n3\n4\n\n\n * # 模拟componentDidMount\n\nuseEffect(() => {\n  console.log('componentDidMount')\n}, [])\n\n\n1\n2\n3\n\n\n\n# useLayoutEffect、useEffect\n\nuseEffect相当于是一个副作用的函数\n\n渲染阶段 可改变DOM、添加订阅、设置定时器、记录日志，执行包含副作用的操作都不被允许，可能产生bug 破坏UI一致性\n\n使用useEffect完成副作用操作\n\n * 共同点\n\n都是处理副作用，包括 DOM改变，订阅设置，定时器操作\n\n * 不同点\n\nuseEffect 渲染之前 异步调用，不会等待DOM真正渲染后执行，可能会闪烁\n\nuseLayoutEffect 渲染之前 同步调用，不会闪烁，**总是比 useEffect先执行！**可获取更新的state\n\nuseLayoutEffect 和 componentDidMount，componentDidUpdate 执行时机一样，在浏览器将所有变化渲染到屏幕之前执行\n\n建议使用 useEffect！建议使用 useEffect！建议使用 useEffect！ 避免阻塞视觉更新\n\n页面有异常就再替换为 useLayoutEffect\n\n> 项目中用于发送请求\n\n> # 第二个参数\n\n航班系统中使用useEffect第二参数对系统发送请求进行优化，仅在组件挂载和卸载时执行，传递一个[]，作为第二参数，告诉React我的effect不依赖于props或state中的任何值，不需要重复执行\n\n控制不同航班信息的展示，使用useEffect的第二个参数传递一个state，控制drawer的变化，只有state变化了，effect才会执行，async-await执行结束，数据更新，打开drawer就有效果了\n\n收集子组件的值，将参数和函数一起传入子组件，子组件调用函数，父组件就能接收子组件的值了，根据传回来的数据，以及判断URL，重新获取数据，根据state更新对应的值，渲染界面\n\n\n1\n2\n3\n4\n5\n\n\n第一个参数 是回调函数\n\n第二个参数 是依赖\n\n当第二个参数为null或undefined时，回调每次 render 都会执行，参数为数组时，只有依赖变了才会执行\n\nVDOM转fiber的过程叫做reconcile，更新到DOM的过程叫做 commit，reconcile的过程可打断，需要schedule\n\nhooks也是基于fiber实现，它在fiber节点上维护一个链表（memorizedState属性）来保存数据，每个hook都是从对应的链表元素上存取各自的数据\n\n这个链表建立的过程叫做——mount，以后只需要update，所以每个hook的实现都分为mount和update两个阶段\n\n> useEffect第二个参数对应的是 deps，如何判断是否要更新？？\n\ndeps是新传入的参数，若是undefined会作为null，hook.memorizedState.deps 取到的是之前的 deps\n\n如果 prevDeps 是 null，直接返回 false，所以第二个参数传 undefined 或 null 函数都会执行\n\n否则，才会新旧的 deps 数组中每个元素对比，有一个不一样就返回 false\n\n\n# useMemo\n\n当父组件中调用子组件时，父组件的state变化，会导致父组件更新，子组件即使没有变化，也会更新\n\n函数式组件从头更新到尾，只要一处改变，所有模块都会刷新——没必要！\n\n理想状态是 各个模块只进行 自己的更新，不相互影响\n\nuseMemo为了防止一种情况——父组件更新，无论是否最子组件操作，子组件都会更新\n\nmemo 结合了 PureComponent 纯组件 和 componentShouldUpdate 功能，会对传入的props进行一次对比，根据第二个函数返回值判断哪些props需要更新\n\nuseMemo和memo类似，都是 判断 是否满足当前限定条件决定是否执行 callback ，useMemo的第二个参数是一个数组，通过这个数组判断是否更新回调函数\n\n好处\n\n * 减少不必要 循环 和 渲染\n * 减少 子组件 渲染次数\n * 避免不必要 的开销\n\n\n# useCallback\n\n和useMemo 可以说是一模一样，唯一不同的是useMemo返回函数运行结果，而useCallback返回函数\n\n缓存回调，避免传入的回调每次都是新的函数实例导致依赖组件re-render\n\n是父组件传递子组件的 一个函数，防止无关 刷新，必须配合 memo，否则可能 还会降低 性能\n\n\n# useRef\n\n获取组件真实节点，返回一个可变的ref对象，且这个对象 只有 current 属性，可设置 initialValue\n\n> 缓存数据\n\nreact-redux 源码中，hooks推出后，react-redux用大量的useMemo重做了 Provide 等核心模块，运用了useRef 缓存数据，所运用的useRef() 没有一个是绑定在dom元素上的，都是用于数据缓存\n\nreact-redux 利用 重新赋值，改变了缓存的数据，减少不必要更新，如果使用userState势必会re-render\n\n\n# 为啥ref获取不到hooks？\n\n\n# 总结\n\n * 一个优秀的hooks一定具备 useMemo useCallback 等api 优化\n * 制作自定义hooks遇到传递过来的值，优先考虑使用useRef，再考虑使用useState\n * 封装时，应该将存放的值放入useRef中\n\n\n# Hooks原理\n\nhooks的本质是链表，保存在组件对应fiber的memoizedState中\n\n\n# 🙋 ref\n\nref --\x3e reference：引用\n\nReact中 引用简写，是一个 属性，助于 存储 对React元素 或 组件的引用，引用由组件渲染配置函数返回\n\nref使用有三种方式：字符串(不推荐使用)，对象，函数\n\n1、字符串 React16 之前用的最多的，如\n\n<p ref=\"info\">text</p>\n\n\n1\n\n\n2、函数格式，ref对应一个方法，该方法有一个参数，即，对应的节点实例\n\n<p ref={ele=>this.info=ele}>test</p>\n\n\n1\n\n\n3、createRef方法，React16 提供的API，使用React.createRef()实现\n\n\n# 使用场景\n\n * input标签聚焦\n * 希望直接使用DOM元素中的某个方法，或者直接使用自定义组件中的某一个方法\n * ref作用于内置的HTML组件，得到的将是真实的DOM元素\n * ref作用于类组件，得到的将是类的实例\n * ref不能作用于函数组件，因为函数组价没有实例，但是函数组件中可以传递ref\n\n\n# 如何使用\n\n 1. class 组件 React.createRef() 声明\n\nclass MyComponent extends React.Component {  constructor(props) {    \n    super(props);    \n    this.myRef = React.createRef();  \n}  \nrender() {    \n    return <div ref={this.myRef} />; \n}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 在函数组件使用 React.forwardRef() 来暴露函数组件的 DOM 元素\n\nconst Input = forwardRef((props, ref) => {\n  return (\n    <input {...props} ref={ref}>\n  )\n})\n\nclass MyComponent extends React.Component {\n\n  constructor() {\n    this.ref = React.createRef(null);\n  }\n\n  clickHandle = () => {\n    // 操作Input组件聚焦\n    this.ref.current.focus();\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.clickHandle}>\n          点击\n        </button>\n        <Input ref={this.ref}>\n      </div>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# render不能访问refs\n\n因为 render 阶段 DOM还未生成，无法获取 DOM，DOM的获取需要在 pre-commit 和 commit 阶段\n\n<>\n  <span id=\"name\" ref={this.spanRef}>{this.state.title}</span>\n  <span>{\n     this.spanRef.current ? '有值' : '无值'\n  }</span>\n</>\n\n\n1\n2\n3\n4\n5\n6\n\n\n不可以！\n\n因为render阶段DOM还没有生成\n\nDOM的获取应该在 pre-commit 阶段和 commit 阶段\n\n\n# 🍊 高阶组件(HOC)\n\n是\"纯组价\"，解决**代码复用！**\n\n不是react API 的一部分，是基于React的组合特性而形成的设计模式，HOC 是参数为 组**件，返回值为 新组件 的函数！**\n\n优点\n\n * 逻辑复用、不影响被包裹组件的内部逻辑\n * 缺点是HOC传递给被 包裹组件的props 容易和被包裹后的组件 重名，被覆盖\n\n> 此处朱云博培训时讲过，BasicLayout中就存在这个情况，不知道谁传递的参数，而且参数名容易被覆盖\n\nHOC就是装饰器模式的实现：通过给函数传入一个组件后在函数内部对该组件 进行功能的增强，最后返回这个组件，即允许向一个现有的组件添加新的功能，同时不修改该组件\n\n\n# 函数式编程\n\n\n# 声明式编程\n\n\n# 惰性执行（Lazy Evaluation）\n\n函数只在需要的时候执行，即不产生无意义的中间变量。\n\n\n# 核心概念\n\n\n# 数据不可变\n\n\n# 无状态\n\n强调对于一个函数，不管合适运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。\n\n\n\n\n# 没有副作用\n\n传递引用一时爽，代码重构火葬场\n\n\n1\n\n\n\n# 纯函数\n\n\n# 💙 开发模式\n\n\n# SPA\n\n单页面应用，我们熟知的React就是典型的单页面应用\n\n\n# MPA\n\n\n# MVVM\n\nModel-View-ViewModel，Model数据模型，View表示UI组件，ViewModel将Model和View关联起来\n\n数据绑定到viewModel层并自动将数据渲染到页面，视图变化时通知viewModel层更新数据\n\n将JS逻辑从繁琐的DOM操作中抽离出来\n\n通信是双向的\n\n\n\n> 应用场景\n\n * 针对具有复杂交互逻辑的前端应用\n * 提供复杂架构抽象\n * Ajax数据持久化，保证用户体验\n\n\n# MVC\n\nModel View Controller\n\n\n\n所有通信都是单向的\n\n\n# MVVM、MVC\n\nMVC是后端的思想\n\nMVVM是前端的思想\n\n\n# 单向数据流框架始祖Flux\n\n一个Flux应用包含四个部分\n\n 1. dispatcher，处理动作分发，维持store之间的依赖管理\n 2. store 负责存储数据和处理数据逻辑\n 3. action 驱动dispatcher的JS对象\n 4. view 视图部分，负责用户界面的显示\n\n访问view——view发送 action——dispatcher接收action——store更新——发送change事件——view更新页面\n\n\n\n\n# import react 导致文件变大？\n\nGzip压缩\n\n\n# React路由懒加载\n\n\n# React.lazy\n\nReact16.6新增React.lazy方法，像渲染常规组件一样处理动态引入的组件，配合 webpack 的 Code Splitting ，只有当组件被加载，对应的资源才会导入 ，从而达到懒加载的效果。\n\n\n# 使用 React.lazy\n\n// 不使用 React.lazy\nimport OtherComponent from './OtherComponent';\n// 使用 React.lazy\nconst OtherComponent = React.lazy(() => import('./OtherComponent'))\n\n\n1\n2\n3\n4\n\n\nReact.lazy 接受一个函数作为参数，这个函数需要调用 import() 。它需要返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件。\n\nReact.lazy 方法返回的是一个 lazy 组件的对象，类型是 react.lazy，并且 lazy 组件具有 _status 属性，与 Promise 类似它具有 Pending、Resolved、Rejected 三个状态，分别代表组件的加载中、已加载、和加载失败三中状态。\n\n需要注意的一点是，React.lazy 需要配合 Suspense 组件一起使用，在 Suspense 组件中渲染 React.lazy 异步加载的组件。如果单独使用 React.lazy，React 会给出错误提示。\n\n\n# Suspense 组件\n\nSuspense 内部主要通过捕获组件的状态去判断如何加载，上面我们提到 React.lazy 创建的动态加载组件具有 Pending、Resolved、Rejected 三种状态，当这个组件的状态为 Pending 时显示的是 Suspense 中 fallback 的内容，只有状态变为 resolve 后才显示组件\n\n\n# ⭐️ VDom\n\n一个对象，最少包含tag、props和children三个属性，将真实的DOM树转换为JS对象树，VD和dom对象一一对应\n\n<button class=\"myButton\">\n  <span>this is button</span>\n</button>\n//转换\n{\n  type: 'button',\n  props: {\n    className: 'myButton',\n    children: [{\n      type: 'span',\n      props: {\n        type: 'text'\n        children: 'this is button'\n      }\n    }]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n将多次DOM修改的结果一次性更新到页面上，有效减少页面渲染次数，减少修改DOM的重排重绘次数，提高渲染性能\n\n优越之处在于，提供更爽的、更高效的研发模式(函数式的UI编程模式)的同时，仍然保持还不错的性能\n\n * 保证性能下限，不手动优化时，提供过得去的性能\n * 跨平台\n\n原生DOM有很多属性和事件，创建空的div也要付出很多代价，可通过diff算法和数据改变前的DOM对比，计算出需要修改的DOM，只对变化的DOM操作，而不是更新整个视图\n\n\n# render()\n\n1.构建虚拟 DOM\n\n2.通过虚拟 DOM 构建真正的 DOM\n\n3.生成新的 VDOM\n\n4.比较两棵 VDOM 异同\n\n5.应用变更于 DOM\n\n\n# diff\n\nDOM是多叉树结构，若完整对比两棵树的差异，时间复杂度高，React团队优化实现了O(n)的复杂度\n\n关键是只对比同层节点，而不是跨层对比\n\n 1. JS建立节点描述对象\n 2. 状态或属性改变后重新计算VD生成补丁对象，diff比较分析新旧VDOM差异\n 3. 将差异patch到ADOM实现更新\n\nJS层面的计算返回一个patch对象，即补丁，通过特定的操作解析patch，完成页面re-render\n\n\n\n 1. ADOM映射为VDOM\n 2. VDOM变化后，根据差距生成patch，这个patch是结构化数据，包括增加 更新 和移除\n 3. 根据patch更新 ADOM\n\n\n\n大部分diff算法思路是\n\n * 只比较同一层级，不跨级比较\n * tag不同，直接删除重建，不再深度比较\n * tag和key都相同，则认为是相同节点，不再深度比较\n\ndiff 从 树 组件 及 元素 3个层面进行复杂度的优化\n\n树diff\n\n> 新旧两棵树逐层对比，找到需要更新的节点\n> \n> 若节点是组件就 component diff\n> \n> 1、忽略节点跨层级操作\n> \n> 若节点不存在了，则该节点及其子节点会被删除掉，不会进一步比较\n\n组件diff\n\n> 节点是组件，先看组件类型\n> \n> 类型不同直接替换(删除旧的)\n> \n> 类型相同则只更新属性，深入组件做树diff(递归)\n> \n> 若组件 是同一类型就进行树 对比，如果不是就直接放入 patch中，只要父组件类型不一致，就会re-render\n\n元素diff\n\n> 若节点是原生标签，则看标签名\n> \n> 标签名不同直接替换，相同则只更新属性，进入标签后代做树diff\n\n同一层级子节点，通过key 进行列表对比\n\n标记key，React 可以直接移动 DOM节点，降低消耗\n\npatch做了啥\n\n\n\n\n# re-render\n\n 1. 对比新旧 VNode，使用 diff算法\n 2. 对新旧两棵树进行深度优先遍历，标记每个节点，每遍历一个，就把该节点和新的节点进行对比，有差异就放在一个对象中\n 3. 遍历差异对象，根据对应 规则 更新VNode\n\nVDOM 优势之处在于，不管数据如何变化，它都会尽量以最小的代码更新 DOM\n\n\n# VDOM比原生快？\n\n网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？\n\n\n# React17新特性\n\n一起来看 React 18 最新特性\n\nReact 18 带来了什么 ——官网\n\nV15-V16，源码架构中的 Stack Reconciler-Fiber Reconciler\n\n启发式更新算法——对开发者无感知\n\nReact纯JS写法太过灵活，编译时优化 方面先天不足，因此，React的优化主要在 运行时\n\n> React15的痛点\n\nReact15 实现了batchdUpdates（批量更新），即 同一事件回调函数上下文中的多次 setState 只会触发一次 更新\n\n但是，如果单次更新就很耗时，造成页面卡顿\n\n因为v15的更新流程是同步的，一旦开始直到页面渲染前都不能中断\n\n为了解决 同步更新 长时间占用 线程 导致页面卡顿的问题，React开始重构，为了实现 Concurrent Mode（并发模式）\n\n> Concurrent Mode\n\n为了 实现 一套 可中断/恢复 的更新机制\n\n2个部分组成\n\n 1. 一套 协程 架构\n 2. 基于 协程架构的 启发式更新算法\n\n协程架构就是V16实现的Fiber Reconciler，可将Fiber Reconciler理解为React自己实现的Generator\n\n协程架构 使 更新 可在需要时被 中断，酱紫 浏览器就有时间 完成 样式布局和绘制，减少 卡顿\n\n当进入下一次 Event Loop，协程架构 可 恢复中断 或 抛弃之前的 更新，重新开始新的更新流程\n\n启发式更新算法 就是控制 协程架构 工作方式的算法\n\n> V16的启发式更新算法\n\n启发式 ——不通过 显式指派，而是 通过 优先级 调度更新（优先级来自 人机交互的研究成果）\n\n人机交互研究结果表明：\n\n用户在输入框输入内容时，希望内容能实时显示\n\n异步请求时，即使等待一会儿再显示内容，用户勉强也能接受\n\n因此，V16中\n\n输入框内容触发的 更新 优先级 >请求数据返回 后触发 更新 优先级\n\nV16的 expirationTimes模型只区分是否>=expirationTimes 决定节点是否更新\n\n> V17启发式更新算法\n\n最理想的模型——可指定任意几个 优先级，更新 以这些 优先级 对应的 update 生成页面快照\n\nV17的lanes模型可选定一个 更新区间，动态向 区间 增减 优先级，可处理更细粒度的更新\n\n\n# 🔥 Fiber\n\nJS单线程运行，负责页面JS解析和执行、绘制、事件处理、资源加载和处理，只能一个一个执行，若一个任务耗时很长，后面的任务则不能执行，卡死。\n\nJS引擎和页面渲染引擎两个线程互斥。\n\nReact 15 ，渲染时 递归对比 VDOM，找需要变动的节点，同步更新，一气呵成！！此过程React霸占浏览器资源，导致用户触发的事件得不到响应，掉帧 卡顿！！Stack Reconciler是同步过程，使用JS引擎自身的函数调用栈，执行到栈空为止，渲染组件时，开始到渲染完成整个过程一气呵成，无法中断\n\n组件较大，js线程一直执行，等到整棵VDOM树计算完成 才会交给渲染的线程\n\n所有任务没有优先级，按照顺序执行\n\n期望找出有增删改的节点，同步更新这个过程分解成2个部分，或变成可中断/恢复的执行，类似 多任务OS的单处理调度\n\n将浏览器 渲染 布局 绘制 资源加载 事件响应 脚本执行 看成OS的process，通过 调度策略合理分配 CPU 资源，提高浏览器 响应速率，兼顾 执行效率\n\nReact16起，引入 Fiber 架构\n\nfiber是 链表，可以打断，可通过 requestIdleCallback 空闲调度 reconcile，不断循环，直到处理完所有的 VDOM 转fiber的reconcile，开始 commit，即 更新到ADOM\n\nrequestIdleCallback实现，React 团队 polyfill 了这个 API，使其兼容性更好且拓展了特性\n\n\n> # window.requestIdleCallback()\n\n浏览器空闲时 被调用，使 开发者能在主事件循环上执行后台和低优先级工作，不影响延迟 关键事件，如 动画 和输入响应\n\n函数一般按先进先调用顺序执行，然而，如果回调指定了执行超时时间 timeout，可能会为了在超时前执行函数 打乱执行顺序\n\n\n\n * 分批延时 操作 DOM，避免一次性操作大量 DOM 节点，用户体验更好\n * 给浏览器一点喘息的机会，对代码进行 编译 优化 及热代码优化\n\n手写简易版 React 来彻底搞懂 fiber 架构\n\n> 实现元素的更新\n\n\n# 双缓冲优化策略\n\n连体婴结构\n\n先绘制到一个缓冲区，再一次性传递给屏幕显示，防止抖动\n\n好处\n\n * 及时复用对象(fiber)\n * 节省内存分配，GC时间开销\n\n当前dom树对应的fiber树交currentFiber，正在构建的fiber树交workInProgress Fiber，两棵树 通过alternate相连\n\n\n\n * 将每次渲染完后的fiber树赋值给currentRoot\n * 第一次更新时将rooterFiber的alternate指向上一次渲染好的currentRoot\n * 第二次之后的更新将workInProgressRoot指向currentRoot.alternate，然后将当前的workInProgressRoot.alternate指向上一次渲染好的currentRoot\n * ...\n * 进而达到复用fiber对象树\n\nalternate对象会接收上方传递的新props，从getDerivedStateFromProps得到新的state，render不一样的组员，master和alternate差异越来越大，子组件出错 则回滚到组件的master分支\n\n模拟git add、git commit和git revert\n\n更新过程由current和workInProgress 两株树双缓冲 完成\n\nworkInProgress更新完成后 修改 current 相关指针 指向新节点\n\n双缓冲：经过reconcile形成新的workInProgress Fiber，将workInProgress Fiber切换成current Fiber应用到ADOM，存在双fiber的好处是内存形成视图的描述，应用到dom，减少对dom的操作\n\n\n# React渲染机制\n\n\n\n\n# 获取dom\n\nreact-dom中的findDOMNode()\n\nimport ReactDOM from 'react-dom';\ncomponentDidMount(){\n    const dom = ReactDOM.findDOMNode(this);\n    // this为当前组件的实例\n}\n\nrender() {}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当组件被渲染 ，findDOMNode 返回该组件实例对应的DOM节点\n\nrefs\n\n多用于React组件内子组件的引用\n\n有两种情况：\n\n（1）子组件为原生DOM：获取到的就是这个DOM节点。如下例，this.input就获取到了当前<input />节点。\n\n<input ref={(ref)=>{this.myInput = ref}} />\n\n\n1\n\n\n通过this.myInput，我就可以对<input />进行一系列操作，比如让输入框聚焦：\n\nthis.myInput.focus();\n\n\n1\n\n\n注：refs也支持字符串格式：\n\n<input ref='myInput' />\n\n\n1\n\n\n通过this.refs.myInput获取到节点。\n\n（2）子组件为React组件，比如<MyInput/>：获得的就是<MyInput/>的实例，因此就可以调用<MyInput/>的实例方法。 示例：\n\ncomponentDidMount(){\n    const myComp = this.refs.myComp;  // 获取到的是<Comp />的实例myComp\n    const dom = ReactDOM.findDOMNode(myComp);  // 获取到实例对应的DOM节点\n}\n\nrender(){\n    return (\n        <div>\n            <Comp ref='myComp' />\n        </div>\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注：调用<Comp />实例方法的方式：this.refs.myComp.method()，但并不建议这种调用方式。\n\n\n# others\n\n\n# dangerouslySetInnerHTML\n\n是REact中innerHTML的替代品\n\n网球系统中使用过，用来接收新闻正文，显示新闻数据HTML\n\n <div dangerouslySetInnerHTML={{ __html: newsTexts }} />\n\n\n1\n\n\nReact的HTML元素上的一个属性，它可能是危险的，因为我们容易收到XSS(跨站脚本攻击)——从第三方获取数据或用户提交内容时\n\nReact会识别HTML标签，然后渲染\n\nHTML元素可能会执行脚本，当JS代码附加到HTML元素上\n\n使用HTML净化工具DOMPurify检测HTML中潜在的恶意部分\n\n\n# import React from 'react'\n\n在使用JSX的JS文件中，必须显示声明，为啥？\n\nJSX在编译时会被Babel编译为React.createElement()方法\n\n否则在运行时该模块会报错——未定义变量React\n\nReact17中，不需要显式导入React",normalizedContent:"> 虽然你知道可以优化，但不代表你应该优化\n\n\n# 为啥用react\n\n答react的好处就是了\n\n * 合成事件\n\n * vdom\n\n * jsx\n\n * 生命周期\n\n * 单向数据流\n\n * ……\n\n\n# react、vue\n\n引出mvc和mvvm\nreact和vue底层思想\n优缺点\n实践：技术选型\n得出结论\n\n\n1\n2\n3\n4\n5\n\n\n\n# 相同\n\n * 组件化开发和vdom\n * 支持props\n * 数据驱动视图，不直接操作adom\n * 支持ssr\n * 都借鉴mvvm的思想\n * 将注意力集中在 保持核心库，将其他功能 如 路由 和全局状态管理 交给相关的库\n * 都有自己的构建工具\n\n\n# 不同\n\n * vue实现数据双向绑定，react单向数据流\n\n * react的jsx功能强大，扩展性强\n\n * vue的dom操作方便，for/if指令\n\n * react思想很棒，代码更美观\n\n * vue标签更方便，也是封装好的语法糖\n\n * vdom\n\nvue比react好？\n\n\n# 区别？\n\n大体相同，都使用vdom高效 更新视图， 提倡组件化， 实现 数据驱动视图， 使用diff算法， 对diff算法 优化， router库实现url到组件的映射， 状态管理\n\n具体实现 不尽相同\n\n\n# 组件化\n\n组件是独立和可复用的代码组织单元，它使开发者使用小型、独立和通常可复用的组件构建大型应用\n\n提高开发效率**、测试性、**复用性\n\n降低耦合度，在保持接口不变可以替换不同组件快速完成需求，输入框，可替换日历、时间、范围等组件作具体的实现\n\n调试方便，整个系统通过组件组合，出现问题时，排除法移除组件，根据报错组件快速定位问题，因为每个组件低耦合，职责单一，逻辑会比分析整个系统简单\n\n提高可维护性，组件职责单一，被复用，对代码优化可获得系统整体升级\n\n都推崇组件化，将页面拆分成小的可复用单元提高 复用率和开发效率。 开发时react和vue有相同的套路，父子组件传参，数据状态管理，前端路由\n\nreact推荐 jsx + inline style， 把 html 和 css 写进 javascript\n\nvue 推荐 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解)，即 html，css，js 写在同一个文件(vue也支持jsx写法)\n\n\n# vdom\n\n表现为描述 dom 结构及其属性信息的 对象\n\n * 存储在内存\n * 描述adom\n * 数据变化 生成新的dom，对比新旧vdom将差异更新到adom\n\n> 优点\n\n * 减少 dom 操作：虚拟 dom 可以将多次 dom 操作合并为一次操作\n * 研发效率的问题：虚拟 dom 的出现，为数据驱动视图 思想提供 高度可用 载体， 前端开发 基于函数式 ui 编程方式实现高效的声明式编程\n * 跨平台的问题： 同一套虚拟 dom，可 对接不同平台 渲染逻辑，从而实现“一次编码，多端运行”\n\n\n> # react、vue vdom相同点\n\n都使用 virtual dom + diff算法，最后都是生成render函数，render函数执行返回vnode(vdom的数据结构，本质是树)\n\n每次ui更新，会根据render重新生成最新vnode，跟以前缓存起来老的vnode比对，使用diff算法 更新adom（vdom是 对象 ， 在js引擎中， adom在浏览器渲染引擎中，所以操作vdom比操作adom开销要小 ）\n\n> # diff 优化基本上思路相同\n\n * tag不同认为是不同节点\n * 只比较同一层级，不跨级比较\n * 同一层级的节点用key唯一标识，tag和key都相同则认为是同一节点\n\n> # diff 源码 相同之处\n\n处理老节点部分，都需要把节点处理 key - value 的 map 结构，方便在往后的比对中 快速通过节点的 key 取到对应 节点。同样在比对两个新老节点是否相同时，key 是否相同也是 判断标准。 设置一个唯一值 key 在 diff 处理 时 性能才最大化\n\n\n> # react和vue中vdom差别\n\n都是用js对象 模拟adom，vdom的diff 最小化更新adom， 减小 性能损耗，按颗粒度分为不同的类型比较同层级dom节点，进行增、删、移\n\n按颗粒度分为tree diff， component diff， element diff. tree diff 比较同层级dom节点，进行增、删、移操作。如果遇到component， 就会重新tree diff流程\n\n> # dom的更新策略不同\n\nreact 自顶向下全diff。vue 跟踪每 个组件 依赖关系，不需要re-rendr\n\nreact 状态 改变时， 重新render 生成新的vdom tree， 新旧dom tree 比较， patch打补丁方式，局部更新 。 react为 避免父组件更新 引起不必要 子组件更新， 在shouldcomponentupdate 逻辑判断，减少没必要 render， 重新生成vdom，做差量对比\n\nvue通过object.defineproperty 把 data 属性全部转为 getter/setter。 watcher实例对象 在组件渲染时，将属性记录为dep， 当dep 项中的 setter被调用时，通知watch重新计算，使得关联组件更新\n\n> # 总结\n\nvue2 核心diff算法采用 双端比较 ，同时从新旧children的两端 比较，借助key值找到可复用的节点，再 操作。相比react的diff算法，同样情况 可以减少移动节点次数，减少 性能损耗，更加 优雅\n\n\n# 数据驱动视图\n\n数据变化 相应 视图 更新。开发者只需要关注数据 变化而不用 手动 操作dom\n\n\n> # vue 数据驱动视图\n\nmvvm 框架实现。mvvm 包含3个部分:model、view和 viewmodel\n\n * model 数据\n * view 视图部分， dom\n * viewmodel 连接视图与数据的中间件\n\nviewmodel是实现数据驱动视图的核心， 数据变化 viewmodel能够监听到 ， 及时 通知view 修改。同样当页面有事件触发 ，viewmodel也能够监听 ，并通知model响应。viewmodel相当于观察者，监控着双方的动作，及时通知对方操作\n\n首先，vuejs实例化过程中，会对遍历传给实例化对象选项中的data 选项，遍历其属性使用 object.defineproperty 全部转为 getter/setter\n\n同时每个实例对象都有watcher实例对象，在模板编译的过程中，用getter访问data的属性，watcher此时把用到的data属性记为依赖，建立视图与数据联系。之后渲染视图的数据依赖改变，watcher对比前后两个的数值是否变化，确定是否通知视图re-render。这样实现所谓的数据对于视图驱动\n\n\n> # react的数据驱动视图\n\n * pending 当前所有等待更新的state队列\n * isbatchingupdates 标识当前是否处理批量更新状态，默认false\n * dirtycomponent 当前所有待更新state的组件队列\n\nsetstate实现数据驱动视图，引发一次组件的更新过程从而实现页面的re-render\n\n * setstate() 将接收的第一个参数state存储在pending队列\n * 判断是否处于批量更新，是 就将需要更新state的组件添加到dirtycomponents\n * 不是 会遍历dirtycomponents所有组件，调用updatecomponent更新每个dirty组件\n\n\n# 核心思想\n\n\n\n\n# react设计实现\n\n * 是一个简单的js ui库，用于构建高效、快速的用户界面\n\n * 是一个轻量级库\n\n * 遵循组件设计模式、声明式编程范式和函数式编程\n\n * 使用vdom操作adom\n\n * 遵循从高阶组件到低阶组件的单向数据流\n\n\n# 优点\n\n * 提高性能\n\n * jsx 可读性增加\n\n * 易集成使用\n\n * 代码直观\n\n * 组件简单可复用\n\n * vdom\n\n * 函数式编程\n\nreact 老矣，我建议大家用用别的框架\n\n\n# 不习惯之处\n\nreact 我爱你，但你太让我失望了\n\n\n# jsx\n\nconst ele=<h1>hello world</h1>\n\n\n1\n\n\n既不是字符串也不是html，是jsx，是js的语法扩展，生成react元素\n\nreact认为渲染逻辑本质与其他ui逻辑内在耦合，将标签和逻辑共同存放在组件中，实现关注点分离\n\n编译之后，jsx被转换为js普通函数调用，取值后得到js对象\n\n允许在条件或循环语句中使用jsx，将其赋值给变量，传入jsx作为参数，以及从函数中返回jsx\n\n防止注入攻击\n\n 1. 可以安全地在jsx中插入用户内容\n 2. react的dom在渲染所有内容后，会进行转义，确保应用中永不会注入那些不是自己写的内容\n\njsx表示对象\n\nbabel将jsx转译为一个名为react.createelement()函数调用\n\nreact读取这些react元素对象并使用它们构建dom以保持随时更新\n\n\n# 状态提升\n\n将多个组件需要共享的state 向上 移动到它们最近的公共组件 中，实现state 的共享\n\n让数据自顶向下单向流动，所有组件数据来自父辈组件，由父辈组件来统一存储和修改，再传入子组件\n\n**为了组件之间的数据更加单向性，**数据的传输上始终出现一对一的情况，方便我们只需要在向子组件传递数据的父组件上操作，并传回子组件，更新数据，体现了react单向数据流的设计思想，复用组件时，组件数据不会相互干扰，代码逻辑上便于管理\n\n\n# key\n\nwarning:each child in an array or iterator should have a unique \"key\" prop\n\n\n1\n\n\n> 为啥使用\n\nkey在dom中元素增删改查时帮助识别哪些元素发生变化，所以需要给每一个元素赋予唯一标志，想要访问key属性值，需要使用其他属性名 显性 访问\n\ndiff算法将key作为唯一id对比组件value确定是否更新\n\n不传key也能用是因为react检测子组件没有key，默认将index作为key\n\n原则\n\n * key同，组件属性有变化，react只会更新组件变化的属性\n * key不同，销毁之前的组件，导致re-render\n\n> 使用index存在啥问题\n\nspan单纯展示组件，是受控组件，值由我们定好\n\n若子组件只是受控组件，index作为key，表面可能不会出问题，实际性能可能受影响\n\n列表数据源 顺序 改变，若适用 index 作为key，对应key为0 1 2的组件都变，子组件全部会re-render\n\n注意：未添加key，兄弟节点更新位置前后错位一个，后续全部的比较都会 错误，导致找不到对比目标，性能大打折扣\n\n若使用id作为key，根据更新原则，子组件和key均未改变，顺序改变，我们只移动而不是re-render\n\ninput是非受控组件，用户可任意改变value\n\n> 正确赋值key\n\n若纯粹展示没有其他变更，使用index或其他值作为key没有问题，因为没有diff，就不会用key\n\n * 和具体元素一一对应\n * 尽力不使用 index 作为key\n * 不使用随机数等 加上不稳定的key，否则性能开销比不加key更糟糕\n\n> 使用场景\n\n由数组动态创建的子组件的情况\n\n为一个有复杂繁琐逻辑的组件添加key后，后续操作可改变key值，从而 达到 先销毁之前的组件，再重新创建该组件\n\n\n\n\n# ⭐️ 生命周期\n\n * 挂载 mount，组件第一次在 dom 树中被渲染\n * 更新过程 update，re-render\n * 卸载 unmount，组件从 dom树中被移除过程\n\nreact15生命周期\n\nconstructor() \ncomponentwillreceiveprops() // 父组件状态属性更新触发\nshouldcomponentupdate() // 组件更新时调用，在此可拦截更新\ncomponentwillmount() // 初始化渲染时调用（挂载前调用）\ncomponentwillupdate() // 组件更新时调用\ncomponentdidupdate() /\ncomponentdidmount() // 初始化渲染时调用（挂载后调用）\nrender()\ncomponentwillunmount() \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nreact16\n\nconstructor() \ngetderivedstatefromprops() // 组件初始化和更新时调用\nshouldcomponentupdate() // 组件更新时调用，在此可拦截更新\nrender() \ngetsnapshotbeforeupdate() // 组件更新时调用\ncomponentdidmount() // 组件初始化时调用（挂载后调用）\ncomponentdidupdate(prevprops, prevstate) // 组件更新后调用\ncomponentwillunmount() \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# react 16前\n\n\n# react 16后\n\n\n\n首次挂载 getdefaultprops、getinitialstate、componentwillmount、render 和 componentdidmount\n\n卸载组件\n\n重新挂载组件 getinitialstate、componentwillmount、render 和 componentdidmount，但并不执行 getdefaultprops\n\n更新组件 componentwillreceiveprops、shouldcomponentupdate、componentwillupdate、render 和 componentdidupdate\n\n\n# constructor\n\n实例过程中自动调用，方法内部通过super关键字获取父组件的props\n\n * 初始化state\n * this上挂载方法\n\n\n# 16新增2个\n\n\n# getderivedstatefromprops\n\nstatic getderivedstatefromprops(nextprops, prevstate) {\n    const {type} = nextprops;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevstate.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * 静态方法(纯函数)\n * 只能通过prestate 而不是 prevprops 作对比，保证了state 和 props 间的简单关系及不需要处理第一次渲染时 prevprops 为空的情况\n\n执行时机：组件创建和更新阶段，不论是props变化还是state变化，也会调用\n\n在每次render方法前调用，第一个参数为即将更新的props，第二个参数为当前组件的state，可以比较props 和 state来加一些限制条件，防止无用的state更新\n\n该方法返回新对象更新state，不更新则返回 null\n\n静态方法阻止操作instance，阻止多次操作setstate，没有instance就不能操作dom\n\n逻辑应该会很简单，就不会出错，不出错就不会打断dfs过程\n\ngetderivedstatefromprops() contains the following legacy lifecycles: componentwillmount componentwillreceiveprops componentwillupdate\n\n> react 16.4后对getderivedstatefromprops做了微调。在>=16.4以后的版本中，组件任何的更新流程都会触发getderivedstatefromprops，而在16.4以前，只有父组件的更新会触发该生命周期\n> \n> 不咋使用\n\n\n# getsnapshotbeforeupdate\n\n返值snapshot值(默认为 null )，作为componentdidupdate第三个参数\n\n运行在render后，表示adom构建完成，但还没有渲染到页面，可理解为更新前的快照，用来做一些附加的dom操作\n\ngetsnapshotbeforeupdate(prevprops, prevstate) {\n    console.log('#enter getsnapshotbeforeupdate');\n    return 'foo';\n}\n\ncomponentdidupdate(prevprops, prevstate, snapshot) {\n    console.log('#enter componentdidupdate snapshot = ', snapshot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n获取组件更新前的一些信息，比如组件的滚动位置之类\n\n\n# componentdidmount\n\n组件挂载到adom节点后执行，render之后执行\n\n * 执行数据获取，事件监听等操作\n\n此处 调用 setstate 触发一次额外的渲染，它 在浏览器刷新屏幕前执行！所以用户没有感知，但会带来一定性能问题\n\n和 componentwillmount 一样，有且仅有一次 调用！\n\n\n# shouldcomponentdidmount\n\n告知组件本身基于当前的props和state是否需要 re-render，默认返回true\n\n执行时机：到新的props/state 调用，返回true/false告知组件更新与否\n\n一般情况，不建议在该周期方法中深层比较，影响效率\n\n同时也不能调用setstate，会导致无限循环更新\n\n\n# componentdidupdate\n\nadom挂载到页面后运行\n\n可根据前后的props和state变化操作，如获取数据，修改dom等\n\ncomponentdidupdate(prevprops, prevstate, snapshot){}\n\n\n1\n\n\n\n# componentwillunmount\n\n组件卸载前，清理副作用\n\n一旦一个组件实例被卸载，不会被再次挂载，只可能被重新创建\n\n\n# 准备废弃\n\n 1. 被废弃的3个方法都在render之前，因为fiber出现，可能因为高优先级任务 打断现有任务导致它们被执行多次\n 2. react想约束使用者，好的框架能让人写出易维护和扩展的代码\n\n\n# componentwillmount\n\n风险很高，鸡肋\n\n此函数可以使用 componentdidmount 和 constructor 代替\n\n为了约束开发者，直接干掉了此 api\n\n\n# componentwillreceiveprops(nextprops)\n\n一个api并非越复杂才越优秀\n\nprops 变化执行，初始化render 时不执行\n\n老版本react中，若组件自身的某个state跟其props密切相关，没有一种优雅的方式处理state，而是需要在 componentwillreceiveprops 中判断前后2个props是否相同，若不同再将新的props更新到相应的state上\n\n通过 setstate更新组件状态，旧属性通过this.props 获得，此处调用更新状态是安全的，不会触发额外render\n\n优点\n\n * 可以在子组件的render函数执行前获取新的props，进而更新子组件自己的state\n * 可以将数据请求放在这里执行，需要的参数中nextprops获取，不必将所有请求都放在父组件中\n\n缺点\n\n * 破坏state数据的单一数据源，导致组件状态不可预测\n * 增加组件的重绘次数\n\n\n# componentwillupdate\n\n> componentwillupdate( nextprops, nextstate )\n\n挡了新的fiber架构的路\n\n * 一次更新可能被调用多次，因为一次更新中 componentdidupdate 只会被调用一次，所以将原先写在 componentwillupdate 中的回调移至componentdidupdate 就可以解决这个问题\n * 获取 dom 元素状态，fiber中render可被打断，可能在willmount中获取到的元素状态很可能与实际需要的不同，这个通常可以使用getsnapshotbeforeupdate解决\n\n由getsnapshotbeforeupdate(prevprops,prevstate) 代替，在最终的render之前调用\n\n> 为何要废弃它们？\n\n在fiber机制下，render阶段允许被暂停、终止和重启\n\n**导致render阶段的生命周期都可能重复执行。**这几个方法常年被滥用，执行过程中存在风险。比如setstate fetch发起请求 操作adom等\n\n这些操作完全可以转移到其他方法中做\n\n即使没有开启异步渲染，recat15中也可能导致一些严重的问题，比如componentwillreceiveprops和componentwillupdate里滥用setstate导致重复渲染，死循环\n\n首先确保了fiber机制下数据安全性，同时也确保生命周期方法的行为更纯粹\n\n\n# 🔥 setstate\n\n> componentwillmount中setstate\n\n无意义，应当将setstate放在constructor中（初始化state）\n\n组件只挂载一次，componentwillmount中的setstate回合constructor中state合并执行\n\n> componentdidmount中setstate\n\n导致组件初始化时触发更新，渲染2次\n\n> componentwillunmount中setstate\n\n不会更新，无意义\n\n> shouldcomponentupdate和componentwillupdate中setstate\n\n禁止\n\n造成死循环\n\nsetstate后会再次触发这2个函数，然后又触发setstate\n\n> componentdidupdate中setstate\n\n可以\n\n组件刚更新完成，又要更新一次，连续render两次\n\n和componentdidmount类似\n\n> componentwillreceiveprops中setstate\n\n可以\n\n不会re-render，因为只有 props变化才会触发，setstate不会造成死循环\n\n\n# 💚 组件通信\n\n * 父组件向子组件传递\n * 子组件向父组件传递\n * 兄弟组件之间的通信\n * 父组件向后代组件传递\n * 非关系组件传递\n\n> 父组件向子组件传递\n\nreact的数据流是单向的，这是最常见的方式，props\n\n父子通信底层如何实现?\n\n> 子组件向父组件传递\n\n父组件向子组件**传一个函数，然后通过这个函数的回调拿到子组件传递的值**\n\n> 兄弟组件之间的通信\n\n父组件作为**中间层实现数据互通**\n\n> 父组件向后代组件传递\n\n最普通的事情，像全局数据一样\n\n使用context可共享数据，其他数据都能读取对应的数据\n\n> 非关系组件传递\n\n组件间关系类型复杂，可以将数据进行一个全局资源管理，从而实现通信，例如redux dva\n\n\n# 💙有/无状态组件\n\n\n# 有状态组件\n\n特点\n\n * 是类组件\n * 有继承\n * 有this\n * 有生命周期\n * 使用较多，易触发生命周期钩子函数\n * 内部使用state，根据外部组件传入的props和自身state渲染\n\n使用场景\n\n * 需要使用状态的\n * 需要状态操作组成的\n\n总结\n\n可维护自己的state，可以对组件做更多的控制\n\n\n# 无状态组件\n\n特点\n\n * 不依赖自身state\n * 可以是类组件或函数组件\n * 可避免使用this\n * 组件内部不维护state，props改变，组件re-render\n\n使用场景\n\n组件不需要管理state\n\n优点\n\n * 简化代码 专注render\n * 组件不需要实例化，无生命周期\n * 视图和数据解耦\n\n缺点\n\n * 无法使用ref\n * 无生命周期\n * 无法控制组件re-render\n\n> 当一个组件不需要管理自身状态时，就是无状组件，应该优先设计为函数组件，比如定义的\n\n\n# 受/非受控组件\n\n\n# 受控组件\n\n表单状态变化，触发onchange，更新state\n\n受控组件中，组件渲染出的状态和value/checked属性相对应，react通过这种方式消除组件的局部状态，使组件变得可控\n\n缺点\n\n多个输入框需要获取到全部值时，需要每个都编写事件处理函数，代码臃肿\n\n后来，出现了非受控组件\n\n\n# 非受控组件\n\ninput组件有内部value，没有任何属性——非受控组件，组件状态不受外部环境控制，而是封闭在组件内部\n\n若把state的value放到props中——变成 受控组件(此时input值取决于外部传递的props)\n\n表单组件没有value props\n\n可使用ref 从 dom 中获取表单值，而不是编写事件处理函数\n\n非受控组件可以减少代码量\n\n\n\n\n# 类/函数组件\n\n相同点\n\n基本可认为两者完全一致\n\n不同点\n\n函数组件 是 无状态组件 的思想\n\n函数组件 无法使用 state，没有 生命周期方法，接收 props，渲染 dom\n\n函数组件没有 this\n\n函数组件 更易理解\n\n函数组件性能优化依靠 react.memo缓存渲染结果实现\n\n类组件 基于面向对象编程，主打 没有副作用，引用透明等特点\n\n类组件性能优化依靠shouldc omponentupdate阻断渲染实现\n\n\n# class、hooks\n\n函数式编程？\n\nclass占内存啊，写了class写hooks可以快速切换，但是写了hooks再写class就不得行，因为所有最终回归的是c++ c 和操作系统，class相当于提供了一个框框，约束我们代码的编写\n\nhooks就有点放飞自我，因为是函数式编程不像class是一个类，实例 有静态方法，占用内存，而函数式就是运行完内存即释放，需要使用的变量得不到一个合适的保存，于是只有使用闭包方式，但是闭包存在挺多的问题，涉及到内存泄漏等，而且存在很多闭包，\n\n链式编程？\n\n如果有bug怎么调试，大家都是学生，首先是为了提高自己发现问题并解决问题的能力\n\nreact存在兼容性，之所以不升级antd版本，为了兼容id浏览器\n\n\n# 💚 性能优化\n\nreact 性能优化的那些事儿\n\n\n# 卡顿原因\n\nrender时会根据现有render产生新的jsx数据和现有fiberroot对比，找到不同地方，生成新的workinprogress，进而在挂载阶段把新的workinprogress交给服务器渲染\n\n这个过程中，为了让底层机制更加高效快速，react做了大量优化，设立任务优先级、异步调度、diff算法和时间分片等\n\n整个链路为了快速高效完成从数据更新到页面渲染的整体流程\n\n为了不让递归遍历寻找所有更新节点太大而占用浏览器资源，react升级了fiber架构，时间分片，实现增量更新\n\ndiff——高效查找所有更新节点\n\n任务调度优先级——高效更新\n\n优化——控制刷新渲染的波及范围，只让该更新的更新，更新链路尽快走完\n\n\n# 优化场景\n\n * 父组件更新，子组件不更新\n\n> purecomponent、shouldcomponentupdate、父组件对子组件缓冲、memo\n\n * 组件自己控制是否刷新\n * 减少波及范围，无关刷新不存在state\n * 合并state，减少setstate执行次数\n * 更快完成diff比较过程\n\n\n# 思路\n\n * 减少render次数\n * 减少渲染的节点\n * key\n * 降低计算量\n * 缓存\n * vdom\n * 使用工具分析性能瓶颈\n * 使用不可突变数据结构，数组使用concat，对象使用object.assign()\n * 组件尽可能拆分\n * 列表类组件优化\n * bind函数优化\n * 不滥用props\n * reactdomserver进行服务端渲染组件\n\n\n# react.memo\n\nreact16.6新增，缓存组件\n\n和purecomponent相似，但memo只用于函数组件\n\n使用其对航班信息可视化系统做了优化\n\nreact17+antvl7+antd\n\n记忆组件渲染结果，提高组件性能\n\n只检查props是否变化\n\n做浅比较\n\n第二个参数可传入自定义比较函数\n\nareequal方法和shouldcomponentupdate返回值相反\n\nconst app=react.memo(\n    function myapp(props){\n   //使用props渲染 \n\t}\n    function areequal(prevprops, nextprops){\n    //如果把prevprops传入render方法的返回结果和将nextprops传入render的返回结果一样，则返回true，否则返回false\n}\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# react.usememo\n\n缓存大量计算\n\n函数组件中，匿名函数，箭头函数和普通函数会重新声明\n\nusememo 第一个参数是函数，这个函数返回的值会被缓存，同时作为 usememo 的返回值，第二个参数是一个数组依赖，如果数组值变化，会重新执行第一个参数的函数，并将函数返回的值缓存起来作为 usememo 的返回值\n\n// 避免这样做\nfunction component(props) {\n  const someprop = heavycalculation(props.item);\n  return <anothercomponent someprop={someprop} /> \n}\n  \n// 只有 `props.item` 改变时someprop的值才会被重新计算\nfunction component(props) {\n  const someprop = usememo(() => heavycalculation(props.item), [props.item]);\n  return <anothercomponent someprop={someprop} /> \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# purecomponent\n\n避免重复渲染\n\nreact.component并未实现 shouldcomponentupdate()，而 react.purecomponent以浅层对比 prop 和 state 的方式实现了该函数\n\nshouldcomponentupdate做的是“浅层比较”。若是“深层比较”，某个特定组件的行为，需要我们自己编写\n\n父组件状态的每次更新，都会导致子组件re-render，即使传入相同props。但这里的re-render 不是说会更新dom，而是每次都会调用diif算法判断是否需要更新dom。这对大型组件例如组件树来说 非常消耗性能\n\nshouldcomponentupdate确保只有当组件props状态改变时才会re-render，返回false表示不希望组件re-render\n\npurecomponent进行浅比较判断组件是否应该re-render，对于传入的基本类型props，只要值相同，浅比较就会认为相同，对于传入的引用类型props，浅比较只会认为传入的props是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是不同的props。\n\npurecomponent，因为进行浅比较也会花费时间，这种优化更适用于大型的展示组件上。大型组件也可以拆分成多个小组件，并使用memo来包裹小组件，也可以提升性能。\n\n * 确保数据类型是值类型\n * 如果是引用类型，不应当有深层次的数据变化(解构)\n\n判断步骤：\n\n 1. 直接比较新老 props /新老 state 是否相等。相等不更新组件\n 2. 判断新老 state / props ，有不是对象/为 null 的，返回 false ，更新组件\n 3. object.keys 将新老 props /新老 state 属性名 key 变成数组，判断数组长度是否相等，不相等证明有属性增加/减少，更新组件\n 4. 遍历老 props /老 state ，判断对应新 props /新 state ，有没有与之对应且相等的（这个相等是浅比较），有一个不对应/不相等，直接返回 false ，更新组件\n\n\n# 高阶组件\n\n函数组件没有 shouldcomponentupdate 方法，可利用 高阶组件 封装一个类似purecomponent 方法\n\n\n# 避免内联对象\n\n使用内联对象时，react会在每次渲染时重新创建对此对象的引用，这会导致接收此对象的组件将其视为不同的对象，因此，该组件对于prop的浅层比较始终返回false，导致组件一直re-render。\n\n// don't do this!\nfunction component(props) {\n  const aprop = { someprop: 'somevalue' }\n  return <anothercomponent style={{ margin: 0 }} aprop={aprop} />  \n}\n\n// do this instead :)\nconst styles = { margin: 0 };\nfunction component(props) {\n  const aprop = { someprop: 'somevalue' }\n  return <anothercomponent style={styles} {...aprop} />  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 避免匿名函数\n\n// 避免这样做\nfunction component(props) {\n  return <anothercomponent onchange={() => props.callback(props.id)} />  \n}\n\n// 优化方法一\nfunction component(props) {\n  const handlechange = usecallback(() => props.callback(props.id), [props.id]);\n  return <anothercomponent onchange={handlechange} />  \n}\n\n// 优化方法二\nclass component extends react.component {\n  handlechange = () => {\n   this.props.callback(this.props.id) \n  }\n  render() {\n    return <anothercomponent onchange={this.handlechange} />\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 组件懒加载\n\n使用新的react.lazy和react.suspense完成\n\nreact.lazy\n\n定义动态加载的组件，可直接缩减打包后 bundle 体积，延迟加载在初次渲染时不需要渲染的组件\n\nreact.suspense\n\n悬挂 终止 暂停\n\n配合渲染 lazy 组件，在等待加载 lazy组件时展示 loading 元素，不至于直接空白，提升用户体验；\n\n> 网球后台用到\n> \n> 只有在生产环境下展示settingdrawer\n\n<suspense fallback={<pageloading />}>{this.rendersettingdrawer()}</suspense>\n\n\nconst settingdrawer = react.lazy(() => import('@/components/settingdrawer'));\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 用 css\n\n而不是强制加/卸载组件\n\n渲染成本很高，尤其是在需要更改dom时。此操作可能非常消耗性能并可能导致延迟\n\n// 避免对大型的组件频繁对加载和卸载\nfunction component(props) {\n  const [view, setview] = usestate('view1');\n  return view === 'view1' ? <somecomponent /> : <anothercomponent />  \n}\n\n// 使用该方式提升性能和速度\nconst visiblestyles = { opacity: 1 };\nconst hiddenstyles = { opacity: 0 };\nfunction component(props) {\n  const [view, setview] = usestate('view1');\n  return (\n    <react.fragment>\n      <somecomponent style={view === 'view1' ? visiblestyles : hiddenstyles}>\n      <anothercomponent style={view !== 'view1' ? visiblestyles : hiddenstyles}>\n    </react.fragment>\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# react.fragment\n\n无需 在dom中添加额外标签，不会渲染任何元素\n\nfunction component() {\n        return (\n            <react.fragment>\n                <h1>hello world!</h1>\n                <h1>hello there!</h1>\n                <h1>hello there again!</h1>\n            </react.fragment>\n        )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# key\n\n * 保证key具有唯一性\n * diff算法根据key判断元素时新创建还是被移动的元素，从而减少不必要渲染\n\n虽然key是一个prop，但是接受key的组件并不能读取到key的值，因为key和ref是react保留的两个特殊prop\n\n\n1\n\n\n\n# 合理使用context\n\n无需为每层组件手动添加 props，通过provider接口在组件树间进行数据传递\n\n原则\n\ncontext 中只定义被大多数组件所共用的属性\n\n * 使用createcontext创建一个上下文\n * 设置provider并通过value接口传递state数据\n * 局部组件从value接口中传递的数据对象中获取读写接口\n\n> 网球系统后台使用了这个技术\n\ntoggle——切换\n\nimport { createcontext } from 'react';\n\nconst logincontext = createcontext();\nexport default logincontext;\n\n\n1\n2\n3\n4\n\n\n\n# 虚拟列表\n\n只渲染当前视口可见元素\n\n * 无限滚动列表，table\n * 无限切换日历\n\n\n# 合理设计组件\n\n简化props\n\n简化state\n\n减少组件嵌套\n\n渲染函数内不该放太多副作用\n\n不滥用context，因为context可穿透react.memo或shouldcomponentupdate的对比，一旦context变化，所以依赖该context的组件都会刷新\n\ncontext不能精细化渲染\n\n\n# purecomponent、component\n\ncomponent需要实现shouldcomponentdidmount，而purecomponent通过浅对比默认实现了shouldcomponentdidmount，当组件更新时，若组件的props 和 state都没有改变，不会触发render函数，省去vdom的生成和对比过程\n\npurecomponent其最佳情况是展示组件，因为其shouldcomponentupdate()进行浅比较，如果是引用数据类型，只会比较是不是同一个地址，不会比较这个地址的数据是否改变，浅比较会忽略属性或状态突变情况\n\n如果确保 state和 props 经常在变，不用 purecomponent反而效率可能更好，因为浅比较也会耗性能\n\n\n# ❤️ setstate\n\n告诉组件数据有更新，可能需要re-render，react通常会集齐一批需更新的组件，再一次性保证渲染性能\n\nsetstate改变之后，立即用this.state拿不到最新状态\n\n\n# 同步or异步\n\n根据变量isbatchingupdates(是否 是批量更新) 判断是直接更新this.state还是放到队列中回头再说，isbatchupdates默认false(同步更新 this.state)，函数batchupdates 会将isbatchingupdates修改为true，当react调用事件处理/生命周期函数之前 调用batchedupdates，后果就是 setstate异步更新\n\n若isbatchingupdates为true，命中batchupdate机制，进行 \"异步更新\"，反之为 \"同步更新\"\n\napi层面，setstate是普通的调用执行的函数，自然是同步api\n\n此 同步 非 彼 同步\n\n同步还是异步 指的是调用api后更新dom是异步还是同步？——取决于 被调用的环境\n\n * react能控制的范围调用，如 合成事件、生命周期，会批量更新，状态合并后再更新dom，为异步\n * 原生js控制的范围调用，如 原生事件，定时器回调，ajax回调，setstate调用后立即更新dom，为同步\n\n异步 就是 批量更新，减少adom渲染次数，在react能控制范围内，一定是批量更新(为了性能着想)，先合并 状态，再一次性 更新dom\n\nsetstate意味着一个完整的渲染流程，包括\n\nshouldcomponentupdate->componentwillupdate->render->componentdidupdate\n\n\n1\n\n\nsetstate 批量更新(异步) 是为了避免 频繁 re-render，消耗性能\n\n批量更新 过程 和 事件循环 类似，来一个setstate将其加入 队列，待时机成熟， 队列中 state 结果合并，最后只对最新的state 进行更新\n\n\n\n在 react17 中，setstate 批量执行，但如果在 settimeout、事件监听器等函数里，setstate 会同步执行。可以在外面包一层 batchupdates 函数，手动设置 excutioncontext 切换成批量执行\n\nreact18 中所有的 setstate 都是异步批量执行了\n\n\n# 第二个参数\n\n是一个可选的回调函数，这个函数 在 组件re-render后执行，等价于 componentdidupdate 中执行\n\n可拿到更新后的state\n\n\n# state如何注入到组件\n\n通过connect 和 mapstatetoprops 将state注入 到组件\n\nmapstatetoprops(state,ownprops)中带有两个参数，含义是\n\n * state-store管理的 全局状态对象，所有组件状态都存储在该对象中\n * ownprops 组件通过 props 传入的参数\n\n\n# 🍊 事件机制\n\nreact为了解决跨平台、兼容性问题，自己封装了一套事件机制，代理了原生事件，例如jsx的onclick和onchange都是合成事件\n\n充当浏览器原生事件的跨浏览器包装器 的对象\n\n将不同浏览器行为组合到一个 api中，确保事件显示一致的 属性\n\n<div onclick={this.handleclick.bind(this)}>点我</div>\n\n\n1\n\n\nreact并不是将click事件绑定到了div的adom上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，react将事件内容封装并交由真正的处理函数运行。这样减少内存消耗，还能在组件挂在销毁时统一订阅和移除事件\n\n除此之外，冒泡到document上的事件也不是原生浏览器事件，而是由react自己实现的合成事件（syntheticevent）。如果不想要事件冒泡的话应调用event.preventdefault()方法，而不是调用event.stopproppagation()方法\n\n\n\n合成事件 是react 模拟原生 dom 事件 所有能力的事件对象，优点如下\n\n * 兼容 所有浏览器，更好跨平台\n * 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果有很多的事件监听，就需要分配很多事件对象，造成高额内存分配。对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，便于下次复用\n * 事件统一 存放在一个数组，避免频繁新增和删除(垃圾回收)\n * 便于 react 统一管理\n\n原生事件 先执行，合成事件 后执行，合成事件 冒泡绑定到 document 上，所以 尽量避免 原生事件和合成事件 混用，(为啥呢？？)\n\n因为 如果原生事件 阻止冒泡，可能导致合成事件无法执行，因为合成事件需要冒泡到 document 上才会执行\n\n\n# 💚 hooks\n\nreact16.8新增特性，主要解决了函数式组件无状态的问题\n\n类组件内部逻辑难以拆分和复用\n\n函数组件，内部无法定义和维护state，也叫 无状态 组件\n\n轻量 灵活 易于维护和组织，学习成本低\n\n组件功能清晰很小巧！\n\n * 类组件需继承 class\n * 类组件可访问生命周期方法\n * 类组件可获取实例化后 的 this\n * 类组件可定义并维护state\n\nhooks前，类组件边界强于函数组件\n\nui=render(data)\n或\nui=func(date)\n\n\n1\n2\n3\n\n\n\n# 解决\n\n * 组件 逻辑复用，render props/hoc也为了复用，hooks作为官方底层api，最轻量且改造成本小，不影响组件层次结构和嵌套地狱\n * 复杂组件理解\n * 难以理解的class，不同生命周期使逻辑分散混乱，不易维护管理，关注this指向问题，代码复用代价高，hoc使整个组件变得臃肿\n * 状态与ui隔离，状态逻辑变成更小的粒度，易抽象为自定义hooks，组件状态和ui更清晰\n\n\n# 限制\n\n * 不在循环、条件和嵌套函数中调用(链表 实现hook，可能导致 数组取值错位)\n * 仅在函数组件中调用hook(因为没有 this)\n * useeffect中避免使用usestate\n\n\n# hooks和生命周期\n\nclass 组件                   hooks 组件\nconstructor                usestate\ngetderivedstatefromprops   usestate 里面 update 函数\nshouldcomponentupdate      usememo\nrender                     函数本身\ncomponentdidmount          useeffect\ncomponentdidupdate         useeffect\ncomponentwillunmount       useeffect 里面返回的函数\ncomponentdidcatch          无\ngetderivedstatefromerror   无\n\n\n# usestate\n\n和class组件的state差不多\n\n返回一个state和更新state的函数\n\n初始渲染期间，返回状态和传入第一个参数相同\n\nsetstate用于state的更新，接收新的state并将组件的一次re-render加入 队列\n\n> 为啥usestate使用数组\n\n解构赋值！！\n\n使用数组，我们可以对数组中元素命名，代码比较干净\n\n使用对象，解构时必须要和usestate内部实现返回对象同名，多次使用只能设置别名\n\n// 第一次使用\nconst { state, setstate } = usestate(false);\n// 第二次使用\nconst { state: counter, setstate: setcounter } = usestate(0) \n\n\n1\n2\n3\n4\n\n\n * # 模拟componentdidmount\n\nuseeffect(() => {\n  console.log('componentdidmount')\n}, [])\n\n\n1\n2\n3\n\n\n\n# uselayouteffect、useeffect\n\nuseeffect相当于是一个副作用的函数\n\n渲染阶段 可改变dom、添加订阅、设置定时器、记录日志，执行包含副作用的操作都不被允许，可能产生bug 破坏ui一致性\n\n使用useeffect完成副作用操作\n\n * 共同点\n\n都是处理副作用，包括 dom改变，订阅设置，定时器操作\n\n * 不同点\n\nuseeffect 渲染之前 异步调用，不会等待dom真正渲染后执行，可能会闪烁\n\nuselayouteffect 渲染之前 同步调用，不会闪烁，**总是比 useeffect先执行！**可获取更新的state\n\nuselayouteffect 和 componentdidmount，componentdidupdate 执行时机一样，在浏览器将所有变化渲染到屏幕之前执行\n\n建议使用 useeffect！建议使用 useeffect！建议使用 useeffect！ 避免阻塞视觉更新\n\n页面有异常就再替换为 uselayouteffect\n\n> 项目中用于发送请求\n\n> # 第二个参数\n\n航班系统中使用useeffect第二参数对系统发送请求进行优化，仅在组件挂载和卸载时执行，传递一个[]，作为第二参数，告诉react我的effect不依赖于props或state中的任何值，不需要重复执行\n\n控制不同航班信息的展示，使用useeffect的第二个参数传递一个state，控制drawer的变化，只有state变化了，effect才会执行，async-await执行结束，数据更新，打开drawer就有效果了\n\n收集子组件的值，将参数和函数一起传入子组件，子组件调用函数，父组件就能接收子组件的值了，根据传回来的数据，以及判断url，重新获取数据，根据state更新对应的值，渲染界面\n\n\n1\n2\n3\n4\n5\n\n\n第一个参数 是回调函数\n\n第二个参数 是依赖\n\n当第二个参数为null或undefined时，回调每次 render 都会执行，参数为数组时，只有依赖变了才会执行\n\nvdom转fiber的过程叫做reconcile，更新到dom的过程叫做 commit，reconcile的过程可打断，需要schedule\n\nhooks也是基于fiber实现，它在fiber节点上维护一个链表（memorizedstate属性）来保存数据，每个hook都是从对应的链表元素上存取各自的数据\n\n这个链表建立的过程叫做——mount，以后只需要update，所以每个hook的实现都分为mount和update两个阶段\n\n> useeffect第二个参数对应的是 deps，如何判断是否要更新？？\n\ndeps是新传入的参数，若是undefined会作为null，hook.memorizedstate.deps 取到的是之前的 deps\n\n如果 prevdeps 是 null，直接返回 false，所以第二个参数传 undefined 或 null 函数都会执行\n\n否则，才会新旧的 deps 数组中每个元素对比，有一个不一样就返回 false\n\n\n# usememo\n\n当父组件中调用子组件时，父组件的state变化，会导致父组件更新，子组件即使没有变化，也会更新\n\n函数式组件从头更新到尾，只要一处改变，所有模块都会刷新——没必要！\n\n理想状态是 各个模块只进行 自己的更新，不相互影响\n\nusememo为了防止一种情况——父组件更新，无论是否最子组件操作，子组件都会更新\n\nmemo 结合了 purecomponent 纯组件 和 componentshouldupdate 功能，会对传入的props进行一次对比，根据第二个函数返回值判断哪些props需要更新\n\nusememo和memo类似，都是 判断 是否满足当前限定条件决定是否执行 callback ，usememo的第二个参数是一个数组，通过这个数组判断是否更新回调函数\n\n好处\n\n * 减少不必要 循环 和 渲染\n * 减少 子组件 渲染次数\n * 避免不必要 的开销\n\n\n# usecallback\n\n和usememo 可以说是一模一样，唯一不同的是usememo返回函数运行结果，而usecallback返回函数\n\n缓存回调，避免传入的回调每次都是新的函数实例导致依赖组件re-render\n\n是父组件传递子组件的 一个函数，防止无关 刷新，必须配合 memo，否则可能 还会降低 性能\n\n\n# useref\n\n获取组件真实节点，返回一个可变的ref对象，且这个对象 只有 current 属性，可设置 initialvalue\n\n> 缓存数据\n\nreact-redux 源码中，hooks推出后，react-redux用大量的usememo重做了 provide 等核心模块，运用了useref 缓存数据，所运用的useref() 没有一个是绑定在dom元素上的，都是用于数据缓存\n\nreact-redux 利用 重新赋值，改变了缓存的数据，减少不必要更新，如果使用userstate势必会re-render\n\n\n# 为啥ref获取不到hooks？\n\n\n# 总结\n\n * 一个优秀的hooks一定具备 usememo usecallback 等api 优化\n * 制作自定义hooks遇到传递过来的值，优先考虑使用useref，再考虑使用usestate\n * 封装时，应该将存放的值放入useref中\n\n\n# hooks原理\n\nhooks的本质是链表，保存在组件对应fiber的memoizedstate中\n\n\n# 🙋 ref\n\nref --\x3e reference：引用\n\nreact中 引用简写，是一个 属性，助于 存储 对react元素 或 组件的引用，引用由组件渲染配置函数返回\n\nref使用有三种方式：字符串(不推荐使用)，对象，函数\n\n1、字符串 react16 之前用的最多的，如\n\n<p ref=\"info\">text</p>\n\n\n1\n\n\n2、函数格式，ref对应一个方法，该方法有一个参数，即，对应的节点实例\n\n<p ref={ele=>this.info=ele}>test</p>\n\n\n1\n\n\n3、createref方法，react16 提供的api，使用react.createref()实现\n\n\n# 使用场景\n\n * input标签聚焦\n * 希望直接使用dom元素中的某个方法，或者直接使用自定义组件中的某一个方法\n * ref作用于内置的html组件，得到的将是真实的dom元素\n * ref作用于类组件，得到的将是类的实例\n * ref不能作用于函数组件，因为函数组价没有实例，但是函数组件中可以传递ref\n\n\n# 如何使用\n\n 1. class 组件 react.createref() 声明\n\nclass mycomponent extends react.component {  constructor(props) {    \n    super(props);    \n    this.myref = react.createref();  \n}  \nrender() {    \n    return <div ref={this.myref} />; \n}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n 2. 在函数组件使用 react.forwardref() 来暴露函数组件的 dom 元素\n\nconst input = forwardref((props, ref) => {\n  return (\n    <input {...props} ref={ref}>\n  )\n})\n\nclass mycomponent extends react.component {\n\n  constructor() {\n    this.ref = react.createref(null);\n  }\n\n  clickhandle = () => {\n    // 操作input组件聚焦\n    this.ref.current.focus();\n  }\n\n  render() {\n    return (\n      <div>\n        <button onclick={this.clickhandle}>\n          点击\n        </button>\n        <input ref={this.ref}>\n      </div>\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# render不能访问refs\n\n因为 render 阶段 dom还未生成，无法获取 dom，dom的获取需要在 pre-commit 和 commit 阶段\n\n<>\n  <span id=\"name\" ref={this.spanref}>{this.state.title}</span>\n  <span>{\n     this.spanref.current ? '有值' : '无值'\n  }</span>\n</>\n\n\n1\n2\n3\n4\n5\n6\n\n\n不可以！\n\n因为render阶段dom还没有生成\n\ndom的获取应该在 pre-commit 阶段和 commit 阶段\n\n\n# 🍊 高阶组件(hoc)\n\n是\"纯组价\"，解决**代码复用！**\n\n不是react api 的一部分，是基于react的组合特性而形成的设计模式，hoc 是参数为 组**件，返回值为 新组件 的函数！**\n\n优点\n\n * 逻辑复用、不影响被包裹组件的内部逻辑\n * 缺点是hoc传递给被 包裹组件的props 容易和被包裹后的组件 重名，被覆盖\n\n> 此处朱云博培训时讲过，basiclayout中就存在这个情况，不知道谁传递的参数，而且参数名容易被覆盖\n\nhoc就是装饰器模式的实现：通过给函数传入一个组件后在函数内部对该组件 进行功能的增强，最后返回这个组件，即允许向一个现有的组件添加新的功能，同时不修改该组件\n\n\n# 函数式编程\n\n\n# 声明式编程\n\n\n# 惰性执行（lazy evaluation）\n\n函数只在需要的时候执行，即不产生无意义的中间变量。\n\n\n# 核心概念\n\n\n# 数据不可变\n\n\n# 无状态\n\n强调对于一个函数，不管合适运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。\n\n\n\n\n# 没有副作用\n\n传递引用一时爽，代码重构火葬场\n\n\n1\n\n\n\n# 纯函数\n\n\n# 💙 开发模式\n\n\n# spa\n\n单页面应用，我们熟知的react就是典型的单页面应用\n\n\n# mpa\n\n\n# mvvm\n\nmodel-view-viewmodel，model数据模型，view表示ui组件，viewmodel将model和view关联起来\n\n数据绑定到viewmodel层并自动将数据渲染到页面，视图变化时通知viewmodel层更新数据\n\n将js逻辑从繁琐的dom操作中抽离出来\n\n通信是双向的\n\n\n\n> 应用场景\n\n * 针对具有复杂交互逻辑的前端应用\n * 提供复杂架构抽象\n * ajax数据持久化，保证用户体验\n\n\n# mvc\n\nmodel view controller\n\n\n\n所有通信都是单向的\n\n\n# mvvm、mvc\n\nmvc是后端的思想\n\nmvvm是前端的思想\n\n\n# 单向数据流框架始祖flux\n\n一个flux应用包含四个部分\n\n 1. dispatcher，处理动作分发，维持store之间的依赖管理\n 2. store 负责存储数据和处理数据逻辑\n 3. action 驱动dispatcher的js对象\n 4. view 视图部分，负责用户界面的显示\n\n访问view——view发送 action——dispatcher接收action——store更新——发送change事件——view更新页面\n\n\n\n\n# import react 导致文件变大？\n\ngzip压缩\n\n\n# react路由懒加载\n\n\n# react.lazy\n\nreact16.6新增react.lazy方法，像渲染常规组件一样处理动态引入的组件，配合 webpack 的 code splitting ，只有当组件被加载，对应的资源才会导入 ，从而达到懒加载的效果。\n\n\n# 使用 react.lazy\n\n// 不使用 react.lazy\nimport othercomponent from './othercomponent';\n// 使用 react.lazy\nconst othercomponent = react.lazy(() => import('./othercomponent'))\n\n\n1\n2\n3\n4\n\n\nreact.lazy 接受一个函数作为参数，这个函数需要调用 import() 。它需要返回一个 promise，该 promise 需要 resolve 一个 defalut export 的 react 组件。\n\nreact.lazy 方法返回的是一个 lazy 组件的对象，类型是 react.lazy，并且 lazy 组件具有 _status 属性，与 promise 类似它具有 pending、resolved、rejected 三个状态，分别代表组件的加载中、已加载、和加载失败三中状态。\n\n需要注意的一点是，react.lazy 需要配合 suspense 组件一起使用，在 suspense 组件中渲染 react.lazy 异步加载的组件。如果单独使用 react.lazy，react 会给出错误提示。\n\n\n# suspense 组件\n\nsuspense 内部主要通过捕获组件的状态去判断如何加载，上面我们提到 react.lazy 创建的动态加载组件具有 pending、resolved、rejected 三种状态，当这个组件的状态为 pending 时显示的是 suspense 中 fallback 的内容，只有状态变为 resolve 后才显示组件\n\n\n# ⭐️ vdom\n\n一个对象，最少包含tag、props和children三个属性，将真实的dom树转换为js对象树，vd和dom对象一一对应\n\n<button class=\"mybutton\">\n  <span>this is button</span>\n</button>\n//转换\n{\n  type: 'button',\n  props: {\n    classname: 'mybutton',\n    children: [{\n      type: 'span',\n      props: {\n        type: 'text'\n        children: 'this is button'\n      }\n    }]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n将多次dom修改的结果一次性更新到页面上，有效减少页面渲染次数，减少修改dom的重排重绘次数，提高渲染性能\n\n优越之处在于，提供更爽的、更高效的研发模式(函数式的ui编程模式)的同时，仍然保持还不错的性能\n\n * 保证性能下限，不手动优化时，提供过得去的性能\n * 跨平台\n\n原生dom有很多属性和事件，创建空的div也要付出很多代价，可通过diff算法和数据改变前的dom对比，计算出需要修改的dom，只对变化的dom操作，而不是更新整个视图\n\n\n# render()\n\n1.构建虚拟 dom\n\n2.通过虚拟 dom 构建真正的 dom\n\n3.生成新的 vdom\n\n4.比较两棵 vdom 异同\n\n5.应用变更于 dom\n\n\n# diff\n\ndom是多叉树结构，若完整对比两棵树的差异，时间复杂度高，react团队优化实现了o(n)的复杂度\n\n关键是只对比同层节点，而不是跨层对比\n\n 1. js建立节点描述对象\n 2. 状态或属性改变后重新计算vd生成补丁对象，diff比较分析新旧vdom差异\n 3. 将差异patch到adom实现更新\n\njs层面的计算返回一个patch对象，即补丁，通过特定的操作解析patch，完成页面re-render\n\n\n\n 1. adom映射为vdom\n 2. vdom变化后，根据差距生成patch，这个patch是结构化数据，包括增加 更新 和移除\n 3. 根据patch更新 adom\n\n\n\n大部分diff算法思路是\n\n * 只比较同一层级，不跨级比较\n * tag不同，直接删除重建，不再深度比较\n * tag和key都相同，则认为是相同节点，不再深度比较\n\ndiff 从 树 组件 及 元素 3个层面进行复杂度的优化\n\n树diff\n\n> 新旧两棵树逐层对比，找到需要更新的节点\n> \n> 若节点是组件就 component diff\n> \n> 1、忽略节点跨层级操作\n> \n> 若节点不存在了，则该节点及其子节点会被删除掉，不会进一步比较\n\n组件diff\n\n> 节点是组件，先看组件类型\n> \n> 类型不同直接替换(删除旧的)\n> \n> 类型相同则只更新属性，深入组件做树diff(递归)\n> \n> 若组件 是同一类型就进行树 对比，如果不是就直接放入 patch中，只要父组件类型不一致，就会re-render\n\n元素diff\n\n> 若节点是原生标签，则看标签名\n> \n> 标签名不同直接替换，相同则只更新属性，进入标签后代做树diff\n\n同一层级子节点，通过key 进行列表对比\n\n标记key，react 可以直接移动 dom节点，降低消耗\n\npatch做了啥\n\n\n\n\n# re-render\n\n 1. 对比新旧 vnode，使用 diff算法\n 2. 对新旧两棵树进行深度优先遍历，标记每个节点，每遍历一个，就把该节点和新的节点进行对比，有差异就放在一个对象中\n 3. 遍历差异对象，根据对应 规则 更新vnode\n\nvdom 优势之处在于，不管数据如何变化，它都会尽量以最小的代码更新 dom\n\n\n# vdom比原生快？\n\n网上都说操作真实 dom 慢，但测试结果却比 react 更快，为什么？\n\n\n# react17新特性\n\n一起来看 react 18 最新特性\n\nreact 18 带来了什么 ——官网\n\nv15-v16，源码架构中的 stack reconciler-fiber reconciler\n\n启发式更新算法——对开发者无感知\n\nreact纯js写法太过灵活，编译时优化 方面先天不足，因此，react的优化主要在 运行时\n\n> react15的痛点\n\nreact15 实现了batchdupdates（批量更新），即 同一事件回调函数上下文中的多次 setstate 只会触发一次 更新\n\n但是，如果单次更新就很耗时，造成页面卡顿\n\n因为v15的更新流程是同步的，一旦开始直到页面渲染前都不能中断\n\n为了解决 同步更新 长时间占用 线程 导致页面卡顿的问题，react开始重构，为了实现 concurrent mode（并发模式）\n\n> concurrent mode\n\n为了 实现 一套 可中断/恢复 的更新机制\n\n2个部分组成\n\n 1. 一套 协程 架构\n 2. 基于 协程架构的 启发式更新算法\n\n协程架构就是v16实现的fiber reconciler，可将fiber reconciler理解为react自己实现的generator\n\n协程架构 使 更新 可在需要时被 中断，酱紫 浏览器就有时间 完成 样式布局和绘制，减少 卡顿\n\n当进入下一次 event loop，协程架构 可 恢复中断 或 抛弃之前的 更新，重新开始新的更新流程\n\n启发式更新算法 就是控制 协程架构 工作方式的算法\n\n> v16的启发式更新算法\n\n启发式 ——不通过 显式指派，而是 通过 优先级 调度更新（优先级来自 人机交互的研究成果）\n\n人机交互研究结果表明：\n\n用户在输入框输入内容时，希望内容能实时显示\n\n异步请求时，即使等待一会儿再显示内容，用户勉强也能接受\n\n因此，v16中\n\n输入框内容触发的 更新 优先级 >请求数据返回 后触发 更新 优先级\n\nv16的 expirationtimes模型只区分是否>=expirationtimes 决定节点是否更新\n\n> v17启发式更新算法\n\n最理想的模型——可指定任意几个 优先级，更新 以这些 优先级 对应的 update 生成页面快照\n\nv17的lanes模型可选定一个 更新区间，动态向 区间 增减 优先级，可处理更细粒度的更新\n\n\n# 🔥 fiber\n\njs单线程运行，负责页面js解析和执行、绘制、事件处理、资源加载和处理，只能一个一个执行，若一个任务耗时很长，后面的任务则不能执行，卡死。\n\njs引擎和页面渲染引擎两个线程互斥。\n\nreact 15 ，渲染时 递归对比 vdom，找需要变动的节点，同步更新，一气呵成！！此过程react霸占浏览器资源，导致用户触发的事件得不到响应，掉帧 卡顿！！stack reconciler是同步过程，使用js引擎自身的函数调用栈，执行到栈空为止，渲染组件时，开始到渲染完成整个过程一气呵成，无法中断\n\n组件较大，js线程一直执行，等到整棵vdom树计算完成 才会交给渲染的线程\n\n所有任务没有优先级，按照顺序执行\n\n期望找出有增删改的节点，同步更新这个过程分解成2个部分，或变成可中断/恢复的执行，类似 多任务os的单处理调度\n\n将浏览器 渲染 布局 绘制 资源加载 事件响应 脚本执行 看成os的process，通过 调度策略合理分配 cpu 资源，提高浏览器 响应速率，兼顾 执行效率\n\nreact16起，引入 fiber 架构\n\nfiber是 链表，可以打断，可通过 requestidlecallback 空闲调度 reconcile，不断循环，直到处理完所有的 vdom 转fiber的reconcile，开始 commit，即 更新到adom\n\nrequestidlecallback实现，react 团队 polyfill 了这个 api，使其兼容性更好且拓展了特性\n\n\n> # window.requestidlecallback()\n\n浏览器空闲时 被调用，使 开发者能在主事件循环上执行后台和低优先级工作，不影响延迟 关键事件，如 动画 和输入响应\n\n函数一般按先进先调用顺序执行，然而，如果回调指定了执行超时时间 timeout，可能会为了在超时前执行函数 打乱执行顺序\n\n\n\n * 分批延时 操作 dom，避免一次性操作大量 dom 节点，用户体验更好\n * 给浏览器一点喘息的机会，对代码进行 编译 优化 及热代码优化\n\n手写简易版 react 来彻底搞懂 fiber 架构\n\n> 实现元素的更新\n\n\n# 双缓冲优化策略\n\n连体婴结构\n\n先绘制到一个缓冲区，再一次性传递给屏幕显示，防止抖动\n\n好处\n\n * 及时复用对象(fiber)\n * 节省内存分配，gc时间开销\n\n当前dom树对应的fiber树交currentfiber，正在构建的fiber树交workinprogress fiber，两棵树 通过alternate相连\n\n\n\n * 将每次渲染完后的fiber树赋值给currentroot\n * 第一次更新时将rooterfiber的alternate指向上一次渲染好的currentroot\n * 第二次之后的更新将workinprogressroot指向currentroot.alternate，然后将当前的workinprogressroot.alternate指向上一次渲染好的currentroot\n * ...\n * 进而达到复用fiber对象树\n\nalternate对象会接收上方传递的新props，从getderivedstatefromprops得到新的state，render不一样的组员，master和alternate差异越来越大，子组件出错 则回滚到组件的master分支\n\n模拟git add、git commit和git revert\n\n更新过程由current和workinprogress 两株树双缓冲 完成\n\nworkinprogress更新完成后 修改 current 相关指针 指向新节点\n\n双缓冲：经过reconcile形成新的workinprogress fiber，将workinprogress fiber切换成current fiber应用到adom，存在双fiber的好处是内存形成视图的描述，应用到dom，减少对dom的操作\n\n\n# react渲染机制\n\n\n\n\n# 获取dom\n\nreact-dom中的finddomnode()\n\nimport reactdom from 'react-dom';\ncomponentdidmount(){\n    const dom = reactdom.finddomnode(this);\n    // this为当前组件的实例\n}\n\nrender() {}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当组件被渲染 ，finddomnode 返回该组件实例对应的dom节点\n\nrefs\n\n多用于react组件内子组件的引用\n\n有两种情况：\n\n（1）子组件为原生dom：获取到的就是这个dom节点。如下例，this.input就获取到了当前<input />节点。\n\n<input ref={(ref)=>{this.myinput = ref}} />\n\n\n1\n\n\n通过this.myinput，我就可以对<input />进行一系列操作，比如让输入框聚焦：\n\nthis.myinput.focus();\n\n\n1\n\n\n注：refs也支持字符串格式：\n\n<input ref='myinput' />\n\n\n1\n\n\n通过this.refs.myinput获取到节点。\n\n（2）子组件为react组件，比如<myinput/>：获得的就是<myinput/>的实例，因此就可以调用<myinput/>的实例方法。 示例：\n\ncomponentdidmount(){\n    const mycomp = this.refs.mycomp;  // 获取到的是<comp />的实例mycomp\n    const dom = reactdom.finddomnode(mycomp);  // 获取到实例对应的dom节点\n}\n\nrender(){\n    return (\n        <div>\n            <comp ref='mycomp' />\n        </div>\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注：调用<comp />实例方法的方式：this.refs.mycomp.method()，但并不建议这种调用方式。\n\n\n# others\n\n\n# dangerouslysetinnerhtml\n\n是react中innerhtml的替代品\n\n网球系统中使用过，用来接收新闻正文，显示新闻数据html\n\n <div dangerouslysetinnerhtml={{ __html: newstexts }} />\n\n\n1\n\n\nreact的html元素上的一个属性，它可能是危险的，因为我们容易收到xss(跨站脚本攻击)——从第三方获取数据或用户提交内容时\n\nreact会识别html标签，然后渲染\n\nhtml元素可能会执行脚本，当js代码附加到html元素上\n\n使用html净化工具dompurify检测html中潜在的恶意部分\n\n\n# import react from 'react'\n\n在使用jsx的js文件中，必须显示声明，为啥？\n\njsx在编译时会被babel编译为react.createelement()方法\n\n否则在运行时该模块会报错——未定义变量react\n\nreact17中，不需要显式导入react",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Review",frontmatter:{title:"Review",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/520a27/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/11.Review.html",relativePath:"08.专栏/11.Review.md",key:"v-fae2a3b8",path:"/pages/520a27/",headersStr:null,content:"> 尽量往自己熟悉的地方靠，后端引入到前端，展现出自己的思考能力和思考的过程，比如为啥用dva，因为实验室是使用dva技术栈，以前没用dva时，和现在做一个对比，有什么不同，有什么好的效果，使用口语化表示出来。尽量扩展，知道多少说多少，拿自己熟悉的点靠近。比如promise就是改善，万一第一个请求出错了怎么办，还有什么其他办法做这个请求先后次序问题呢？\n\n\n# 2022/3/29 美团一面\n\n90min\n\n\n1\n\n\n说说你的项目吧\n\n为什么选择Dva，React\n\nReact原生route如何跨页面传参?\n\n路由对应同一页面，你是怎么做的\n\nreact原生或Dva如何监听路由变化，从而改变页面\n\n路由跳转的过程，浏览器发生哪些变化\n\n性能优化有哪些\n\n> 为什么通过变量改变CSS样式属于优化？——笨蛋，答错了！\n\nReact渲染机制\n\nReact生命周期\n\n生命周期有哪些作用？\n\n页面更新后还会执行componentDidMount吗？\n\n> 不会\n> \n> componentDidMount只有挂载时才会执行\n> \n> 页面更新render后getSnapshotBeforeUpdate,然后再是componentDidUpdate\n\nsetState一定是异步吗？什么时候是同步？\n\nrender为什么有时渲染两次？(求你,下次别给自己挖坑了!!!)\n\n> React在严格模式下会执行两次render以帮助检查额外的副作用\n\n浏览器输入一个URL的完整流程\n\n浏览器缓存机制\n\n浏览器存储\n\ncookie和session区别\n\n浏览器渲染一个页面运行哪些进程或线程\n\n页面更新，会触发什么进程线程\n\nUDP和TCP区别\n\nTCP为啥可靠？\n\n滑动窗口？\n\n网络层用的啥协议？\n\n计算机网络OSI\n\n进程线程区别\n\n进程通信方式\n\nDOM刷新后一个节点一定是VDOM算法吗\n\n> React的事件处理机制本身就是VDOM\n> \n> 根节点就只有root，即使一个节点发生了变化，还是使用的VDOM\n> \n> 原生就不是了\n\n说说事件循环机制\n\n说说输出的结果\n\n哪些是微任务 哪些是宏任务\n\n宏任务:script块,async前两句,setTimeout\n\n微任务:await后面的语句放进微任务队列,promise回调\n\nconsole.log('1');\n\nasync function async1() {\n    console.log('2');\n    await console.log('3');\n    console.log('4');// 放进微任务队列\n}\n\nsetTimeout(function () { console.log('5'); }, 0)\n\nasync1();\n\nnew Promise(function (resolve) {\n    console.log('6');\n    resolve(6);\n}).then((x) => x + 6)\n    .then((x) => { throw new Error('My Error') })\n    .then(() => 6)\n    .then((x) => x + 6)\n    .then((x) => console.log(x))\n    .catch(console.error)\n\nconsole.log('8');\n/**\n 1 2 3 6 8 4 my error 5\n \nthen的第一个 throw 抛出错误,返回的新的promise状态为rejected,所以就不会继续向下执行回调了\n/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n解析URL参数\n\n我的思路\n\n// 正则或直接是字符串提取\n// https://campus.meituan.com/index?key=value&key2=value2\n// {\n//     key:value,\n//     key2:value2\n// }\n\nfunction abstractPara(url) {\n    let qIndex = url.indexOf(\"?\");\n    let newUrl = url.slice(qIndex + 1, url.length);\n    newUrl = newUrl.split(\"&\")\n    let obj = {};\n    for (let item of newUrl) {\n        let tmp = item.split(\"=\");\n        obj[tmp[0]] = tmp[1];\n    }\n    console.log(obj);\n}\n\nlet url = 'https://campus.meituan.com/index?key=value&key2=value2';\nabstractPara(url);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n反问\n\n\n# 2022/5/10 字节一面\n\n1h\n\n\n1\n\n\n自我介绍\n\n项目功能是啥？\n\n使用的Taro？\n\n小程序的功能？\n\n项目积分有做二次加密吗？\n\n为啥学前端，大一开始的吗\n\n怎么学的前端？看过什么书\n\n实验室用的框架，分别是？\n\n接触过node吗？\n\n项目中跨域如何解决的？\n\n现在用的React哪个版本？\n\n\"react\": \"^16.6.3\", //^表示不改变大版本号，可以改变次版本号\n    //~ 表示 大版本和次版本号都不能\n\n\n1\n2\n\n\nReact15和React16的区别？\n\nReact生命周期钩子\n\n说说Fiber机制吧？\n\n使得 VDOM 生成变成可 打断的\n\n介绍一下HTTP吧？\n\n> 跨文本传输协议，笨蛋！！名字都记错了\n> \n> 这一块需要多扩展出来\n\n超文本指的啥？\n\nHTTP状态码分别是什么意思？\n\nHTTPS是啥？\n\nHTTP端口 HTTPS端口\n\nHTTPS的认证机制？\n\n盒模型？\n\n下一次把box-sizing属性说出来：规定如何计算元素的总宽高\n\n画一个三角形？\n\n .div {\n        width: 0px;\n        height: 0px;\n        border: 100px solid transparent;\n        border-top-color: red;\n        border-bottom-color: blue;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n事件循环\n\n说说前端路由吧？\n\nSPA路由跳转怎么实现的\n\n程序怎么知道哪个路由跳转到哪个页面的？\n\n配置完成之后，Nginx怎么知道去到哪一个页面呢\n\n框架路由怎么实现的\n\nHooks接触过吗？\n\n可以在if else中使用useState吗？\n\nuseState更新数据是浅比较吗？\n\nhooks的依赖了解过吗？callback那些\n\nVUE angular了解过吗？\n\n词法作用域\n\nfunction fun(a,b){\n    console.log(b);\n    return {\n        fun:function(c){\n            return fun(c,a);\n        }\n    };\n}\nvar d=fun(0);d.fun(1);d.fun(2);d.fun(3);\n//undefined 0 0 0\nvar d1=fun(0).fun(1).fun(2).fun(3);\n//undefined 0 1 2\nvar d2=fun(0).fun(1);d2.fun(2);d2.fun(3);\n//undefined 0 1 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n合并两个有序数组，O(n)实现\n\n直接双指针就行\n\n从后往前遍历，把元素放进nums1数组\n\nlet nums1 = [1, 4, 7, 9];\nlet nums2 = [2, 3, 6, 8, 19, 21];\n\nconst merge=(nums1, nums2) =>{\n    const m = nums1.length;\n    const n = nums2.length;\n    let left = m - 1;\n    let right = n - 1;\n    for (let i = m + n - 1; i >= 0; i--) {\n        if (left >= 0 && right >= 0) {\n            if (nums1[left] > nums2[right]) {\n                nums1[i] = nums1[left--];\n                continue;\n            } else if (nums1[left] < nums2[right]) {\n                nums1[i] = nums2[right--];\n                continue;\n            }\n        }\n        if (left >= 0) {\n            nums1[i] = nums1[left--];\n        } else if (right >= 0) {\n            nums1[i] = nums2[right--];\n        }\n    }\n    return nums1;\n};\nconsole.log(merge(nums1, nums2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n时间复杂度 O(m+n)\n\n实现Router.route\n\n注册功能相当于是，监听到对应路由的话，就会去执行对应的函数\n\nwindow.addEventListener('popstate',callback)\n//页面通过history.pushstate 修改路径，更新路径 console.log 对应内容\nclass Routers {\n    constructor(){\n        \n    }\n    route(){\n        \n    }\n}\nRouter=new Routers();\nRouter.route('/',function(){console.log('/')});\nRouter.route('/blue',function(){console.log('blue')});\nRouter.route('/green',function(){console.log('green')});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nTypeScript用过吗？\n\n\n# 2022/6/2 知道创宇一面\n\n30min\n\n\n1\n\n\n自我介绍\n\n之前实习过吗？\n\nflex布局？\n\nflex元素适应策略？\n\nflex定义元素的排列方式\n\nspace-between和space-around区别？\n\nCSS动画写过吗？\n\n项目中使用过canvas绘制圆弧\n\n下来看看canvas绘制图形基础 及 可能踩的坑\n\nPromise常用方法\n\n用过allSettled吗？\n\nES6新增的数组方法\n\n参考文档：https://es6.ruanyifeng.com/#docs/array\n\nforEach和map区别？\n\n迭代器\n\n> interator吗？\n> \n> 没回答上来\n\nfor...in和for...of\n\n怎么实现的遍历？\n\n对于没有迭代器的数据结构，可以遍历吗？\n\n项目中防抖咋做的？\n\nES6的proxy了解过吗\n\nrestFul文档怎么规定的api编写\n\napi编写规范有吗？\n\n项目分支有吗？合并冲突怎么做的？\n\nLinux常用指令知道吗？\n\n了解TypeScript吗？\n\n扩展了JS的语法\n\nHooks了解过吗？和Class有哪些不同\n\nreact性能优化有哪些\n\nshouldComponentUpdate了解过吗？\n\n父组件调用子组件的方法\n\n类组件\n\nReact.createRef()\n\nref的函数式声明 和上述一样，这是定义ref方式不同\n\nprops自定义onRef属性\n\n职业规划是啥？\n\n反问\n\n\n# 2022/8/27 百度一面\n\n53min\n\n\n1\n\n\n自我介绍\n\n下次可以根据应聘岗位动态调整自我介绍内容\n\n项目同时用到React和Vue，是为啥？\n\nTaro和原生区别，或者说Taro缺点\n\n> 根据使用经验，原生拥有更多API，还有些小的bug，这些只有自己应用时才去进行调整\n> \n> 原生给的API比较丰富，语法相对来说比较简单，项目层次性没有Taro开发那么深\n\nTaro的性能优于原生？\n\n不然，针对不同场景，我们可以用原生写出性能最佳的代码，但是工作量太大，实际项目开发中需要掌握效率和优化之间的平衡\n\nTaro的优势在于 能让我们书写更有效率的代码，拥有丰富生态的同时，带来不错的性能\n\n你对JS了解程度怎么样？\n\n简单说下JS的闭包\n\n有了解过JS引擎里面的一些详细实现逻辑？\n\n简单说下JS的作用域\n\n局部作用域var声明的变量会提升到全局作用域吗\n\n说一下JS的数据类型\n\nES6中你常用的语法\n\n箭头函数和普通函数区别是啥？\n\n除了this指向，还有啥区别\n\nLinux中，怎么查看当前目前下的所有文件，包括隐形目录\n\nV8引擎垃圾回收机制？\n\nCSS选择器优先级\n\n盒子模型了解过吗\n\n> 下次可以再带上自己平时使用的，所接触的，表示自己是真的做过的\n\n你nginx部署遇到过哪些问题？\n\n你简单和我说一下反向代理，你理解的反向代理\n\n反向代理除了解决跨域，还有啥作用\n\n> 为了安全考虑，可以保护真实服务器IP地址，用代理，不知道我服务器的真实IP地址\n\n还有吗？\n\n负载均衡了解过？\n\n> 并发访问一台服务器，压力过大，对用户访问实时性较高，减少服务器的承载压力\n\n分发的行为称为啥？\n\n设计全链路的登录模块，你会怎么设计，包含前后端和数据库\n\ntoken怎么生成\n\n> 为了加密，使用字符串拼接\n> \n> 密码 +随机字符串\n\n密码放token中吗\n\n> 加密算法被破解的话，密码也暴露了，反应过来，不需要，万一破解的话，密码就没了\n> \n> 可以使用用户名，加一些随机数，带一些随机性较强的比如时间戳\n> \n> token不容易被模仿\n\n时间戳还有其他目的吗\n\n> token实时性高一些\n> \n> 如何对方不是同时登录，就会失败(不确定)\n\n更高的作用是——登录超时，在一定时间内，让它重新登录\n\njwt是后端生成的吧\n\n原生小程序遇到哪些坑吗？\n\n怎么做的响应式\n\n那有了解它这块具体怎么做的响应适配吗\n\n移动端布局，有了解吗？\n\n移动端布局如何做到设计稿的高还原度\n\n我看你比较善于总结，这几个项目\n\n哪个对你挑战最高，学到的东西最多\n\n做项目，接触一门新技术，会怎么学习\n\n> 拿到项目，首先看项目结构，再看别人写的代码，文件作用\n> \n> 结合官网看\n> \n> 遇到不熟悉的，官网没有的，就求助 google和github\n> \n> 自己写的时候，再模仿别人的代码写\n> \n> 画图或者其他方式理清逻辑\n\n第三个项目总结有个页面设计合理性……，能说一下项目中的case\n\n你经常写CSDN吗？\n\n怎么访问谷歌，是搭梯子吗？\n\n项目中，是单独负责项目，还是负责整个项目\n\n从系统设计宏观层面介绍项目，哪个最了解的\n\n系统的设计，业务模块，模块间的关系\n\n了解过项目管理吗\n\n讲一下你了解的项目管理\n\n拿出实施计划后，后面会有闭环反馈吗\n\n有项目总结吗？团体性的总结\n\n明年毕业，没错吧？\n\n公司一个新需求，到交付，角色分别是？他们的职责？\n\nwebstorm用的正版吗？\n\n算法：手写二分法\n\n了解过nodejs吗\n\n反问\n\n\n# 2022/8/31 神策一面\n\n41min\n\n\n1\n\n\n自我介绍\n\n描述自己做的项目\n\nReact用的哪个版本\n\n使用的class还是hooks\n\n了解过hooks吗？他们有啥区别\n\nuseEffect的第二个参数如何理解监听数据改变？\n\nJS\n\n数据类型\n\n看下次能否再多说些\n\n数组API引起数组本身变化\n\nreduce用过吗\n\nES5实现reduce\n\n为啥不能用箭头函数？\n\n用了箭头的话，this指向？\n\ninitial条件判断规范些\n\n> 如果初始值为0的话，判断方法是undefined\n\nArray.prototype.reduce = function (func, initial) {\n    let val = initial!==undefined ? initial : this[0];\n    for (let i = initial ? 1 : 0; i < this.length; i++) {\n        let ele = this[i];\n        val = func(val, ele, i, this);\n    }\n    return val;\n}\n\nlet arr = [1, 2, 3, 4]\nlet ans = arr.reduce((pre, cur, index, arr) => {\n    return pre + cur;\n}, 0)\nconsole.log(ans)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n304和200区别\n\nexpires和Cache-Control字段\n\nlast_modified和etag\n\n下次还可以说说他们之间的优先级，还有优势也说一下\n\n过程描述清晰一些\n\nCSS水平垂直居中\n\n反问\n\n\n# 2022/9/2 百度二面\n\n24min\n\n\n1\n\n\n自我介绍\n\n项目是实验室的吗？\n\nXXX教学平台负责的啥\n\n介绍下React+Vue的衔接处理\n\n为啥使用React而不是Vue\n\n开发的项目上线了吗\n\n跳转是路由自己的跳转吗？\n\nwindow.open跳转有遇到问题吗？\n\n项目比较复杂的点？收获大的点？\n\n性能优化哪些方面考虑\n\n有什么方法做缓存？\n\n了解过CDN\n\n接着说性能优化\n\n简单介绍原生微信小程序\n\n通过什么实现用户信息获取的？\n\n获取用户身份授权信息通过什么API实现的？\n\n最近 微信小程序更新了，取消了一些钩子函数\n\n你知道微信小程序的更新吗\n\n跨页面数据传递怎么做的？\n\n> 没完全说出来\n> \n>  1. url\n>  2. data-属性\n>  3. 缓存\n>  4. 全局变量\n\n使用原生微信小程序和Vue的区别或是体验？\n\nES6的模块加载\n\nCommonJS和ES6\n\n> 先说为什么有这个东西——这个东西有啥作用——我们平时如何使用的，结合自己的项目经验——具体用法语法，表明自己是有准备的——结合自己的理解\n\nthis取值情况\n\n待会有时间吗，三面\n\n\n# 2022/9/2 百度三面\n\n15min\n\n\n1\n\n\n分享一下做项目过程中有挑战或者能体现出技术深度的地方吗？\n\n合适的时间选择合适的工具，正确高效的找出问题出现的原因并解决\n\n之前一直使用React？\n\nReact对比式更新和需要注意的地方？\n\nReact对比式更新是如何做的，更新过程如何保证性能的？\n\nPureComponent\n\n不能完全靠react官方文档实现性能优化\n\n有了解过Taro如何实现一套代码多端使用？\n\n> 同一套代码多端运行，底层编译时 生成适应多端的配置文件\n\ngit rebase和git merge区别\n\n用过Nodejs吗？\n\n有用过？\n\n项目中写了微前端\n\n\n# 2022/9/5 京东一面\n\n35min\n\n\n1\n\n\n自我介绍\n\n为啥要使用React+Vue一起开发\n\nReact和Vue，你怎么看\n\n错误处理？\n\n如果变量状态不对？怎么处理？\n\n项目组几个人？你负责哪部分？\n\n关于状态管理的理解？\n\n你觉得你的亮点是啥？\n\n大学生涯最有挑战的事情\n\n这个过程中，对你影响最大的是\n\n> 自己对自己的影响占而更多比例\n\n反问\n\n\n# 2022/9/6 途虎一面\n\n34min\n\n\n1\n\n\n自我介绍\n\n如何开始学习前端\n\n手写发布/订阅模式\n\nclass myEventEmitter {\n    constructor() {\n        this.eventObj = new Map()\n    }\n\n    On(type, handler) {\n        if (typeof handler !== 'function') {\n            throw new Error('error')\n        }\n        if (!this.eventObj[type]) {\n            this.eventObj[type] = []\n        }\n        this.eventObj[type].push(handler);\n    }\n\n    emit(type, payload) {\n        if (this.eventObj[type]) {\n            this.eventObj[type].forEach((handler, index) => {\n                handler(payload);\n            });\n        }\n    }\n\n    off(type, handler) {\n        if (this.eventObj[type]) {\n            let tmp = [];\n            let tmpIndex = this.eventObj[type].indexOf(handler)\n            tmp = this.eventObj[type].filter((item, index) => {\n                return item !== tmpIndex;\n            })\n            this.eventObj[type] = [...tmp]\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n加个once，只执行一次\n\nset和map\n\nmap比对象更适用？\n\n对象和map区别\n\n对象键值对有序吗？map有序吗\n\nweakmap和weakset\n\nJS垃圾回收机制\n\nClass和Hooks区别\n\nReact用的demo\n\n有了解过Hooks底层实现吗？\n\n场景题，初始值为0，useEffect中useState(1),useState(2)，页面会触发几次？console.log(1)执行几次\n\n会先打印0，再打印两次2\n\n如果换成setTimeout会执行几次呢?\n\n反问\n\n\n# 2002/9/6 神策二面\n\n35min\n\n\n1\n\n\n自我介绍\n\n印象最深项目？深入理解\n\n系统是否能够抽象出来，用于其他的一些赛事\n\n难点体现在哪？\n\n小程序没有跨域问题！！答错了\n\n后台跨域，两个域名吗\n\n一个人既写小程序也写后台吗\n\n状态管理页面，如何维护的代码\n\nC页面中间状态判断，用户体验？为啥不加一个中间层\n\n看前辈的东西，觉得有哪些东西设计的好，哪些觉得不合理？\n\n设计层面可以优化的地方\n\n你是否尝试做过改进\n\n说过对组件封装，让你封装一个form组件，从哪些方面考虑组件封装？设计哪些API\n\n布局方面的考虑呢？这里可以去看看antd如何实现的form\n\n反问\n\n\n# 2022/9/7 易校一面\n\n自我介绍\n\n哪一个项目最满意\n\n印象比较深刻的地方，业务逻辑\n\n关于代码可读性和可维护性，展开说说\n\n协作通过什么方式\n\n你有主持过会议，或是阶段性成果？\n\n前后端如何合作\n\n使用较多的git命令\n\n如何解决冲突\n\n项目还有比较有意思的地方吗？\n\n跨越是提前知道的，还是遇到了发现的\n\n网页渲染成页面的过程\n\nJS啥时候加载\n\nJS放在head标签呢？\n\n让script标签不阻塞\n\n重绘和重排\n\n哪些操作引起重排\n\nReact常用生命周期\n\n了解过ts吗\n\n场景题\n\n一个会员制网站，会员到期弹出提示，过期前一个月弹出，用户关闭后，一周之内再次弹出，如何实现\n\ncookie和localStorage区别\n\ncookie设置域名访问字段\n\n你的理解，前端是做啥的\n\n你自己感兴趣的方向？\n\n通过哪些途径学习前端\n\n简单说一下让你收获较多的项目\n\nReact和Vue的设计思想有啥不同吗\n\n反问\n\n\n# 2022/9/9 易校二面\n\n42min\n\n\n1\n\n\n自我介绍\n\ngit pull和git fetch\n\n如何解决冲突\n\n了解rebase吗\n\n项目介绍，背景，亮点，遇到的问题，思路是啥，如何解决，收获了啥\n\n遇到的技术难点\n\n关于技术的细节\n\n用了富文本，如何封装组件，考虑哪些事项，暴露哪个API\n\n为啥选择这个富文本编辑器\n\n使用Quill插件遇到的问题\n\n组件是同一封装再使用吗\n\n介绍封装过的组件，比较有意思，有难点的\n\n场景题，滚动加载\n\n封装组件，使用哪些属性，需要暴露哪些API\n\ninput需要验证输入内容，//就提示，http://就不提示\n\n> 场景在JSON编辑器中，传输JSON格式数据，不能有单行注释，有个问题 反向否定查找有兼容性问题\n> \n> (?<!http:)// 反向否定查找\n\n> 使用普通正则？\n> \n> 用户在链接中添加 转义字符 ，正则只检测 //(干掉！很麻烦)\n> \n> (str).replace('/http:,/gm',\"\") 解决问题，没有全局替换，gm\n> \n> 实现细节？replaceAll()？？兼容性问题\n> \n> indexOf()只能查到第一个\n> \n> 循环，串变为数组\n\n反问\n\n\n# 2022/9/13 神策三面\n\n40min\n\n\n1\n\n\n自我介绍\n\n你对前端的理解？\n\n你刚说到原生，那我问一些原生的\n\nlet 相比var有啥区别\n\nvar时代如何避免对全局变量的污染\n\n箭头函数好处是啥\n\n什么场景使用箭头函数\n\n没有箭头函数咋做\n\n声明函数不使用箭头函数，如何让函数指向我声明的类，比bind更简单的？\n\n介绍花的时间多的项目\n\n技术选型参与过吗\n\n选择Taro不是你的决策？\n\n使用Taro的原因是啥\n\nTaro不稳定，使用过程中是否遇到坑？\n\n讲讲跨域问题\n\n了解过其他解决跨域的方法\n\n服务端设置Access-Control-Allow-Origin，前端不做代理可以吗？\n\n> 说的不可以，笨蛋！打错了！\n> \n> 面试官反问了几次，还是没答对，这就是解决跨域问题啊！\n\n对前端的方向和职业规划\n\n反问\n\n\n# 2022/9/15 途虎二面\n\n44min\n\n\n1\n\n\n自我介绍\n\n自己平时会写代码 做项目吗\n\n自己会写博客 记笔记吗\n\n求最长连续不重复字符串长度\n\nfunction func(s) {\n    let arr = [], max = 0;\n    for (let i = 0; i < s.length; i++) {\n        let index = arr.indexOf(s[i]);\n        if (index !== -1) {\n            arr.splice(0, index + 1);\n        }\n        arr.push(s.charAt(i));\n        max = Math.max(arr.length, max)\n    }\n    return max\n}\n\nconsole.log(func('aaacdaaaa'))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n优化？\n\n没想出来\n\nlet list=['zhifuboa/aaaa','xmh/wwwl/wwww'...]\nlet ans='aaaa/wwww'\n一个数组元素都是URL，挨个发送请求，将结果拼接成字符串\n\n\n1\n2\n3\n\n\n实际工作中，时间很紧，除了项目功能完成，还需要做啥\n\n怎么看待用户体验\n\n反问\n\n\n# 2022/9/15 途虎HR面\n\n33min\n\n\n1\n\n\n为啥想要离开四川？\n\n为啥不考研\n\n为啥大三就下定决心找工作了\n\n为什么考虑是否考研不适合\n\n今年就业形势不乐观，当初考虑过吗？或者说还是对自己很有信心的？\n\n介绍下3个项目\n\n哪个项目对个人成长最大？\n\n一个新的领域，如何去学习？\n\n你如何评价自己写的模块代码质量？\n\n还是需要在实际工作中才发现问题吗？\n\n项目中有需要更新的地方？\n\n项目之中发现的问题还是？\n\n是否做过相关的优化？\n\n如何确定先优化哪些？\n\n反问\n\n\n# 2022/9/16 优赛时代一面\n\n22min\n\n\n1\n\n\n自我介绍\n\nPromise常用方法\n\nallSettled和all区别\n\n场景题，2个异步请求，同时发起，整理结果后，再渲染结果\n\n如何使用git做迭代，切分支\n\nmaster上线了，代码有问题 代码回滚？\n\nReact和Vue谁用的多\n\nTS了解吗\n\n如何看待TS，为啥现在还没有往TS走\n\n数组index或重复元素作为key，解释下原理？\n\n数组索引作为key，会造成什么问题？会渲染错误吗？\n\n无法渲染更新后的数据？为啥\n\n实际上，普通列表并未渲染错误？为啥？\n\n除了对比key，还可以对比key啥\n\n代码命名规范\n\n小/大驼峰啥时候用到\n\n\n# 2022/9/28 同程一面\n\n25min\n\n\n1\n\n\n自我介绍\n\n行内/块级元素\n\n哪些是行业/块级？\n\n分别的定义？\n\nlink标签是行内？块级？都不算？\n\nlink和@import区别\n\n浏览器存储\n\nlocalStorage容量上限了，但还是想存数据咋整？\n\n> 滚动存储\n> \n> 跨域存储\n\n原型和原型链\n\n跨域，项目中咋解决的\n\n性能优化需注意的点\n\n性能优化指标？\n\n减少http请求数量？对http2.0来说，这个优化有必要吗\n\nhttp缓存\n\n微信小程序和web区别\n\n反问\n\n\n# 2022/9/28 百奥一面\n\n50min\n\n\n1\n\n\n自我介绍\n\n最近学过什么新的技术？\n\n若不是秋招，推上一些在学什么\n\nBFC\n\n创建BFC\n\n垂直居中方案\n\n使用兼容性好的属性设置居中(display:inline-block)\n\n一个方块平移的动画，使用CSS还是JS写？\n\n为啥觉得CSS性能好？(如果能够从浏览器进程原理去解释，我觉得会更好)\n\n使用JS如何实现动画？\n\nsetTimeout和setInterval区别\n\n除了这个两个API，还有什么JS的API\n\nrequestAnimationFrame对比setTimeout好处是？\n\n什么情况会重排，如何避免？\n\n从你的语言中，你可能对性能优化有了解，如果多的话，可以从网络层展开说说\n\nCDN分发原理\n\n避免CDN缓存我的节点资源，如何使用nginx的配置\n\n如果想让CDN缓存呢？会根据哪些哪些字段缓存\n\n什么资源用强缓存，什么资源用协商缓存\n\n了解过什么负载均衡算法\n\n解释下跨域，开发环境和线上环境\n\n开发环境配置的什么？\n\n原生端？(微信原生小程序没有跨域问题)\n\nget请求，后端会收到吗？\n\n什么情况会发送预检请求？\n\n什么时候浏览器会认为发送的请求是复杂请求？\n\n跨域时会携带cookie吗？(不会)\n\n如何在跨域时携带cookie？\n\nVDOM的本质？\n\nMVVM的架构一定会比原生性能更好吗？\n\nReact的状态提升了解过吗\n\ndiff算法了解过吗\n\ndiff主要的算法思路？(后面时间赶，就没咋展开说了)\n\n如果使用index作为key，有什么后果？\n\n有什么途径可以验证页面性能如何？(f12 performance)\n\n是否有通过链表完成过什么东西？\n\n二分查找的时间复杂度？(log2n)\n\n知道是如何推算出来的吗？\n\nx===1&&x===2&&x==3？(valueOf重写方法)\n\n关闭页面后继续发请求\n\nCommonJS和ES6\n\n若没有模块化导出，如何实现作用域封闭？(闭包，自执行函数，let const)\n\n检测用户什么时候关闭页面？关闭页面后再发请求\n\n如果页面关闭后再发请求\n\n\n# 2022/9/29 同程二面\n\n17min\n\n\n1\n\n\n自我介绍\n\nCSS优先级\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n\n        div.a{\n            color: red;\n        }\n        .b{\n            color: blue;\n        }\n    </style>\n</head>\n<body>\n<div class=\"a b\">s</div>\n<div class=\"b a\">v</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n最有挑战的事？自定义页面栈\n\n微信最大层级页面(10层)\n\n如果想要到11层，怎么办\n\nMVVM双向数据绑定实现原理\n\n最有成就感的事？\n\n反问\n\n\n# 2022/9/30 睿联一面\n\n40min\n\n\n1\n\n\n自我介绍\n\n数组内存不够了，但还是要继续push元素咋办？\n\n数组遍历方法\n\nfor-of可遍历哪些数据类型\n\nfor-of如何遍历对象\n\n哪些数据类型可迭代\n\nJS的作用域分类\n\n如何理解这个\"块\"字？\n\nfor循环的setTimeout输出，var和let定义变量区别\n\n它们算是闭包吗？\n\nsetTimeout是异步吗？\n\nsetTimeout设置的时间一定是1s后执行吗？\n\n开一个服务，如何在外部电脑访问？\n\n> 具体咋实现\n\n代码输出，答错了\n\ntry {\n    new Promise(function (resolve) {\n        resolve(1);\n        console.log(2);\n    })\n        .then(function (v) {\n        console.log(v);\n        throw new Error(3);\n    });\n} catch (e) {\n    console.log(e.message)\n} finally {\n    console.log(4)\n}\nconsole.log(5)\n/**\n2\n4\n5\n1\nUncaught (in promise) Error: 3\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n输出2后，其他任务进入微任务队列，立即执行finally语句块，然后回头执行微任务，此时不能catch到错误，因为宏任务已经执行完了？\n\ntry {\n   await new Promise(function (resolve) {\n        resolve(1);\n        console.log(2);\n    })\n        .then(function (v) {\n        console.log(v);\n        throw new Error(3);\n    });\n} catch (e) {\n    console.log(e.message)\n} finally {\n    console.log(4)\n}\nconsole.log(5)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n实现Promise.all()思路\n\npuppeter实现点击付款流程\n\nwaitfor实现思路\n\nawait后面可以跟setTimeout吗\n\n前端领域很多，有想要发展的方向吗？\n\n反问\n\n\n# 2022/10/10 水滴一面\n\n35min\n\n\n1\n\n\n自我介绍\n\n讲下项目经历\n\n简单说下axios，为啥用axios，axios和fetch区别\n\nfetch能监听网络请求超时吗\n\nJS单线程，针对异步事件如何处理\n\n事件循环的事件队列有优先级吗\n\n宏任务和微任务区别\n\n微任务和宏任务谁先执行\n\ndom渲染时啥时候？\n\n渲染后干啥？\n\n了解nodejs和浏览器的事件循环区别\n\n你表达的是整个事件循环都不一样，是吗\n\n有了解过跨域吗\n\ndocument.domain+iframe，两个页面域名完全不一样，如何解决跨域\n\nJWT的概念简单说说\n\nJWT和cookie方案区别\n\n使用Vue多还是React对\n\nVue和React区别\n\n重新学习一个新的框架成本大吗\n\n现在流行的框架，React和Vue的核心思想是啥\n\n反问\n\n\n# 2022/10/11 联友一面\n\n30min\n\n\n1\n\n\n自我介绍\n\n介绍项目，难点，负责部分\n\n用了什么微前端框架吗\n\n2个技术栈间的跳转如何保证用户体验？\n\nElementUI的el-table，如何实现表格内容宽度自适应？\n\n改变table第二列第二行的input框内容？\n\nvue用的多吗？\n\nreact的hook和vue的hooks区别？\n\nES6新特性\n\nES6新特性 数组去重\n\n介绍React的diff原理\n\n更新时除了对比类型，还会对比啥？\n\n项目中你是用的什么做的key\n\nReact的高阶组件\n\nReact中哪几种方式获取dom\n\n反问\n\n\n# 2022/10/12 百奥二面\n\n50min\n\n\n1\n\n\n自我介绍\n\n了解过React和vue区别吗\n\n看过React源码吗\n\n介绍React的diff\n\n项目是从头搭建还是自己搭建\n\n熟悉webpack构建工具吗\n\nwebpack 和 Rollup适用场景\n\nvite了解过吗\n\nnginx对资源做缓存的配置\n\n啥资源使用强缓存，啥资源使用协商缓存\n\n跨域除了反向代理，还有啥问题\n\n浏览器跨域的请求会在什么时候中断，会真的发送到服务端呢\n\npackage.json和package-lock.json区别\n\ndevDependencies和dependencies区别\n\nnpm build时会打包devDependencies下的依赖吗\n\n了解过npm有啥缺陷吗\n\n那为啥现在还是使用npm，有替代方案吗\n\n了解过pnpm吗\n\naxios可用在node环境吗？有了解过原理吗？\n\naxios如何区分浏览器还是node环境，库的开发者，判断环境的操作应该由开发者还是提供者判断\n\n单向链表和双向链表区别\n\n链表在前端的应用\n\n手撕 css画三角形，判断空对象的方法，反转链表\n\n项目过程中特别难的地方，如何解决的\n\n用canvas做过其他应用吗\n\n可视化框架是什么\n\n加入你选的话，倾向做后台还是小游戏 动效 3d 2d 酷炫的效果\n\n\n# 2022/10/13 睿联二面\n\n45min\n\n\n1\n\n\n自我介绍\n\n你理解的前端如何划分，技术这块的理解\n\n3个项目哪个觉得更有成就感一点\n\nXXX项目的背景\n\n系统功能上你怎样理解去划分的，你承担的角色\n\n测试 ，沟通 ，部署这方面时间占比和你自己开发占比如何区分\n\n核心的地方，是指什么，可以举个栗子吗\n\n在编码上的核心是指什么\n\n简历提到深入了解http跨域问题，你了解的解决跨域问题的方案主要有哪些\n\n场景题\n\n典型的自营电商的一个解决平台，这种情况你会选择哪种方式解决跨域(小米商城 、苹果等)\n\n为什么使用CORS\n\n使用了JWT吗，jwt和token的差别\n\nJWT有可能破解码\n\n可能从哪个层面去破解呢？比如https层面也不一定是绝对安全的\n\nHTTPS通信，如何能劫持到JWT\n\n浏览器网页是否能实现一个功能，去本地选择视频，浏览器播放\n\n本地选择图片，网页上显示，可行吗\n\n不跟服务端交付，纯本地实现图片在浏览器显示\n\n你如何理解宏任务微任务及其调度\n\n使用过puppeteer进行爬虫测试吗\n\n测试的效果怎么样\n\n除了这个还有什么方法实现自动化测试吗\n\n你总结的前端性能优化规范和方案有哪些\n\n把不太变化的本地存在本地localStorage，假设网站比较大 复杂，localStorage存满之后，可能是别人的项目造成的干扰，你去写入的时候可能失败，类似这种异常，如何处理比较好\n\n> 开始答的 换种方式存，存在另一个地方或者换个源\n\n站在个人开发这样说，若是站在团队开发如何处理，因为不可能每个人遇到都去处理一下，复杂度上去，团队角度的处理规范规避这样的事情发生\n\n但其实收拢不一定可能，因为有时候不能将所有情况具象化到一个具体的，不是具体的就不知道大小，不清楚是否超预算\n\n> 对域名进行划分？让专门的业务组规范使用划分的域名\n> \n> 没有规范答案\n\n反问\n\n\n# 2022/10/13 达达一面\n\n37min\n\n\n1\n\n\n自我介绍\n\n使用Taro的原因是啥\n\n最早操纵DOM是JS原生，后面是jQuery，再后面是React使用VDOM操作，你觉得它的优势在哪\n\n体验是研发的体验还是用户的体验\n\n前端的数据类型\n\nnull和undefined区别\n\n你觉得typeof和instanceof的区别\n\n对原型链概念的理解\n\n代码输出\n\nfunction Person(){\n\tthis.name ='DaDa'\n}\nconst people = new Person()\nPerson.prototype = {age: 18}\nconsole.log(people.name, people.age)\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果将 Person.prototype = {age: 18} 换成 Person.prototype.age=18 有啥区别\n\n你觉得它对实例的影响是啥？\n\n描述下对事件循环的理解\n\n代码输出\n\nsetTimeout(()=>{console.log(1)}, 5000)\nsetTimeout(()=>{console.log(2)}, 1000)\n\n\n1\n2\n\n\n为什么是这样的，按照刚才的理解，为什么先打印2再打印1？\n\n时间戳一到push进任务队列，你觉得这个事情是谁在做\n\n还记得浏览器由其他进程线程吗\n\nGUI线程和JS引擎线程为啥互斥\n\nJS阻塞DOM解析，CSS会阻塞DOM构建吗？顶部的CSS是否会阻塞底部JS代码执行吗\n\n按照你的说法，理解下这个过程\n\n反问\n\n\n# 2022/10/14 酷家乐一面\n\n1h22min\n\n\n1\n\n\n自我介绍\n\n线程和进程概念有了解吗\n\n说的抽象的概念，可以用浏览器举例说明吗\n\n浏览器的渲染过程，大概讲讲\n\n解析HTML代码时遇到scrip标签会怎样\n\n数组和链表区别\n\n数组和链表分别插入 或查询效率如何\n\n栈和队列区别\n\n对于二叉树有哪些遍历方式\n\n遍历对象属性有哪些方式\n\nfor-in和Object.keys()区别\n\n说下对原型链的理解\n\n对于闭包的理解\n\n使用闭包可能造成什么问题\n\n还有其他什么操作会造成内存泄露\n\n了解过哪些ES6新特性\n\nconst let和var区别\n\n箭头函数和普通函数区别\n\n除了localStorage，浏览器其他的一些存储方式\n\n大概讲下跨域问题如何理解\n\n简述下React和Vue生命周期\n\nReact中setState(1)两次，render触发几次\n\n如果state=1，再次setState(1)，render是否会执行\n\n> 特定条件下，render会触发，只是页面不会变\n\ngit常见命令\n\n代码输出\n\nvar name = 'window';\n\nvar person = {\n    name: 'person',\n    sayName: function () {\n        console.log(this.name)\n    }\n}\n\nfunction sayName () {\n    var sss = person.sayName;\n\n    sss();\n\n    person.sayName();\n\n    (person.sayName)();\n\n    (b = person.sayName)();\n}\n\nsayName();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n实现比num大的最小的数字\n\n/*2.寻找比目标数字大的最小数字：\n\n输入：排序后的数组A，包含从小到大排序的数字；\n\n目标数字：num\n\n要求：从数组A中找出比num大的最小数字，若不存在则返回第一个数字；\n\n例如：\n\n输入数组A = [5,11,15,20,100]\n\n目标数字num = 13\n\n则返回15*/\nlet A = [5, 11, 15, 20, 100];\n\n\nfunction solve(arr, num) {\n    /*arr.sort((a, b) => a - b);\n    for (let i of arr) {\n        if (i > num) {\n            return i;\n        }\n    }\n    return arr[0];*/\n\n    arr.sort((a, b) => a - b);\n    let left = 0, right = arr.length - 1;\n    while (left < right) {\n        let mid = left + (Math.floor((right - left) / 2));\n        if (arr[mid] > num) {\n            right = mid ;\n        } else {\n            left=mid+1;\n        }\n    }\n    return arr[left];\n}\n\nconsole.log(solve(A, 13))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n合并2个有序数组\n\n/*3.数组Union\n合并两个有序数组A和B，要求合并后的数组C仍然保持有序。\n例如：\n\n数组A = 【2，3， 6， 7， 9】 B=【1，4， 5，8】\n\n结果数组C应为【1，2，3，4，5， 6， 7， 8，9】 */\nlet a = [2, 3, 6, 7, 9]\nlet b = [1, 4, 5, 8]\n\nfunction merge(ary1, ary2) {\n    let len1 = ary1.length - 1, len2 = ary2.length - 1;\n    let len = ary1.length + ary2.length - 1;\n    let bufs ;\n    while (len1>=0 || len2>=0) {\n        if (len1 === -1) {\n            bufs = ary2[len2--];\n        } else if (len2 === -1) {\n            bufs = ary1[len1--];\n        } else if (ary1[len1] > ary2[len2]) {\n            bufs = ary1[len1--];\n        } else {\n            bufs = ary2[len2--];\n        }\n        ary2[len--] = bufs;\n    }\n    return ary2;\n}\n\nconsole.log(merge(a, b))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n反问\n\n\n# 2022/10/14 酷家乐二面\n\n45min\n\n\n1\n\n\n自我介绍\n\n892. 三维形体的表面积\n\nfunction solve(grid) {\n    let size = grid.length;\n    let num = 0, area = 0;\n    for (let i = 0; i < size; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            let bufs = grid[i][j];\n            if (bufs > 0) {\n                num += bufs;\n                area += (bufs - 1) * 2;\n                area += i > 0 ? Math.min(bufs, grid[i - 1][j]) * 2 : 0;\n                area += j > 0 ? Math.min(bufs, grid[i ][j-1]) * 2: 0;\n            }\n        }\n    }\n    return num * 6 - area;\n}\nconsole.log(solve([[1, 2], [3, 4]]))\nconsole.log(solve([[1,1,1],[1,0,1],[1,1,1]])) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n反问\n\n\n# 2022/10/17 睿联HR面\n\n深圳\n20min\n\n\n1\n2\n\n\n自我介绍\n\n为啥选择睿联\n\n项目经历\n\n统筹前端小组困难的地方，或者自己不太擅长的地方\n\n团队合作的时候，最大的难点，或者比较头疼的事情\n\n为什么老师选择你作为组长\n\n平时喜欢看哪些书\n\n介绍一下《明朝那些事儿》看到哪里了，在分享哪些事情\n\n这本书谁写的(当年明月)\n\n目前手上有offer吗\n\n对手上的offer是否满意\n\n期望薪资\n\n哪里人\n\n想过考研吗\n\n班级考研同学多吗\n\n反问\n\n\n# 2022/10/17 百奥HR面\n\n广州\n28min\n\n\n1\n2\n\n\n什么时候决定走前端这条路\n\n成绩挺好的，是否有想过偏软件开发，比如后端这个方向发展\n\n挑一个项目介绍开发工作流程\n\n项目是0到1还是说在原有基础改进迭代的\n\n前端多少个人\n\n在学姐带领下负责项目哪块功能\n\n项目中0到上线做了多久\n\n你们的组长如何筛选的\n\n开始写代码后面带别人写代码，你觉得角色转换最大的区别是啥(花了哪些功夫去做了转换)\n\n教学平台是实习项目吗\n\n啥时候开始秋招\n\n感觉今年的行情怎么样\n\n成绩不错，有考研想法吗\n\n手上有一些offer在对比了吧\n\n对秋招这份工作会比较关注哪些点\n\n项目对接有遇到难沟通的人或事吗\n\n之前聊过工作氛围吗\n\n期望薪资\n\n对工作地点的想法\n\n秋招导出都会投吧\n\n反问\n\n以下皆为实习岗位\n\n\n1\n\n\n\n# 2022/11/8 先胜业财一面\n\n> 38min\n\n对H5的新特性\n\nCSS3的新特性\n\nflex实现垂直居中\n\nflex实现两栏布局\n\nES6新特性\n\n项目中如何处理异步问题？\n\n> promise\n> \n> async/await\n\n使用方式差异和优缺点\n\npromise API用过哪些\n\nall()使用的场景\n\nasync/await错误处理\n\n> try catch 其实很简单\n\n若后端返回数据结构和预期不一致，咋整\n\n前端存储\n\n用的类组件开发吗\n\nHooks项目中用过吗\n\n为啥不使用hooks\n\n反问\n\n\n# 2022/11/10 先胜业财一面\n\n自我介绍\n\n怎样学习前端\n\n前端和后端区别\n\n有看书的习惯，红宝书看完了吗\n\n实习的时候，自己的角色，感受是啥，加班厉不厉害，有啥看法\n\n作为一个新人，在公司最重要的是什么\n\nReact的合成事件\n\nsetState是同步或异步\n\nReact合成事件中实现setState同步怎么办\n\n父组件更新子组件不更新\n\n反问\n\n\n# 2022/11/11 同程一面\n\n> 34min\n\n自我介绍\n\n提到了新的技术，简单描述学的新的东西\n\n> 低代码，微前端\n\n对低代码怎么看，如何理解\n\n做低代码会导致技术退步，你怎么看\n\n低代码在国内是不断探索的状态，2条路如何选，做低代码还是说选择低代码平台项目开发\n\n介绍教学平台项目，啥角色，做了啥功能\n\nreact跳转vue的jwt如何传递\n\ntoken比较长，URL会有长度限制，咋整\n\n> 使用cookie，切换验证方案\n> \n> 结合前后端和网络系统想到的解决方案\n\n若cookie做验证，整个路径是啥，说一下想法\n\n> set-cookie做身份验证\n\ncookie同源限制，建议后端怎么做\n\n> cors去解决\n\n若token过期了，还用登录吗\n\n> token不能一直有效，定时去查看token\n> \n> 后端做了有效校验，前端如何做才知道token过期了\n> \n> 每次发送请求，后端会返回对应数据，401前端再做响应处理，重新登录\n\n刚说了，会关注社区\n\n使用React哪个版本，为啥不使用17、18\n\n了解过React17、18的新特性吗？\n\n讲下浏览器的垃圾回收机制\n\n对未来实习岗位的预期，平台？行业和业务线？\n\n反问\n\n\n# 2022/11/11 映宇宙一面\n\n> 1h25min\n\n实现垂直水平居中\n\n\n\n代码输出\n\nvar obj = {\n    name: 'baidu',\n    arr: ['a', 'b', 'c']\n}\n\nvar obj2 = obj\nvar arr = obj.arr\n\nobj2.arr = ['a', 'b', 'c', 'd']\nobj2.name = 'inke'\n\nconsole.log(arr)\nconsole.log(obj.name)\nconsole.log(obj === obj2)\nconsole.log(obj.arr === obj2.arr)\nconsole.log(obj.arr === arr) \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n实现清除浮动的几种方法\n\n代码输出\n\nvar MAP =  {\n    onclick: function () {\n\n    },\n    curry: function (val) {\n        return function (z) {\n            return val++ + z\n        }\n    }\n}\n\nvar getInfo = function (val) {\n    return MAP[val]\n}\nvar fn = getInfo('curry')\n\nvar a = fn(100)\n\nconsole.log(a(200))\nconsole.log(a(300))\nconsole.log(fn(100)(200))\nconsole.log(getInfo('curry')(100)(300))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n代码输出\n\nvar name = 'oop'\n\nvar Person = function (options) {\n    this.name = options.name\n}\n\nPerson.prototype.name = 'Person'\nPerson.prototype.getName = function () {\n    return this.name\n}\nPerson.getName = function() {\n    return this.name;\n}\n\nvar p = new Person({name: 'inke'})\n\nconsole.log(p.constructor ===  ?) // true\n\nconsole.log(p instanceof ?) // true\n\nconsole.log(p.__proto__ === ?) // true\n\nconsole.log(p.hasOwnProperty('name')) \nconsole.log(p.hasOwnProperty('getName')) \n\nvar getName = p.getName\n\nconsole.log(getName === Person.getName) // ?\nconsole.log(getName()) // ?\n\nconsole.log(Person.prototype.getName()) // ?\n\nconsole.log(p.getName())\n\nconsole.log(Person.getName())\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n写出React常见生命周期方法\n\ncomponentWillMount()\ncomponentDidMount()\n\ncomponentWillUnMount()\n\ncomponentWillReceiveProps()\nshouldComponentUpdate()\ncomponentWillUpdate()\ncomponentDidUpdate()\nrender()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n渲染顺序\n\n\n\n问觉得自己最牛逼的技能是啥？\n\n熟悉this算吗？\n\n那如何修改this指向呢？\n\n熟悉的常用算法\n\n能用JS实现一个吗\n\n实现冒泡排序\n\nfunction bubbleSort(arr) {\n    let size = arr.length;\n    for (let i = 0; i < size - 1; i++) {\n        for (let j = 0; j < size - 1 - i; j++) {\n            arr[j] > arr[j + 1] ? [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] : '';\n        }\n    }\n    return arr;\n}\n\nconsole.log(bubbleSort([2, 4, 1, 22, 9, 22]))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n反问\n\n\n# 2022/11/11 同程二面\n\n> 30min\n\n自我介绍\n\n100万条数据找到出现次数Top10的数\n\n分段分多少合适？\n\n考虑很多因素，遍历方式\n\n算法的时间复杂度是？O(n)\n\nMap的时间复杂度是？不清楚\n\n做了多久的前端\n\n圆角如何实现？CSS2情况如何实现border-radius？\n\n场景题，看页面有哪些功能？哪些功能的实现是难点？\n\n影视类的内容上传文件的组件，需要考虑哪些内容\n\n上传中途网络中断怎么办，可以怎么做到呢？可能需要哪些事情实现\n\n之前实习中收获最大的是啥\n\n反问",normalizedContent:"> 尽量往自己熟悉的地方靠，后端引入到前端，展现出自己的思考能力和思考的过程，比如为啥用dva，因为实验室是使用dva技术栈，以前没用dva时，和现在做一个对比，有什么不同，有什么好的效果，使用口语化表示出来。尽量扩展，知道多少说多少，拿自己熟悉的点靠近。比如promise就是改善，万一第一个请求出错了怎么办，还有什么其他办法做这个请求先后次序问题呢？\n\n\n# 2022/3/29 美团一面\n\n90min\n\n\n1\n\n\n说说你的项目吧\n\n为什么选择dva，react\n\nreact原生route如何跨页面传参?\n\n路由对应同一页面，你是怎么做的\n\nreact原生或dva如何监听路由变化，从而改变页面\n\n路由跳转的过程，浏览器发生哪些变化\n\n性能优化有哪些\n\n> 为什么通过变量改变css样式属于优化？——笨蛋，答错了！\n\nreact渲染机制\n\nreact生命周期\n\n生命周期有哪些作用？\n\n页面更新后还会执行componentdidmount吗？\n\n> 不会\n> \n> componentdidmount只有挂载时才会执行\n> \n> 页面更新render后getsnapshotbeforeupdate,然后再是componentdidupdate\n\nsetstate一定是异步吗？什么时候是同步？\n\nrender为什么有时渲染两次？(求你,下次别给自己挖坑了!!!)\n\n> react在严格模式下会执行两次render以帮助检查额外的副作用\n\n浏览器输入一个url的完整流程\n\n浏览器缓存机制\n\n浏览器存储\n\ncookie和session区别\n\n浏览器渲染一个页面运行哪些进程或线程\n\n页面更新，会触发什么进程线程\n\nudp和tcp区别\n\ntcp为啥可靠？\n\n滑动窗口？\n\n网络层用的啥协议？\n\n计算机网络osi\n\n进程线程区别\n\n进程通信方式\n\ndom刷新后一个节点一定是vdom算法吗\n\n> react的事件处理机制本身就是vdom\n> \n> 根节点就只有root，即使一个节点发生了变化，还是使用的vdom\n> \n> 原生就不是了\n\n说说事件循环机制\n\n说说输出的结果\n\n哪些是微任务 哪些是宏任务\n\n宏任务:script块,async前两句,settimeout\n\n微任务:await后面的语句放进微任务队列,promise回调\n\nconsole.log('1');\n\nasync function async1() {\n    console.log('2');\n    await console.log('3');\n    console.log('4');// 放进微任务队列\n}\n\nsettimeout(function () { console.log('5'); }, 0)\n\nasync1();\n\nnew promise(function (resolve) {\n    console.log('6');\n    resolve(6);\n}).then((x) => x + 6)\n    .then((x) => { throw new error('my error') })\n    .then(() => 6)\n    .then((x) => x + 6)\n    .then((x) => console.log(x))\n    .catch(console.error)\n\nconsole.log('8');\n/**\n 1 2 3 6 8 4 my error 5\n \nthen的第一个 throw 抛出错误,返回的新的promise状态为rejected,所以就不会继续向下执行回调了\n/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n解析url参数\n\n我的思路\n\n// 正则或直接是字符串提取\n// https://campus.meituan.com/index?key=value&key2=value2\n// {\n//     key:value,\n//     key2:value2\n// }\n\nfunction abstractpara(url) {\n    let qindex = url.indexof(\"?\");\n    let newurl = url.slice(qindex + 1, url.length);\n    newurl = newurl.split(\"&\")\n    let obj = {};\n    for (let item of newurl) {\n        let tmp = item.split(\"=\");\n        obj[tmp[0]] = tmp[1];\n    }\n    console.log(obj);\n}\n\nlet url = 'https://campus.meituan.com/index?key=value&key2=value2';\nabstractpara(url);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n反问\n\n\n# 2022/5/10 字节一面\n\n1h\n\n\n1\n\n\n自我介绍\n\n项目功能是啥？\n\n使用的taro？\n\n小程序的功能？\n\n项目积分有做二次加密吗？\n\n为啥学前端，大一开始的吗\n\n怎么学的前端？看过什么书\n\n实验室用的框架，分别是？\n\n接触过node吗？\n\n项目中跨域如何解决的？\n\n现在用的react哪个版本？\n\n\"react\": \"^16.6.3\", //^表示不改变大版本号，可以改变次版本号\n    //~ 表示 大版本和次版本号都不能\n\n\n1\n2\n\n\nreact15和react16的区别？\n\nreact生命周期钩子\n\n说说fiber机制吧？\n\n使得 vdom 生成变成可 打断的\n\n介绍一下http吧？\n\n> 跨文本传输协议，笨蛋！！名字都记错了\n> \n> 这一块需要多扩展出来\n\n超文本指的啥？\n\nhttp状态码分别是什么意思？\n\nhttps是啥？\n\nhttp端口 https端口\n\nhttps的认证机制？\n\n盒模型？\n\n下一次把box-sizing属性说出来：规定如何计算元素的总宽高\n\n画一个三角形？\n\n .div {\n        width: 0px;\n        height: 0px;\n        border: 100px solid transparent;\n        border-top-color: red;\n        border-bottom-color: blue;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n事件循环\n\n说说前端路由吧？\n\nspa路由跳转怎么实现的\n\n程序怎么知道哪个路由跳转到哪个页面的？\n\n配置完成之后，nginx怎么知道去到哪一个页面呢\n\n框架路由怎么实现的\n\nhooks接触过吗？\n\n可以在if else中使用usestate吗？\n\nusestate更新数据是浅比较吗？\n\nhooks的依赖了解过吗？callback那些\n\nvue angular了解过吗？\n\n词法作用域\n\nfunction fun(a,b){\n    console.log(b);\n    return {\n        fun:function(c){\n            return fun(c,a);\n        }\n    };\n}\nvar d=fun(0);d.fun(1);d.fun(2);d.fun(3);\n//undefined 0 0 0\nvar d1=fun(0).fun(1).fun(2).fun(3);\n//undefined 0 1 2\nvar d2=fun(0).fun(1);d2.fun(2);d2.fun(3);\n//undefined 0 1 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n合并两个有序数组，o(n)实现\n\n直接双指针就行\n\n从后往前遍历，把元素放进nums1数组\n\nlet nums1 = [1, 4, 7, 9];\nlet nums2 = [2, 3, 6, 8, 19, 21];\n\nconst merge=(nums1, nums2) =>{\n    const m = nums1.length;\n    const n = nums2.length;\n    let left = m - 1;\n    let right = n - 1;\n    for (let i = m + n - 1; i >= 0; i--) {\n        if (left >= 0 && right >= 0) {\n            if (nums1[left] > nums2[right]) {\n                nums1[i] = nums1[left--];\n                continue;\n            } else if (nums1[left] < nums2[right]) {\n                nums1[i] = nums2[right--];\n                continue;\n            }\n        }\n        if (left >= 0) {\n            nums1[i] = nums1[left--];\n        } else if (right >= 0) {\n            nums1[i] = nums2[right--];\n        }\n    }\n    return nums1;\n};\nconsole.log(merge(nums1, nums2))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n时间复杂度 o(m+n)\n\n实现router.route\n\n注册功能相当于是，监听到对应路由的话，就会去执行对应的函数\n\nwindow.addeventlistener('popstate',callback)\n//页面通过history.pushstate 修改路径，更新路径 console.log 对应内容\nclass routers {\n    constructor(){\n        \n    }\n    route(){\n        \n    }\n}\nrouter=new routers();\nrouter.route('/',function(){console.log('/')});\nrouter.route('/blue',function(){console.log('blue')});\nrouter.route('/green',function(){console.log('green')});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ntypescript用过吗？\n\n\n# 2022/6/2 知道创宇一面\n\n30min\n\n\n1\n\n\n自我介绍\n\n之前实习过吗？\n\nflex布局？\n\nflex元素适应策略？\n\nflex定义元素的排列方式\n\nspace-between和space-around区别？\n\ncss动画写过吗？\n\n项目中使用过canvas绘制圆弧\n\n下来看看canvas绘制图形基础 及 可能踩的坑\n\npromise常用方法\n\n用过allsettled吗？\n\nes6新增的数组方法\n\n参考文档：https://es6.ruanyifeng.com/#docs/array\n\nforeach和map区别？\n\n迭代器\n\n> interator吗？\n> \n> 没回答上来\n\nfor...in和for...of\n\n怎么实现的遍历？\n\n对于没有迭代器的数据结构，可以遍历吗？\n\n项目中防抖咋做的？\n\nes6的proxy了解过吗\n\nrestful文档怎么规定的api编写\n\napi编写规范有吗？\n\n项目分支有吗？合并冲突怎么做的？\n\nlinux常用指令知道吗？\n\n了解typescript吗？\n\n扩展了js的语法\n\nhooks了解过吗？和class有哪些不同\n\nreact性能优化有哪些\n\nshouldcomponentupdate了解过吗？\n\n父组件调用子组件的方法\n\n类组件\n\nreact.createref()\n\nref的函数式声明 和上述一样，这是定义ref方式不同\n\nprops自定义onref属性\n\n职业规划是啥？\n\n反问\n\n\n# 2022/8/27 百度一面\n\n53min\n\n\n1\n\n\n自我介绍\n\n下次可以根据应聘岗位动态调整自我介绍内容\n\n项目同时用到react和vue，是为啥？\n\ntaro和原生区别，或者说taro缺点\n\n> 根据使用经验，原生拥有更多api，还有些小的bug，这些只有自己应用时才去进行调整\n> \n> 原生给的api比较丰富，语法相对来说比较简单，项目层次性没有taro开发那么深\n\ntaro的性能优于原生？\n\n不然，针对不同场景，我们可以用原生写出性能最佳的代码，但是工作量太大，实际项目开发中需要掌握效率和优化之间的平衡\n\ntaro的优势在于 能让我们书写更有效率的代码，拥有丰富生态的同时，带来不错的性能\n\n你对js了解程度怎么样？\n\n简单说下js的闭包\n\n有了解过js引擎里面的一些详细实现逻辑？\n\n简单说下js的作用域\n\n局部作用域var声明的变量会提升到全局作用域吗\n\n说一下js的数据类型\n\nes6中你常用的语法\n\n箭头函数和普通函数区别是啥？\n\n除了this指向，还有啥区别\n\nlinux中，怎么查看当前目前下的所有文件，包括隐形目录\n\nv8引擎垃圾回收机制？\n\ncss选择器优先级\n\n盒子模型了解过吗\n\n> 下次可以再带上自己平时使用的，所接触的，表示自己是真的做过的\n\n你nginx部署遇到过哪些问题？\n\n你简单和我说一下反向代理，你理解的反向代理\n\n反向代理除了解决跨域，还有啥作用\n\n> 为了安全考虑，可以保护真实服务器ip地址，用代理，不知道我服务器的真实ip地址\n\n还有吗？\n\n负载均衡了解过？\n\n> 并发访问一台服务器，压力过大，对用户访问实时性较高，减少服务器的承载压力\n\n分发的行为称为啥？\n\n设计全链路的登录模块，你会怎么设计，包含前后端和数据库\n\ntoken怎么生成\n\n> 为了加密，使用字符串拼接\n> \n> 密码 +随机字符串\n\n密码放token中吗\n\n> 加密算法被破解的话，密码也暴露了，反应过来，不需要，万一破解的话，密码就没了\n> \n> 可以使用用户名，加一些随机数，带一些随机性较强的比如时间戳\n> \n> token不容易被模仿\n\n时间戳还有其他目的吗\n\n> token实时性高一些\n> \n> 如何对方不是同时登录，就会失败(不确定)\n\n更高的作用是——登录超时，在一定时间内，让它重新登录\n\njwt是后端生成的吧\n\n原生小程序遇到哪些坑吗？\n\n怎么做的响应式\n\n那有了解它这块具体怎么做的响应适配吗\n\n移动端布局，有了解吗？\n\n移动端布局如何做到设计稿的高还原度\n\n我看你比较善于总结，这几个项目\n\n哪个对你挑战最高，学到的东西最多\n\n做项目，接触一门新技术，会怎么学习\n\n> 拿到项目，首先看项目结构，再看别人写的代码，文件作用\n> \n> 结合官网看\n> \n> 遇到不熟悉的，官网没有的，就求助 google和github\n> \n> 自己写的时候，再模仿别人的代码写\n> \n> 画图或者其他方式理清逻辑\n\n第三个项目总结有个页面设计合理性……，能说一下项目中的case\n\n你经常写csdn吗？\n\n怎么访问谷歌，是搭梯子吗？\n\n项目中，是单独负责项目，还是负责整个项目\n\n从系统设计宏观层面介绍项目，哪个最了解的\n\n系统的设计，业务模块，模块间的关系\n\n了解过项目管理吗\n\n讲一下你了解的项目管理\n\n拿出实施计划后，后面会有闭环反馈吗\n\n有项目总结吗？团体性的总结\n\n明年毕业，没错吧？\n\n公司一个新需求，到交付，角色分别是？他们的职责？\n\nwebstorm用的正版吗？\n\n算法：手写二分法\n\n了解过nodejs吗\n\n反问\n\n\n# 2022/8/31 神策一面\n\n41min\n\n\n1\n\n\n自我介绍\n\n描述自己做的项目\n\nreact用的哪个版本\n\n使用的class还是hooks\n\n了解过hooks吗？他们有啥区别\n\nuseeffect的第二个参数如何理解监听数据改变？\n\njs\n\n数据类型\n\n看下次能否再多说些\n\n数组api引起数组本身变化\n\nreduce用过吗\n\nes5实现reduce\n\n为啥不能用箭头函数？\n\n用了箭头的话，this指向？\n\ninitial条件判断规范些\n\n> 如果初始值为0的话，判断方法是undefined\n\narray.prototype.reduce = function (func, initial) {\n    let val = initial!==undefined ? initial : this[0];\n    for (let i = initial ? 1 : 0; i < this.length; i++) {\n        let ele = this[i];\n        val = func(val, ele, i, this);\n    }\n    return val;\n}\n\nlet arr = [1, 2, 3, 4]\nlet ans = arr.reduce((pre, cur, index, arr) => {\n    return pre + cur;\n}, 0)\nconsole.log(ans)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n304和200区别\n\nexpires和cache-control字段\n\nlast_modified和etag\n\n下次还可以说说他们之间的优先级，还有优势也说一下\n\n过程描述清晰一些\n\ncss水平垂直居中\n\n反问\n\n\n# 2022/9/2 百度二面\n\n24min\n\n\n1\n\n\n自我介绍\n\n项目是实验室的吗？\n\nxxx教学平台负责的啥\n\n介绍下react+vue的衔接处理\n\n为啥使用react而不是vue\n\n开发的项目上线了吗\n\n跳转是路由自己的跳转吗？\n\nwindow.open跳转有遇到问题吗？\n\n项目比较复杂的点？收获大的点？\n\n性能优化哪些方面考虑\n\n有什么方法做缓存？\n\n了解过cdn\n\n接着说性能优化\n\n简单介绍原生微信小程序\n\n通过什么实现用户信息获取的？\n\n获取用户身份授权信息通过什么api实现的？\n\n最近 微信小程序更新了，取消了一些钩子函数\n\n你知道微信小程序的更新吗\n\n跨页面数据传递怎么做的？\n\n> 没完全说出来\n> \n>  1. url\n>  2. data-属性\n>  3. 缓存\n>  4. 全局变量\n\n使用原生微信小程序和vue的区别或是体验？\n\nes6的模块加载\n\ncommonjs和es6\n\n> 先说为什么有这个东西——这个东西有啥作用——我们平时如何使用的，结合自己的项目经验——具体用法语法，表明自己是有准备的——结合自己的理解\n\nthis取值情况\n\n待会有时间吗，三面\n\n\n# 2022/9/2 百度三面\n\n15min\n\n\n1\n\n\n分享一下做项目过程中有挑战或者能体现出技术深度的地方吗？\n\n合适的时间选择合适的工具，正确高效的找出问题出现的原因并解决\n\n之前一直使用react？\n\nreact对比式更新和需要注意的地方？\n\nreact对比式更新是如何做的，更新过程如何保证性能的？\n\npurecomponent\n\n不能完全靠react官方文档实现性能优化\n\n有了解过taro如何实现一套代码多端使用？\n\n> 同一套代码多端运行，底层编译时 生成适应多端的配置文件\n\ngit rebase和git merge区别\n\n用过nodejs吗？\n\n有用过？\n\n项目中写了微前端\n\n\n# 2022/9/5 京东一面\n\n35min\n\n\n1\n\n\n自我介绍\n\n为啥要使用react+vue一起开发\n\nreact和vue，你怎么看\n\n错误处理？\n\n如果变量状态不对？怎么处理？\n\n项目组几个人？你负责哪部分？\n\n关于状态管理的理解？\n\n你觉得你的亮点是啥？\n\n大学生涯最有挑战的事情\n\n这个过程中，对你影响最大的是\n\n> 自己对自己的影响占而更多比例\n\n反问\n\n\n# 2022/9/6 途虎一面\n\n34min\n\n\n1\n\n\n自我介绍\n\n如何开始学习前端\n\n手写发布/订阅模式\n\nclass myeventemitter {\n    constructor() {\n        this.eventobj = new map()\n    }\n\n    on(type, handler) {\n        if (typeof handler !== 'function') {\n            throw new error('error')\n        }\n        if (!this.eventobj[type]) {\n            this.eventobj[type] = []\n        }\n        this.eventobj[type].push(handler);\n    }\n\n    emit(type, payload) {\n        if (this.eventobj[type]) {\n            this.eventobj[type].foreach((handler, index) => {\n                handler(payload);\n            });\n        }\n    }\n\n    off(type, handler) {\n        if (this.eventobj[type]) {\n            let tmp = [];\n            let tmpindex = this.eventobj[type].indexof(handler)\n            tmp = this.eventobj[type].filter((item, index) => {\n                return item !== tmpindex;\n            })\n            this.eventobj[type] = [...tmp]\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n加个once，只执行一次\n\nset和map\n\nmap比对象更适用？\n\n对象和map区别\n\n对象键值对有序吗？map有序吗\n\nweakmap和weakset\n\njs垃圾回收机制\n\nclass和hooks区别\n\nreact用的demo\n\n有了解过hooks底层实现吗？\n\n场景题，初始值为0，useeffect中usestate(1),usestate(2)，页面会触发几次？console.log(1)执行几次\n\n会先打印0，再打印两次2\n\n如果换成settimeout会执行几次呢?\n\n反问\n\n\n# 2002/9/6 神策二面\n\n35min\n\n\n1\n\n\n自我介绍\n\n印象最深项目？深入理解\n\n系统是否能够抽象出来，用于其他的一些赛事\n\n难点体现在哪？\n\n小程序没有跨域问题！！答错了\n\n后台跨域，两个域名吗\n\n一个人既写小程序也写后台吗\n\n状态管理页面，如何维护的代码\n\nc页面中间状态判断，用户体验？为啥不加一个中间层\n\n看前辈的东西，觉得有哪些东西设计的好，哪些觉得不合理？\n\n设计层面可以优化的地方\n\n你是否尝试做过改进\n\n说过对组件封装，让你封装一个form组件，从哪些方面考虑组件封装？设计哪些api\n\n布局方面的考虑呢？这里可以去看看antd如何实现的form\n\n反问\n\n\n# 2022/9/7 易校一面\n\n自我介绍\n\n哪一个项目最满意\n\n印象比较深刻的地方，业务逻辑\n\n关于代码可读性和可维护性，展开说说\n\n协作通过什么方式\n\n你有主持过会议，或是阶段性成果？\n\n前后端如何合作\n\n使用较多的git命令\n\n如何解决冲突\n\n项目还有比较有意思的地方吗？\n\n跨越是提前知道的，还是遇到了发现的\n\n网页渲染成页面的过程\n\njs啥时候加载\n\njs放在head标签呢？\n\n让script标签不阻塞\n\n重绘和重排\n\n哪些操作引起重排\n\nreact常用生命周期\n\n了解过ts吗\n\n场景题\n\n一个会员制网站，会员到期弹出提示，过期前一个月弹出，用户关闭后，一周之内再次弹出，如何实现\n\ncookie和localstorage区别\n\ncookie设置域名访问字段\n\n你的理解，前端是做啥的\n\n你自己感兴趣的方向？\n\n通过哪些途径学习前端\n\n简单说一下让你收获较多的项目\n\nreact和vue的设计思想有啥不同吗\n\n反问\n\n\n# 2022/9/9 易校二面\n\n42min\n\n\n1\n\n\n自我介绍\n\ngit pull和git fetch\n\n如何解决冲突\n\n了解rebase吗\n\n项目介绍，背景，亮点，遇到的问题，思路是啥，如何解决，收获了啥\n\n遇到的技术难点\n\n关于技术的细节\n\n用了富文本，如何封装组件，考虑哪些事项，暴露哪个api\n\n为啥选择这个富文本编辑器\n\n使用quill插件遇到的问题\n\n组件是同一封装再使用吗\n\n介绍封装过的组件，比较有意思，有难点的\n\n场景题，滚动加载\n\n封装组件，使用哪些属性，需要暴露哪些api\n\ninput需要验证输入内容，//就提示，http://就不提示\n\n> 场景在json编辑器中，传输json格式数据，不能有单行注释，有个问题 反向否定查找有兼容性问题\n> \n> (?<!http:)// 反向否定查找\n\n> 使用普通正则？\n> \n> 用户在链接中添加 转义字符 ，正则只检测 //(干掉！很麻烦)\n> \n> (str).replace('/http:,/gm',\"\") 解决问题，没有全局替换，gm\n> \n> 实现细节？replaceall()？？兼容性问题\n> \n> indexof()只能查到第一个\n> \n> 循环，串变为数组\n\n反问\n\n\n# 2022/9/13 神策三面\n\n40min\n\n\n1\n\n\n自我介绍\n\n你对前端的理解？\n\n你刚说到原生，那我问一些原生的\n\nlet 相比var有啥区别\n\nvar时代如何避免对全局变量的污染\n\n箭头函数好处是啥\n\n什么场景使用箭头函数\n\n没有箭头函数咋做\n\n声明函数不使用箭头函数，如何让函数指向我声明的类，比bind更简单的？\n\n介绍花的时间多的项目\n\n技术选型参与过吗\n\n选择taro不是你的决策？\n\n使用taro的原因是啥\n\ntaro不稳定，使用过程中是否遇到坑？\n\n讲讲跨域问题\n\n了解过其他解决跨域的方法\n\n服务端设置access-control-allow-origin，前端不做代理可以吗？\n\n> 说的不可以，笨蛋！打错了！\n> \n> 面试官反问了几次，还是没答对，这就是解决跨域问题啊！\n\n对前端的方向和职业规划\n\n反问\n\n\n# 2022/9/15 途虎二面\n\n44min\n\n\n1\n\n\n自我介绍\n\n自己平时会写代码 做项目吗\n\n自己会写博客 记笔记吗\n\n求最长连续不重复字符串长度\n\nfunction func(s) {\n    let arr = [], max = 0;\n    for (let i = 0; i < s.length; i++) {\n        let index = arr.indexof(s[i]);\n        if (index !== -1) {\n            arr.splice(0, index + 1);\n        }\n        arr.push(s.charat(i));\n        max = math.max(arr.length, max)\n    }\n    return max\n}\n\nconsole.log(func('aaacdaaaa'))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n优化？\n\n没想出来\n\nlet list=['zhifuboa/aaaa','xmh/wwwl/wwww'...]\nlet ans='aaaa/wwww'\n一个数组元素都是url，挨个发送请求，将结果拼接成字符串\n\n\n1\n2\n3\n\n\n实际工作中，时间很紧，除了项目功能完成，还需要做啥\n\n怎么看待用户体验\n\n反问\n\n\n# 2022/9/15 途虎hr面\n\n33min\n\n\n1\n\n\n为啥想要离开四川？\n\n为啥不考研\n\n为啥大三就下定决心找工作了\n\n为什么考虑是否考研不适合\n\n今年就业形势不乐观，当初考虑过吗？或者说还是对自己很有信心的？\n\n介绍下3个项目\n\n哪个项目对个人成长最大？\n\n一个新的领域，如何去学习？\n\n你如何评价自己写的模块代码质量？\n\n还是需要在实际工作中才发现问题吗？\n\n项目中有需要更新的地方？\n\n项目之中发现的问题还是？\n\n是否做过相关的优化？\n\n如何确定先优化哪些？\n\n反问\n\n\n# 2022/9/16 优赛时代一面\n\n22min\n\n\n1\n\n\n自我介绍\n\npromise常用方法\n\nallsettled和all区别\n\n场景题，2个异步请求，同时发起，整理结果后，再渲染结果\n\n如何使用git做迭代，切分支\n\nmaster上线了，代码有问题 代码回滚？\n\nreact和vue谁用的多\n\nts了解吗\n\n如何看待ts，为啥现在还没有往ts走\n\n数组index或重复元素作为key，解释下原理？\n\n数组索引作为key，会造成什么问题？会渲染错误吗？\n\n无法渲染更新后的数据？为啥\n\n实际上，普通列表并未渲染错误？为啥？\n\n除了对比key，还可以对比key啥\n\n代码命名规范\n\n小/大驼峰啥时候用到\n\n\n# 2022/9/28 同程一面\n\n25min\n\n\n1\n\n\n自我介绍\n\n行内/块级元素\n\n哪些是行业/块级？\n\n分别的定义？\n\nlink标签是行内？块级？都不算？\n\nlink和@import区别\n\n浏览器存储\n\nlocalstorage容量上限了，但还是想存数据咋整？\n\n> 滚动存储\n> \n> 跨域存储\n\n原型和原型链\n\n跨域，项目中咋解决的\n\n性能优化需注意的点\n\n性能优化指标？\n\n减少http请求数量？对http2.0来说，这个优化有必要吗\n\nhttp缓存\n\n微信小程序和web区别\n\n反问\n\n\n# 2022/9/28 百奥一面\n\n50min\n\n\n1\n\n\n自我介绍\n\n最近学过什么新的技术？\n\n若不是秋招，推上一些在学什么\n\nbfc\n\n创建bfc\n\n垂直居中方案\n\n使用兼容性好的属性设置居中(display:inline-block)\n\n一个方块平移的动画，使用css还是js写？\n\n为啥觉得css性能好？(如果能够从浏览器进程原理去解释，我觉得会更好)\n\n使用js如何实现动画？\n\nsettimeout和setinterval区别\n\n除了这个两个api，还有什么js的api\n\nrequestanimationframe对比settimeout好处是？\n\n什么情况会重排，如何避免？\n\n从你的语言中，你可能对性能优化有了解，如果多的话，可以从网络层展开说说\n\ncdn分发原理\n\n避免cdn缓存我的节点资源，如何使用nginx的配置\n\n如果想让cdn缓存呢？会根据哪些哪些字段缓存\n\n什么资源用强缓存，什么资源用协商缓存\n\n了解过什么负载均衡算法\n\n解释下跨域，开发环境和线上环境\n\n开发环境配置的什么？\n\n原生端？(微信原生小程序没有跨域问题)\n\nget请求，后端会收到吗？\n\n什么情况会发送预检请求？\n\n什么时候浏览器会认为发送的请求是复杂请求？\n\n跨域时会携带cookie吗？(不会)\n\n如何在跨域时携带cookie？\n\nvdom的本质？\n\nmvvm的架构一定会比原生性能更好吗？\n\nreact的状态提升了解过吗\n\ndiff算法了解过吗\n\ndiff主要的算法思路？(后面时间赶，就没咋展开说了)\n\n如果使用index作为key，有什么后果？\n\n有什么途径可以验证页面性能如何？(f12 performance)\n\n是否有通过链表完成过什么东西？\n\n二分查找的时间复杂度？(log2n)\n\n知道是如何推算出来的吗？\n\nx===1&&x===2&&x==3？(valueof重写方法)\n\n关闭页面后继续发请求\n\ncommonjs和es6\n\n若没有模块化导出，如何实现作用域封闭？(闭包，自执行函数，let const)\n\n检测用户什么时候关闭页面？关闭页面后再发请求\n\n如果页面关闭后再发请求\n\n\n# 2022/9/29 同程二面\n\n17min\n\n\n1\n\n\n自我介绍\n\ncss优先级\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>title</title>\n    <style>\n\n        div.a{\n            color: red;\n        }\n        .b{\n            color: blue;\n        }\n    </style>\n</head>\n<body>\n<div class=\"a b\">s</div>\n<div class=\"b a\">v</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n最有挑战的事？自定义页面栈\n\n微信最大层级页面(10层)\n\n如果想要到11层，怎么办\n\nmvvm双向数据绑定实现原理\n\n最有成就感的事？\n\n反问\n\n\n# 2022/9/30 睿联一面\n\n40min\n\n\n1\n\n\n自我介绍\n\n数组内存不够了，但还是要继续push元素咋办？\n\n数组遍历方法\n\nfor-of可遍历哪些数据类型\n\nfor-of如何遍历对象\n\n哪些数据类型可迭代\n\njs的作用域分类\n\n如何理解这个\"块\"字？\n\nfor循环的settimeout输出，var和let定义变量区别\n\n它们算是闭包吗？\n\nsettimeout是异步吗？\n\nsettimeout设置的时间一定是1s后执行吗？\n\n开一个服务，如何在外部电脑访问？\n\n> 具体咋实现\n\n代码输出，答错了\n\ntry {\n    new promise(function (resolve) {\n        resolve(1);\n        console.log(2);\n    })\n        .then(function (v) {\n        console.log(v);\n        throw new error(3);\n    });\n} catch (e) {\n    console.log(e.message)\n} finally {\n    console.log(4)\n}\nconsole.log(5)\n/**\n2\n4\n5\n1\nuncaught (in promise) error: 3\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n输出2后，其他任务进入微任务队列，立即执行finally语句块，然后回头执行微任务，此时不能catch到错误，因为宏任务已经执行完了？\n\ntry {\n   await new promise(function (resolve) {\n        resolve(1);\n        console.log(2);\n    })\n        .then(function (v) {\n        console.log(v);\n        throw new error(3);\n    });\n} catch (e) {\n    console.log(e.message)\n} finally {\n    console.log(4)\n}\nconsole.log(5)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n实现promise.all()思路\n\npuppeter实现点击付款流程\n\nwaitfor实现思路\n\nawait后面可以跟settimeout吗\n\n前端领域很多，有想要发展的方向吗？\n\n反问\n\n\n# 2022/10/10 水滴一面\n\n35min\n\n\n1\n\n\n自我介绍\n\n讲下项目经历\n\n简单说下axios，为啥用axios，axios和fetch区别\n\nfetch能监听网络请求超时吗\n\njs单线程，针对异步事件如何处理\n\n事件循环的事件队列有优先级吗\n\n宏任务和微任务区别\n\n微任务和宏任务谁先执行\n\ndom渲染时啥时候？\n\n渲染后干啥？\n\n了解nodejs和浏览器的事件循环区别\n\n你表达的是整个事件循环都不一样，是吗\n\n有了解过跨域吗\n\ndocument.domain+iframe，两个页面域名完全不一样，如何解决跨域\n\njwt的概念简单说说\n\njwt和cookie方案区别\n\n使用vue多还是react对\n\nvue和react区别\n\n重新学习一个新的框架成本大吗\n\n现在流行的框架，react和vue的核心思想是啥\n\n反问\n\n\n# 2022/10/11 联友一面\n\n30min\n\n\n1\n\n\n自我介绍\n\n介绍项目，难点，负责部分\n\n用了什么微前端框架吗\n\n2个技术栈间的跳转如何保证用户体验？\n\nelementui的el-table，如何实现表格内容宽度自适应？\n\n改变table第二列第二行的input框内容？\n\nvue用的多吗？\n\nreact的hook和vue的hooks区别？\n\nes6新特性\n\nes6新特性 数组去重\n\n介绍react的diff原理\n\n更新时除了对比类型，还会对比啥？\n\n项目中你是用的什么做的key\n\nreact的高阶组件\n\nreact中哪几种方式获取dom\n\n反问\n\n\n# 2022/10/12 百奥二面\n\n50min\n\n\n1\n\n\n自我介绍\n\n了解过react和vue区别吗\n\n看过react源码吗\n\n介绍react的diff\n\n项目是从头搭建还是自己搭建\n\n熟悉webpack构建工具吗\n\nwebpack 和 rollup适用场景\n\nvite了解过吗\n\nnginx对资源做缓存的配置\n\n啥资源使用强缓存，啥资源使用协商缓存\n\n跨域除了反向代理，还有啥问题\n\n浏览器跨域的请求会在什么时候中断，会真的发送到服务端呢\n\npackage.json和package-lock.json区别\n\ndevdependencies和dependencies区别\n\nnpm build时会打包devdependencies下的依赖吗\n\n了解过npm有啥缺陷吗\n\n那为啥现在还是使用npm，有替代方案吗\n\n了解过pnpm吗\n\naxios可用在node环境吗？有了解过原理吗？\n\naxios如何区分浏览器还是node环境，库的开发者，判断环境的操作应该由开发者还是提供者判断\n\n单向链表和双向链表区别\n\n链表在前端的应用\n\n手撕 css画三角形，判断空对象的方法，反转链表\n\n项目过程中特别难的地方，如何解决的\n\n用canvas做过其他应用吗\n\n可视化框架是什么\n\n加入你选的话，倾向做后台还是小游戏 动效 3d 2d 酷炫的效果\n\n\n# 2022/10/13 睿联二面\n\n45min\n\n\n1\n\n\n自我介绍\n\n你理解的前端如何划分，技术这块的理解\n\n3个项目哪个觉得更有成就感一点\n\nxxx项目的背景\n\n系统功能上你怎样理解去划分的，你承担的角色\n\n测试 ，沟通 ，部署这方面时间占比和你自己开发占比如何区分\n\n核心的地方，是指什么，可以举个栗子吗\n\n在编码上的核心是指什么\n\n简历提到深入了解http跨域问题，你了解的解决跨域问题的方案主要有哪些\n\n场景题\n\n典型的自营电商的一个解决平台，这种情况你会选择哪种方式解决跨域(小米商城 、苹果等)\n\n为什么使用cors\n\n使用了jwt吗，jwt和token的差别\n\njwt有可能破解码\n\n可能从哪个层面去破解呢？比如https层面也不一定是绝对安全的\n\nhttps通信，如何能劫持到jwt\n\n浏览器网页是否能实现一个功能，去本地选择视频，浏览器播放\n\n本地选择图片，网页上显示，可行吗\n\n不跟服务端交付，纯本地实现图片在浏览器显示\n\n你如何理解宏任务微任务及其调度\n\n使用过puppeteer进行爬虫测试吗\n\n测试的效果怎么样\n\n除了这个还有什么方法实现自动化测试吗\n\n你总结的前端性能优化规范和方案有哪些\n\n把不太变化的本地存在本地localstorage，假设网站比较大 复杂，localstorage存满之后，可能是别人的项目造成的干扰，你去写入的时候可能失败，类似这种异常，如何处理比较好\n\n> 开始答的 换种方式存，存在另一个地方或者换个源\n\n站在个人开发这样说，若是站在团队开发如何处理，因为不可能每个人遇到都去处理一下，复杂度上去，团队角度的处理规范规避这样的事情发生\n\n但其实收拢不一定可能，因为有时候不能将所有情况具象化到一个具体的，不是具体的就不知道大小，不清楚是否超预算\n\n> 对域名进行划分？让专门的业务组规范使用划分的域名\n> \n> 没有规范答案\n\n反问\n\n\n# 2022/10/13 达达一面\n\n37min\n\n\n1\n\n\n自我介绍\n\n使用taro的原因是啥\n\n最早操纵dom是js原生，后面是jquery，再后面是react使用vdom操作，你觉得它的优势在哪\n\n体验是研发的体验还是用户的体验\n\n前端的数据类型\n\nnull和undefined区别\n\n你觉得typeof和instanceof的区别\n\n对原型链概念的理解\n\n代码输出\n\nfunction person(){\n\tthis.name ='dada'\n}\nconst people = new person()\nperson.prototype = {age: 18}\nconsole.log(people.name, people.age)\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果将 person.prototype = {age: 18} 换成 person.prototype.age=18 有啥区别\n\n你觉得它对实例的影响是啥？\n\n描述下对事件循环的理解\n\n代码输出\n\nsettimeout(()=>{console.log(1)}, 5000)\nsettimeout(()=>{console.log(2)}, 1000)\n\n\n1\n2\n\n\n为什么是这样的，按照刚才的理解，为什么先打印2再打印1？\n\n时间戳一到push进任务队列，你觉得这个事情是谁在做\n\n还记得浏览器由其他进程线程吗\n\ngui线程和js引擎线程为啥互斥\n\njs阻塞dom解析，css会阻塞dom构建吗？顶部的css是否会阻塞底部js代码执行吗\n\n按照你的说法，理解下这个过程\n\n反问\n\n\n# 2022/10/14 酷家乐一面\n\n1h22min\n\n\n1\n\n\n自我介绍\n\n线程和进程概念有了解吗\n\n说的抽象的概念，可以用浏览器举例说明吗\n\n浏览器的渲染过程，大概讲讲\n\n解析html代码时遇到scrip标签会怎样\n\n数组和链表区别\n\n数组和链表分别插入 或查询效率如何\n\n栈和队列区别\n\n对于二叉树有哪些遍历方式\n\n遍历对象属性有哪些方式\n\nfor-in和object.keys()区别\n\n说下对原型链的理解\n\n对于闭包的理解\n\n使用闭包可能造成什么问题\n\n还有其他什么操作会造成内存泄露\n\n了解过哪些es6新特性\n\nconst let和var区别\n\n箭头函数和普通函数区别\n\n除了localstorage，浏览器其他的一些存储方式\n\n大概讲下跨域问题如何理解\n\n简述下react和vue生命周期\n\nreact中setstate(1)两次，render触发几次\n\n如果state=1，再次setstate(1)，render是否会执行\n\n> 特定条件下，render会触发，只是页面不会变\n\ngit常见命令\n\n代码输出\n\nvar name = 'window';\n\nvar person = {\n    name: 'person',\n    sayname: function () {\n        console.log(this.name)\n    }\n}\n\nfunction sayname () {\n    var sss = person.sayname;\n\n    sss();\n\n    person.sayname();\n\n    (person.sayname)();\n\n    (b = person.sayname)();\n}\n\nsayname();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n实现比num大的最小的数字\n\n/*2.寻找比目标数字大的最小数字：\n\n输入：排序后的数组a，包含从小到大排序的数字；\n\n目标数字：num\n\n要求：从数组a中找出比num大的最小数字，若不存在则返回第一个数字；\n\n例如：\n\n输入数组a = [5,11,15,20,100]\n\n目标数字num = 13\n\n则返回15*/\nlet a = [5, 11, 15, 20, 100];\n\n\nfunction solve(arr, num) {\n    /*arr.sort((a, b) => a - b);\n    for (let i of arr) {\n        if (i > num) {\n            return i;\n        }\n    }\n    return arr[0];*/\n\n    arr.sort((a, b) => a - b);\n    let left = 0, right = arr.length - 1;\n    while (left < right) {\n        let mid = left + (math.floor((right - left) / 2));\n        if (arr[mid] > num) {\n            right = mid ;\n        } else {\n            left=mid+1;\n        }\n    }\n    return arr[left];\n}\n\nconsole.log(solve(a, 13))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n合并2个有序数组\n\n/*3.数组union\n合并两个有序数组a和b，要求合并后的数组c仍然保持有序。\n例如：\n\n数组a = 【2，3， 6， 7， 9】 b=【1，4， 5，8】\n\n结果数组c应为【1，2，3，4，5， 6， 7， 8，9】 */\nlet a = [2, 3, 6, 7, 9]\nlet b = [1, 4, 5, 8]\n\nfunction merge(ary1, ary2) {\n    let len1 = ary1.length - 1, len2 = ary2.length - 1;\n    let len = ary1.length + ary2.length - 1;\n    let bufs ;\n    while (len1>=0 || len2>=0) {\n        if (len1 === -1) {\n            bufs = ary2[len2--];\n        } else if (len2 === -1) {\n            bufs = ary1[len1--];\n        } else if (ary1[len1] > ary2[len2]) {\n            bufs = ary1[len1--];\n        } else {\n            bufs = ary2[len2--];\n        }\n        ary2[len--] = bufs;\n    }\n    return ary2;\n}\n\nconsole.log(merge(a, b))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n反问\n\n\n# 2022/10/14 酷家乐二面\n\n45min\n\n\n1\n\n\n自我介绍\n\n892. 三维形体的表面积\n\nfunction solve(grid) {\n    let size = grid.length;\n    let num = 0, area = 0;\n    for (let i = 0; i < size; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            let bufs = grid[i][j];\n            if (bufs > 0) {\n                num += bufs;\n                area += (bufs - 1) * 2;\n                area += i > 0 ? math.min(bufs, grid[i - 1][j]) * 2 : 0;\n                area += j > 0 ? math.min(bufs, grid[i ][j-1]) * 2: 0;\n            }\n        }\n    }\n    return num * 6 - area;\n}\nconsole.log(solve([[1, 2], [3, 4]]))\nconsole.log(solve([[1,1,1],[1,0,1],[1,1,1]])) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n反问\n\n\n# 2022/10/17 睿联hr面\n\n深圳\n20min\n\n\n1\n2\n\n\n自我介绍\n\n为啥选择睿联\n\n项目经历\n\n统筹前端小组困难的地方，或者自己不太擅长的地方\n\n团队合作的时候，最大的难点，或者比较头疼的事情\n\n为什么老师选择你作为组长\n\n平时喜欢看哪些书\n\n介绍一下《明朝那些事儿》看到哪里了，在分享哪些事情\n\n这本书谁写的(当年明月)\n\n目前手上有offer吗\n\n对手上的offer是否满意\n\n期望薪资\n\n哪里人\n\n想过考研吗\n\n班级考研同学多吗\n\n反问\n\n\n# 2022/10/17 百奥hr面\n\n广州\n28min\n\n\n1\n2\n\n\n什么时候决定走前端这条路\n\n成绩挺好的，是否有想过偏软件开发，比如后端这个方向发展\n\n挑一个项目介绍开发工作流程\n\n项目是0到1还是说在原有基础改进迭代的\n\n前端多少个人\n\n在学姐带领下负责项目哪块功能\n\n项目中0到上线做了多久\n\n你们的组长如何筛选的\n\n开始写代码后面带别人写代码，你觉得角色转换最大的区别是啥(花了哪些功夫去做了转换)\n\n教学平台是实习项目吗\n\n啥时候开始秋招\n\n感觉今年的行情怎么样\n\n成绩不错，有考研想法吗\n\n手上有一些offer在对比了吧\n\n对秋招这份工作会比较关注哪些点\n\n项目对接有遇到难沟通的人或事吗\n\n之前聊过工作氛围吗\n\n期望薪资\n\n对工作地点的想法\n\n秋招导出都会投吧\n\n反问\n\n以下皆为实习岗位\n\n\n1\n\n\n\n# 2022/11/8 先胜业财一面\n\n> 38min\n\n对h5的新特性\n\ncss3的新特性\n\nflex实现垂直居中\n\nflex实现两栏布局\n\nes6新特性\n\n项目中如何处理异步问题？\n\n> promise\n> \n> async/await\n\n使用方式差异和优缺点\n\npromise api用过哪些\n\nall()使用的场景\n\nasync/await错误处理\n\n> try catch 其实很简单\n\n若后端返回数据结构和预期不一致，咋整\n\n前端存储\n\n用的类组件开发吗\n\nhooks项目中用过吗\n\n为啥不使用hooks\n\n反问\n\n\n# 2022/11/10 先胜业财一面\n\n自我介绍\n\n怎样学习前端\n\n前端和后端区别\n\n有看书的习惯，红宝书看完了吗\n\n实习的时候，自己的角色，感受是啥，加班厉不厉害，有啥看法\n\n作为一个新人，在公司最重要的是什么\n\nreact的合成事件\n\nsetstate是同步或异步\n\nreact合成事件中实现setstate同步怎么办\n\n父组件更新子组件不更新\n\n反问\n\n\n# 2022/11/11 同程一面\n\n> 34min\n\n自我介绍\n\n提到了新的技术，简单描述学的新的东西\n\n> 低代码，微前端\n\n对低代码怎么看，如何理解\n\n做低代码会导致技术退步，你怎么看\n\n低代码在国内是不断探索的状态，2条路如何选，做低代码还是说选择低代码平台项目开发\n\n介绍教学平台项目，啥角色，做了啥功能\n\nreact跳转vue的jwt如何传递\n\ntoken比较长，url会有长度限制，咋整\n\n> 使用cookie，切换验证方案\n> \n> 结合前后端和网络系统想到的解决方案\n\n若cookie做验证，整个路径是啥，说一下想法\n\n> set-cookie做身份验证\n\ncookie同源限制，建议后端怎么做\n\n> cors去解决\n\n若token过期了，还用登录吗\n\n> token不能一直有效，定时去查看token\n> \n> 后端做了有效校验，前端如何做才知道token过期了\n> \n> 每次发送请求，后端会返回对应数据，401前端再做响应处理，重新登录\n\n刚说了，会关注社区\n\n使用react哪个版本，为啥不使用17、18\n\n了解过react17、18的新特性吗？\n\n讲下浏览器的垃圾回收机制\n\n对未来实习岗位的预期，平台？行业和业务线？\n\n反问\n\n\n# 2022/11/11 映宇宙一面\n\n> 1h25min\n\n实现垂直水平居中\n\n\n\n代码输出\n\nvar obj = {\n    name: 'baidu',\n    arr: ['a', 'b', 'c']\n}\n\nvar obj2 = obj\nvar arr = obj.arr\n\nobj2.arr = ['a', 'b', 'c', 'd']\nobj2.name = 'inke'\n\nconsole.log(arr)\nconsole.log(obj.name)\nconsole.log(obj === obj2)\nconsole.log(obj.arr === obj2.arr)\nconsole.log(obj.arr === arr) \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n实现清除浮动的几种方法\n\n代码输出\n\nvar map =  {\n    onclick: function () {\n\n    },\n    curry: function (val) {\n        return function (z) {\n            return val++ + z\n        }\n    }\n}\n\nvar getinfo = function (val) {\n    return map[val]\n}\nvar fn = getinfo('curry')\n\nvar a = fn(100)\n\nconsole.log(a(200))\nconsole.log(a(300))\nconsole.log(fn(100)(200))\nconsole.log(getinfo('curry')(100)(300))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n代码输出\n\nvar name = 'oop'\n\nvar person = function (options) {\n    this.name = options.name\n}\n\nperson.prototype.name = 'person'\nperson.prototype.getname = function () {\n    return this.name\n}\nperson.getname = function() {\n    return this.name;\n}\n\nvar p = new person({name: 'inke'})\n\nconsole.log(p.constructor ===  ?) // true\n\nconsole.log(p instanceof ?) // true\n\nconsole.log(p.__proto__ === ?) // true\n\nconsole.log(p.hasownproperty('name')) \nconsole.log(p.hasownproperty('getname')) \n\nvar getname = p.getname\n\nconsole.log(getname === person.getname) // ?\nconsole.log(getname()) // ?\n\nconsole.log(person.prototype.getname()) // ?\n\nconsole.log(p.getname())\n\nconsole.log(person.getname())\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n写出react常见生命周期方法\n\ncomponentwillmount()\ncomponentdidmount()\n\ncomponentwillunmount()\n\ncomponentwillreceiveprops()\nshouldcomponentupdate()\ncomponentwillupdate()\ncomponentdidupdate()\nrender()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n渲染顺序\n\n\n\n问觉得自己最牛逼的技能是啥？\n\n熟悉this算吗？\n\n那如何修改this指向呢？\n\n熟悉的常用算法\n\n能用js实现一个吗\n\n实现冒泡排序\n\nfunction bubblesort(arr) {\n    let size = arr.length;\n    for (let i = 0; i < size - 1; i++) {\n        for (let j = 0; j < size - 1 - i; j++) {\n            arr[j] > arr[j + 1] ? [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] : '';\n        }\n    }\n    return arr;\n}\n\nconsole.log(bubblesort([2, 4, 1, 22, 9, 22]))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n反问\n\n\n# 2022/11/11 同程二面\n\n> 30min\n\n自我介绍\n\n100万条数据找到出现次数top10的数\n\n分段分多少合适？\n\n考虑很多因素，遍历方式\n\n算法的时间复杂度是？o(n)\n\nmap的时间复杂度是？不清楚\n\n做了多久的前端\n\n圆角如何实现？css2情况如何实现border-radius？\n\n场景题，看页面有哪些功能？哪些功能的实现是难点？\n\n影视类的内容上传文件的组件，需要考虑哪些内容\n\n上传中途网络中断怎么办，可以怎么做到呢？可能需要哪些事情实现\n\n之前实习中收获最大的是啥\n\n反问",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Vue",frontmatter:{title:"Vue",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/7bb646/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/12.Vue.html",relativePath:"08.专栏/12.Vue.md",key:"v-6b0e2206",path:"/pages/7bb646/",headers:[{level:2,title:"基本原理",slug:"基本原理",normalizedTitle:"基本原理",charIndex:10},{level:2,title:"Reflect",slug:"reflect",normalizedTitle:"reflect",charIndex:343},{level:2,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:985},{level:2,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:1061},{level:2,title:"性能优化",slug:"性能优化",normalizedTitle:"性能优化",charIndex:1110},{level:3,title:"编码",slug:"编码",normalizedTitle:"编码",charIndex:1119},{level:2,title:"Computed",slug:"computed",normalizedTitle:"computed",charIndex:1521},{level:2,title:"Watch",slug:"watch",normalizedTitle:"watch",charIndex:1530},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1778},{level:2,title:"作用在表单元素",slug:"作用在表单元素",normalizedTitle:"作用在表单元素",charIndex:1915},{level:2,title:"作用在组件",slug:"作用在组件",normalizedTitle:"作用在组件",charIndex:2275},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:12}],headersStr:"基本原理 Reflect 优点 缺点 性能优化 编码 Computed Watch 总结 作用在表单元素 作用在组件 原理",content:'# Vue\n\n\n# 基本原理\n\n当一个Vue实例创建时，Vue会遍历 data 中的属性，用Object.defieProperty (Vue3.0使用proxy)将它们转换为getter/setter ，在内部追踪相关依赖，在属性被访问和修改时通知变化。在每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新\n\n\n\nconst obj = { a: 1 };\nconst p = new Proxy(obj, {\n  get(target, property, receiver) {\n    console.log("get");\n    return Reflect.get(target, property, receiver);\n  },\n  set(target, property, value, receiver) {\n    console.log("set");\n    return Reflect.set(target, property, receiver);\n  },\n  has(target, prop) {\n    console.log("has");\n    return Reflect.has(target, prop);\n  },\n  deleteProperty(target, prop) {\n    console.log("deleteProperty");\n    return Reflect.deleteProperty(target, prop);\n  },\n});\n\np.a; // 输出 --\x3e get\np.a = 2; // 输出 --\x3e set\n"a" in p; // 输出 --\x3e has\ndelete p.a; // 输出 --\x3e deleteProperty\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# Reflect\n\n与Proxy搭配使用，当劫持某些操作时，需要将这些操作反射回去，就使用Reflect\n\n想拥有拦截前的功能，需要使用Reflect反射回去\n\n\n# 优点\n\n * 轻量级 框架\n * 简单易学\n * 双向数据 绑定\n * 组件化\n * 视图 数据 结构 分离\n * VDOM\n * 运行速度快\n\n\n# 缺点\n\n * 生态不够完善\n\n构建大型应用——React居多\n\n中小型企业——Vue居多\n\n\n# 性能优化\n\n\n# 编码\n\n * 建少 data中数据\n * v-if和v-for不能连用\n * SPA页面使用keep-alive缓存组件\n * key 唯一\n * 路由懒加载 异步组件\n * 防抖 节流\n * 三方模块 按需导入\n * 图片懒加载\n * 长列表 滚动到可视化动态加载\n\n\n# 生命周期\n\nbeforeCreate\n\n创建前，实例初始化之后，data和methods中数据未初始化，常执行与vue数据无关的事，比如loading\n\ncreated\n\n实例创建完成，挂载未开始，完成data和methods的初始化，只是页面还未渲染，可发起请求，操作data或methods\n\nbeforeMount\n\nmounted\n\n实例被挂载后调用，完成vue实例初始化，且已挂载到页面，我们可以操作DOM节点\n\nbeforeUpdate\n\nupdated\n\nbeforeDestroy\n\ndestroyed\n\n\n# Computed、Watch\n\n\n# Computed\n\n * 支持缓存，只有依赖的数据变化，才会重新计算\n * 不支持异步\n * 默认走缓存，基于响应式依赖缓存，即 基于 data 声明过，或是 父组件 传递过来的props 中的数据进行计算\n * 属性有一个get 方法 和set方法 ，数据变化时调用set方法\n\n\n# Watch\n\n * 不支持 缓存，数据变化 就触发相应操作\n * 支持异步监听\n * 当属性变化时 就需要执行相应 操作\n * 监听数据必须是data中或是父组件传递的props\n\n\n# 总结\n\ncomputed计算属性，依赖其他属性值，并且computed有缓存，只有依赖的属性变化，下一次获取computed的值才会重新计算\n\nWatch侦听器，更多是 观察 的作用，没有缓存，类似某些数据的 监听回调，数据变化时 执行回调\n\n\n# v-model\n\n\n# 作用在表单元素\n\n动态绑定了 input 的value指向 message变量，在触发input事件时动态 将message设为目标值\n\n<input v-model="sth" />\n//  等同于\n<input \n    v-bind:value="message" \n    v-on:input="message=$event.target.value"\n>\n//$event 指代当前触发的事件对象;\n//$event.target 指代当前触发的事件对象的dom;\n//$event.target.value 就是当前dom的value值;\n//在@input方法中，value => sth;\n//在:value中,sth => value;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 作用在组件\n\n自定义组件中，v-model默认利用名为value的prop和名为input的事件\n\n本质是一个父子组件通信的语法糖，通过 props 和 $emit 实现\n\n<child :value="message"  @input="function(e){message = e}"></child>\n\n\n1\n\n\n\n# data为啥是函数\n\nJS的对象是引用类型数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会变化\n\nVue中需要复用组件，每个组件都有自己的数据，组件间 才不会相互干扰\n\n所以组件数据不能是对象的形式，而是 函数 的形式\n\n数据以函数返回值的形式定义，这样复用时，返回新的data，每个组件都有私有数据空间，各自维护自己的数据\n\n\n# Vue template到render\n\nvue模板编译过程：template->AST->render函数\n\n\n# data变化，会立即同步re-render吗？\n\n不会立即同步执行re-render，Vue实现响应式 是按一定的策略进行 DOM的更新\n\n只要侦听到数据变化，Vue将开启一个队列，并缓存 在同一事件循环中发生的 数据变更\n\n若同一个 watcher 触发多次，只会被push到队列一次，即 在缓存时去除重复数据，避免 不必要的计算和DOM 操作\n\n然后，在下一个事件循环tick中，Vue刷新队列并 执行工作\n\n\n# Vue-router 路由守卫\n\n * 全局前置/钩子：beforeEach、beforeResolve、afterEach\n * 路由独享的守卫：beforeEnter\n * 组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave\n\n\n# Vuex\n\n\n# 原理\n\nVuex是一个专为Vue开发的状态管理模式，每个Vuex应用核心是store，store包含应用中大部分状态——state\n\n * Vuex状态存储是响应式的，当Vuex组件从store读取状态时，若store中状态变化，相应组件会相应更新\n * 改变store中的状态唯一途径是 显式 提交(commit)mutation，便于跟踪状态变化\n\n\n\n\n# Vue模块化开发思路\n\n\n# v-show、v-if\n\nv-if\n\n * 真正 的条件渲染，确保在切换过程中 分支内的事件监听器和子组件适当被销毁和重建\n * 动态向DOM树添加/删除 DOM元素\n * 惰性，若初始条件为假 啥也不做；在条件第一次变为真时 才开始局部编译\n * 更高的切换消耗\n\nv-show\n\n * 不管初始条件是啥，总被 渲染，仅基于CSS切换\n * 设置DOM的display\n * 任何条件都被编译，缓存\n * 更高的初识渲染消耗\n\n总结\n\n * 若非常频繁切换，使用v-show；若运行时条件很少改变，使用v-if\n * 都用来控制元素渲染。v-if判断是否加载 减轻服务器压力，有更高切换开销；display调整display 是客户端操作更流畅，但更高的初始渲染开销',normalizedContent:'# vue\n\n\n# 基本原理\n\n当一个vue实例创建时，vue会遍历 data 中的属性，用object.defieproperty (vue3.0使用proxy)将它们转换为getter/setter ，在内部追踪相关依赖，在属性被访问和修改时通知变化。在每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新\n\n\n\nconst obj = { a: 1 };\nconst p = new proxy(obj, {\n  get(target, property, receiver) {\n    console.log("get");\n    return reflect.get(target, property, receiver);\n  },\n  set(target, property, value, receiver) {\n    console.log("set");\n    return reflect.set(target, property, receiver);\n  },\n  has(target, prop) {\n    console.log("has");\n    return reflect.has(target, prop);\n  },\n  deleteproperty(target, prop) {\n    console.log("deleteproperty");\n    return reflect.deleteproperty(target, prop);\n  },\n});\n\np.a; // 输出 --\x3e get\np.a = 2; // 输出 --\x3e set\n"a" in p; // 输出 --\x3e has\ndelete p.a; // 输出 --\x3e deleteproperty\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# reflect\n\n与proxy搭配使用，当劫持某些操作时，需要将这些操作反射回去，就使用reflect\n\n想拥有拦截前的功能，需要使用reflect反射回去\n\n\n# 优点\n\n * 轻量级 框架\n * 简单易学\n * 双向数据 绑定\n * 组件化\n * 视图 数据 结构 分离\n * vdom\n * 运行速度快\n\n\n# 缺点\n\n * 生态不够完善\n\n构建大型应用——react居多\n\n中小型企业——vue居多\n\n\n# 性能优化\n\n\n# 编码\n\n * 建少 data中数据\n * v-if和v-for不能连用\n * spa页面使用keep-alive缓存组件\n * key 唯一\n * 路由懒加载 异步组件\n * 防抖 节流\n * 三方模块 按需导入\n * 图片懒加载\n * 长列表 滚动到可视化动态加载\n\n\n# 生命周期\n\nbeforecreate\n\n创建前，实例初始化之后，data和methods中数据未初始化，常执行与vue数据无关的事，比如loading\n\ncreated\n\n实例创建完成，挂载未开始，完成data和methods的初始化，只是页面还未渲染，可发起请求，操作data或methods\n\nbeforemount\n\nmounted\n\n实例被挂载后调用，完成vue实例初始化，且已挂载到页面，我们可以操作dom节点\n\nbeforeupdate\n\nupdated\n\nbeforedestroy\n\ndestroyed\n\n\n# computed、watch\n\n\n# computed\n\n * 支持缓存，只有依赖的数据变化，才会重新计算\n * 不支持异步\n * 默认走缓存，基于响应式依赖缓存，即 基于 data 声明过，或是 父组件 传递过来的props 中的数据进行计算\n * 属性有一个get 方法 和set方法 ，数据变化时调用set方法\n\n\n# watch\n\n * 不支持 缓存，数据变化 就触发相应操作\n * 支持异步监听\n * 当属性变化时 就需要执行相应 操作\n * 监听数据必须是data中或是父组件传递的props\n\n\n# 总结\n\ncomputed计算属性，依赖其他属性值，并且computed有缓存，只有依赖的属性变化，下一次获取computed的值才会重新计算\n\nwatch侦听器，更多是 观察 的作用，没有缓存，类似某些数据的 监听回调，数据变化时 执行回调\n\n\n# v-model\n\n\n# 作用在表单元素\n\n动态绑定了 input 的value指向 message变量，在触发input事件时动态 将message设为目标值\n\n<input v-model="sth" />\n//  等同于\n<input \n    v-bind:value="message" \n    v-on:input="message=$event.target.value"\n>\n//$event 指代当前触发的事件对象;\n//$event.target 指代当前触发的事件对象的dom;\n//$event.target.value 就是当前dom的value值;\n//在@input方法中，value => sth;\n//在:value中,sth => value;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 作用在组件\n\n自定义组件中，v-model默认利用名为value的prop和名为input的事件\n\n本质是一个父子组件通信的语法糖，通过 props 和 $emit 实现\n\n<child :value="message"  @input="function(e){message = e}"></child>\n\n\n1\n\n\n\n# data为啥是函数\n\njs的对象是引用类型数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会变化\n\nvue中需要复用组件，每个组件都有自己的数据，组件间 才不会相互干扰\n\n所以组件数据不能是对象的形式，而是 函数 的形式\n\n数据以函数返回值的形式定义，这样复用时，返回新的data，每个组件都有私有数据空间，各自维护自己的数据\n\n\n# vue template到render\n\nvue模板编译过程：template->ast->render函数\n\n\n# data变化，会立即同步re-render吗？\n\n不会立即同步执行re-render，vue实现响应式 是按一定的策略进行 dom的更新\n\n只要侦听到数据变化，vue将开启一个队列，并缓存 在同一事件循环中发生的 数据变更\n\n若同一个 watcher 触发多次，只会被push到队列一次，即 在缓存时去除重复数据，避免 不必要的计算和dom 操作\n\n然后，在下一个事件循环tick中，vue刷新队列并 执行工作\n\n\n# vue-router 路由守卫\n\n * 全局前置/钩子：beforeeach、beforeresolve、aftereach\n * 路由独享的守卫：beforeenter\n * 组件内的守卫：beforerouteenter、beforerouteupdate、beforerouteleave\n\n\n# vuex\n\n\n# 原理\n\nvuex是一个专为vue开发的状态管理模式，每个vuex应用核心是store，store包含应用中大部分状态——state\n\n * vuex状态存储是响应式的，当vuex组件从store读取状态时，若store中状态变化，相应组件会相应更新\n * 改变store中的状态唯一途径是 显式 提交(commit)mutation，便于跟踪状态变化\n\n\n\n\n# vue模块化开发思路\n\n\n# v-show、v-if\n\nv-if\n\n * 真正 的条件渲染，确保在切换过程中 分支内的事件监听器和子组件适当被销毁和重建\n * 动态向dom树添加/删除 dom元素\n * 惰性，若初始条件为假 啥也不做；在条件第一次变为真时 才开始局部编译\n * 更高的切换消耗\n\nv-show\n\n * 不管初始条件是啥，总被 渲染，仅基于css切换\n * 设置dom的display\n * 任何条件都被编译，缓存\n * 更高的初识渲染消耗\n\n总结\n\n * 若非常频繁切换，使用v-show；若运行时条件很少改变，使用v-if\n * 都用来控制元素渲染。v-if判断是否加载 减轻服务器压力，有更高切换开销；display调整display 是客户端操作更流畅，但更高的初始渲染开销',charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"场景题",frontmatter:{title:"场景题",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/98b72d/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/13.%E5%9C%BA%E6%99%AF%E9%A2%98.html",relativePath:"08.专栏/13.场景题.md",key:"v-e45e5412",path:"/pages/98b72d/",headers:[{level:2,title:"离开页面可靠发请求",slug:"离开页面可靠发请求",normalizedTitle:"离开页面可靠发请求",charIndex:4736},{level:2,title:"callback",slug:"callback",normalizedTitle:"callback",charIndex:4060},{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:14203},{level:2,title:"async/await",slug:"async-await",normalizedTitle:"async/await",charIndex:14809},{level:2,title:"编辑器组件API，滚动加载？",slug:"编辑器组件api-滚动加载",normalizedTitle:"编辑器组件api，滚动加载？",charIndex:19997},{level:2,title:"Modal组件封装？",slug:"modal组件封装",normalizedTitle:"modal组件封装？",charIndex:20917},{level:2,title:"🙋 div宽高比例变化",slug:"div宽高比例变化",normalizedTitle:"🙋 div宽高比例变化",charIndex:27796},{level:2,title:"0.5px的线",slug:"_0-5px的线",normalizedTitle:"0.5px的线",charIndex:30280},{level:2,title:"🙋 12px以下文字",slug:"_12px以下文字",normalizedTitle:"🙋 12px以下文字",charIndex:30502},{level:2,title:"1px效果",slug:"_1px效果",normalizedTitle:"1px效果",charIndex:31301},{level:2,title:"🚩 三角形?",slug:"三角形",normalizedTitle:"🚩 三角形?",charIndex:33493},{level:2,title:"画圆形",slug:"画圆形",normalizedTitle:"画圆形",charIndex:33887},{level:2,title:"画同心圆(类似麻将的五饼)",slug:"画同心圆-类似麻将的五饼",normalizedTitle:"画同心圆(类似麻将的五饼)",charIndex:34059},{level:2,title:"CSS实现 偶数 子元素高亮， 排除第二个偶数",slug:"css实现-偶数-子元素高亮-排除第二个偶数",normalizedTitle:"css实现 偶数 子元素高亮， 排除第二个偶数",charIndex:34077},{level:2,title:"不整页刷新、前进、后退",slug:"不整页刷新、前进、后退",normalizedTitle:"不整页刷新、前进、后退",charIndex:34116},{level:2,title:"数组乱序输出",slug:"数组乱序输出",normalizedTitle:"数组乱序输出",charIndex:34441},{level:2,title:"圆形环状进度条",slug:"圆形环状进度条",normalizedTitle:"圆形环状进度条",charIndex:34721},{level:2,title:"蚂蚁面试",slug:"蚂蚁面试",normalizedTitle:"蚂蚁面试",charIndex:23969}],headersStr:"离开页面可靠发请求 callback Promise async/await 编辑器组件API，滚动加载？ Modal组件封装？ 🙋 div宽高比例变化 0.5px的线 🙋 12px以下文字 1px效果 🚩 三角形? 画圆形 画同心圆(类似麻将的五饼) CSS实现 偶数 子元素高亮， 排除第二个偶数 不整页刷新、前进、后退 数组乱序输出 圆形环状进度条 蚂蚁面试",content:"# 🔥 解析URL参数\n\n\nlet url = 'https://campus.meituan.com/index?key=value&key2=value2';\n\nfunction abstractPara(url) {\n    const obj = {};\n    url.slice(url.indexOf('?') + 1).split('&').forEach(item => {\n        const [key, value] = item.split('=');\n        obj[key] = value;\n    })\n    return obj;\n}\n\nconsole.log(abstractPara(url));\n\n\n//升级版\nfunction regParseParam(url) {\n    const paramsStr = /.+\\?(.+)$/.exec(url)[1];\n    const paramArr = paramsStr.split('&');\n    let paramObj = {};\n    paramArr.forEach(param => {\n        if (/=/.test(param)) {\n            let [key, val] = param.split('=');\n            val = decodeURIComponent(val);\n            val = /^\\d+$/.test(val) ? parseFloat(val) : val;\n            if (paramObj.hasOwnProperty(key)) {\n                paramObj[key] = [].concat(paramObj[key], val);\n            } else {\n                paramObj[key] = val;\n            }\n        } else {\n            paramObj[key] = true;\n        }\n    })\n    return paramObj;\n}\n\nconsole.log(regParseParam(url));\n\n\n//reduce实现\nfunction reduceUrl(url) {\n    let newUrl = '';\n    let index = url.indexOf('#')\n    if (index !== -1) {\n        newUrl = url.slice(0, index)\n    } else {\n        newUrl = url;\n    }\n    let ans= newUrl.slice(newUrl.indexOf('?') + 1).split('&').reduce((pre, cur, index, arr) => {\n        const [key, value=''] = cur.split('=');\n        pre[key] = value||'';\n        return pre;\n    }, {});\n    return JSON.stringify(ans)\n}\n\nconsole.log(reduceUrl(url));\n\n\n//解析URL Params为对象\nfunction parseParam(url) {\n    const paramsStr = /.+\\?(.+)$/.exec(url)[1];\n    const paramsArr = paramsStr.split('&');\n    let paramsObj = {};\n    paramsArr.forEach(param => {\n        if (/=/.test(param)) { \n            let [key, val] = param.split('=');\n            val = decodeURIComponent(val); \n            val = /^\\d+$/.test(val) ? parseFloat(val) : val;\n            if (paramsObj.hasOwnProperty(key)) {\n                paramsObj[key] = [].concat(paramsObj[key], val);\n            } else {\n                paramsObj[key] = val;\n            }\n        } else {\n            paramsObj[param] = true;\n        }\n    })\n    return paramsObj;\n}\n\nlet url1 = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';\nconsole.log(parseParam(url1))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# 🙋 a == 1 && a == 2\n\n考察 非严格相等\n\n==比较时 ，把对象a转为字符串再比较，a.toString()\n\n重构私有方法toString()，使其在不调用对象原型toString()\n\nvar a = {\n  n: 0,\n  //私有属性方法\n  toString: function() {\n    return ++this.n\n  }\n}\n//此时的a.toString()调用的不再是Object.prototype.toString(),而是自己私有的属性方法toString();\nif(a == 1 && a == 2 && a ==3) {\n  console.log(\"OK\")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n重构对象私有方法toString()\n\nvar a = [1,2,3];\na.toString = a.shift;\n//此时的a.toString()调用的不再是Object.prototype.toString(),而是自己私有的属性方法toString();\nif(a == 1 && a == 2 && a ==3) {\n  console.log(\"OK\")\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n利用Object.defineProperty()\n\nObject.defineProperty(window,'a',{\n  get:function() {\n    //this指向window.a\n    this.value ? this.value++ : this.value = 1;\n    return this.value;\n  }\n})\nif(a == 1 && a == 2 && a ==3) {\n  console.log(\"OK\")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nvar a = {\n  value: 0,\n  valueOf: function() {\n    this.value++;\n    return this.value;\n  }\n};\nconsole.log(a == 1 && a == 2);//true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# a===1 && a===2\n\nvar value = 0; //window.value\nObject.defineProperty(window, 'a', {\n    get: function() {\n        return this.value += 1;\n    }\n});\n\nconsole.log(a===1 && a===2 && a===3) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 发布订阅模式\n\nclass EventEmitter {\n    constructor() {\n        this.cache = {}\n    }\n    on(name, fn) {\n        if (this.cache[name]) {\n            this.cache[name].push(fn)\n        } else {\n            this.cache[name] = [fn]\n        }\n    }\n    off(name, fn) {\n        let tasks = this.cache[name]\n        if (tasks) {\n            const index = tasks.findIndex(f => f === fn || f.callback === fn)\n            if (index >= 0) {\n                tasks.splice(index, 1)\n            }\n        }\n    }\n    emit(name, once = false, ...args) {\n        if (this.cache[name]) {\n            // 创建副本，如果回调函数内继续注册相同事件，会造成死循环\n            let tasks = this.cache[name].slice()\n            for (let fn of tasks) {\n                fn(...args)\n            }\n            if (once) {\n                delete this.cache[name]\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 关闭页面后发请求\n\nnavigator.sendBeacon()\n\n用于满足统计和诊断代码的需要，尝试在卸载（unload）前发请求\n\n当用户代理成功把数据加入传输队列，sendBeacon() 返回 true，否则返回 false\n\n\n# 离开页面可靠发请求\n\n默认，XHR请求异步且非阻塞\n\n有被遗弃的风险，无法保证任何幕后工作都能完成\n\n浏览器设计假设当一个页面被关闭时，没有必要继续处理它排队的任何后台进程\n\n1、延迟用户操作，但是会阻塞主线程，导致性能问题\n\n2、指示浏览器保留未完成的请求，使用fetch的keepalive标志，将相应的请求保持打开状态，即使该请求页面已终止\n\n\n# 大数相加\n\nfunction solve(s, t) {\n  let len = Math.max(s.length, t.length);\n  const ss = s.padStart(len, \"0\").split(\"\");\n  const tt = t.padStart(len, \"0\").split(\"\");\n  let flag = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    let sum = +ss[i] + +tt[i] + flag;\n    ss[i] = sum % 10;\n    flag = sum > 9 ? 1 : 0;\n  }\n  if (flag === 1) {\n    ss.unshift(1);\n  }\n  return ss.join(\"\");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# input和object双向绑定？\n\n  var Person = {}\n  var name = null\n  Object.defineProperty(Person, 'name', {\n    get: function () {\n      return name\n    },\n    set: function (newV) {\n      name = newV\n    }\n  })\n  \n  let p = document.getElementById('ppp')\n  let ipt = document.getElementById('ipt')\n  ipt.addEventListener('input', function (e) {\n    Person.name = e.target.value\n    p.innerText = Person.name\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 🌈 对象拍平\n\nconst entry = {\n    a: {\n        b: {\n            c: {\n                dd: 'abcdd'\n            }\n        },\n        d: [1]\n    },\n    e: 'ae',\n    b: [1, 2, {c: true}],\n};\n//转换为如下对象\nconst output = {\n    'a.b.c.dd': 'abcdd',\n    'a.d': [1],\n    e: 'ae'\n};\n\n//method 1\n//遍历对象，传入对象的key值和value，再对value进行递归遍历\nfunction flatObj(target) {\n    let res = {};\n    const process = (key, value) => {\n        //    先判断数据类型\n        if (Object(value) !== value) {\n            if (key) {\n                res[key] = value;\n            }\n        } else if (Array.isArray(value)) {\n            for (let i = 0; i < value.length; i++) {\n                process(`${key}[${i}]`, value[i]);\n            }\n            if (value.length === 0) {\n                res[key] = [];\n            }\n        } else {\n            let objArr = Object.keys(value);\n            objArr.forEach(item => {\n                process(key ? `${key}.${item}` : `${item}`, value[item]);\n            });\n            if (objArr.length === 0 && key) {\n                res[key] = {};\n            }\n        }\n    }\n    process('', target);\n    return res;\n}\n\nlet ans = flatObj(entry);\n// console.log(ans);\n\n//method 2\nfunction objectFlat(obj = ''){\n    const res = {};\n    function flat(item , preKey = ''){\n        Object.entries(item).forEach(([key,value]) => {\n            let newKey = key;\n            // console.log(value,typeof value,Array.isArray(value))\n            if (Array.isArray(item)){\n                // console.log('是数组')\n                newKey = preKey ? `${preKey}[${key}]` : key;\n            }else{\n                newKey = preKey ? `${preKey}.${key}` : key;\n            }\n            if (value && typeof value === 'object'){\n                flat(value , newKey);\n            }else{\n                res[newKey] = value;\n            }\n        })\n    }\n    flat(obj);\n    return res;\n}\nans=objectFlat(entry);\nconsole.log(ans)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\nfunction fLatten(data) {\n    var result = {};\n\n    function recurse(cur, prop) {\n//如果输入进来的是不是对象，就将其放在数组中，返回\n        if (Object(cur) !== cur) {\n            result[prop] = cur;\n//如果输入进来的是数组，长度不为0就递归数组，得出结果\n        } else {\n            var isEmpty = true;\n            for (var p in cur) {\n                isEmpty = false;\n                recurse(cur[p], prop ? prop + \".\" + p : p);\n            }\n            if (isEmpty && prop)\n                result[prop] = {};\n        }\n    }\n\n    recurse(data, \"\");\n    return result;\n};\nlet obj = {\n    a: 1,\n    b: {\n        c: 2,\n        d: {\n            e: 2\n        }\n    }\n}\nconsole.log(fLatten(obj))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 括号匹配\n\nfunction matchBracket(str) {\n    const length = str.length;\n    if (length === 0) return true\n    const stack = []\n    const leftSymbols = '{[('\n    const rightSymbols = ' }]) '\n    const match = {\n        \"}\": \"{\",\n        \")\": \"(\",\n        \"]\": \"[\",\n    }\n    for (let i = 0; i < length; i++) {\n        const s = str[i]\n        if (leftSymbols.includes(s)) {\n//左括号，压栈\n            stack.push(s)\n        } else if (rightSymbols.includes(s)) {\n//右括号，判断栈顶(是否出栈)\n            const top = stack[stack.length - 1]\n// @ts- ignore\n            if (match[s] === top) {\n                stack.pop()\n            } else {\n                return false\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\nconsole.log(matchBracket('(1+2))*3'))\nconsole.log(matchBracket('(1+2)*3'))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 文件扩展名\n\nfunction getFileExtension(fileName){\n    return fileName.slice((fileName.lastIndexOf(\".\")-1)+2);\n}\n\n\n1\n2\n3\n\n\n\n# 🔥 数组转树\n\nlet arrData = [\n    {\n        id: 1, val: '学校', parentId: 0, department: ['部门1', '部门2']\n    }, {\n        id: 2, val: '班级1', parentId: 1\n    }, {\n        id: 3, val: '班级2', parentId: 1\n    }, {\n        id: 4, val: '学生1', parentId: 2\n    }, {\n        id: 5, val: '学生2', parentId: 2\n    }, {\n        id: 6, val: '学生3', parentId: 3\n    },\n];\n\n// 创建parentId的子节点，没有创建根节点的其他信息，只是创建了根节点的子节点数组，所以返回数组\nfunction arrayToTree(data, parentId) {\n    let result = [];\n    for (let i = 0; i < data.length; i++) { // 创建子节点列表\n        if (data[i].parentId === parentId) {\n            let obj = {};\n            deepClone(data[i], obj); // 深拷贝，创建子节点\n            let children = this.arrayToTree(data, data[i].id) || []; // 递归创建子节点的子节点\n            if (children.length > 0) {\n                obj.children = children;\n            }\n            result.push(obj);\n        }\n    }\n    return result;\n}\nfunction deepClone(obj, newObj) {\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === 'object' ?\n                deepClone(obj[key], newObj[key]) :\n                obj[key];\n        }\n    }\n}\n\nconsole.log(arrayToTree(arrData, 1));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n实现\n\n// 转换前：\nlet source = [{\n    id: 1,\n    pid: 0,\n    name: 'body'\n}, {\n    id: 2,\n    pid: 1,\n    name: 'title'\n}, {\n    id: 3,\n    pid: 2,\n    name: 'div'\n}];\n\nfunction jsonToTree(data) {\n    let ans = [];\n    if (!Array.isArray(data)) {\n        return ans;\n    }\n    //使用map，将当前对象id和当前对象对应存储\n    let map = {};\n    data.forEach(item => {\n        map[item.id] = item;\n    });\n    data.forEach(item => {\n        let par = map[item.pid];\n        if (par) {\n            (par.children || (par.children = [])).push(item);\n        } else {\n            ans.push(item);\n        }\n    });\n    return ans;\n}\n\nconsole.log(jsonToTree(source))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 🌈 数组对象找id\n\nvar result = [];\nfunction find(arr, id) {\n    if (arr == null) return null;\n    for (let obj of arr) {\n        if (obj.id === id) {\n            result = [...result, collect(obj)];\n        }\n        find(obj.children, id);\n    }\n}\nfunction collect(obj) {\n    let ret = obj;\n    if (obj.children) {\n        for (let o of obj.children) {\n            ret = [...ret, ...collect(o)]\n        }\n    }\n    return ret;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nlet tree = [\n    {\n        id: '1',\n        name: '节点1',\n        children: [\n            {\n                id: '1-1',\n                name: '节点1-1',\n                children: [\n                    {\n                        id: '1-1-1',\n                        name: '节点1-1-1'\n                    }\n                ]\n            },\n            {\n                id: '1-2',\n                name: '节点1-2'\n            }\n        ]\n    },\n    {\n        id: '2',\n        name: '节点2',\n        children: [\n            {\n                id: '2-1',\n                name: '节点2-1'\n            }\n        ]\n    }\n];\nfunction findNode(tree, func) {\n    let node, curTree = [...tree]\n    for (let i = 0; i < curTree.length; i++) {\n        if (func(curTree[i])) {\n            return curTree[i]\n        }\n        if (curTree[i].children) {\n            curTree.splice(i + 1, 0, ...curTree[i].children)\n        }\n    }\n}\nconst data = findNode(tree, (node) => {\n    return node.name === '节点1-1-1'\n})\nconsole.log( data)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 循环打印红黄绿\n\n> 红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；让三个灯不断交替重复亮灯？\n\nfunction red() {\n    console.log('red');\n}\nfunction green() {\n    console.log('green');\n}\nfunction yellow() {\n    console.log('yellow');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# callback\n\nconst task = (timer, light, callback) => {\n    setTimeout(() => {\n        if (light === 'red') {\n            red()\n        }\n        else if (light === 'green') {\n            green()\n        }\n        else if (light === 'yellow') {\n            yellow()\n        }\n        callback()\n    }, timer)\n}\ntask(3000, 'red', () => {\n    task(2000, 'green', () => {\n        task(1000, 'yellow', Function.prototype)\n    })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n问题：只完成了一次 流程，如何交替重复 执行？\n\n使用 递归\n\nconst step=()=>{\n    task(3000,'red',()=>{\n        task(2000,'green',()=>{\n            task(1000,'yellow',step);\n        })\n    })\n}\nstep();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Promise\n\nconst task = (timer, light) => \n    new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (light === 'red') {\n                red()\n            }\n            else if (light === 'green') {\n                green()\n            }\n            else if (light === 'yellow') {\n                yellow()\n            }\n            resolve()\n        }, timer)\n    })\nconst step = () => {\n    task(3000, 'red')\n        .then(() => task(2000, 'green'))\n        .then(() => task(2100, 'yellow'))\n        .then(step)\n}\nstep()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# async/await\n\nconst taskRunner=async()=>{\n    await task(3000,'red');\n    await task(2000,'green');\n    await task(1000,'yellow');\n    taskRunner();\n}\ntaskRunner();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 隔一秒打印 1 2 3 4\n\n// 闭包实现\nfor(var i=0;i<5;i++){\n    (function (i){\n        setTimeout(function(){\n            console.log(i);\n        },i*1000);\n    })(i);\n}\n\n//使用 let块级作用域\nfor(let i=0;i<5;i++){\n    setTimeout(function(){\n        console.log(i);\n    },i*1000);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 对象 循环引用\n\nconst isCycleObject = (obj,parent) => {\n    const parentArr = parent || [obj];\n    for(let i in obj) {\n        if(typeof obj[i] === 'object') {\n            let flag = false;\n            parentArr.forEach((pObj) => {\n                if(pObj === obj[i]){\n                    flag = true;\n                }\n            })\n            if(flag) return true;\n            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);\n            if(flag) return true;\n        }\n    }\n    return false;\n}\n\n\nconst a = 1;\nconst b = {a};\nconst c = {b};\nconst o = {d:{a:3},c}\no.c.b.aa = a;\n\nconsole.log(isCycleObject(o))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 🌰 0.1+0.2 === 0.3?\n\n0.1 + 0.2 = 0.30000000000000004 //15个0\n\n\n1\n\n\n一个数出现无限循环，再大的内存计算机也存不下，所以只能存储一个近似值，再取出就会出现精度丢失\n\n在JS中，主流的数值类型是Number，Number采用的是IEEE754规范中64位双精度浮点数编码\n\n优点是可以归一化处理整数和小数，节省存储空间\n\n对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，且小数点的位置不固定。解决思路就是使用科学计数法，这样小数点位置就固定了\n\n10进制科学计数法表达式，底数为10，n为整数\n\n\n\n如0.1就可以表示——0.1=1*(10的-1次方)\n\n在IEEE 754标准中类似，计算机只能用二进制（0或1）表示，底数为2，二进制转换为科学记数法的公式如下：\n\n0.1的二进制表示为：\n\n\n\n其中，a为0或者1，e为小数点移动的位置\n\n十进制小数转二进制？\n\n十进制小数转二进制，具体做法是：用2乘十进制小数，得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止\n\n把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。（乘2取整，顺序排列）\n\n举个例子：\n\n27.0转化成二进制为11011.0\n\n先把0.5转换为二进制小数\n0.5*2=1.0 //积中小数部分为0\n\n(27) 10=(11011) 2\n(0.5) 10=(1.0) 2\n合并整数和小数部分可得\n(27.5) 10=(11011.1) 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n0.1转为二进制？\n\n0.1 * 2 = 0.2 --------------- 取整数 0，小数 0.2\n0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4\n0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8\n0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6\n0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2\n0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4\n0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8\n0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6\n0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n最后 0.1的二进制可以表示为0.000110011……(0011无限循环)，因此二进制无法精确保存类似0.1这样的小数\n\nJS存储方式是IEEE 754 标准浮点数表示常用的 双精度浮点数 表示法，其长度为8个字节，即64位比特\n\n64位比特又可分为三个部分：\n\n * 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数\n * 指数位E：阶码，中间的 11 位存储指数（exponent），表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023\n * 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零。(能够真正决定数字精度)\n\n\n\n27.0的二进制11011.1转换为科学记数法\n\n\n\n符号位为0(正数)，指数位为4+，1023+4，即1027\n\n因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够52位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\n所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示\n\n> 0+100 0000 0011+1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\n0.1的二进制科学计数法表示\n\n\n\n所以0.1存储为计算机的二进制形式为\n\n符号位为0，指数位为 -4 ，1023+(-4)=1019，二进制位 1111 1110 11，E为11位，最终为 011 1111 1011\n\nIEEE754中，循环尾可不能再无限循环，双精度 64 位最多存储的有效整数为 52 位，采用 **就近舍入模式(进1舍0)**存储\n\n> 0+011 1111 1011+1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010\n\n同理，0.2的二进制形式为\n\n> 0+011 1111 1100+1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010\n\n浮点数求和步骤\n\n 1. 对阶\n 2. 求和\n 3. 规格化\n\n> 对阶\n\n判断指数位是否相同，即小数位是否对其，若指数位不同，需要对阶保证指数相同\n\n对阶时遵守小阶向大阶看齐原则，*尾数向右移位，每移动一位，指数位加 1 直到指数位相同，即完成对阶。\n\n本示例，0.1 的阶码为 -4 小于 0.2 的阶码 -3，故对 0.1 做移码操作\n\n// 0.1 移动之前\n0 + 011 1111 1011+ 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 \n\n// 0.1 右移 1 位之后尾数最高位空出一位，（0 舍 1 入，此处舍去末尾 0）\n0 + 011 1111 1100 +1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 101(0) \n\n// 0.1 右移 1 位完成\n0 +011 1111 1100 +1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n尾数求和\n\n// 0.1 和 0.2 都转化成二进制后再进行运算\n0+011 1111 1100+1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 // 0.1 \n(+) 0+011 1111 1100+1001  1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 // 0.2\n= 0+011 1111 1100+10 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111 // 产生进位，待处理\n\n\n\n1\n2\n3\n4\n5\n\n\n规格化和舍入\n\n由于产生进位，阶码需要+1，原阶码为011 1111 1100，+1后得到1000 10，转换为十进制，即1021，此时阶码为1021-1023= -2，此时符号位，指数位分别为0 + 011 1111 1101\n\n尾部进位2位，去除最高位默认的1，因为最低位为1需要进行舍入操作，即在最低有效位上+1，若为0则直接舍去，若为1继续+1\n\n  10 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111 // + 1\n=  0 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 1000 // 去除最高位默认的 1\n=  0 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 1000 // 最后一位 0 舍去\n=  0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100  // 尾数最后结果      \n\n\n1\n2\n3\n4\n\n\n因此 IEE 754最终存储如下：\n\n0+011 1111 1101+0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100\n\n\n1\n\n\n最高位为1，得到二进制\n\n2^-2 * 1.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100\n\n\n1\n\n\n转换为十进制\n\n0.3 0000 0000 0000 0004\n\n\n1\n\n\n总结\n\n 1. 精度损失 0.1和0.2转换为二进制出现无限循环情况，JS以64位双精度格式存储数字，最大可存储53位有效数字，超过此长度会被截取掉，造成精度损失\n 2. 对2个64位双精度格式数据计算时，首先进行对阶处理(将阶码对齐，将小数点位置对齐),因此，小阶数在对齐时，有效数字会向右移动，超过有效位数的位被截取掉\n 3. 当两个数据阶码对齐后进行加运算，得到的结果可能超过53位有效数字，超过的位会被截取掉\n\n相加后因浮点数小数位限制截断的二进制数字转换为十进制时变成0.30000000000000004(15个0)\n\n\n# 💚 组件封装\n\n\n# 编辑器组件API，滚动加载？\n\n文本编辑器 style value、setValue、getValue、clearContent、config\n\n滚动加载使用的属性\n\n使用offsetTop实现的话\n\n属性                  说明             类型                  默认                      必传\nstyle                                                                          \nlazy                开启懒加载          boolean or string   false or '.lazy-view'   \nhasMore             加载更多           boolean             true                    true\nisEmpty             展示空页           boolean                                     \nisError             展示错误页          boolean                                     \nneedInit            初始化&自动调用下拉刷新   boolean                                     \ndistanceToRefresh   下拉刷新距离         number                                      \ndamping             最大下拉距离         number                                      \nautoHeight          开启自适应高度        boolean                                     \n\n自定义页面UI\n\n\n# Modal组件封装？\n\n 1. visible控制modal显隐\n 2. title content自定义显示内容\n 3. 点击取消关闭modal，调用onClose回调；点击确认调用confirm回调，关闭modal，点击蒙层mask关闭modal\n 4. animate可关闭/开启动画\n\n\n# 🌰 代码看输出\n\n考察 函数柯里化\n\nlet init = 2\nf = init => arg => num => {\n    console.log('init '+init)\n    console.log('arg '+arg)\n    console.log('num '+num)\n    console.log((init = init + num * arg))\n}\nf1 = f(5)\ncalc1 = f1(1)\ncalc2 = f1(-1)\ncalc1(1)\ncalc1(1)\ncalc2(1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n考察node事件循环\n\nprocess.nextTick(function A() {\n    process.nextTick(function B() {\n        console.log(1);\n        process.nextTick(function D() {\n            console.log(2)\n        });\n        process.nextTick(function E() {\n            console.log(3)\n        });\n    });\n    process.nextTick(function C() {\n        console.log(4);\n        process.nextTick(function F() {\n            console.log(5)\n        });\n        process.nextTick(function G() {\n            console.log(6)\n        });\n    });\n});\nsetTimeout(function timeout() {\n    console.log('timeout fired')\n}, 0)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n考察class\n\nlet a=5\nclass A{\n    a=10\n    fn(){\n        console.log(this.a)\n    }\n}\nconst b=new A().fn\nb()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 异步任务调度器\n\nJavaScript 实现异步任务调度器\n\nJS实现一个带并发限制的异步调度器scheduler，保证他同时运行的任务最多2个\n\nclass Scheduler {\n  add(promiseCreator) {}\n  // ......\n}\n\nfunction timeout(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\nconst scheduler = new Scheduler();\nconst addTask = (time, order) => {\n  // scheduler.add(() => timeout(time)).then(() => console.log(order));\n  // then放进里面\n  scheduler.add(() => timeout(time).then(() => console.log(order)));\n};\naddTask(1000, '1');\naddTask(500, '2');\naddTask(300, '3');\naddTask(400, '4');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n不是几个一组，而是完成一个任务就push一个任务进队列\n\nclass Scheduler {\n    constructor(max) {\n        // 最大可并发任务数\n        this.max = max;\n        // 当前并发任务数\n        this.count = 0;\n        // 阻塞的任务队列\n        this.queue = [];\n    }\n\n    async add(fn) {\n        if (this.count >= this.max) {\n            // 若当前正在执行的任务，达到最大容量max\n            // 阻塞在此处，等待前面的任务执行完毕后将resolve弹出并执行\n            await new Promise(resolve => this.queue.push(resolve));\n        }\n        // 当前并发任务数++\n        this.count++;\n        // 使用await执行此函数\n\n        //执行传进来的函数 等待执行完，这是传的参数\n        const res = await fn();\n        // 执行完毕，当前并发任务数--\n        this.count--;\n        // 若队列中有值，将其resolve弹出，并执行\n        // 以便阻塞的任务，可以正常执行\n        this.queue.length && this.queue.shift()();\n        // 返回函数执行的结果\n        return res;\n    }\n}\nconst sleep = time => new Promise(resolve => setTimeout(resolve, time));\n\nconst scheduler = new Scheduler(2);\n\nconst addTask = (time, val) => {\n    scheduler.add(() => {\n        return sleep(time).then(() => console.log(val));\n    });\n};\n\naddTask(1000, '1');\naddTask(500, '2');\naddTask(300, '3');\naddTask(400, '4');\n// 2\n// 3\n// 1\n// 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 蚂蚁面试题\n\n/*\n约定:\ntitle数据类型为string\nuserId为主键，数据类型为Number\n*/\nconst data = [\n    {userId: 8, title: 'title1'},\n    {userId: 11, title: ' other'},\n    {userId: 15, title: null},\n    {userId: 19, title: 'title2'}\n];\nconst find = (origin) => {\n    return {\n        data: origin,\n        where: function (obj) {\n            for (let key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    this.data = this.data.filter(v => obj[key].test(v[key]))\n                }\n                // return find(this.data) // return在此处写，where只能过滤一个筛选条件\n            }\n            return this;\n            // return find(this.data)\n        },\n        orderBy: function (key, order) {\n            this.data.sort((a, b) => {\n                if (order == 'desc') {\n                    return b[key] - a[key]\n                } else {\n                    return a[key] - b[key]\n                }\n            })\n            return this.data\n        }\n    }\n}\n\nvar result = find(data).where({\n    'title': /\\d$/\n}).orderBy('userId', 'desc');\nconsole.log(result);\n// [{( userId: 19, title: 'title2'}, { userId: 8, title: 'title1' }]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 异步顺序执行\n\n异步调异步\n\nfunction fn1() {\n    setTimeout(() => {\n        console.log('fn1执行')\n        fn2('fn1传递过去的参数')\n    }, 1000)\n}\n\nfunction fn2(data) {\n    setTimeout(() => {\n        console.log('fn2执行', data)\n        fn3('fn2传递过去的参数')\n    }, 1000)\n}\n\nfunction fn3(data) {\n    setTimeout(() => {\n        console.log('fn3执行', data)\n    }, 1000)\n}\nfn1()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nPromise\n\nfunction fn1() {\n    return new Promise((resolve, reject) => {\n        console.log('fn1执行')\n        setTimeout(() => {\n            console.log('fn1结束')\n            resolve('fn1传递过去的参数')\n        }, 1000)\n    })\n}\n\nfunction fn2(data) {\n    return new Promise((resolve, reject) => {\n        console.log('fn2执行，接收的参数', data)\n        setTimeout(() => {\n            resolve('fn2传递过去的参数')\n        }, 1000)\n    })\n}\n\nfunction fn3(data) {\n    return new Promise((resolve, reject) => {\n        console.log('fn3执行，接收的参数', data)\n        setTimeout(() => {\n            resolve('fn3传递过去的参数')\n        }, 1000)\n    })\n}\n\nfn1().then(fn2).then(fn3).then(res => {\n    console.log('最后一个', res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n生成器\n\n返回迭代器的函数，使用yield，函数暂停等待，直到 生成的对象调用下一个next()，调用一次next执行一次yield，暂停\n\nfunction* main() {\n    const res1 = yield fn1('开始')\n    const res2 = yield fn2(res1)\n    const res3 = yield fn3(res2)\n    console.log(res3, '全部执行完毕')\n}\n\nconst task = main()\ntask.next()\n\nfunction fn1(data) {\n    setTimeout(() => {\n        console.log('fn1执行', data)\n        task.next('fn1执行完毕')\n    }, 1000)\n}\n\nfunction fn2(data) {\n    setTimeout(() => {\n        console.log('fn2执行', data)\n        task.next('fn2执行完毕')\n    }, 1000)\n}\n\nfunction fn3(data) {\n    setTimeout(() => {\n        console.log('fn3执行', data)\n        task.next('fn3执行完毕')\n    }, 1000)\n}\n\nconsole.log('我是最开始同步执行的')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 串行Promise.all\n\n利用ES6新特性\n\n\n# Array扩展\n\n// 需要进行功能拓展的方法\nconst mutationMethods = [\n    'push',\n    'pop',\n    'shift',\n]\n\n// 请在此出编写扩展方法\nconst arrayMethods = Object.create(Array.prototype);\nconst arrayProto = Array.prototype;\n\nmutationMethods.forEach(method => {\n    arrayMethods[method] = function (...args) {\n        const ans = arrayProto[method].apply(this, args);\n        console.log(`hello ${method}`);\n        return ans;\n    }\n})\n\nconst arr = [1, 2, 3]\narr.__proto__ = arrayMethods;\narr.push(4)\nconsole.log(arr)\narr.pop()\nconsole.log(arr)\narr.shift()\nconsole.log(arr)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# CSS\n\n\n# 🙋 div宽高比例变化\n\n1、非等比放大\n\nvh是视窗单位，也是相对单位。相对视窗的高度。视窗被均分为100单位的vh。能够直接获取高度，而用 % 在没有设置 body 高度的情况下，无法正确获得可视区域的高度\n\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\t.square {\n\t\t\t\twidth: 30%;\n\t\t\t\theight: 30vh;\n\t\t\t\tborder: 1px solid red;\n\t\t\t\tbackground-color: #00FFFF;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"square\"></div>\n\t</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n2、指定width为父元素的一个固定百分比，自适应宽度\n\nmargin和padding的百分比数值相对父元素宽度计算，将元素垂直方向上的padding值设定为和width相同的百分比绘制出自适应正方形\n\n * 若向容器内添加内容，内容占据一定宽度，设置height为0\n * 另一种解决办法：子绝父相，父元素相对定位，text绝对定位(不再占有文档位置，自然不会撑大父元素的height，相对父元素偏移)\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title></title>\n    <style>\n         .square2 {\n            width: 30%;\n            /*height: 0;*/\n            padding-bottom: 30%;\n            border: 1px solid red;\n            background-color: #00FFFF;\n            position: relative;\n        }\n        .text{\n            position: absolute;\n        }\n    </style>\n</head>\n<body>\n<div class=\"square2\"></div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n3、设置伪元素的margin-top撑开容器，max-height属性失效，因为其只会对元素的content height起作用\n\n使用子元素撑开content部分的高度，使max-height属性生效\n\n容器和伪元素在垂直方向上存在外边距合并问题，解决方法：父元素设置overflow为hidden，触发BFC布局\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title></title>\n    <style>\n         .square3 {\n            width: 30%;\n            /* 处理外边距合并 */\n            overflow: hidden;\n            border: 1px solid red;\n            background-color: #00FFFF;\n        }\n\n        .square3::after {\n            content: '占位符';\n            display: block;\n            margin-top: 100%;\n        }\n    </style>\n</head>\n<body>\n<div class=\"square3\"></div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n4、设置垂直方向上的padding撑开父元素，不触发BFC\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title></title>\n    <style>\n        .square4 {\n            width: 30%;\n            border: 1px solid red;\n            background-color: #00FFFF;\n        }\n        .square4::after {\n            content: '占位符';\n            display: block;\n            padding-top: 100%;\n        }\n    </style>\n</head>\n<body>\n<div class=\"square4\"></div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> CSS伪元素 ::after 创建一个伪元素，作为已选中元素的最后一个子元素。通常配合 content属性为该元素添加内容。这个虚拟元素默认是行内元素\n> \n> content属性用于在before或after伪元素中插入内容\n\n\n# 0.5px的线\n\n * 直接设置(兼容性问题)\n * transform: scaleY(0.5);\n * linear-gradient、box-shadow(各自有兼容性问题)\n * svg的描边等属性的1px是物理像素的1px\n * 使用垂直渐变，上部分透明，下部分配置想要的颜色\n\nbackground-image: linear-gradient(0deg, #f00 50%, transparent 50%);\n\n\n1\n\n\n\n# 🙋 12px以下文字\n\nChrome中做了限制\n\n 1. font-size最小值为12px，低于12px的 一律按照12px显示\n 2. Chrome认为低于12px的中文对人类不友好\n\n> zoom\n\n\"变焦\"，可以改变页面上元素的尺寸，属于真实尺寸。有兼容问题，非标准属性，缩放会改变元素占据空间大小，触发重排\n\n * zoom:50%，表示缩小到原来的一半\n * zoom:0.5，表示缩小到原来的一半\n\n .test1 {\n        font-size: 10px;\n        zoom: 0.8;\n    }\n\n    .test2 {\n        font-size: 16px;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> -webkit-transform:scale()\n\n针对Chrome使用webkit前缀\n\n使用scale只对可以**定义宽高的元素生效**。不改变页面布局\n\n .test1 {\n        font-size: 5px;\n        display: inline-block;\n        transform: scale(0.8);\n    }\n\n    .test2 {\n        font-size: 16px;\n        //行内元素没有宽高，所以设置display\n        display: inline-block;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> -webkit-text-size-adjust:none\n\n设定文字大小是否根据设备(浏览器)来自动调整显示大小\n\n * percentage：字体显示的大小；\n * auto：默认，字体大小会根据设备/浏览器来自动调整；\n * none:字体大小不会自动调整\n\n> 被废掉了\n\n\n# 1px效果\n\n * 伪元素+缩放\n * 动态viewport+rem(flex)\n * vw单位适配(未来推荐)\n\n> 伪元素+缩放\n\n设计稿中的1px，代码要实现0.5px\n\n缩放 避免 直接写小数像素带来的不同手机的兼容性处理不同\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Title</title>\n  <style>\n    /*伪元素实现0.5px border*/\n    .border::after {\n      content: \"\";\n      /*为了与原元素等大*/\n      box-sizing: border-box;\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 200%;\n      height: 200%;\n      border: 1px solid red;\n      transform: scale(0.5);\n      transform-origin: 0 0;\n    }\n\n    /*实现0.5px 细线*/\n    .line::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 200%;\n      height: 1px;\n      background: red;\n      transform: scale(0.5);\n      /*更改元素变形的原点*/\n      transform-origin: 0 0;\n    }\n\n    /*dpr适配 ，当前显示设备的物理像素分辨率与CSS 像素分辨率之比为2*/\n    @media (-webkit-min-device-pixel-ratio: 2) {\n      .line::after {\n        height: 1px;\n        transform: scale(0.5);\n        transform-origin: 0 0;\n      }\n    }\n\n    @media (-webkit-min-device-pixel-ratio: 3) {\n      .line::after {\n        height: 1px;\n        transform: scale(0.333);\n        transform-origin: 0 0;\n      }\n    }\n  </style>\n</head>\n<body>\n<div class=\"border\">\n  <div class=\"line\"></div>\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n> 动态viewport+rem\n\n不仅可解决移动端适配，也解决1px的问题\n\n三种viewport中我们常用的layout viewport(浏览器默认)，宽度大于浏览器可视区域宽度，因此会出现横向滚动条\n\nconst clientWidth = document.documentElement.clientWidth || document.body.clientWidth\n\n\n1\n\n\n设置meta标签属性避免横向滚动条\n\n<meta \n  name=\"viewport\" \n  content=\"\n    width=device-width,  // viewport宽等于屏幕宽\n    initial-scale=1.0,  // 初始缩放为1\n    maximum-scale=1.0, \n    user-scalable=no,  // 不允许手动缩放\n    viewport-fit=cover // 缩放以填充满屏幕\n    \" \n>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> flexible的原理——已弃用！\n\n * 根据dpr动态修改initial-scale\n * 动态修改viewport大小，以此 统一使用rem布局，viewport动态影响font-size，实现适配\n\n> 总结\n\n移动端适配主要分为两方面\n\n * 适配不同机型的屏幕尺寸\n * 对细节像素的处理。如果直接写 1px ，由于 dpr 的存导致渲染偏粗。使用rem 布局计算出对应小数值，有兼容性问题。老项目整体修改 viewport 成本过高，采用第一种实现方案处理；新项目可动态设置 viewport ，一键解决适配问题\n\n移动端对 1px 的渲染适配实现起来配置简单、代码简短，能够快速上手\n\n\n# 🚩 三角形?\n\n通过上下左右 边框 控制三角形的方向，用边框的宽度控制三角形的角度\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<style>\n    .div {\n        width: 0px;\n        height: 0px;\n        border: 100px solid transparent;\n        border-bottom-color: blue;\n    }\n</style>\n<body>\n<div class=\"div\"></div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 画圆形\n\n设置值超过50%会怎样？\n\n.circle {\n        width: 300px;\n        height: 300px;\n        background-color: green;\n        border-radius: 50%;\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n超过50%，还是圆形\n\n\n# 画同心圆(类似麻将的五饼)\n\n\n# CSS实现 偶数 子元素高亮， 排除第二个偶数\n\n\n# others\n\n\n# 不整页刷新、前进、后退\n\n使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个state 对象，使用 content 来传递数据。最后 window.onpopstate 监听响应浏览器的前进后退操作\n\n使用 pushState 来实现有两个问题，一个是打开首页时没有记录，使用 replaceState 将首页的记录替换，另一个是当一个页面刷新时，仍然会向服务器端请求，如果请求的 url 需要后端的配合将其重定向到一个页面\n\n\n# 数组乱序输出\n\n取出数组第一个元素，随机产生一个索引，将其交换，后面依次类推\n\nMath.round()四舍五入\n\nlet ary=[1,2,3,4,5,6,7,8,9];\nfor(let i=0;i<ary.length;i++){\n    let randomIndex=Math.round(Math.random()*(ary.length-1-i))+i;\n    [ary[i],ary[randomIndex]]=[ary[randomIndex],ary[i]];\n}\nconsole.log(ary);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 圆形环状进度条\n\n一个正方形div中分两个等宽div，设置overflow:hidden\n\n两个div中分别画两个半圆： border-top、border- left，再旋转-45deg\n\n通过旋转动画指定他们漏出来的角度\n\n\n# 蚂蚁面试\n\n实现100个url(存放在数组)，并发请求，调度器 ，并发数不超过5个，按顺序返回请求结果，class类——批量请求函数，限制并发量\n\n在对象数组中查找对应路由(根据关键词)，搜索结果可能不唯一，层次遍历 深度优先搜索 递归查询 拍平查询\n\n/*\n约定:\ntitle数据类型为string\nuserId为主键，数据类型为Number\n*/\nconst data = [\n    {userId: 8, title: 'title1'},\n    {userId: 11, title: ' other'},\n    {userId: 15, title: null},\n    {userId: 19, title: 'title2'}\n];\nconst find = (origin) => {\n    return {\n        data: origin,\n        where: function (obj) {\n            for (let key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    this.data = this.data.filter(v => obj[key].test(v[key]))\n                }\n                // return find(this.data) // return在此处写，where只能过滤一个筛选条件\n            }\n            return this;\n            // return find(this.data)\n        },\n        orderBy: function (key, order) {\n            this.data.sort((a, b) => {\n                if (order == 'desc') {\n                    return b[key] - a[key]\n                } else {\n                    return a[key] - b[key]\n                }\n            })\n            return this.data\n        }\n    }\n}\n//查找 data 中，符合条件的数据，并进行排序\nvar result = find(data).where({\n    'title': /\\d$/\n}).orderBy('userId', 'desc');\nconsole.log(result);\n// [{( userId: 19, title: 'title2'}, { userId: 8, title: 'title1' }]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n前端实现动画匀速直线运动，兼容性问题 css，JS如何实现？触动？",normalizedContent:"# 🔥 解析url参数\n\n\nlet url = 'https://campus.meituan.com/index?key=value&key2=value2';\n\nfunction abstractpara(url) {\n    const obj = {};\n    url.slice(url.indexof('?') + 1).split('&').foreach(item => {\n        const [key, value] = item.split('=');\n        obj[key] = value;\n    })\n    return obj;\n}\n\nconsole.log(abstractpara(url));\n\n\n//升级版\nfunction regparseparam(url) {\n    const paramsstr = /.+\\?(.+)$/.exec(url)[1];\n    const paramarr = paramsstr.split('&');\n    let paramobj = {};\n    paramarr.foreach(param => {\n        if (/=/.test(param)) {\n            let [key, val] = param.split('=');\n            val = decodeuricomponent(val);\n            val = /^\\d+$/.test(val) ? parsefloat(val) : val;\n            if (paramobj.hasownproperty(key)) {\n                paramobj[key] = [].concat(paramobj[key], val);\n            } else {\n                paramobj[key] = val;\n            }\n        } else {\n            paramobj[key] = true;\n        }\n    })\n    return paramobj;\n}\n\nconsole.log(regparseparam(url));\n\n\n//reduce实现\nfunction reduceurl(url) {\n    let newurl = '';\n    let index = url.indexof('#')\n    if (index !== -1) {\n        newurl = url.slice(0, index)\n    } else {\n        newurl = url;\n    }\n    let ans= newurl.slice(newurl.indexof('?') + 1).split('&').reduce((pre, cur, index, arr) => {\n        const [key, value=''] = cur.split('=');\n        pre[key] = value||'';\n        return pre;\n    }, {});\n    return json.stringify(ans)\n}\n\nconsole.log(reduceurl(url));\n\n\n//解析url params为对象\nfunction parseparam(url) {\n    const paramsstr = /.+\\?(.+)$/.exec(url)[1];\n    const paramsarr = paramsstr.split('&');\n    let paramsobj = {};\n    paramsarr.foreach(param => {\n        if (/=/.test(param)) { \n            let [key, val] = param.split('=');\n            val = decodeuricomponent(val); \n            val = /^\\d+$/.test(val) ? parsefloat(val) : val;\n            if (paramsobj.hasownproperty(key)) {\n                paramsobj[key] = [].concat(paramsobj[key], val);\n            } else {\n                paramsobj[key] = val;\n            }\n        } else {\n            paramsobj[param] = true;\n        }\n    })\n    return paramsobj;\n}\n\nlet url1 = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%e5%8c%97%e4%ba%ac&enabled';\nconsole.log(parseparam(url1))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# 🙋 a == 1 && a == 2\n\n考察 非严格相等\n\n==比较时 ，把对象a转为字符串再比较，a.tostring()\n\n重构私有方法tostring()，使其在不调用对象原型tostring()\n\nvar a = {\n  n: 0,\n  //私有属性方法\n  tostring: function() {\n    return ++this.n\n  }\n}\n//此时的a.tostring()调用的不再是object.prototype.tostring(),而是自己私有的属性方法tostring();\nif(a == 1 && a == 2 && a ==3) {\n  console.log(\"ok\")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n重构对象私有方法tostring()\n\nvar a = [1,2,3];\na.tostring = a.shift;\n//此时的a.tostring()调用的不再是object.prototype.tostring(),而是自己私有的属性方法tostring();\nif(a == 1 && a == 2 && a ==3) {\n  console.log(\"ok\")\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n利用object.defineproperty()\n\nobject.defineproperty(window,'a',{\n  get:function() {\n    //this指向window.a\n    this.value ? this.value++ : this.value = 1;\n    return this.value;\n  }\n})\nif(a == 1 && a == 2 && a ==3) {\n  console.log(\"ok\")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nvar a = {\n  value: 0,\n  valueof: function() {\n    this.value++;\n    return this.value;\n  }\n};\nconsole.log(a == 1 && a == 2);//true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# a===1 && a===2\n\nvar value = 0; //window.value\nobject.defineproperty(window, 'a', {\n    get: function() {\n        return this.value += 1;\n    }\n});\n\nconsole.log(a===1 && a===2 && a===3) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 发布订阅模式\n\nclass eventemitter {\n    constructor() {\n        this.cache = {}\n    }\n    on(name, fn) {\n        if (this.cache[name]) {\n            this.cache[name].push(fn)\n        } else {\n            this.cache[name] = [fn]\n        }\n    }\n    off(name, fn) {\n        let tasks = this.cache[name]\n        if (tasks) {\n            const index = tasks.findindex(f => f === fn || f.callback === fn)\n            if (index >= 0) {\n                tasks.splice(index, 1)\n            }\n        }\n    }\n    emit(name, once = false, ...args) {\n        if (this.cache[name]) {\n            // 创建副本，如果回调函数内继续注册相同事件，会造成死循环\n            let tasks = this.cache[name].slice()\n            for (let fn of tasks) {\n                fn(...args)\n            }\n            if (once) {\n                delete this.cache[name]\n            }\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 关闭页面后发请求\n\nnavigator.sendbeacon()\n\n用于满足统计和诊断代码的需要，尝试在卸载（unload）前发请求\n\n当用户代理成功把数据加入传输队列，sendbeacon() 返回 true，否则返回 false\n\n\n# 离开页面可靠发请求\n\n默认，xhr请求异步且非阻塞\n\n有被遗弃的风险，无法保证任何幕后工作都能完成\n\n浏览器设计假设当一个页面被关闭时，没有必要继续处理它排队的任何后台进程\n\n1、延迟用户操作，但是会阻塞主线程，导致性能问题\n\n2、指示浏览器保留未完成的请求，使用fetch的keepalive标志，将相应的请求保持打开状态，即使该请求页面已终止\n\n\n# 大数相加\n\nfunction solve(s, t) {\n  let len = math.max(s.length, t.length);\n  const ss = s.padstart(len, \"0\").split(\"\");\n  const tt = t.padstart(len, \"0\").split(\"\");\n  let flag = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    let sum = +ss[i] + +tt[i] + flag;\n    ss[i] = sum % 10;\n    flag = sum > 9 ? 1 : 0;\n  }\n  if (flag === 1) {\n    ss.unshift(1);\n  }\n  return ss.join(\"\");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# input和object双向绑定？\n\n  var person = {}\n  var name = null\n  object.defineproperty(person, 'name', {\n    get: function () {\n      return name\n    },\n    set: function (newv) {\n      name = newv\n    }\n  })\n  \n  let p = document.getelementbyid('ppp')\n  let ipt = document.getelementbyid('ipt')\n  ipt.addeventlistener('input', function (e) {\n    person.name = e.target.value\n    p.innertext = person.name\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 🌈 对象拍平\n\nconst entry = {\n    a: {\n        b: {\n            c: {\n                dd: 'abcdd'\n            }\n        },\n        d: [1]\n    },\n    e: 'ae',\n    b: [1, 2, {c: true}],\n};\n//转换为如下对象\nconst output = {\n    'a.b.c.dd': 'abcdd',\n    'a.d': [1],\n    e: 'ae'\n};\n\n//method 1\n//遍历对象，传入对象的key值和value，再对value进行递归遍历\nfunction flatobj(target) {\n    let res = {};\n    const process = (key, value) => {\n        //    先判断数据类型\n        if (object(value) !== value) {\n            if (key) {\n                res[key] = value;\n            }\n        } else if (array.isarray(value)) {\n            for (let i = 0; i < value.length; i++) {\n                process(`${key}[${i}]`, value[i]);\n            }\n            if (value.length === 0) {\n                res[key] = [];\n            }\n        } else {\n            let objarr = object.keys(value);\n            objarr.foreach(item => {\n                process(key ? `${key}.${item}` : `${item}`, value[item]);\n            });\n            if (objarr.length === 0 && key) {\n                res[key] = {};\n            }\n        }\n    }\n    process('', target);\n    return res;\n}\n\nlet ans = flatobj(entry);\n// console.log(ans);\n\n//method 2\nfunction objectflat(obj = ''){\n    const res = {};\n    function flat(item , prekey = ''){\n        object.entries(item).foreach(([key,value]) => {\n            let newkey = key;\n            // console.log(value,typeof value,array.isarray(value))\n            if (array.isarray(item)){\n                // console.log('是数组')\n                newkey = prekey ? `${prekey}[${key}]` : key;\n            }else{\n                newkey = prekey ? `${prekey}.${key}` : key;\n            }\n            if (value && typeof value === 'object'){\n                flat(value , newkey);\n            }else{\n                res[newkey] = value;\n            }\n        })\n    }\n    flat(obj);\n    return res;\n}\nans=objectflat(entry);\nconsole.log(ans)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\nfunction flatten(data) {\n    var result = {};\n\n    function recurse(cur, prop) {\n//如果输入进来的是不是对象，就将其放在数组中，返回\n        if (object(cur) !== cur) {\n            result[prop] = cur;\n//如果输入进来的是数组，长度不为0就递归数组，得出结果\n        } else {\n            var isempty = true;\n            for (var p in cur) {\n                isempty = false;\n                recurse(cur[p], prop ? prop + \".\" + p : p);\n            }\n            if (isempty && prop)\n                result[prop] = {};\n        }\n    }\n\n    recurse(data, \"\");\n    return result;\n};\nlet obj = {\n    a: 1,\n    b: {\n        c: 2,\n        d: {\n            e: 2\n        }\n    }\n}\nconsole.log(flatten(obj))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 括号匹配\n\nfunction matchbracket(str) {\n    const length = str.length;\n    if (length === 0) return true\n    const stack = []\n    const leftsymbols = '{[('\n    const rightsymbols = ' }]) '\n    const match = {\n        \"}\": \"{\",\n        \")\": \"(\",\n        \"]\": \"[\",\n    }\n    for (let i = 0; i < length; i++) {\n        const s = str[i]\n        if (leftsymbols.includes(s)) {\n//左括号，压栈\n            stack.push(s)\n        } else if (rightsymbols.includes(s)) {\n//右括号，判断栈顶(是否出栈)\n            const top = stack[stack.length - 1]\n// @ts- ignore\n            if (match[s] === top) {\n                stack.pop()\n            } else {\n                return false\n            }\n        }\n    }\n    return stack.length === 0;\n}\n\nconsole.log(matchbracket('(1+2))*3'))\nconsole.log(matchbracket('(1+2)*3'))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 文件扩展名\n\nfunction getfileextension(filename){\n    return filename.slice((filename.lastindexof(\".\")-1)+2);\n}\n\n\n1\n2\n3\n\n\n\n# 🔥 数组转树\n\nlet arrdata = [\n    {\n        id: 1, val: '学校', parentid: 0, department: ['部门1', '部门2']\n    }, {\n        id: 2, val: '班级1', parentid: 1\n    }, {\n        id: 3, val: '班级2', parentid: 1\n    }, {\n        id: 4, val: '学生1', parentid: 2\n    }, {\n        id: 5, val: '学生2', parentid: 2\n    }, {\n        id: 6, val: '学生3', parentid: 3\n    },\n];\n\n// 创建parentid的子节点，没有创建根节点的其他信息，只是创建了根节点的子节点数组，所以返回数组\nfunction arraytotree(data, parentid) {\n    let result = [];\n    for (let i = 0; i < data.length; i++) { // 创建子节点列表\n        if (data[i].parentid === parentid) {\n            let obj = {};\n            deepclone(data[i], obj); // 深拷贝，创建子节点\n            let children = this.arraytotree(data, data[i].id) || []; // 递归创建子节点的子节点\n            if (children.length > 0) {\n                obj.children = children;\n            }\n            result.push(obj);\n        }\n    }\n    return result;\n}\nfunction deepclone(obj, newobj) {\n    for (let key in obj) {\n        if (obj.hasownproperty(key)) {\n            newobj[key] = typeof obj[key] === 'object' ?\n                deepclone(obj[key], newobj[key]) :\n                obj[key];\n        }\n    }\n}\n\nconsole.log(arraytotree(arrdata, 1));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n实现\n\n// 转换前：\nlet source = [{\n    id: 1,\n    pid: 0,\n    name: 'body'\n}, {\n    id: 2,\n    pid: 1,\n    name: 'title'\n}, {\n    id: 3,\n    pid: 2,\n    name: 'div'\n}];\n\nfunction jsontotree(data) {\n    let ans = [];\n    if (!array.isarray(data)) {\n        return ans;\n    }\n    //使用map，将当前对象id和当前对象对应存储\n    let map = {};\n    data.foreach(item => {\n        map[item.id] = item;\n    });\n    data.foreach(item => {\n        let par = map[item.pid];\n        if (par) {\n            (par.children || (par.children = [])).push(item);\n        } else {\n            ans.push(item);\n        }\n    });\n    return ans;\n}\n\nconsole.log(jsontotree(source))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 🌈 数组对象找id\n\nvar result = [];\nfunction find(arr, id) {\n    if (arr == null) return null;\n    for (let obj of arr) {\n        if (obj.id === id) {\n            result = [...result, collect(obj)];\n        }\n        find(obj.children, id);\n    }\n}\nfunction collect(obj) {\n    let ret = obj;\n    if (obj.children) {\n        for (let o of obj.children) {\n            ret = [...ret, ...collect(o)]\n        }\n    }\n    return ret;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nlet tree = [\n    {\n        id: '1',\n        name: '节点1',\n        children: [\n            {\n                id: '1-1',\n                name: '节点1-1',\n                children: [\n                    {\n                        id: '1-1-1',\n                        name: '节点1-1-1'\n                    }\n                ]\n            },\n            {\n                id: '1-2',\n                name: '节点1-2'\n            }\n        ]\n    },\n    {\n        id: '2',\n        name: '节点2',\n        children: [\n            {\n                id: '2-1',\n                name: '节点2-1'\n            }\n        ]\n    }\n];\nfunction findnode(tree, func) {\n    let node, curtree = [...tree]\n    for (let i = 0; i < curtree.length; i++) {\n        if (func(curtree[i])) {\n            return curtree[i]\n        }\n        if (curtree[i].children) {\n            curtree.splice(i + 1, 0, ...curtree[i].children)\n        }\n    }\n}\nconst data = findnode(tree, (node) => {\n    return node.name === '节点1-1-1'\n})\nconsole.log( data)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 循环打印红黄绿\n\n> 红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；让三个灯不断交替重复亮灯？\n\nfunction red() {\n    console.log('red');\n}\nfunction green() {\n    console.log('green');\n}\nfunction yellow() {\n    console.log('yellow');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# callback\n\nconst task = (timer, light, callback) => {\n    settimeout(() => {\n        if (light === 'red') {\n            red()\n        }\n        else if (light === 'green') {\n            green()\n        }\n        else if (light === 'yellow') {\n            yellow()\n        }\n        callback()\n    }, timer)\n}\ntask(3000, 'red', () => {\n    task(2000, 'green', () => {\n        task(1000, 'yellow', function.prototype)\n    })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n问题：只完成了一次 流程，如何交替重复 执行？\n\n使用 递归\n\nconst step=()=>{\n    task(3000,'red',()=>{\n        task(2000,'green',()=>{\n            task(1000,'yellow',step);\n        })\n    })\n}\nstep();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# promise\n\nconst task = (timer, light) => \n    new promise((resolve, reject) => {\n        settimeout(() => {\n            if (light === 'red') {\n                red()\n            }\n            else if (light === 'green') {\n                green()\n            }\n            else if (light === 'yellow') {\n                yellow()\n            }\n            resolve()\n        }, timer)\n    })\nconst step = () => {\n    task(3000, 'red')\n        .then(() => task(2000, 'green'))\n        .then(() => task(2100, 'yellow'))\n        .then(step)\n}\nstep()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# async/await\n\nconst taskrunner=async()=>{\n    await task(3000,'red');\n    await task(2000,'green');\n    await task(1000,'yellow');\n    taskrunner();\n}\ntaskrunner();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 隔一秒打印 1 2 3 4\n\n// 闭包实现\nfor(var i=0;i<5;i++){\n    (function (i){\n        settimeout(function(){\n            console.log(i);\n        },i*1000);\n    })(i);\n}\n\n//使用 let块级作用域\nfor(let i=0;i<5;i++){\n    settimeout(function(){\n        console.log(i);\n    },i*1000);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 对象 循环引用\n\nconst iscycleobject = (obj,parent) => {\n    const parentarr = parent || [obj];\n    for(let i in obj) {\n        if(typeof obj[i] === 'object') {\n            let flag = false;\n            parentarr.foreach((pobj) => {\n                if(pobj === obj[i]){\n                    flag = true;\n                }\n            })\n            if(flag) return true;\n            flag = iscycleobject(obj[i],[...parentarr,obj[i]]);\n            if(flag) return true;\n        }\n    }\n    return false;\n}\n\n\nconst a = 1;\nconst b = {a};\nconst c = {b};\nconst o = {d:{a:3},c}\no.c.b.aa = a;\n\nconsole.log(iscycleobject(o))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 🌰 0.1+0.2 === 0.3?\n\n0.1 + 0.2 = 0.30000000000000004 //15个0\n\n\n1\n\n\n一个数出现无限循环，再大的内存计算机也存不下，所以只能存储一个近似值，再取出就会出现精度丢失\n\n在js中，主流的数值类型是number，number采用的是ieee754规范中64位双精度浮点数编码\n\n优点是可以归一化处理整数和小数，节省存储空间\n\n对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，且小数点的位置不固定。解决思路就是使用科学计数法，这样小数点位置就固定了\n\n10进制科学计数法表达式，底数为10，n为整数\n\n\n\n如0.1就可以表示——0.1=1*(10的-1次方)\n\n在ieee 754标准中类似，计算机只能用二进制（0或1）表示，底数为2，二进制转换为科学记数法的公式如下：\n\n0.1的二进制表示为：\n\n\n\n其中，a为0或者1，e为小数点移动的位置\n\n十进制小数转二进制？\n\n十进制小数转二进制，具体做法是：用2乘十进制小数，得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止\n\n把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。（乘2取整，顺序排列）\n\n举个例子：\n\n27.0转化成二进制为11011.0\n\n先把0.5转换为二进制小数\n0.5*2=1.0 //积中小数部分为0\n\n(27) 10=(11011) 2\n(0.5) 10=(1.0) 2\n合并整数和小数部分可得\n(27.5) 10=(11011.1) 2\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n0.1转为二进制？\n\n0.1 * 2 = 0.2 --------------- 取整数 0，小数 0.2\n0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4\n0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8\n0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6\n0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2\n0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4\n0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8\n0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6\n0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n最后 0.1的二进制可以表示为0.000110011……(0011无限循环)，因此二进制无法精确保存类似0.1这样的小数\n\njs存储方式是ieee 754 标准浮点数表示常用的 双精度浮点数 表示法，其长度为8个字节，即64位比特\n\n64位比特又可分为三个部分：\n\n * 符号位s：第 1 位是正负数符号位（sign），0代表正数，1代表负数\n * 指数位e：阶码，中间的 11 位存储指数（exponent），表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为1023\n * 尾数位m：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零。(能够真正决定数字精度)\n\n\n\n27.0的二进制11011.1转换为科学记数法\n\n\n\n符号位为0(正数)，指数位为4+，1023+4，即1027\n\n因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够52位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\n所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示\n\n> 0+100 0000 0011+1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000\n\n0.1的二进制科学计数法表示\n\n\n\n所以0.1存储为计算机的二进制形式为\n\n符号位为0，指数位为 -4 ，1023+(-4)=1019，二进制位 1111 1110 11，e为11位，最终为 011 1111 1011\n\nieee754中，循环尾可不能再无限循环，双精度 64 位最多存储的有效整数为 52 位，采用 **就近舍入模式(进1舍0)**存储\n\n> 0+011 1111 1011+1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010\n\n同理，0.2的二进制形式为\n\n> 0+011 1111 1100+1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010\n\n浮点数求和步骤\n\n 1. 对阶\n 2. 求和\n 3. 规格化\n\n> 对阶\n\n判断指数位是否相同，即小数位是否对其，若指数位不同，需要对阶保证指数相同\n\n对阶时遵守小阶向大阶看齐原则，*尾数向右移位，每移动一位，指数位加 1 直到指数位相同，即完成对阶。\n\n本示例，0.1 的阶码为 -4 小于 0.2 的阶码 -3，故对 0.1 做移码操作\n\n// 0.1 移动之前\n0 + 011 1111 1011+ 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 \n\n// 0.1 右移 1 位之后尾数最高位空出一位，（0 舍 1 入，此处舍去末尾 0）\n0 + 011 1111 1100 +1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 101(0) \n\n// 0.1 右移 1 位完成\n0 +011 1111 1100 +1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n尾数求和\n\n// 0.1 和 0.2 都转化成二进制后再进行运算\n0+011 1111 1100+1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 // 0.1 \n(+) 0+011 1111 1100+1001  1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010 // 0.2\n= 0+011 1111 1100+10 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111 // 产生进位，待处理\n\n\n\n1\n2\n3\n4\n5\n\n\n规格化和舍入\n\n由于产生进位，阶码需要+1，原阶码为011 1111 1100，+1后得到1000 10，转换为十进制，即1021，此时阶码为1021-1023= -2，此时符号位，指数位分别为0 + 011 1111 1101\n\n尾部进位2位，去除最高位默认的1，因为最低位为1需要进行舍入操作，即在最低有效位上+1，若为0则直接舍去，若为1继续+1\n\n  10 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111 // + 1\n=  0 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 1000 // 去除最高位默认的 1\n=  0 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 1000 // 最后一位 0 舍去\n=  0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100  // 尾数最后结果      \n\n\n1\n2\n3\n4\n\n\n因此 iee 754最终存储如下：\n\n0+011 1111 1101+0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100\n\n\n1\n\n\n最高位为1，得到二进制\n\n2^-2 * 1.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0100\n\n\n1\n\n\n转换为十进制\n\n0.3 0000 0000 0000 0004\n\n\n1\n\n\n总结\n\n 1. 精度损失 0.1和0.2转换为二进制出现无限循环情况，js以64位双精度格式存储数字，最大可存储53位有效数字，超过此长度会被截取掉，造成精度损失\n 2. 对2个64位双精度格式数据计算时，首先进行对阶处理(将阶码对齐，将小数点位置对齐),因此，小阶数在对齐时，有效数字会向右移动，超过有效位数的位被截取掉\n 3. 当两个数据阶码对齐后进行加运算，得到的结果可能超过53位有效数字，超过的位会被截取掉\n\n相加后因浮点数小数位限制截断的二进制数字转换为十进制时变成0.30000000000000004(15个0)\n\n\n# 💚 组件封装\n\n\n# 编辑器组件api，滚动加载？\n\n文本编辑器 style value、setvalue、getvalue、clearcontent、config\n\n滚动加载使用的属性\n\n使用offsettop实现的话\n\n属性                  说明             类型                  默认                      必传\nstyle                                                                          \nlazy                开启懒加载          boolean or string   false or '.lazy-view'   \nhasmore             加载更多           boolean             true                    true\nisempty             展示空页           boolean                                     \niserror             展示错误页          boolean                                     \nneedinit            初始化&自动调用下拉刷新   boolean                                     \ndistancetorefresh   下拉刷新距离         number                                      \ndamping             最大下拉距离         number                                      \nautoheight          开启自适应高度        boolean                                     \n\n自定义页面ui\n\n\n# modal组件封装？\n\n 1. visible控制modal显隐\n 2. title content自定义显示内容\n 3. 点击取消关闭modal，调用onclose回调；点击确认调用confirm回调，关闭modal，点击蒙层mask关闭modal\n 4. animate可关闭/开启动画\n\n\n# 🌰 代码看输出\n\n考察 函数柯里化\n\nlet init = 2\nf = init => arg => num => {\n    console.log('init '+init)\n    console.log('arg '+arg)\n    console.log('num '+num)\n    console.log((init = init + num * arg))\n}\nf1 = f(5)\ncalc1 = f1(1)\ncalc2 = f1(-1)\ncalc1(1)\ncalc1(1)\ncalc2(1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n考察node事件循环\n\nprocess.nexttick(function a() {\n    process.nexttick(function b() {\n        console.log(1);\n        process.nexttick(function d() {\n            console.log(2)\n        });\n        process.nexttick(function e() {\n            console.log(3)\n        });\n    });\n    process.nexttick(function c() {\n        console.log(4);\n        process.nexttick(function f() {\n            console.log(5)\n        });\n        process.nexttick(function g() {\n            console.log(6)\n        });\n    });\n});\nsettimeout(function timeout() {\n    console.log('timeout fired')\n}, 0)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n考察class\n\nlet a=5\nclass a{\n    a=10\n    fn(){\n        console.log(this.a)\n    }\n}\nconst b=new a().fn\nb()\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 异步任务调度器\n\njavascript 实现异步任务调度器\n\njs实现一个带并发限制的异步调度器scheduler，保证他同时运行的任务最多2个\n\nclass scheduler {\n  add(promisecreator) {}\n  // ......\n}\n\nfunction timeout(time) {\n  return new promise(resolve => {\n    settimeout(resolve, time);\n  });\n}\nconst scheduler = new scheduler();\nconst addtask = (time, order) => {\n  // scheduler.add(() => timeout(time)).then(() => console.log(order));\n  // then放进里面\n  scheduler.add(() => timeout(time).then(() => console.log(order)));\n};\naddtask(1000, '1');\naddtask(500, '2');\naddtask(300, '3');\naddtask(400, '4');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n不是几个一组，而是完成一个任务就push一个任务进队列\n\nclass scheduler {\n    constructor(max) {\n        // 最大可并发任务数\n        this.max = max;\n        // 当前并发任务数\n        this.count = 0;\n        // 阻塞的任务队列\n        this.queue = [];\n    }\n\n    async add(fn) {\n        if (this.count >= this.max) {\n            // 若当前正在执行的任务，达到最大容量max\n            // 阻塞在此处，等待前面的任务执行完毕后将resolve弹出并执行\n            await new promise(resolve => this.queue.push(resolve));\n        }\n        // 当前并发任务数++\n        this.count++;\n        // 使用await执行此函数\n\n        //执行传进来的函数 等待执行完，这是传的参数\n        const res = await fn();\n        // 执行完毕，当前并发任务数--\n        this.count--;\n        // 若队列中有值，将其resolve弹出，并执行\n        // 以便阻塞的任务，可以正常执行\n        this.queue.length && this.queue.shift()();\n        // 返回函数执行的结果\n        return res;\n    }\n}\nconst sleep = time => new promise(resolve => settimeout(resolve, time));\n\nconst scheduler = new scheduler(2);\n\nconst addtask = (time, val) => {\n    scheduler.add(() => {\n        return sleep(time).then(() => console.log(val));\n    });\n};\n\naddtask(1000, '1');\naddtask(500, '2');\naddtask(300, '3');\naddtask(400, '4');\n// 2\n// 3\n// 1\n// 4\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 蚂蚁面试题\n\n/*\n约定:\ntitle数据类型为string\nuserid为主键，数据类型为number\n*/\nconst data = [\n    {userid: 8, title: 'title1'},\n    {userid: 11, title: ' other'},\n    {userid: 15, title: null},\n    {userid: 19, title: 'title2'}\n];\nconst find = (origin) => {\n    return {\n        data: origin,\n        where: function (obj) {\n            for (let key in obj) {\n                if (obj.hasownproperty(key)) {\n                    this.data = this.data.filter(v => obj[key].test(v[key]))\n                }\n                // return find(this.data) // return在此处写，where只能过滤一个筛选条件\n            }\n            return this;\n            // return find(this.data)\n        },\n        orderby: function (key, order) {\n            this.data.sort((a, b) => {\n                if (order == 'desc') {\n                    return b[key] - a[key]\n                } else {\n                    return a[key] - b[key]\n                }\n            })\n            return this.data\n        }\n    }\n}\n\nvar result = find(data).where({\n    'title': /\\d$/\n}).orderby('userid', 'desc');\nconsole.log(result);\n// [{( userid: 19, title: 'title2'}, { userid: 8, title: 'title1' }]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 异步顺序执行\n\n异步调异步\n\nfunction fn1() {\n    settimeout(() => {\n        console.log('fn1执行')\n        fn2('fn1传递过去的参数')\n    }, 1000)\n}\n\nfunction fn2(data) {\n    settimeout(() => {\n        console.log('fn2执行', data)\n        fn3('fn2传递过去的参数')\n    }, 1000)\n}\n\nfunction fn3(data) {\n    settimeout(() => {\n        console.log('fn3执行', data)\n    }, 1000)\n}\nfn1()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\npromise\n\nfunction fn1() {\n    return new promise((resolve, reject) => {\n        console.log('fn1执行')\n        settimeout(() => {\n            console.log('fn1结束')\n            resolve('fn1传递过去的参数')\n        }, 1000)\n    })\n}\n\nfunction fn2(data) {\n    return new promise((resolve, reject) => {\n        console.log('fn2执行，接收的参数', data)\n        settimeout(() => {\n            resolve('fn2传递过去的参数')\n        }, 1000)\n    })\n}\n\nfunction fn3(data) {\n    return new promise((resolve, reject) => {\n        console.log('fn3执行，接收的参数', data)\n        settimeout(() => {\n            resolve('fn3传递过去的参数')\n        }, 1000)\n    })\n}\n\nfn1().then(fn2).then(fn3).then(res => {\n    console.log('最后一个', res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n生成器\n\n返回迭代器的函数，使用yield，函数暂停等待，直到 生成的对象调用下一个next()，调用一次next执行一次yield，暂停\n\nfunction* main() {\n    const res1 = yield fn1('开始')\n    const res2 = yield fn2(res1)\n    const res3 = yield fn3(res2)\n    console.log(res3, '全部执行完毕')\n}\n\nconst task = main()\ntask.next()\n\nfunction fn1(data) {\n    settimeout(() => {\n        console.log('fn1执行', data)\n        task.next('fn1执行完毕')\n    }, 1000)\n}\n\nfunction fn2(data) {\n    settimeout(() => {\n        console.log('fn2执行', data)\n        task.next('fn2执行完毕')\n    }, 1000)\n}\n\nfunction fn3(data) {\n    settimeout(() => {\n        console.log('fn3执行', data)\n        task.next('fn3执行完毕')\n    }, 1000)\n}\n\nconsole.log('我是最开始同步执行的')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 串行promise.all\n\n利用es6新特性\n\n\n# array扩展\n\n// 需要进行功能拓展的方法\nconst mutationmethods = [\n    'push',\n    'pop',\n    'shift',\n]\n\n// 请在此出编写扩展方法\nconst arraymethods = object.create(array.prototype);\nconst arrayproto = array.prototype;\n\nmutationmethods.foreach(method => {\n    arraymethods[method] = function (...args) {\n        const ans = arrayproto[method].apply(this, args);\n        console.log(`hello ${method}`);\n        return ans;\n    }\n})\n\nconst arr = [1, 2, 3]\narr.__proto__ = arraymethods;\narr.push(4)\nconsole.log(arr)\narr.pop()\nconsole.log(arr)\narr.shift()\nconsole.log(arr)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# css\n\n\n# 🙋 div宽高比例变化\n\n1、非等比放大\n\nvh是视窗单位，也是相对单位。相对视窗的高度。视窗被均分为100单位的vh。能够直接获取高度，而用 % 在没有设置 body 高度的情况下，无法正确获得可视区域的高度\n\n<!doctype html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<title></title>\n\t\t<style type=\"text/css\">\n\t\t\t.square {\n\t\t\t\twidth: 30%;\n\t\t\t\theight: 30vh;\n\t\t\t\tborder: 1px solid red;\n\t\t\t\tbackground-color: #00ffff;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"square\"></div>\n\t</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n2、指定width为父元素的一个固定百分比，自适应宽度\n\nmargin和padding的百分比数值相对父元素宽度计算，将元素垂直方向上的padding值设定为和width相同的百分比绘制出自适应正方形\n\n * 若向容器内添加内容，内容占据一定宽度，设置height为0\n * 另一种解决办法：子绝父相，父元素相对定位，text绝对定位(不再占有文档位置，自然不会撑大父元素的height，相对父元素偏移)\n\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title></title>\n    <style>\n         .square2 {\n            width: 30%;\n            /*height: 0;*/\n            padding-bottom: 30%;\n            border: 1px solid red;\n            background-color: #00ffff;\n            position: relative;\n        }\n        .text{\n            position: absolute;\n        }\n    </style>\n</head>\n<body>\n<div class=\"square2\"></div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n3、设置伪元素的margin-top撑开容器，max-height属性失效，因为其只会对元素的content height起作用\n\n使用子元素撑开content部分的高度，使max-height属性生效\n\n容器和伪元素在垂直方向上存在外边距合并问题，解决方法：父元素设置overflow为hidden，触发bfc布局\n\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title></title>\n    <style>\n         .square3 {\n            width: 30%;\n            /* 处理外边距合并 */\n            overflow: hidden;\n            border: 1px solid red;\n            background-color: #00ffff;\n        }\n\n        .square3::after {\n            content: '占位符';\n            display: block;\n            margin-top: 100%;\n        }\n    </style>\n</head>\n<body>\n<div class=\"square3\"></div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n4、设置垂直方向上的padding撑开父元素，不触发bfc\n\n<!doctype html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title></title>\n    <style>\n        .square4 {\n            width: 30%;\n            border: 1px solid red;\n            background-color: #00ffff;\n        }\n        .square4::after {\n            content: '占位符';\n            display: block;\n            padding-top: 100%;\n        }\n    </style>\n</head>\n<body>\n<div class=\"square4\"></div>\n</body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n> css伪元素 ::after 创建一个伪元素，作为已选中元素的最后一个子元素。通常配合 content属性为该元素添加内容。这个虚拟元素默认是行内元素\n> \n> content属性用于在before或after伪元素中插入内容\n\n\n# 0.5px的线\n\n * 直接设置(兼容性问题)\n * transform: scaley(0.5);\n * linear-gradient、box-shadow(各自有兼容性问题)\n * svg的描边等属性的1px是物理像素的1px\n * 使用垂直渐变，上部分透明，下部分配置想要的颜色\n\nbackground-image: linear-gradient(0deg, #f00 50%, transparent 50%);\n\n\n1\n\n\n\n# 🙋 12px以下文字\n\nchrome中做了限制\n\n 1. font-size最小值为12px，低于12px的 一律按照12px显示\n 2. chrome认为低于12px的中文对人类不友好\n\n> zoom\n\n\"变焦\"，可以改变页面上元素的尺寸，属于真实尺寸。有兼容问题，非标准属性，缩放会改变元素占据空间大小，触发重排\n\n * zoom:50%，表示缩小到原来的一半\n * zoom:0.5，表示缩小到原来的一半\n\n .test1 {\n        font-size: 10px;\n        zoom: 0.8;\n    }\n\n    .test2 {\n        font-size: 16px;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> -webkit-transform:scale()\n\n针对chrome使用webkit前缀\n\n使用scale只对可以**定义宽高的元素生效**。不改变页面布局\n\n .test1 {\n        font-size: 5px;\n        display: inline-block;\n        transform: scale(0.8);\n    }\n\n    .test2 {\n        font-size: 16px;\n        //行内元素没有宽高，所以设置display\n        display: inline-block;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> -webkit-text-size-adjust:none\n\n设定文字大小是否根据设备(浏览器)来自动调整显示大小\n\n * percentage：字体显示的大小；\n * auto：默认，字体大小会根据设备/浏览器来自动调整；\n * none:字体大小不会自动调整\n\n> 被废掉了\n\n\n# 1px效果\n\n * 伪元素+缩放\n * 动态viewport+rem(flex)\n * vw单位适配(未来推荐)\n\n> 伪元素+缩放\n\n设计稿中的1px，代码要实现0.5px\n\n缩放 避免 直接写小数像素带来的不同手机的兼容性处理不同\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>title</title>\n  <style>\n    /*伪元素实现0.5px border*/\n    .border::after {\n      content: \"\";\n      /*为了与原元素等大*/\n      box-sizing: border-box;\n      position: absolute;\n      left: 0;\n      top: 0;\n      width: 200%;\n      height: 200%;\n      border: 1px solid red;\n      transform: scale(0.5);\n      transform-origin: 0 0;\n    }\n\n    /*实现0.5px 细线*/\n    .line::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 200%;\n      height: 1px;\n      background: red;\n      transform: scale(0.5);\n      /*更改元素变形的原点*/\n      transform-origin: 0 0;\n    }\n\n    /*dpr适配 ，当前显示设备的物理像素分辨率与css 像素分辨率之比为2*/\n    @media (-webkit-min-device-pixel-ratio: 2) {\n      .line::after {\n        height: 1px;\n        transform: scale(0.5);\n        transform-origin: 0 0;\n      }\n    }\n\n    @media (-webkit-min-device-pixel-ratio: 3) {\n      .line::after {\n        height: 1px;\n        transform: scale(0.333);\n        transform-origin: 0 0;\n      }\n    }\n  </style>\n</head>\n<body>\n<div class=\"border\">\n  <div class=\"line\"></div>\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n> 动态viewport+rem\n\n不仅可解决移动端适配，也解决1px的问题\n\n三种viewport中我们常用的layout viewport(浏览器默认)，宽度大于浏览器可视区域宽度，因此会出现横向滚动条\n\nconst clientwidth = document.documentelement.clientwidth || document.body.clientwidth\n\n\n1\n\n\n设置meta标签属性避免横向滚动条\n\n<meta \n  name=\"viewport\" \n  content=\"\n    width=device-width,  // viewport宽等于屏幕宽\n    initial-scale=1.0,  // 初始缩放为1\n    maximum-scale=1.0, \n    user-scalable=no,  // 不允许手动缩放\n    viewport-fit=cover // 缩放以填充满屏幕\n    \" \n>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> flexible的原理——已弃用！\n\n * 根据dpr动态修改initial-scale\n * 动态修改viewport大小，以此 统一使用rem布局，viewport动态影响font-size，实现适配\n\n> 总结\n\n移动端适配主要分为两方面\n\n * 适配不同机型的屏幕尺寸\n * 对细节像素的处理。如果直接写 1px ，由于 dpr 的存导致渲染偏粗。使用rem 布局计算出对应小数值，有兼容性问题。老项目整体修改 viewport 成本过高，采用第一种实现方案处理；新项目可动态设置 viewport ，一键解决适配问题\n\n移动端对 1px 的渲染适配实现起来配置简单、代码简短，能够快速上手\n\n\n# 🚩 三角形?\n\n通过上下左右 边框 控制三角形的方向，用边框的宽度控制三角形的角度\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>title</title>\n</head>\n<style>\n    .div {\n        width: 0px;\n        height: 0px;\n        border: 100px solid transparent;\n        border-bottom-color: blue;\n    }\n</style>\n<body>\n<div class=\"div\"></div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 画圆形\n\n设置值超过50%会怎样？\n\n.circle {\n        width: 300px;\n        height: 300px;\n        background-color: green;\n        border-radius: 50%;\n    }\n\n\n1\n2\n3\n4\n5\n6\n\n\n超过50%，还是圆形\n\n\n# 画同心圆(类似麻将的五饼)\n\n\n# css实现 偶数 子元素高亮， 排除第二个偶数\n\n\n# others\n\n\n# 不整页刷新、前进、后退\n\n使用 pushstate + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个state 对象，使用 content 来传递数据。最后 window.onpopstate 监听响应浏览器的前进后退操作\n\n使用 pushstate 来实现有两个问题，一个是打开首页时没有记录，使用 replacestate 将首页的记录替换，另一个是当一个页面刷新时，仍然会向服务器端请求，如果请求的 url 需要后端的配合将其重定向到一个页面\n\n\n# 数组乱序输出\n\n取出数组第一个元素，随机产生一个索引，将其交换，后面依次类推\n\nmath.round()四舍五入\n\nlet ary=[1,2,3,4,5,6,7,8,9];\nfor(let i=0;i<ary.length;i++){\n    let randomindex=math.round(math.random()*(ary.length-1-i))+i;\n    [ary[i],ary[randomindex]]=[ary[randomindex],ary[i]];\n}\nconsole.log(ary);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 圆形环状进度条\n\n一个正方形div中分两个等宽div，设置overflow:hidden\n\n两个div中分别画两个半圆： border-top、border- left，再旋转-45deg\n\n通过旋转动画指定他们漏出来的角度\n\n\n# 蚂蚁面试\n\n实现100个url(存放在数组)，并发请求，调度器 ，并发数不超过5个，按顺序返回请求结果，class类——批量请求函数，限制并发量\n\n在对象数组中查找对应路由(根据关键词)，搜索结果可能不唯一，层次遍历 深度优先搜索 递归查询 拍平查询\n\n/*\n约定:\ntitle数据类型为string\nuserid为主键，数据类型为number\n*/\nconst data = [\n    {userid: 8, title: 'title1'},\n    {userid: 11, title: ' other'},\n    {userid: 15, title: null},\n    {userid: 19, title: 'title2'}\n];\nconst find = (origin) => {\n    return {\n        data: origin,\n        where: function (obj) {\n            for (let key in obj) {\n                if (obj.hasownproperty(key)) {\n                    this.data = this.data.filter(v => obj[key].test(v[key]))\n                }\n                // return find(this.data) // return在此处写，where只能过滤一个筛选条件\n            }\n            return this;\n            // return find(this.data)\n        },\n        orderby: function (key, order) {\n            this.data.sort((a, b) => {\n                if (order == 'desc') {\n                    return b[key] - a[key]\n                } else {\n                    return a[key] - b[key]\n                }\n            })\n            return this.data\n        }\n    }\n}\n//查找 data 中，符合条件的数据，并进行排序\nvar result = find(data).where({\n    'title': /\\d$/\n}).orderby('userid', 'desc');\nconsole.log(result);\n// [{( userid: 19, title: 'title2'}, { userid: 8, title: 'title1' }]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n前端实现动画匀速直线运动，兼容性问题 css，js如何实现？触动？",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"备注",frontmatter:{title:"备注",date:"2022-12-19T12:57:16.000Z",permalink:"/pages/8f19fc/",tags:[null],author:{name:"yuadh",link:"https://github.com/yuadh"}},regularPath:"/08.%E4%B8%93%E6%A0%8F/14.%E5%A4%87%E6%B3%A8.html",relativePath:"08.专栏/14.备注.md",key:"v-985e936c",path:"/pages/8f19fc/",headersStr:null,content:"# 备注\n\n 1. 笔记所有图片均存在根目录下的assets文件夹，请一同下载查看\n 2. 笔记为读者自行整理，难免存在笔误/错误之处，请各位看官辩证性看待，也恳请指正\n 3. 文中省略了一些不必要的助词/形容词以减少字数\n 4. 笔记内容来源：各大学习网站+自行搜索+面试总结+笔者个人理解\n\n谢谢~~",normalizedContent:"# 备注\n\n 1. 笔记所有图片均存在根目录下的assets文件夹，请一同下载查看\n 2. 笔记为读者自行整理，难免存在笔误/错误之处，请各位看官辩证性看待，也恳请指正\n 3. 文中省略了一些不必要的助词/形容词以减少字数\n 4. 笔记内容来源：各大学习网站+自行搜索+面试总结+笔者个人理解\n\n谢谢~~",charsets:{cjk:!0},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-411169a5",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-da7221b6",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3},{title:"Home",frontmatter:{home:!0,heroImage:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200409124835.png",heroText:"yuadhのinterview_note",tagline:"🚀面试笔记",actionText:"开始使用 →",actionLink:"/pages/21ecd6/",bannerBg:"none",postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-794777be",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/02/07, 15:11:55",lastUpdatedTimestamp:1675753915e3}],themeConfig:{nav:[{text:"前端基础",link:"/code/"},{text:"软件框架",link:"/frame/",items:[]},{text:"算法|数据结构",link:"/algorithm/",items:[]},{text:"基础学科",link:"/base/",items:[]},{text:"系统|工具",link:"/system/",items:[]},{text:"项目",link:"/project/"},{text:"面试综合",link:"/interviews/"},{text:"专栏",link:"/part/",items:[]}],sidebarDepth:2,logo:"/img/logo.png",repo:"yuadh/interview2",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",category:!1,updateBar:{showToArticle:!0,moreArticle:"/code"},sidebar:{"/00.目录页/":[["01.前端基础.md","前端基础","/code"],["02.软件框架.md","软件框架","/frame"],["03.算法与数据结构.md","算法与设计结构","/algorithm"],["04.计算机基础.md","计算机基础","/base"],["05.系统与工具.md","系统与工具","/system"],["06.项目.md","项目","/project"],["07.面试综合.md","面试综合","/interviews"],["08.专栏.md","专栏","/part"]],catalogue:{"前端基础":"/code","软件框架":"/frame","算法与数据结构":"/algorithm","计算机基础":"/base","系统与工具":"/system","项目":"/project","面试综合":"/interviews","专栏":"/part"},"/01.前端基础/":[{title:"HTML",collapsable:!0,children:[{title:"ruanyf",collapsable:!0,children:[["01.HTML/01.ruanyf/01.html语言简介.md","html语言简介","/pages/a4421a/"],["01.HTML/01.ruanyf/02.URL简介.md","URL简介","/pages/e4644a/"],["01.HTML/01.ruanyf/03.元素属性.md","元素属性","/pages/ec6dce/"],["01.HTML/01.ruanyf/04.字符编码.md","字符编码","/pages/ed5e93/"],["01.HTML/01.ruanyf/05.语义结构.md","语义结构","/pages/d279ea/"],["01.HTML/01.ruanyf/06.文本标签.md","文本标签","/pages/1788c5/"]]}]},{title:"ES6",collapsable:!0,children:[{title:"ruanyf",collapsable:!0,children:[["04.ES6/01.ruanyf/10.Generator.md","Generator","/pages/02a35f/"],["04.ES6/01.ruanyf/11.Promise.md","Promise","/pages/aebd55/"]]}]}],"/02.软件框架/":[{title:"vscode",collapsable:!0,children:[["01.vscode/01.vs快捷键.md","vs快捷键","/pages/83b396/"]]},{title:"vue",collapsable:!0,children:[{title:"heima",collapsable:!0,children:[["04.vue/01.heima/01.webpack构建工具.md","webpack构建工具","/pages/c60c2c/"],["04.vue/01.heima/02.Vue快速开始.md","Vue快速开始","/pages/2e2311/"],["04.vue/01.heima/03.vue生态技术Router.md","vue生态技术Router","/pages/017a2c/"],["04.vue/01.heima/04.vue生态技术axios.md","vue生态技术axios","/pages/9204e3/"],["04.vue/01.heima/31.vue生态技术vuex.md","vue生态技术vuex","/pages/46ecd6/"]]}]},{title:"react",collapsable:!0,children:[{title:"heima",collapsable:!0,children:[["06.react/01.heima/01.react快速开始.md","react快速开始","/pages/5082ac/"],["06.react/01.heima/02.react受控和非受控组件.md","react受控和非受控组件","/pages/e67f9a/"],["06.react/01.heima/03.react组件通信.md","react组件通信","/pages/d4ac65/"],["06.react/01.heima/04.react生命周期.md","react生命周期","/pages/a33ce9/"],["06.react/01.heima/05.react路由.md","react路由","/pages/f24f8d/"],["06.react/01.heima/06.react的hooks.md","react的hooks","/pages/361177/"],["06.react/01.heima/07.react生态redux.md","react生态redux","/pages/bfa1be/"],["06.react/01.heima/08.react生态router.md","react生态router","/pages/6cbc7a/"]]},{title:"react官方",collapsable:!0,children:[["06.react/04.react官方/01.核心概念.md","核心概念","/pages/424a10/"],["06.react/04.react官方/02.hooks.md","hooks","/pages/69da0f/"],["06.react/04.react官方/03.高级指引.md","高级指引","/pages/acec16/"],["06.react/04.react官方/04.API.md","API","/pages/17f77d/"]]}]}],"/06.项目/":[{title:"中台管理项目",collapsable:!0,children:[["01.中台管理项目/01.项目介绍.md","项目介绍","/pages/330866/"]]},{title:"react项目搭建",collapsable:!0,children:[["04.react项目搭建/01.index.md","index","/pages/bf4db4/"]]}],"/07.面试综合/":[{title:"字节前端青训营",collapsable:!0,children:[["01.字节前端青训营/01.青训营真题day01.md","青训营真题day01","/pages/e0384f/"],["01.字节前端青训营/03.day03-ts.md","day03-ts","/pages/e7f910/"],["01.字节前端青训营/04.day04-HTTP.md","day04-HTTP","/pages/4dacdd/"]]},{title:"blog",collapsable:!0,children:[["02.blog/01.常用登录功能的逻辑.md","常用登录功能的逻辑","/pages/b52f92/"],["02.blog/02.代码多环境开发.md","代码多环境开发","/pages/0489e2/"]]}],"/08.专栏/":[["01.Browser.md","Browser","/pages/b48262/"],["02.CN.md","CN","/pages/eab60b/"],["03.CSS.md","CSS","/pages/77ad0a/"],["04.Git.md","Git","/pages/8564fd/"],["05.HTML.md","HTML","/pages/5798b5/"],["06.JS.md","JS","/pages/1f9ab3/"],["07.Optimize.md","Optimize","/pages/c60f99/"],["08.OS.md","OS","/pages/1312c8/"],["09.Project-Others.md","Project-Others","/pages/a9e64c/"],["10.React.md","React","/pages/727eb5/"],["11.Review.md","Review","/pages/520a27/"],["12.Vue.md","Vue","/pages/7bb646/"],["13.场景题.md","场景题","/pages/98b72d/"],["14.备注.md","备注","/pages/8f19fc/"]]},author:{name:"yuadh",link:"https://github.com/yuadh"},social:{icons:[{iconClass:"icon-github",title:"GitHub",link:"https://github.com/yuadh"}]},footer:{createYear:2022,copyrightInfo:'yuadh | <a href="https://github.com/yuadh/interview2/blob/master/LICENSE" target="_blank">MIT License</a>'},extendFrontmatter:{author:{name:"yuadh",link:"https://github.com/yuadh"}}},locales:{"/":{lang:"zh-CN",title:"yuadhのinterview_note",description:"yuadh的面试笔记网站",path:"/"}}};var wl=t(96),kl=t(97),Tl=t(11);var jl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:o}}=n;return!(e||!1===t||!0===o)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,o=e.frontmatter.sticky;return t&&o?t==o?Object(Tl.a)(n,e):t-o:t&&!o?-1:!t&&o?1:Object(Tl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Tl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let o=0,r=n.length;o<r;o++){const{frontmatter:{categories:r,tags:a}}=n[o];"array"===Object(Tl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[o]))}),"array"===Object(Tl.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[o]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(wl.default),Vt.component(kl.default);function Sl(n){return n.toString().padStart(2,"0")}t(244);Vt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,400))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,96))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,97)));t(245),t(246);var Cl=t(95),Il=t.n(Cl),Pl=t(26);let _l,zl;var El;"valine"===(El="gitalk")?t.e(68).then(t.t.bind(null,334,7)).then(n=>zl=n.default):"gitalk"===El&&Promise.all([t.e(0),t.e(67)]).then(t.t.bind(null,335,7)).then(()=>t.e(66).then(t.t.bind(null,336,7))).then(n=>_l=n.default);function Ol(n,e){const t={};return Reflect.ownKeys(n).forEach(o=>{if("string"==typeof n[o])try{t[o]=Il.a.render(n[o],e)}catch(e){console.warn(`Comment config option error at key named "${o}"`),console.warn("More info: "+e.message),t[o]=n[o]}else t[o]=n[o]}),t}console.log(`How to use "gitalk" in ${Pl.name}@v${Pl.version}:`,Pl.homepage);const Al={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new _l(Ol({clientID:"a6e1355287947096b88b",clientSecret:"f0e77d070fabfcd5af95bebb82b2d574d7248d71",repo:"blog-gitalk-comment",owner:"xugaoyi",admin:["xugaoyi"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new zl({...Ol({clientID:"a6e1355287947096b88b",clientSecret:"f0e77d070fabfcd5af95bebb82b2d574d7248d71",repo:"blog-gitalk-comment",owner:"xugaoyi",admin:["xugaoyi"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Rl="vuepress-plugin-comment";let Ml=null;function Dl(n){return Al.gitalk.clear(Rl)}function Ll(n){return!1!==n.comment&&!1!==n.comments}function Nl(n){clearTimeout(Ml);if(document.querySelector("main.page"))return Al.gitalk.render(n,Rl);Ml=setTimeout(()=>Nl(n),200)}var Hl={mounted(){Ml=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Dl()&&Ll(n)&&Nl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Dl()&&Ll(t)&&Nl(t)})}},Ul=Object(vl.a)(Hl,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Bl=[({Vue:n,options:e,router:t,siteData:o})=>{},({Vue:n,options:e,router:t,siteData:o})=>{o.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Sl(n.getUTCMonth()+1)}-${Sl(n.getUTCDate())} ${Sl(n.getUTCHours())}:${Sl(n.getUTCMinutes())}:${Sl(n.getUTCSeconds())}`}(e)),t?n.author=t:o.themeConfig.author&&(n.author=o.themeConfig.author)}),n.mixin(jl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({Vue:n})=>{n.component("Comment",Ul)}],Fl=["Comment"];class $l extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign($l.prototype,{getPageAsyncComponent:is,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Jl={install(n){const e=new $l;n.$vuepress=e,n.prototype.$vuepress=e}};function ql(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Vl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Vt.component(e)||Vt.component(e,is(e)),Vt.component(e)?n(e):n("")}},Wl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Gl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Xl=(t(252),t(253),Object(vl.a)(Gl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Kl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(Ji),Vt.use(Jl),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const o=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),a={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const o in n)"/"===o?t=n[o]:0===this.$page.path.indexOf(o)&&(e=n[o]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,o=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?o?o+" | "+t:t:o||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const o=n[t];if(o.path.toLowerCase()===e.toLowerCase())return o}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},xl)),Vt.component("Content",Vl),Vt.component("ContentSlotsDistributor",Wl),Vt.component("OutboundLink",Xl),Vt.component("ClientOnly",Kl),Vt.component("Layout",ss("Layout")),Vt.component("NotFound",ss("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"88b36a3"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:xl.routerBase||xl.base,t=new Ji({base:e,mode:"history",fallback:!1,routes:yl,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,o)=>{if(ql(n,e.path))o();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";ql(n,t)?o(t):o()}else o();else{const t=e.path+"/",r=e.path+".html";ql(n,r)?o(r):ql(n,t)?o(t):o()}})}(t);const o={};try{await Promise.all(Bl.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:o,router:t,siteData:xl,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(o,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Fl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);