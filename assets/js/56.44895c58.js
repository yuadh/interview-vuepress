(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{390:function(v,_,t){"use strict";t.r(_);var a=t(4),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"对os理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对os理解"}},[v._v("#")]),v._v(" 对OS理解？")]),v._v(" "),_("p",[v._v("OS是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高他们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。")]),v._v(" "),_("p",[v._v("相当于是软件管家。")]),v._v(" "),_("h1",{attrs:{id:"🍅-进程-线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#🍅-进程-线程"}},[v._v("#")]),v._v(" 🍅 进程&线程")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://interview.yuadh.com/assets/1649652076433.png",alt:"1649652076433"}})]),v._v(" "),_("h2",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[v._v("#")]),v._v(" 区别")]),v._v(" "),_("ol",[_("li",[v._v("线程是进程的一个实体，是程序执行的最小单位")]),v._v(" "),_("li",[v._v("进程是具有一定功能的程序在一个数据集上的一次动态执行的过程")]),v._v(" "),_("li",[v._v("进程是资源分配的独立单元，线程是资源调度的基本单元")]),v._v(" "),_("li",[v._v("资源开销："),_("strong",[v._v("进程是拥有资源的一个独立单位，每个进程都有自己单独的地址空间，进程切换会消耗较大的资源——进程调度算法。线程只拥有一点在运行中必不可少的资源，一类线程共享代码和内存空间，线程切换消耗较小")])]),v._v(" "),_("li",[v._v("内存分配：进程间地址空间和资源相互独立；线程共享本进程地址空间和资源")]),v._v(" "),_("li",[v._v("进程比线程健壮")]),v._v(" "),_("li",[v._v("执行过程：进程有独立的运行入口")]),v._v(" "),_("li",[v._v("执行顺序；进程和线程均可并发执行")])]),v._v(" "),_("h2",{attrs:{id:"cpu类比一个工厂"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cpu类比一个工厂"}},[v._v("#")]),v._v(" CPU类比一个工厂")]),v._v(" "),_("ol",[_("li",[v._v("一个进程 就是 一个车间，同时只能有一个进程运行，单个CPU一次只能运行一个任务")]),v._v(" "),_("li",[v._v("多个线程 类比 车间的工人")]),v._v(" "),_("li",[v._v("进程内存空间共享 类比 车间房间工人可进出")]),v._v(" "),_("li",[v._v("一个线程使用某些共享内存时，其他线程必须等它结束才能使用这块内存类比 "),_("strong",[v._v("洗手间")]),v._v("只能容纳一人")]),v._v(" "),_("li",[v._v("防止多个线程同时读写某一块区域，"),_("strong",[v._v("加一把“互斥锁” 类比 在门上加一把锁")])]),v._v(" "),_("li",[v._v("某些内存区域只能供给固定数目的线程使用 类比 "),_("strong",[v._v("厨房容纳n个人，多的人只能在外面等着")])]),v._v(" "),_("li",[_("strong",[v._v("信号量")]),v._v("，保证多个线程不会冲突 类比 门口放n把钥匙，进去取钥匙，出来放钥匙，后面的人发现钥匙架空就知道必须在门口等着")])]),v._v(" "),_("blockquote",[_("h4",{attrs:{id:"线程和进程的区别在于-子进程和父进程有不同的代码和数据空间-而多个线程则共享数据空间-每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约cpu时间。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线程和进程的区别在于-子进程和父进程有不同的代码和数据空间-而多个线程则共享数据空间-每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约cpu时间。"}},[v._v("#")]),v._v(" 线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程是为了节约CPU时间。")])]),v._v(" "),_("h2",{attrs:{id:"进程间通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信"}},[v._v("#")]),v._v(" 进程间通信")]),v._v(" "),_("h3",{attrs:{id:"管道"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[v._v("#")]),v._v(" 管道")]),v._v(" "),_("p",[v._v("匿名管道和命名管道。")]),v._v(" "),_("p",[v._v("管道的通知机制类似于缓存，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，而且管道是单向传输的。")]),v._v(" "),_("p",[v._v("效率低下，因为如果a进程给b进程传输数据，"),_("strong",[v._v("只有等b进程取到数据之后a进程才能返回，所以管道不适用于频繁通信的进程")]),v._v("。当然，优点就是简单，能够保证我们的数据是真的已经被其他进程拿走的。")]),v._v(" "),_("h3",{attrs:{id:"消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[v._v("#")]),v._v(" 消息队列")]),v._v(" "),_("p",[v._v("那我们是否可以把进程的数据放在某个内存后就马上让进程返回呢？不用等待其他进程来取就返回？")]),v._v(" "),_("p",[v._v("可以的。我们可以利用消息队列解决这个问题，例如a需要给b进程发送消息，只需将消息放在对应的消息队列中就可以，b进程需要的时候再去对应的消息队列中取出。这种通行方式类似于 缓存。")]),v._v(" "),_("p",[v._v("有缺点吗？\n如果a进程发送的数据内存比较大，且两个进程通信非常频繁的话，队列模式就不大适合了。因为如果a发送的数据很大的话，意味着发送消息这个过程需要花很多时间读内存。")]),v._v(" "),_("h3",{attrs:{id:"共享内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[v._v("#")]),v._v(" 共享内存")]),v._v(" "),_("p",[v._v("共享内存这个通信方式就可以很好的解决 拷贝 所消耗的时间。")]),v._v(" "),_("p",[v._v("进程拥有自己的独立内存，两个进程怎么共享一块内存？")]),v._v(" "),_("p",[v._v("我们知道，系统加载一个进程时，分配给进程的内存不是实际物理内存，而是虚拟内存空间。那么我们就可以让"),_("strong",[v._v("两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但是有一部分却是映射到相同的物理内存")]),v._v("，即，完成进程的内存共享机制。")]),v._v(" "),_("h3",{attrs:{id:"信号量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[v._v("#")]),v._v(" 信号量")]),v._v(" "),_("p",[v._v("共享内存存在问题吗？")]),v._v(" "),_("p",[_("strong",[v._v("最大的问题就是  多进程竞争内存。")])]),v._v(" "),_("p",[v._v("我们可以通过信号量解决这个问题。")]),v._v(" "),_("p",[_("strong",[v._v("信号量的本质就是一个计数器，用来实现进程间的互斥和同步。")])]),v._v(" "),_("p",[v._v("我们用信号量这个变量来辅助内存共享。")]),v._v(" "),_("h3",{attrs:{id:"套接字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#套接字"}},[v._v("#")]),v._v(" 套接字")]),v._v(" "),_("p",[v._v("前面的4个通信方式(管道，消息队列，内存共享，信号量)都是多个进程在一台主机上的通信，如果是"),_("strong",[v._v("两个相隔万里的进程还能通信吗")]),v._v("？")]),v._v(" "),_("p",[v._v("Socket可以解决这个问题，我们平时通过浏览器发起一个HTTP请求，然后服务器返回我们对应的数据，即是，socket通信")]),v._v(" "),_("h1",{attrs:{id:"🍅反码-补码-原码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#🍅反码-补码-原码"}},[v._v("#")]),v._v(" 🍅反码 补码 原码")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("原码：计算机对数字二进制的定点表示方法，最高位表示符号位，其余位表示数值位。")]),v._v(" "),_("ul",[_("li",[v._v("优点：易于分辨，缺点：不能够直接参与运算。")])])]),v._v(" "),_("li",[_("p",[v._v("正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。\n如 [+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。")])]),v._v(" "),_("li",[_("p",[v._v("正数的补码和其原码一样；负数的补码为其反码加1。\n例如 [+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；\n[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001")])]),v._v(" "),_("li",[_("p",[v._v("补码来表示负数的原因：可以将加法运算扩展到所有的数值计算上，因此在数字电路中只需考虑加法器的设计就行，而不用再为减法设置新的数字电路。")])])]),v._v(" "),_("h1",{attrs:{id:"死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[v._v("#")]),v._v(" 死锁")]),v._v(" "),_("h1",{attrs:{id:""}},[_("a",{staticClass:"header-anchor",attrs:{href:"#"}},[v._v("#")])])])}),[],!1,null,null,null);_.default=s.exports}}]);