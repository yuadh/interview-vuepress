(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{361:function(v,_,t){"use strict";t.r(_);var e=t(4),r=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"react"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[v._v("#")]),v._v(" React")]),v._v(" "),_("h2",{attrs:{id:"虚拟dom和diff算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom和diff算法"}},[v._v("#")]),v._v(" 虚拟DOM和Diff算法")]),v._v(" "),_("p",[v._v("虚拟DOM")]),v._v(" "),_("p",[_("strong",[v._v("问题描述")]),v._v("：假设我们的数据发生一点点的变化，也会被强制重建整顿DOM树，这么做，会涉及到很多元素的重绘和重排，导致性能浪费严重")]),v._v(" "),_("p",[_("strong",[v._v("解决上述问题思路")]),v._v("：实现按需更行页面上的元素即可。也就是说，把需要修改的元素，所对应的 DOM 元素重新构建；其它没有变化的数据，所对应的 DOM 节点不需要被强制更新")]),v._v(" "),_("p",[_("strong",[v._v("具体实现方案")]),v._v("：只需要拿到页面更新前的 内存中的DOM树，同时再拿到页面更新前新渲染出来的内存DOM树；然后，对比这两颗新旧DOM树，找到那些需要被重新创建和修改的元素即可。这样就能实现DOM的按需更新")]),v._v(" "),_("p",[_("strong",[v._v("如何拿到这两颗DOM树")]),v._v("： 如果要拿到浏览器私有的DOM树，那我们必须调用浏览器提供的相关JS的API才行。但是浏览器没有提供相关的API，那我们可以自己模拟这两颗新旧DOM树")]),v._v(" "),_("p",[_("strong",[v._v("如何自己模拟这两颗新旧DOM树")]),v._v("： 这里涉及到手动模拟DOM树的原理：使用JS创建一个对象，用和这个对象来模拟每一个DOM节点；然后在每个DOM节点中，有提供了类似于children这样的属性来描述当前子节点。这样的话，当DOM节点形成了嵌套关系，就模拟出了一颗DOM树")]),v._v(" "),_("p",[_("strong",[_("code",[v._v("总结")])])]),v._v(" "),_("ul",[_("li",[v._v("虚拟DOM的"),_("strong",[v._v("本质")]),v._v("：使用 JS 对象模拟DOM树。")]),v._v(" "),_("li",[v._v("虚拟DOM的"),_("strong",[v._v("目的")]),v._v("：为了实现 DOM 节点的高效更新。")])]),v._v(" "),_("p",[v._v("diff算法")]),v._v(" "),_("p",[v._v("怎么实现 两颗新旧DOM树的对比呢，这里就涉及到diff算法")]),v._v(" "),_("p",[_("code",[v._v("tree diff")]),v._v(" ： 新旧DOM树，逐层对比的方式，就叫做 "),_("code",[v._v("tree diff")]),v._v("。每当我们从前到后，把所有层的节点对比完后，必须能够找到哪些需要被更新的元素")]),v._v(" "),_("p",[_("code",[v._v("component diff")]),v._v(" ：在对比每一层的时候，组件之间的对比，叫做 "),_("code",[v._v("component diff")]),v._v(" 。当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换被移除的位置")]),v._v(" "),_("p",[_("code",[v._v("element diff")]),v._v(" ： 在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff")]),v._v(" "),_("p",[_("code",[v._v("key")]),v._v(" ： "),_("code",[v._v("key")]),v._v(" 这个属性，可以把页面上的DOM节点和虚拟DOM中的对象，做一层关联关系")]),v._v(" "),_("p",[_("strong",[v._v("声明式编程")])]),v._v(" "),_("p",[v._v("声明式编程是目前整个大前端开发的模式：Vue、React、Flutter、SwitfUI")]),v._v(" "),_("p",[v._v("它允许我们 "),_("strong",[v._v("只需要维护自己的状态，当状态改变时，react 可以根据最新的状态去渲染我们的UI界面")])]),v._v(" "),_("p",[_("strong",[v._v("组件化开发")])]),v._v(" "),_("p",[v._v("组件化开发页面目前前端的流行趋势，我们会将复杂的界面拆分成一个个小的组件")]),v._v(" "),_("p",[v._v("如何合理的进行组件的划分和设计")]),v._v(" "),_("h2",{attrs:{id:"react开发依赖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react开发依赖"}},[v._v("#")]),v._v(" react开发依赖")]),v._v(" "),_("ul",[_("li",[v._v("react")]),v._v(" "),_("li",[v._v("react-dom")]),v._v(" "),_("li",[v._v("babel")])]),v._v(" "),_("p",[v._v("React18 之前渲染用法")]),v._v(" "),_("p",[_("code",[v._v("ReactDOM.render(<h2></h2>,document.querey)")])])])}),[],!1,null,null,null);_.default=r.exports}}]);